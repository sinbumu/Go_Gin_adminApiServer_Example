// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://172.31.24.195:4466/gotchu/live"
var Secret = "ivEwQ9FnKxN91FaHSxT2"

func (client *Client) AdminUser(params AdminUserWhereUniqueInput) *AdminUserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AdminUserWhereUniqueInput!", "AdminUser"},
		"adminUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

type AdminUsersParams struct {
	Where   *AdminUserWhereInput   `json:"where,omitempty"`
	OrderBy *AdminUserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) AdminUsers(params *AdminUsersParams) *AdminUserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AdminUserWhereInput", "AdminUserOrderByInput", "AdminUser"},
		"adminUsers",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExecArray{ret}
}

type AdminUsersConnectionParams struct {
	Where   *AdminUserWhereInput   `json:"where,omitempty"`
	OrderBy *AdminUserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AdminUserConnection) Nodes() []AdminUser {
	var nodes []AdminUser
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AdminUserConnection) NodesPtr() []*AdminUser {
	var nodes []*AdminUser
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AdminUsersConnection(params *AdminUsersConnectionParams) *AdminUserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AdminUserWhereInput", "AdminUserOrderByInput", "AdminUser"},
		"adminUsersConnection",
		[]string{"edges", "pageInfo"})

	return &AdminUserConnectionExec{ret}
}

func (client *Client) AergoAccount(params AergoAccountWhereUniqueInput) *AergoAccountExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AergoAccountWhereUniqueInput!", "AergoAccount"},
		"aergoAccount",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountExec{ret}
}

type AergoAccountsParams struct {
	Where   *AergoAccountWhereInput   `json:"where,omitempty"`
	OrderBy *AergoAccountOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) AergoAccounts(params *AergoAccountsParams) *AergoAccountExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AergoAccountWhereInput", "AergoAccountOrderByInput", "AergoAccount"},
		"aergoAccounts",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountExecArray{ret}
}

type AergoAccountsConnectionParams struct {
	Where   *AergoAccountWhereInput   `json:"where,omitempty"`
	OrderBy *AergoAccountOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AergoAccountConnection) Nodes() []AergoAccount {
	var nodes []AergoAccount
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AergoAccountConnection) NodesPtr() []*AergoAccount {
	var nodes []*AergoAccount
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AergoAccountsConnection(params *AergoAccountsConnectionParams) *AergoAccountConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AergoAccountWhereInput", "AergoAccountOrderByInput", "AergoAccount"},
		"aergoAccountsConnection",
		[]string{"edges", "pageInfo"})

	return &AergoAccountConnectionExec{ret}
}

func (client *Client) AergoAccountHistory(params AergoAccountHistoryWhereUniqueInput) *AergoAccountHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AergoAccountHistoryWhereUniqueInput!", "AergoAccountHistory"},
		"aergoAccountHistory",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExec{ret}
}

type AergoAccountHistoriesParams struct {
	Where   *AergoAccountHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *AergoAccountHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                           `json:"skip,omitempty"`
	After   *string                          `json:"after,omitempty"`
	Before  *string                          `json:"before,omitempty"`
	First   *int32                           `json:"first,omitempty"`
	Last    *int32                           `json:"last,omitempty"`
}

func (client *Client) AergoAccountHistories(params *AergoAccountHistoriesParams) *AergoAccountHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AergoAccountHistoryWhereInput", "AergoAccountHistoryOrderByInput", "AergoAccountHistory"},
		"aergoAccountHistories",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExecArray{ret}
}

type AergoAccountHistoriesConnectionParams struct {
	Where   *AergoAccountHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *AergoAccountHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                           `json:"skip,omitempty"`
	After   *string                          `json:"after,omitempty"`
	Before  *string                          `json:"before,omitempty"`
	First   *int32                           `json:"first,omitempty"`
	Last    *int32                           `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AergoAccountHistoryConnection) Nodes() []AergoAccountHistory {
	var nodes []AergoAccountHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AergoAccountHistoryConnection) NodesPtr() []*AergoAccountHistory {
	var nodes []*AergoAccountHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AergoAccountHistoriesConnection(params *AergoAccountHistoriesConnectionParams) *AergoAccountHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AergoAccountHistoryWhereInput", "AergoAccountHistoryOrderByInput", "AergoAccountHistory"},
		"aergoAccountHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &AergoAccountHistoryConnectionExec{ret}
}

func (client *Client) AfreecaTv(params AfreecaTvWhereUniqueInput) *AfreecaTvExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AfreecaTVWhereUniqueInput!", "AfreecaTV"},
		"afreecaTV",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvExec{ret}
}

type AfreecaTVsParams struct {
	Where   *AfreecaTvWhereInput   `json:"where,omitempty"`
	OrderBy *AfreecaTvOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) AfreecaTVs(params *AfreecaTVsParams) *AfreecaTvExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AfreecaTVWhereInput", "AfreecaTVOrderByInput", "AfreecaTV"},
		"afreecaTVs",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvExecArray{ret}
}

type AfreecaTVsConnectionParams struct {
	Where   *AfreecaTvWhereInput   `json:"where,omitempty"`
	OrderBy *AfreecaTvOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AfreecaTvConnection) Nodes() []AfreecaTv {
	var nodes []AfreecaTv
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AfreecaTvConnection) NodesPtr() []*AfreecaTv {
	var nodes []*AfreecaTv
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AfreecaTVsConnection(params *AfreecaTVsConnectionParams) *AfreecaTvConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AfreecaTvWhereInput", "AfreecaTvOrderByInput", "AfreecaTv"},
		"afreecaTVsConnection",
		[]string{"edges", "pageInfo"})

	return &AfreecaTvConnectionExec{ret}
}

func (client *Client) AfreecaTvDailyStatistics(params AfreecaTvDailyStatisticsWhereUniqueInput) *AfreecaTvDailyStatisticsExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AfreecaTVDailyStatisticsWhereUniqueInput!", "AfreecaTVDailyStatistics"},
		"afreecaTVDailyStatistics",
		[]string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvDailyStatisticsExec{ret}
}

type AfreecaTvDailyStatisticsesParams struct {
	Where   *AfreecaTvDailyStatisticsWhereInput   `json:"where,omitempty"`
	OrderBy *AfreecaTvDailyStatisticsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                                `json:"skip,omitempty"`
	After   *string                               `json:"after,omitempty"`
	Before  *string                               `json:"before,omitempty"`
	First   *int32                                `json:"first,omitempty"`
	Last    *int32                                `json:"last,omitempty"`
}

func (client *Client) AfreecaTvDailyStatisticses(params *AfreecaTvDailyStatisticsesParams) *AfreecaTvDailyStatisticsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AfreecaTVDailyStatisticsWhereInput", "AfreecaTVDailyStatisticsOrderByInput", "AfreecaTVDailyStatistics"},
		"afreecaTVDailyStatisticses",
		[]string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvDailyStatisticsExecArray{ret}
}

type AfreecaTvDailyStatisticsesConnectionParams struct {
	Where   *AfreecaTvDailyStatisticsWhereInput   `json:"where,omitempty"`
	OrderBy *AfreecaTvDailyStatisticsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                                `json:"skip,omitempty"`
	After   *string                               `json:"after,omitempty"`
	Before  *string                               `json:"before,omitempty"`
	First   *int32                                `json:"first,omitempty"`
	Last    *int32                                `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AfreecaTvDailyStatisticsConnection) Nodes() []AfreecaTvDailyStatistics {
	var nodes []AfreecaTvDailyStatistics
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AfreecaTvDailyStatisticsConnection) NodesPtr() []*AfreecaTvDailyStatistics {
	var nodes []*AfreecaTvDailyStatistics
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AfreecaTvDailyStatisticsesConnection(params *AfreecaTvDailyStatisticsesConnectionParams) *AfreecaTvDailyStatisticsConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AfreecaTvDailyStatisticsWhereInput", "AfreecaTvDailyStatisticsOrderByInput", "AfreecaTvDailyStatistics"},
		"afreecaTVDailyStatisticsesConnection",
		[]string{"edges", "pageInfo"})

	return &AfreecaTvDailyStatisticsConnectionExec{ret}
}

func (client *Client) AirDrop(params AirDropWhereUniqueInput) *AirDropExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AirDropWhereUniqueInput!", "AirDrop"},
		"airDrop",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExec{ret}
}

type AirDropsParams struct {
	Where   *AirDropWhereInput   `json:"where,omitempty"`
	OrderBy *AirDropOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) AirDrops(params *AirDropsParams) *AirDropExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AirDropWhereInput", "AirDropOrderByInput", "AirDrop"},
		"airDrops",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExecArray{ret}
}

type AirDropsConnectionParams struct {
	Where   *AirDropWhereInput   `json:"where,omitempty"`
	OrderBy *AirDropOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AirDropConnection) Nodes() []AirDrop {
	var nodes []AirDrop
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AirDropConnection) NodesPtr() []*AirDrop {
	var nodes []*AirDrop
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AirDropsConnection(params *AirDropsConnectionParams) *AirDropConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AirDropWhereInput", "AirDropOrderByInput", "AirDrop"},
		"airDropsConnection",
		[]string{"edges", "pageInfo"})

	return &AirDropConnectionExec{ret}
}

func (client *Client) AirDropHistory(params AirDropHistoryWhereUniqueInput) *AirDropHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AirDropHistoryWhereUniqueInput!", "AirDropHistory"},
		"airDropHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExec{ret}
}

type AirDropHistoriesParams struct {
	Where   *AirDropHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *AirDropHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) AirDropHistories(params *AirDropHistoriesParams) *AirDropHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AirDropHistoryWhereInput", "AirDropHistoryOrderByInput", "AirDropHistory"},
		"airDropHistories",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExecArray{ret}
}

type AirDropHistoriesConnectionParams struct {
	Where   *AirDropHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *AirDropHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AirDropHistoryConnection) Nodes() []AirDropHistory {
	var nodes []AirDropHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AirDropHistoryConnection) NodesPtr() []*AirDropHistory {
	var nodes []*AirDropHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AirDropHistoriesConnection(params *AirDropHistoriesConnectionParams) *AirDropHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AirDropHistoryWhereInput", "AirDropHistoryOrderByInput", "AirDropHistory"},
		"airDropHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &AirDropHistoryConnectionExec{ret}
}

func (client *Client) AirDropMember(params AirDropMemberWhereUniqueInput) *AirDropMemberExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AirDropMemberWhereUniqueInput!", "AirDropMember"},
		"airDropMember",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExec{ret}
}

type AirDropMembersParams struct {
	Where   *AirDropMemberWhereInput   `json:"where,omitempty"`
	OrderBy *AirDropMemberOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) AirDropMembers(params *AirDropMembersParams) *AirDropMemberExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AirDropMemberWhereInput", "AirDropMemberOrderByInput", "AirDropMember"},
		"airDropMembers",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExecArray{ret}
}

type AirDropMembersConnectionParams struct {
	Where   *AirDropMemberWhereInput   `json:"where,omitempty"`
	OrderBy *AirDropMemberOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AirDropMemberConnection) Nodes() []AirDropMember {
	var nodes []AirDropMember
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AirDropMemberConnection) NodesPtr() []*AirDropMember {
	var nodes []*AirDropMember
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AirDropMembersConnection(params *AirDropMembersConnectionParams) *AirDropMemberConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AirDropMemberWhereInput", "AirDropMemberOrderByInput", "AirDropMember"},
		"airDropMembersConnection",
		[]string{"edges", "pageInfo"})

	return &AirDropMemberConnectionExec{ret}
}

func (client *Client) AppVersion(params AppVersionWhereUniqueInput) *AppVersionExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AppVersionWhereUniqueInput!", "AppVersion"},
		"appVersion",
		[]string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"})

	return &AppVersionExec{ret}
}

type AppVersionsParams struct {
	Where   *AppVersionWhereInput   `json:"where,omitempty"`
	OrderBy *AppVersionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) AppVersions(params *AppVersionsParams) *AppVersionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AppVersionWhereInput", "AppVersionOrderByInput", "AppVersion"},
		"appVersions",
		[]string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"})

	return &AppVersionExecArray{ret}
}

type AppVersionsConnectionParams struct {
	Where   *AppVersionWhereInput   `json:"where,omitempty"`
	OrderBy *AppVersionOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *AppVersionConnection) Nodes() []AppVersion {
	var nodes []AppVersion
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *AppVersionConnection) NodesPtr() []*AppVersion {
	var nodes []*AppVersion
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) AppVersionsConnection(params *AppVersionsConnectionParams) *AppVersionConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AppVersionWhereInput", "AppVersionOrderByInput", "AppVersion"},
		"appVersionsConnection",
		[]string{"edges", "pageInfo"})

	return &AppVersionConnectionExec{ret}
}

func (client *Client) Badge(params BadgeWhereUniqueInput) *BadgeExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BadgeWhereUniqueInput!", "Badge"},
		"badge",
		[]string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"})

	return &BadgeExec{ret}
}

type BadgesParams struct {
	Where   *BadgeWhereInput   `json:"where,omitempty"`
	OrderBy *BadgeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Badges(params *BadgesParams) *BadgeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BadgeWhereInput", "BadgeOrderByInput", "Badge"},
		"badges",
		[]string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"})

	return &BadgeExecArray{ret}
}

type BadgesConnectionParams struct {
	Where   *BadgeWhereInput   `json:"where,omitempty"`
	OrderBy *BadgeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BadgeConnection) Nodes() []Badge {
	var nodes []Badge
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BadgeConnection) NodesPtr() []*Badge {
	var nodes []*Badge
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BadgesConnection(params *BadgesConnectionParams) *BadgeConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BadgeWhereInput", "BadgeOrderByInput", "Badge"},
		"badgesConnection",
		[]string{"edges", "pageInfo"})

	return &BadgeConnectionExec{ret}
}

func (client *Client) BadgeVoter(params BadgeVoterWhereUniqueInput) *BadgeVoterExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BadgeVoterWhereUniqueInput!", "BadgeVoter"},
		"badgeVoter",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &BadgeVoterExec{ret}
}

type BadgeVotersParams struct {
	Where   *BadgeVoterWhereInput   `json:"where,omitempty"`
	OrderBy *BadgeVoterOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) BadgeVoters(params *BadgeVotersParams) *BadgeVoterExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BadgeVoterWhereInput", "BadgeVoterOrderByInput", "BadgeVoter"},
		"badgeVoters",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &BadgeVoterExecArray{ret}
}

type BadgeVotersConnectionParams struct {
	Where   *BadgeVoterWhereInput   `json:"where,omitempty"`
	OrderBy *BadgeVoterOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BadgeVoterConnection) Nodes() []BadgeVoter {
	var nodes []BadgeVoter
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BadgeVoterConnection) NodesPtr() []*BadgeVoter {
	var nodes []*BadgeVoter
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BadgeVotersConnection(params *BadgeVotersConnectionParams) *BadgeVoterConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BadgeVoterWhereInput", "BadgeVoterOrderByInput", "BadgeVoter"},
		"badgeVotersConnection",
		[]string{"edges", "pageInfo"})

	return &BadgeVoterConnectionExec{ret}
}

func (client *Client) Bank(params BankWhereUniqueInput) *BankExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BankWhereUniqueInput!", "Bank"},
		"bank",
		[]string{"id", "code", "name", "createdAt", "updatedAt"})

	return &BankExec{ret}
}

type BanksParams struct {
	Where   *BankWhereInput   `json:"where,omitempty"`
	OrderBy *BankOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Banks(params *BanksParams) *BankExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BankWhereInput", "BankOrderByInput", "Bank"},
		"banks",
		[]string{"id", "code", "name", "createdAt", "updatedAt"})

	return &BankExecArray{ret}
}

type BanksConnectionParams struct {
	Where   *BankWhereInput   `json:"where,omitempty"`
	OrderBy *BankOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BankConnection) Nodes() []Bank {
	var nodes []Bank
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BankConnection) NodesPtr() []*Bank {
	var nodes []*Bank
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BanksConnection(params *BanksConnectionParams) *BankConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BankWhereInput", "BankOrderByInput", "Bank"},
		"banksConnection",
		[]string{"edges", "pageInfo"})

	return &BankConnectionExec{ret}
}

func (client *Client) BankAccountVerification(params BankAccountVerificationWhereUniqueInput) *BankAccountVerificationExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BankAccountVerificationWhereUniqueInput!", "BankAccountVerification"},
		"bankAccountVerification",
		[]string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationExec{ret}
}

type BankAccountVerificationsParams struct {
	Where   *BankAccountVerificationWhereInput   `json:"where,omitempty"`
	OrderBy *BankAccountVerificationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                               `json:"skip,omitempty"`
	After   *string                              `json:"after,omitempty"`
	Before  *string                              `json:"before,omitempty"`
	First   *int32                               `json:"first,omitempty"`
	Last    *int32                               `json:"last,omitempty"`
}

func (client *Client) BankAccountVerifications(params *BankAccountVerificationsParams) *BankAccountVerificationExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BankAccountVerificationWhereInput", "BankAccountVerificationOrderByInput", "BankAccountVerification"},
		"bankAccountVerifications",
		[]string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationExecArray{ret}
}

type BankAccountVerificationsConnectionParams struct {
	Where   *BankAccountVerificationWhereInput   `json:"where,omitempty"`
	OrderBy *BankAccountVerificationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                               `json:"skip,omitempty"`
	After   *string                              `json:"after,omitempty"`
	Before  *string                              `json:"before,omitempty"`
	First   *int32                               `json:"first,omitempty"`
	Last    *int32                               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BankAccountVerificationConnection) Nodes() []BankAccountVerification {
	var nodes []BankAccountVerification
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BankAccountVerificationConnection) NodesPtr() []*BankAccountVerification {
	var nodes []*BankAccountVerification
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BankAccountVerificationsConnection(params *BankAccountVerificationsConnectionParams) *BankAccountVerificationConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BankAccountVerificationWhereInput", "BankAccountVerificationOrderByInput", "BankAccountVerification"},
		"bankAccountVerificationsConnection",
		[]string{"edges", "pageInfo"})

	return &BankAccountVerificationConnectionExec{ret}
}

func (client *Client) BankAccountVerificationTransactionInfo(params BankAccountVerificationTransactionInfoWhereUniqueInput) *BankAccountVerificationTransactionInfoExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BankAccountVerificationTransactionInfoWhereUniqueInput!", "BankAccountVerificationTransactionInfo"},
		"bankAccountVerificationTransactionInfo",
		[]string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationTransactionInfoExec{ret}
}

type BankAccountVerificationTransactionInfoesParams struct {
	Where   *BankAccountVerificationTransactionInfoWhereInput   `json:"where,omitempty"`
	OrderBy *BankAccountVerificationTransactionInfoOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                                              `json:"skip,omitempty"`
	After   *string                                             `json:"after,omitempty"`
	Before  *string                                             `json:"before,omitempty"`
	First   *int32                                              `json:"first,omitempty"`
	Last    *int32                                              `json:"last,omitempty"`
}

func (client *Client) BankAccountVerificationTransactionInfoes(params *BankAccountVerificationTransactionInfoesParams) *BankAccountVerificationTransactionInfoExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BankAccountVerificationTransactionInfoWhereInput", "BankAccountVerificationTransactionInfoOrderByInput", "BankAccountVerificationTransactionInfo"},
		"bankAccountVerificationTransactionInfoes",
		[]string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationTransactionInfoExecArray{ret}
}

type BankAccountVerificationTransactionInfoesConnectionParams struct {
	Where   *BankAccountVerificationTransactionInfoWhereInput   `json:"where,omitempty"`
	OrderBy *BankAccountVerificationTransactionInfoOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                                              `json:"skip,omitempty"`
	After   *string                                             `json:"after,omitempty"`
	Before  *string                                             `json:"before,omitempty"`
	First   *int32                                              `json:"first,omitempty"`
	Last    *int32                                              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BankAccountVerificationTransactionInfoConnection) Nodes() []BankAccountVerificationTransactionInfo {
	var nodes []BankAccountVerificationTransactionInfo
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BankAccountVerificationTransactionInfoConnection) NodesPtr() []*BankAccountVerificationTransactionInfo {
	var nodes []*BankAccountVerificationTransactionInfo
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BankAccountVerificationTransactionInfoesConnection(params *BankAccountVerificationTransactionInfoesConnectionParams) *BankAccountVerificationTransactionInfoConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BankAccountVerificationTransactionInfoWhereInput", "BankAccountVerificationTransactionInfoOrderByInput", "BankAccountVerificationTransactionInfo"},
		"bankAccountVerificationTransactionInfoesConnection",
		[]string{"edges", "pageInfo"})

	return &BankAccountVerificationTransactionInfoConnectionExec{ret}
}

func (client *Client) Board(params BoardWhereUniqueInput) *BoardExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"BoardWhereUniqueInput!", "Board"},
		"board",
		[]string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"})

	return &BoardExec{ret}
}

type BoardsParams struct {
	Where   *BoardWhereInput   `json:"where,omitempty"`
	OrderBy *BoardOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Boards(params *BoardsParams) *BoardExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BoardWhereInput", "BoardOrderByInput", "Board"},
		"boards",
		[]string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"})

	return &BoardExecArray{ret}
}

type BoardsConnectionParams struct {
	Where   *BoardWhereInput   `json:"where,omitempty"`
	OrderBy *BoardOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *BoardConnection) Nodes() []Board {
	var nodes []Board
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *BoardConnection) NodesPtr() []*Board {
	var nodes []*Board
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) BoardsConnection(params *BoardsConnectionParams) *BoardConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"BoardWhereInput", "BoardOrderByInput", "Board"},
		"boardsConnection",
		[]string{"edges", "pageInfo"})

	return &BoardConnectionExec{ret}
}

func (client *Client) CashHistory(params CashHistoryWhereUniqueInput) *CashHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CashHistoryWhereUniqueInput!", "CashHistory"},
		"cashHistory",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExec{ret}
}

type CashHistoriesParams struct {
	Where   *CashHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *CashHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) CashHistories(params *CashHistoriesParams) *CashHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CashHistoryWhereInput", "CashHistoryOrderByInput", "CashHistory"},
		"cashHistories",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExecArray{ret}
}

type CashHistoriesConnectionParams struct {
	Where   *CashHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *CashHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CashHistoryConnection) Nodes() []CashHistory {
	var nodes []CashHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CashHistoryConnection) NodesPtr() []*CashHistory {
	var nodes []*CashHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CashHistoriesConnection(params *CashHistoriesConnectionParams) *CashHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CashHistoryWhereInput", "CashHistoryOrderByInput", "CashHistory"},
		"cashHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &CashHistoryConnectionExec{ret}
}

func (client *Client) Category(params CategoryWhereUniqueInput) *CategoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CategoryWhereUniqueInput!", "Category"},
		"category",
		[]string{"id", "name", "order_index"})

	return &CategoryExec{ret}
}

type CategoriesParams struct {
	Where   *CategoryWhereInput   `json:"where,omitempty"`
	OrderBy *CategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) Categories(params *CategoriesParams) *CategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CategoryWhereInput", "CategoryOrderByInput", "Category"},
		"categories",
		[]string{"id", "name", "order_index"})

	return &CategoryExecArray{ret}
}

type CategoriesConnectionParams struct {
	Where   *CategoryWhereInput   `json:"where,omitempty"`
	OrderBy *CategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CategoryConnection) Nodes() []Category {
	var nodes []Category
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CategoryConnection) NodesPtr() []*Category {
	var nodes []*Category
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CategoriesConnection(params *CategoriesConnectionParams) *CategoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CategoryWhereInput", "CategoryOrderByInput", "Category"},
		"categoriesConnection",
		[]string{"edges", "pageInfo"})

	return &CategoryConnectionExec{ret}
}

func (client *Client) Coin(params CoinWhereUniqueInput) *CoinExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CoinWhereUniqueInput!", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

type CoinsParams struct {
	Where   *CoinWhereInput   `json:"where,omitempty"`
	OrderBy *CoinOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Coins(params *CoinsParams) *CoinExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CoinWhereInput", "CoinOrderByInput", "Coin"},
		"coins",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExecArray{ret}
}

type CoinsConnectionParams struct {
	Where   *CoinWhereInput   `json:"where,omitempty"`
	OrderBy *CoinOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CoinConnection) Nodes() []Coin {
	var nodes []Coin
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CoinConnection) NodesPtr() []*Coin {
	var nodes []*Coin
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CoinsConnection(params *CoinsConnectionParams) *CoinConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CoinWhereInput", "CoinOrderByInput", "Coin"},
		"coinsConnection",
		[]string{"edges", "pageInfo"})

	return &CoinConnectionExec{ret}
}

func (client *Client) CoinKline(params CoinKlineWhereUniqueInput) *CoinKlineExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CoinKlineWhereUniqueInput!", "CoinKline"},
		"coinKline",
		[]string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"})

	return &CoinKlineExec{ret}
}

type CoinKlinesParams struct {
	Where   *CoinKlineWhereInput   `json:"where,omitempty"`
	OrderBy *CoinKlineOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) CoinKlines(params *CoinKlinesParams) *CoinKlineExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CoinKlineWhereInput", "CoinKlineOrderByInput", "CoinKline"},
		"coinKlines",
		[]string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"})

	return &CoinKlineExecArray{ret}
}

type CoinKlinesConnectionParams struct {
	Where   *CoinKlineWhereInput   `json:"where,omitempty"`
	OrderBy *CoinKlineOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CoinKlineConnection) Nodes() []CoinKline {
	var nodes []CoinKline
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CoinKlineConnection) NodesPtr() []*CoinKline {
	var nodes []*CoinKline
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CoinKlinesConnection(params *CoinKlinesConnectionParams) *CoinKlineConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CoinKlineWhereInput", "CoinKlineOrderByInput", "CoinKline"},
		"coinKlinesConnection",
		[]string{"edges", "pageInfo"})

	return &CoinKlineConnectionExec{ret}
}

func (client *Client) CoinPriceTable(params CoinPriceTableWhereUniqueInput) *CoinPriceTableExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CoinPriceTableWhereUniqueInput!", "CoinPriceTable"},
		"coinPriceTable",
		[]string{"id", "type", "infoValue", "createdAt", "updatedAt"})

	return &CoinPriceTableExec{ret}
}

type CoinPriceTablesParams struct {
	Where   *CoinPriceTableWhereInput   `json:"where,omitempty"`
	OrderBy *CoinPriceTableOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) CoinPriceTables(params *CoinPriceTablesParams) *CoinPriceTableExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CoinPriceTableWhereInput", "CoinPriceTableOrderByInput", "CoinPriceTable"},
		"coinPriceTables",
		[]string{"id", "type", "infoValue", "createdAt", "updatedAt"})

	return &CoinPriceTableExecArray{ret}
}

type CoinPriceTablesConnectionParams struct {
	Where   *CoinPriceTableWhereInput   `json:"where,omitempty"`
	OrderBy *CoinPriceTableOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CoinPriceTableConnection) Nodes() []CoinPriceTable {
	var nodes []CoinPriceTable
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CoinPriceTableConnection) NodesPtr() []*CoinPriceTable {
	var nodes []*CoinPriceTable
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CoinPriceTablesConnection(params *CoinPriceTablesConnectionParams) *CoinPriceTableConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CoinPriceTableWhereInput", "CoinPriceTableOrderByInput", "CoinPriceTable"},
		"coinPriceTablesConnection",
		[]string{"edges", "pageInfo"})

	return &CoinPriceTableConnectionExec{ret}
}

func (client *Client) Comment(params CommentWhereUniqueInput) *CommentExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CommentWhereUniqueInput!", "Comment"},
		"comment",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExec{ret}
}

type CommentsParams struct {
	Where   *CommentWhereInput   `json:"where,omitempty"`
	OrderBy *CommentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Comments(params *CommentsParams) *CommentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
		"comments",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExecArray{ret}
}

type CommentsConnectionParams struct {
	Where   *CommentWhereInput   `json:"where,omitempty"`
	OrderBy *CommentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CommentConnection) Nodes() []Comment {
	var nodes []Comment
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CommentConnection) NodesPtr() []*Comment {
	var nodes []*Comment
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CommentsConnection(params *CommentsConnectionParams) *CommentConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
		"commentsConnection",
		[]string{"edges", "pageInfo"})

	return &CommentConnectionExec{ret}
}

func (client *Client) CommentReply(params CommentReplyWhereUniqueInput) *CommentReplyExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"CommentReplyWhereUniqueInput!", "CommentReply"},
		"commentReply",
		[]string{"id", "content", "createdAt", "updatedAt", "isDel"})

	return &CommentReplyExec{ret}
}

type CommentRepliesParams struct {
	Where   *CommentReplyWhereInput   `json:"where,omitempty"`
	OrderBy *CommentReplyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) CommentReplies(params *CommentRepliesParams) *CommentReplyExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CommentReplyWhereInput", "CommentReplyOrderByInput", "CommentReply"},
		"commentReplies",
		[]string{"id", "content", "createdAt", "updatedAt", "isDel"})

	return &CommentReplyExecArray{ret}
}

type CommentRepliesConnectionParams struct {
	Where   *CommentReplyWhereInput   `json:"where,omitempty"`
	OrderBy *CommentReplyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *CommentReplyConnection) Nodes() []CommentReply {
	var nodes []CommentReply
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *CommentReplyConnection) NodesPtr() []*CommentReply {
	var nodes []*CommentReply
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) CommentRepliesConnection(params *CommentRepliesConnectionParams) *CommentReplyConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"CommentReplyWhereInput", "CommentReplyOrderByInput", "CommentReply"},
		"commentRepliesConnection",
		[]string{"edges", "pageInfo"})

	return &CommentReplyConnectionExec{ret}
}

func (client *Client) Device(params DeviceWhereUniqueInput) *DeviceExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"DeviceWhereUniqueInput!", "Device"},
		"device",
		[]string{"id", "code", "name"})

	return &DeviceExec{ret}
}

type DevicesParams struct {
	Where   *DeviceWhereInput   `json:"where,omitempty"`
	OrderBy *DeviceOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Devices(params *DevicesParams) *DeviceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"DeviceWhereInput", "DeviceOrderByInput", "Device"},
		"devices",
		[]string{"id", "code", "name"})

	return &DeviceExecArray{ret}
}

type DevicesConnectionParams struct {
	Where   *DeviceWhereInput   `json:"where,omitempty"`
	OrderBy *DeviceOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *DeviceConnection) Nodes() []Device {
	var nodes []Device
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *DeviceConnection) NodesPtr() []*Device {
	var nodes []*Device
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) DevicesConnection(params *DevicesConnectionParams) *DeviceConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"DeviceWhereInput", "DeviceOrderByInput", "Device"},
		"devicesConnection",
		[]string{"edges", "pageInfo"})

	return &DeviceConnectionExec{ret}
}

func (client *Client) Fee(params FeeWhereUniqueInput) *FeeExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FeeWhereUniqueInput!", "Fee"},
		"fee",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeeExec{ret}
}

type FeesParams struct {
	Where   *FeeWhereInput   `json:"where,omitempty"`
	OrderBy *FeeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

func (client *Client) Fees(params *FeesParams) *FeeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FeeWhereInput", "FeeOrderByInput", "Fee"},
		"fees",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeeExecArray{ret}
}

type FeesConnectionParams struct {
	Where   *FeeWhereInput   `json:"where,omitempty"`
	OrderBy *FeeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32           `json:"skip,omitempty"`
	After   *string          `json:"after,omitempty"`
	Before  *string          `json:"before,omitempty"`
	First   *int32           `json:"first,omitempty"`
	Last    *int32           `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *FeeConnection) Nodes() []Fee {
	var nodes []Fee
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *FeeConnection) NodesPtr() []*Fee {
	var nodes []*Fee
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) FeesConnection(params *FeesConnectionParams) *FeeConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FeeWhereInput", "FeeOrderByInput", "Fee"},
		"feesConnection",
		[]string{"edges", "pageInfo"})

	return &FeeConnectionExec{ret}
}

func (client *Client) File(params FileWhereUniqueInput) *FileExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FileWhereUniqueInput!", "File"},
		"file",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExec{ret}
}

type FilesParams struct {
	Where   *FileWhereInput   `json:"where,omitempty"`
	OrderBy *FileOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Files(params *FilesParams) *FileExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FileWhereInput", "FileOrderByInput", "File"},
		"files",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExecArray{ret}
}

type FilesConnectionParams struct {
	Where   *FileWhereInput   `json:"where,omitempty"`
	OrderBy *FileOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *FileConnection) Nodes() []File {
	var nodes []File
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *FileConnection) NodesPtr() []*File {
	var nodes []*File
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) FilesConnection(params *FilesConnectionParams) *FileConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FileWhereInput", "FileOrderByInput", "File"},
		"filesConnection",
		[]string{"edges", "pageInfo"})

	return &FileConnectionExec{ret}
}

func (client *Client) FileInfo(params FileInfoWhereUniqueInput) *FileInfoExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"FileInfoWhereUniqueInput!", "FileInfo"},
		"fileInfo",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExec{ret}
}

type FileInfoesParams struct {
	Where   *FileInfoWhereInput   `json:"where,omitempty"`
	OrderBy *FileInfoOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

func (client *Client) FileInfoes(params *FileInfoesParams) *FileInfoExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FileInfoWhereInput", "FileInfoOrderByInput", "FileInfo"},
		"fileInfoes",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExecArray{ret}
}

type FileInfoesConnectionParams struct {
	Where   *FileInfoWhereInput   `json:"where,omitempty"`
	OrderBy *FileInfoOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                `json:"skip,omitempty"`
	After   *string               `json:"after,omitempty"`
	Before  *string               `json:"before,omitempty"`
	First   *int32                `json:"first,omitempty"`
	Last    *int32                `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *FileInfoConnection) Nodes() []FileInfo {
	var nodes []FileInfo
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *FileInfoConnection) NodesPtr() []*FileInfo {
	var nodes []*FileInfo
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) FileInfoesConnection(params *FileInfoesConnectionParams) *FileInfoConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"FileInfoWhereInput", "FileInfoOrderByInput", "FileInfo"},
		"fileInfoesConnection",
		[]string{"edges", "pageInfo"})

	return &FileInfoConnectionExec{ret}
}

func (client *Client) Instagram(params InstagramWhereUniqueInput) *InstagramExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"InstagramWhereUniqueInput!", "Instagram"},
		"instagram",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramExec{ret}
}

type InstagramsParams struct {
	Where   *InstagramWhereInput   `json:"where,omitempty"`
	OrderBy *InstagramOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) Instagrams(params *InstagramsParams) *InstagramExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"InstagramWhereInput", "InstagramOrderByInput", "Instagram"},
		"instagrams",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramExecArray{ret}
}

type InstagramsConnectionParams struct {
	Where   *InstagramWhereInput   `json:"where,omitempty"`
	OrderBy *InstagramOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *InstagramConnection) Nodes() []Instagram {
	var nodes []Instagram
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *InstagramConnection) NodesPtr() []*Instagram {
	var nodes []*Instagram
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) InstagramsConnection(params *InstagramsConnectionParams) *InstagramConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"InstagramWhereInput", "InstagramOrderByInput", "Instagram"},
		"instagramsConnection",
		[]string{"edges", "pageInfo"})

	return &InstagramConnectionExec{ret}
}

func (client *Client) InstagramDailyStatistics(params InstagramDailyStatisticsWhereUniqueInput) *InstagramDailyStatisticsExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"InstagramDailyStatisticsWhereUniqueInput!", "InstagramDailyStatistics"},
		"instagramDailyStatistics",
		[]string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"})

	return &InstagramDailyStatisticsExec{ret}
}

type InstagramDailyStatisticsesParams struct {
	Where   *InstagramDailyStatisticsWhereInput   `json:"where,omitempty"`
	OrderBy *InstagramDailyStatisticsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                                `json:"skip,omitempty"`
	After   *string                               `json:"after,omitempty"`
	Before  *string                               `json:"before,omitempty"`
	First   *int32                                `json:"first,omitempty"`
	Last    *int32                                `json:"last,omitempty"`
}

func (client *Client) InstagramDailyStatisticses(params *InstagramDailyStatisticsesParams) *InstagramDailyStatisticsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"InstagramDailyStatisticsWhereInput", "InstagramDailyStatisticsOrderByInput", "InstagramDailyStatistics"},
		"instagramDailyStatisticses",
		[]string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"})

	return &InstagramDailyStatisticsExecArray{ret}
}

type InstagramDailyStatisticsesConnectionParams struct {
	Where   *InstagramDailyStatisticsWhereInput   `json:"where,omitempty"`
	OrderBy *InstagramDailyStatisticsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                                `json:"skip,omitempty"`
	After   *string                               `json:"after,omitempty"`
	Before  *string                               `json:"before,omitempty"`
	First   *int32                                `json:"first,omitempty"`
	Last    *int32                                `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *InstagramDailyStatisticsConnection) Nodes() []InstagramDailyStatistics {
	var nodes []InstagramDailyStatistics
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *InstagramDailyStatisticsConnection) NodesPtr() []*InstagramDailyStatistics {
	var nodes []*InstagramDailyStatistics
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) InstagramDailyStatisticsesConnection(params *InstagramDailyStatisticsesConnectionParams) *InstagramDailyStatisticsConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"InstagramDailyStatisticsWhereInput", "InstagramDailyStatisticsOrderByInput", "InstagramDailyStatistics"},
		"instagramDailyStatisticsesConnection",
		[]string{"edges", "pageInfo"})

	return &InstagramDailyStatisticsConnectionExec{ret}
}

func (client *Client) InviteCode(params InviteCodeWhereUniqueInput) *InviteCodeExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"InviteCodeWhereUniqueInput!", "InviteCode"},
		"inviteCode",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodeExec{ret}
}

type InviteCodesParams struct {
	Where   *InviteCodeWhereInput   `json:"where,omitempty"`
	OrderBy *InviteCodeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

func (client *Client) InviteCodes(params *InviteCodesParams) *InviteCodeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"InviteCodeWhereInput", "InviteCodeOrderByInput", "InviteCode"},
		"inviteCodes",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodeExecArray{ret}
}

type InviteCodesConnectionParams struct {
	Where   *InviteCodeWhereInput   `json:"where,omitempty"`
	OrderBy *InviteCodeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                  `json:"skip,omitempty"`
	After   *string                 `json:"after,omitempty"`
	Before  *string                 `json:"before,omitempty"`
	First   *int32                  `json:"first,omitempty"`
	Last    *int32                  `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *InviteCodeConnection) Nodes() []InviteCode {
	var nodes []InviteCode
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *InviteCodeConnection) NodesPtr() []*InviteCode {
	var nodes []*InviteCode
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) InviteCodesConnection(params *InviteCodesConnectionParams) *InviteCodeConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"InviteCodeWhereInput", "InviteCodeOrderByInput", "InviteCode"},
		"inviteCodesConnection",
		[]string{"edges", "pageInfo"})

	return &InviteCodeConnectionExec{ret}
}

func (client *Client) InviteUserHistory(params InviteUserHistoryWhereUniqueInput) *InviteUserHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"InviteUserHistoryWhereUniqueInput!", "InviteUserHistory"},
		"inviteUserHistory",
		[]string{"id", "createdAt", "updatedAt"})

	return &InviteUserHistoryExec{ret}
}

type InviteUserHistoriesParams struct {
	Where   *InviteUserHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *InviteUserHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

func (client *Client) InviteUserHistories(params *InviteUserHistoriesParams) *InviteUserHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"InviteUserHistoryWhereInput", "InviteUserHistoryOrderByInput", "InviteUserHistory"},
		"inviteUserHistories",
		[]string{"id", "createdAt", "updatedAt"})

	return &InviteUserHistoryExecArray{ret}
}

type InviteUserHistoriesConnectionParams struct {
	Where   *InviteUserHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *InviteUserHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *InviteUserHistoryConnection) Nodes() []InviteUserHistory {
	var nodes []InviteUserHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *InviteUserHistoryConnection) NodesPtr() []*InviteUserHistory {
	var nodes []*InviteUserHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) InviteUserHistoriesConnection(params *InviteUserHistoriesConnectionParams) *InviteUserHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"InviteUserHistoryWhereInput", "InviteUserHistoryOrderByInput", "InviteUserHistory"},
		"inviteUserHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &InviteUserHistoryConnectionExec{ret}
}

func (client *Client) Maintenance(params MaintenanceWhereUniqueInput) *MaintenanceExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"MaintenanceWhereUniqueInput!", "Maintenance"},
		"maintenance",
		[]string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"})

	return &MaintenanceExec{ret}
}

type MaintenancesParams struct {
	Where   *MaintenanceWhereInput   `json:"where,omitempty"`
	OrderBy *MaintenanceOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) Maintenances(params *MaintenancesParams) *MaintenanceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"MaintenanceWhereInput", "MaintenanceOrderByInput", "Maintenance"},
		"maintenances",
		[]string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"})

	return &MaintenanceExecArray{ret}
}

type MaintenancesConnectionParams struct {
	Where   *MaintenanceWhereInput   `json:"where,omitempty"`
	OrderBy *MaintenanceOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *MaintenanceConnection) Nodes() []Maintenance {
	var nodes []Maintenance
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *MaintenanceConnection) NodesPtr() []*Maintenance {
	var nodes []*Maintenance
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) MaintenancesConnection(params *MaintenancesConnectionParams) *MaintenanceConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"MaintenanceWhereInput", "MaintenanceOrderByInput", "Maintenance"},
		"maintenancesConnection",
		[]string{"edges", "pageInfo"})

	return &MaintenanceConnectionExec{ret}
}

func (client *Client) MotherHistory(params MotherHistoryWhereUniqueInput) *MotherHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"MotherHistoryWhereUniqueInput!", "MotherHistory"},
		"motherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

type MotherHistoriesParams struct {
	Where   *MotherHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *MotherHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) MotherHistories(params *MotherHistoriesParams) *MotherHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"MotherHistoryWhereInput", "MotherHistoryOrderByInput", "MotherHistory"},
		"motherHistories",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExecArray{ret}
}

type MotherHistoriesConnectionParams struct {
	Where   *MotherHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *MotherHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *MotherHistoryConnection) Nodes() []MotherHistory {
	var nodes []MotherHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *MotherHistoryConnection) NodesPtr() []*MotherHistory {
	var nodes []*MotherHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) MotherHistoriesConnection(params *MotherHistoriesConnectionParams) *MotherHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"MotherHistoryWhereInput", "MotherHistoryOrderByInput", "MotherHistory"},
		"motherHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &MotherHistoryConnectionExec{ret}
}

func (client *Client) Notification(params NotificationWhereUniqueInput) *NotificationExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"NotificationWhereUniqueInput!", "Notification"},
		"notification",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationExec{ret}
}

type NotificationsParams struct {
	Where   *NotificationWhereInput   `json:"where,omitempty"`
	OrderBy *NotificationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) Notifications(params *NotificationsParams) *NotificationExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"NotificationWhereInput", "NotificationOrderByInput", "Notification"},
		"notifications",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationExecArray{ret}
}

type NotificationsConnectionParams struct {
	Where   *NotificationWhereInput   `json:"where,omitempty"`
	OrderBy *NotificationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *NotificationConnection) Nodes() []Notification {
	var nodes []Notification
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *NotificationConnection) NodesPtr() []*Notification {
	var nodes []*Notification
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) NotificationsConnection(params *NotificationsConnectionParams) *NotificationConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"NotificationWhereInput", "NotificationOrderByInput", "Notification"},
		"notificationsConnection",
		[]string{"edges", "pageInfo"})

	return &NotificationConnectionExec{ret}
}

func (client *Client) Offer(params OfferWhereUniqueInput) *OfferExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"OfferWhereUniqueInput!", "Offer"},
		"offer",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferExec{ret}
}

type OffersParams struct {
	Where   *OfferWhereInput   `json:"where,omitempty"`
	OrderBy *OfferOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Offers(params *OffersParams) *OfferExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OfferWhereInput", "OfferOrderByInput", "Offer"},
		"offers",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferExecArray{ret}
}

type OffersConnectionParams struct {
	Where   *OfferWhereInput   `json:"where,omitempty"`
	OrderBy *OfferOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *OfferConnection) Nodes() []Offer {
	var nodes []Offer
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *OfferConnection) NodesPtr() []*Offer {
	var nodes []*Offer
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) OffersConnection(params *OffersConnectionParams) *OfferConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OfferWhereInput", "OfferOrderByInput", "Offer"},
		"offersConnection",
		[]string{"edges", "pageInfo"})

	return &OfferConnectionExec{ret}
}

func (client *Client) Offeror(params OfferorWhereUniqueInput) *OfferorExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"OfferorWhereUniqueInput!", "Offeror"},
		"offeror",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorExec{ret}
}

type OfferorsParams struct {
	Where   *OfferorWhereInput   `json:"where,omitempty"`
	OrderBy *OfferorOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Offerors(params *OfferorsParams) *OfferorExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OfferorWhereInput", "OfferorOrderByInput", "Offeror"},
		"offerors",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorExecArray{ret}
}

type OfferorsConnectionParams struct {
	Where   *OfferorWhereInput   `json:"where,omitempty"`
	OrderBy *OfferorOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *OfferorConnection) Nodes() []Offeror {
	var nodes []Offeror
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *OfferorConnection) NodesPtr() []*Offeror {
	var nodes []*Offeror
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) OfferorsConnection(params *OfferorsConnectionParams) *OfferorConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OfferorWhereInput", "OfferorOrderByInput", "Offeror"},
		"offerorsConnection",
		[]string{"edges", "pageInfo"})

	return &OfferorConnectionExec{ret}
}

func (client *Client) OrderDealsHistory(params OrderDealsHistoryWhereUniqueInput) *OrderDealsHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"OrderDealsHistoryWhereUniqueInput!", "OrderDealsHistory"},
		"orderDealsHistory",
		[]string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"})

	return &OrderDealsHistoryExec{ret}
}

type OrderDealsHistoriesParams struct {
	Where   *OrderDealsHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *OrderDealsHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

func (client *Client) OrderDealsHistories(params *OrderDealsHistoriesParams) *OrderDealsHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OrderDealsHistoryWhereInput", "OrderDealsHistoryOrderByInput", "OrderDealsHistory"},
		"orderDealsHistories",
		[]string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"})

	return &OrderDealsHistoryExecArray{ret}
}

type OrderDealsHistoriesConnectionParams struct {
	Where   *OrderDealsHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *OrderDealsHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *OrderDealsHistoryConnection) Nodes() []OrderDealsHistory {
	var nodes []OrderDealsHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *OrderDealsHistoryConnection) NodesPtr() []*OrderDealsHistory {
	var nodes []*OrderDealsHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) OrderDealsHistoriesConnection(params *OrderDealsHistoriesConnectionParams) *OrderDealsHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OrderDealsHistoryWhereInput", "OrderDealsHistoryOrderByInput", "OrderDealsHistory"},
		"orderDealsHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &OrderDealsHistoryConnectionExec{ret}
}

func (client *Client) OrderHistory(params OrderHistoryWhereUniqueInput) *OrderHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"OrderHistoryWhereUniqueInput!", "OrderHistory"},
		"orderHistory",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExec{ret}
}

type OrderHistoriesParams struct {
	Where   *OrderHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *OrderHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) OrderHistories(params *OrderHistoriesParams) *OrderHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OrderHistoryWhereInput", "OrderHistoryOrderByInput", "OrderHistory"},
		"orderHistories",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExecArray{ret}
}

type OrderHistoriesConnectionParams struct {
	Where   *OrderHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *OrderHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *OrderHistoryConnection) Nodes() []OrderHistory {
	var nodes []OrderHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *OrderHistoryConnection) NodesPtr() []*OrderHistory {
	var nodes []*OrderHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) OrderHistoriesConnection(params *OrderHistoriesConnectionParams) *OrderHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OrderHistoryWhereInput", "OrderHistoryOrderByInput", "OrderHistory"},
		"orderHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &OrderHistoryConnectionExec{ret}
}

func (client *Client) OrderUserDealsHistory(params OrderUserDealsHistoryWhereUniqueInput) *OrderUserDealsHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"OrderUserDealsHistoryWhereUniqueInput!", "OrderUserDealsHistory"},
		"orderUserDealsHistory",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExec{ret}
}

type OrderUserDealsHistoriesParams struct {
	Where   *OrderUserDealsHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *OrderUserDealsHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                             `json:"skip,omitempty"`
	After   *string                            `json:"after,omitempty"`
	Before  *string                            `json:"before,omitempty"`
	First   *int32                             `json:"first,omitempty"`
	Last    *int32                             `json:"last,omitempty"`
}

func (client *Client) OrderUserDealsHistories(params *OrderUserDealsHistoriesParams) *OrderUserDealsHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OrderUserDealsHistoryWhereInput", "OrderUserDealsHistoryOrderByInput", "OrderUserDealsHistory"},
		"orderUserDealsHistories",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExecArray{ret}
}

type OrderUserDealsHistoriesConnectionParams struct {
	Where   *OrderUserDealsHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *OrderUserDealsHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                             `json:"skip,omitempty"`
	After   *string                            `json:"after,omitempty"`
	Before  *string                            `json:"before,omitempty"`
	First   *int32                             `json:"first,omitempty"`
	Last    *int32                             `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *OrderUserDealsHistoryConnection) Nodes() []OrderUserDealsHistory {
	var nodes []OrderUserDealsHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *OrderUserDealsHistoryConnection) NodesPtr() []*OrderUserDealsHistory {
	var nodes []*OrderUserDealsHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) OrderUserDealsHistoriesConnection(params *OrderUserDealsHistoriesConnectionParams) *OrderUserDealsHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"OrderUserDealsHistoryWhereInput", "OrderUserDealsHistoryOrderByInput", "OrderUserDealsHistory"},
		"orderUserDealsHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &OrderUserDealsHistoryConnectionExec{ret}
}

func (client *Client) Page(params PageWhereUniqueInput) *PageExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PageWhereUniqueInput!", "Page"},
		"page",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

type PagesParams struct {
	Where   *PageWhereInput   `json:"where,omitempty"`
	OrderBy *PageOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Pages(params *PagesParams) *PageExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PageWhereInput", "PageOrderByInput", "Page"},
		"pages",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExecArray{ret}
}

type PagesConnectionParams struct {
	Where   *PageWhereInput   `json:"where,omitempty"`
	OrderBy *PageOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PageConnection) Nodes() []Page {
	var nodes []Page
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PageConnection) NodesPtr() []*Page {
	var nodes []*Page
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PagesConnection(params *PagesConnectionParams) *PageConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PageWhereInput", "PageOrderByInput", "Page"},
		"pagesConnection",
		[]string{"edges", "pageInfo"})

	return &PageConnectionExec{ret}
}

func (client *Client) PageBadge(params PageBadgeWhereUniqueInput) *PageBadgeExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PageBadgeWhereUniqueInput!", "PageBadge"},
		"pageBadge",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExec{ret}
}

type PageBadgesParams struct {
	Where   *PageBadgeWhereInput   `json:"where,omitempty"`
	OrderBy *PageBadgeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

func (client *Client) PageBadges(params *PageBadgesParams) *PageBadgeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PageBadgeWhereInput", "PageBadgeOrderByInput", "PageBadge"},
		"pageBadges",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExecArray{ret}
}

type PageBadgesConnectionParams struct {
	Where   *PageBadgeWhereInput   `json:"where,omitempty"`
	OrderBy *PageBadgeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                 `json:"skip,omitempty"`
	After   *string                `json:"after,omitempty"`
	Before  *string                `json:"before,omitempty"`
	First   *int32                 `json:"first,omitempty"`
	Last    *int32                 `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PageBadgeConnection) Nodes() []PageBadge {
	var nodes []PageBadge
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PageBadgeConnection) NodesPtr() []*PageBadge {
	var nodes []*PageBadge
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PageBadgesConnection(params *PageBadgesConnectionParams) *PageBadgeConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PageBadgeWhereInput", "PageBadgeOrderByInput", "PageBadge"},
		"pageBadgesConnection",
		[]string{"edges", "pageInfo"})

	return &PageBadgeConnectionExec{ret}
}

func (client *Client) PageComment(params PageCommentWhereUniqueInput) *PageCommentExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PageCommentWhereUniqueInput!", "PageComment"},
		"pageComment",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExec{ret}
}

type PageCommentsParams struct {
	Where   *PageCommentWhereInput   `json:"where,omitempty"`
	OrderBy *PageCommentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) PageComments(params *PageCommentsParams) *PageCommentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PageCommentWhereInput", "PageCommentOrderByInput", "PageComment"},
		"pageComments",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExecArray{ret}
}

type PageCommentsConnectionParams struct {
	Where   *PageCommentWhereInput   `json:"where,omitempty"`
	OrderBy *PageCommentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PageCommentConnection) Nodes() []PageComment {
	var nodes []PageComment
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PageCommentConnection) NodesPtr() []*PageComment {
	var nodes []*PageComment
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PageCommentsConnection(params *PageCommentsConnectionParams) *PageCommentConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PageCommentWhereInput", "PageCommentOrderByInput", "PageComment"},
		"pageCommentsConnection",
		[]string{"edges", "pageInfo"})

	return &PageCommentConnectionExec{ret}
}

func (client *Client) PageCommentReply(params PageCommentReplyWhereUniqueInput) *PageCommentReplyExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PageCommentReplyWhereUniqueInput!", "PageCommentReply"},
		"pageCommentReply",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentReplyExec{ret}
}

type PageCommentRepliesParams struct {
	Where   *PageCommentReplyWhereInput   `json:"where,omitempty"`
	OrderBy *PageCommentReplyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                        `json:"skip,omitempty"`
	After   *string                       `json:"after,omitempty"`
	Before  *string                       `json:"before,omitempty"`
	First   *int32                        `json:"first,omitempty"`
	Last    *int32                        `json:"last,omitempty"`
}

func (client *Client) PageCommentReplies(params *PageCommentRepliesParams) *PageCommentReplyExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PageCommentReplyWhereInput", "PageCommentReplyOrderByInput", "PageCommentReply"},
		"pageCommentReplies",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentReplyExecArray{ret}
}

type PageCommentRepliesConnectionParams struct {
	Where   *PageCommentReplyWhereInput   `json:"where,omitempty"`
	OrderBy *PageCommentReplyOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                        `json:"skip,omitempty"`
	After   *string                       `json:"after,omitempty"`
	Before  *string                       `json:"before,omitempty"`
	First   *int32                        `json:"first,omitempty"`
	Last    *int32                        `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PageCommentReplyConnection) Nodes() []PageCommentReply {
	var nodes []PageCommentReply
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PageCommentReplyConnection) NodesPtr() []*PageCommentReply {
	var nodes []*PageCommentReply
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PageCommentRepliesConnection(params *PageCommentRepliesConnectionParams) *PageCommentReplyConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PageCommentReplyWhereInput", "PageCommentReplyOrderByInput", "PageCommentReply"},
		"pageCommentRepliesConnection",
		[]string{"edges", "pageInfo"})

	return &PageCommentReplyConnectionExec{ret}
}

func (client *Client) PageFan(params PageFanWhereUniqueInput) *PageFanExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PageFanWhereUniqueInput!", "PageFan"},
		"pageFan",
		[]string{"id", "createdAt", "updatedAt"})

	return &PageFanExec{ret}
}

type PageFansParams struct {
	Where   *PageFanWhereInput   `json:"where,omitempty"`
	OrderBy *PageFanOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) PageFans(params *PageFansParams) *PageFanExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PageFanWhereInput", "PageFanOrderByInput", "PageFan"},
		"pageFans",
		[]string{"id", "createdAt", "updatedAt"})

	return &PageFanExecArray{ret}
}

type PageFansConnectionParams struct {
	Where   *PageFanWhereInput   `json:"where,omitempty"`
	OrderBy *PageFanOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PageFanConnection) Nodes() []PageFan {
	var nodes []PageFan
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PageFanConnection) NodesPtr() []*PageFan {
	var nodes []*PageFan
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PageFansConnection(params *PageFansConnectionParams) *PageFanConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PageFanWhereInput", "PageFanOrderByInput", "PageFan"},
		"pageFansConnection",
		[]string{"edges", "pageInfo"})

	return &PageFanConnectionExec{ret}
}

func (client *Client) PaymentHistory(params PaymentHistoryWhereUniqueInput) *PaymentHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PaymentHistoryWhereUniqueInput!", "PaymentHistory"},
		"paymentHistory",
		[]string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"})

	return &PaymentHistoryExec{ret}
}

type PaymentHistoriesParams struct {
	Where   *PaymentHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *PaymentHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

func (client *Client) PaymentHistories(params *PaymentHistoriesParams) *PaymentHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PaymentHistoryWhereInput", "PaymentHistoryOrderByInput", "PaymentHistory"},
		"paymentHistories",
		[]string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"})

	return &PaymentHistoryExecArray{ret}
}

type PaymentHistoriesConnectionParams struct {
	Where   *PaymentHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *PaymentHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                      `json:"skip,omitempty"`
	After   *string                     `json:"after,omitempty"`
	Before  *string                     `json:"before,omitempty"`
	First   *int32                      `json:"first,omitempty"`
	Last    *int32                      `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PaymentHistoryConnection) Nodes() []PaymentHistory {
	var nodes []PaymentHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PaymentHistoryConnection) NodesPtr() []*PaymentHistory {
	var nodes []*PaymentHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PaymentHistoriesConnection(params *PaymentHistoriesConnectionParams) *PaymentHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PaymentHistoryWhereInput", "PaymentHistoryOrderByInput", "PaymentHistory"},
		"paymentHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &PaymentHistoryConnectionExec{ret}
}

func (client *Client) PhoneVerification(params PhoneVerificationWhereUniqueInput) *PhoneVerificationExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PhoneVerificationWhereUniqueInput!", "PhoneVerification"},
		"phoneVerification",
		[]string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"})

	return &PhoneVerificationExec{ret}
}

type PhoneVerificationsParams struct {
	Where   *PhoneVerificationWhereInput   `json:"where,omitempty"`
	OrderBy *PhoneVerificationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

func (client *Client) PhoneVerifications(params *PhoneVerificationsParams) *PhoneVerificationExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PhoneVerificationWhereInput", "PhoneVerificationOrderByInput", "PhoneVerification"},
		"phoneVerifications",
		[]string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"})

	return &PhoneVerificationExecArray{ret}
}

type PhoneVerificationsConnectionParams struct {
	Where   *PhoneVerificationWhereInput   `json:"where,omitempty"`
	OrderBy *PhoneVerificationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PhoneVerificationConnection) Nodes() []PhoneVerification {
	var nodes []PhoneVerification
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PhoneVerificationConnection) NodesPtr() []*PhoneVerification {
	var nodes []*PhoneVerification
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PhoneVerificationsConnection(params *PhoneVerificationsConnectionParams) *PhoneVerificationConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PhoneVerificationWhereInput", "PhoneVerificationOrderByInput", "PhoneVerification"},
		"phoneVerificationsConnection",
		[]string{"edges", "pageInfo"})

	return &PhoneVerificationConnectionExec{ret}
}

func (client *Client) Post(params PostWhereUniqueInput) *PostExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PostWhereUniqueInput!", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

type PostsParams struct {
	Where   *PostWhereInput   `json:"where,omitempty"`
	OrderBy *PostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Posts(params *PostsParams) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"posts",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExecArray{ret}
}

type PostsConnectionParams struct {
	Where   *PostWhereInput   `json:"where,omitempty"`
	OrderBy *PostOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PostConnection) Nodes() []Post {
	var nodes []Post
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PostConnection) NodesPtr() []*Post {
	var nodes []*Post
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PostsConnection(params *PostsConnectionParams) *PostConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"postsConnection",
		[]string{"edges", "pageInfo"})

	return &PostConnectionExec{ret}
}

func (client *Client) PostRewardHistory(params PostRewardHistoryWhereUniqueInput) *PostRewardHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"PostRewardHistoryWhereUniqueInput!", "PostRewardHistory"},
		"postRewardHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExec{ret}
}

type PostRewardHistoriesParams struct {
	Where   *PostRewardHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *PostRewardHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

func (client *Client) PostRewardHistories(params *PostRewardHistoriesParams) *PostRewardHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PostRewardHistoryWhereInput", "PostRewardHistoryOrderByInput", "PostRewardHistory"},
		"postRewardHistories",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExecArray{ret}
}

type PostRewardHistoriesConnectionParams struct {
	Where   *PostRewardHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *PostRewardHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *PostRewardHistoryConnection) Nodes() []PostRewardHistory {
	var nodes []PostRewardHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *PostRewardHistoryConnection) NodesPtr() []*PostRewardHistory {
	var nodes []*PostRewardHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) PostRewardHistoriesConnection(params *PostRewardHistoriesConnectionParams) *PostRewardHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"PostRewardHistoryWhereInput", "PostRewardHistoryOrderByInput", "PostRewardHistory"},
		"postRewardHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &PostRewardHistoryConnectionExec{ret}
}

func (client *Client) QuestExpenditureHistory(params QuestExpenditureHistoryWhereUniqueInput) *QuestExpenditureHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"QuestExpenditureHistoryWhereUniqueInput!", "QuestExpenditureHistory"},
		"questExpenditureHistory",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExec{ret}
}

type QuestExpenditureHistoriesParams struct {
	Where   *QuestExpenditureHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *QuestExpenditureHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                               `json:"skip,omitempty"`
	After   *string                              `json:"after,omitempty"`
	Before  *string                              `json:"before,omitempty"`
	First   *int32                               `json:"first,omitempty"`
	Last    *int32                               `json:"last,omitempty"`
}

func (client *Client) QuestExpenditureHistories(params *QuestExpenditureHistoriesParams) *QuestExpenditureHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"QuestExpenditureHistoryWhereInput", "QuestExpenditureHistoryOrderByInput", "QuestExpenditureHistory"},
		"questExpenditureHistories",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExecArray{ret}
}

type QuestExpenditureHistoriesConnectionParams struct {
	Where   *QuestExpenditureHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *QuestExpenditureHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                               `json:"skip,omitempty"`
	After   *string                              `json:"after,omitempty"`
	Before  *string                              `json:"before,omitempty"`
	First   *int32                               `json:"first,omitempty"`
	Last    *int32                               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *QuestExpenditureHistoryConnection) Nodes() []QuestExpenditureHistory {
	var nodes []QuestExpenditureHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *QuestExpenditureHistoryConnection) NodesPtr() []*QuestExpenditureHistory {
	var nodes []*QuestExpenditureHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) QuestExpenditureHistoriesConnection(params *QuestExpenditureHistoriesConnectionParams) *QuestExpenditureHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"QuestExpenditureHistoryWhereInput", "QuestExpenditureHistoryOrderByInput", "QuestExpenditureHistory"},
		"questExpenditureHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &QuestExpenditureHistoryConnectionExec{ret}
}

func (client *Client) QuestMember(params QuestMemberWhereUniqueInput) *QuestMemberExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"QuestMemberWhereUniqueInput!", "QuestMember"},
		"questMember",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberExec{ret}
}

type QuestMembersParams struct {
	Where   *QuestMemberWhereInput   `json:"where,omitempty"`
	OrderBy *QuestMemberOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

func (client *Client) QuestMembers(params *QuestMembersParams) *QuestMemberExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"QuestMemberWhereInput", "QuestMemberOrderByInput", "QuestMember"},
		"questMembers",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberExecArray{ret}
}

type QuestMembersConnectionParams struct {
	Where   *QuestMemberWhereInput   `json:"where,omitempty"`
	OrderBy *QuestMemberOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                   `json:"skip,omitempty"`
	After   *string                  `json:"after,omitempty"`
	Before  *string                  `json:"before,omitempty"`
	First   *int32                   `json:"first,omitempty"`
	Last    *int32                   `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *QuestMemberConnection) Nodes() []QuestMember {
	var nodes []QuestMember
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *QuestMemberConnection) NodesPtr() []*QuestMember {
	var nodes []*QuestMember
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) QuestMembersConnection(params *QuestMembersConnectionParams) *QuestMemberConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"QuestMemberWhereInput", "QuestMemberOrderByInput", "QuestMember"},
		"questMembersConnection",
		[]string{"edges", "pageInfo"})

	return &QuestMemberConnectionExec{ret}
}

func (client *Client) Report(params ReportWhereUniqueInput) *ReportExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ReportWhereUniqueInput!", "Report"},
		"report",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportExec{ret}
}

type ReportsParams struct {
	Where   *ReportWhereInput   `json:"where,omitempty"`
	OrderBy *ReportOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Reports(params *ReportsParams) *ReportExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReportWhereInput", "ReportOrderByInput", "Report"},
		"reports",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportExecArray{ret}
}

type ReportsConnectionParams struct {
	Where   *ReportWhereInput   `json:"where,omitempty"`
	OrderBy *ReportOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ReportConnection) Nodes() []Report {
	var nodes []Report
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ReportConnection) NodesPtr() []*Report {
	var nodes []*Report
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ReportsConnection(params *ReportsConnectionParams) *ReportConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReportWhereInput", "ReportOrderByInput", "Report"},
		"reportsConnection",
		[]string{"edges", "pageInfo"})

	return &ReportConnectionExec{ret}
}

func (client *Client) RequestPageItem(params RequestPageItemWhereUniqueInput) *RequestPageItemExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"RequestPageItemWhereUniqueInput!", "RequestPageItem"},
		"requestPageItem",
		[]string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"})

	return &RequestPageItemExec{ret}
}

type RequestPageItemsParams struct {
	Where   *RequestPageItemWhereInput   `json:"where,omitempty"`
	OrderBy *RequestPageItemOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

func (client *Client) RequestPageItems(params *RequestPageItemsParams) *RequestPageItemExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RequestPageItemWhereInput", "RequestPageItemOrderByInput", "RequestPageItem"},
		"requestPageItems",
		[]string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"})

	return &RequestPageItemExecArray{ret}
}

type RequestPageItemsConnectionParams struct {
	Where   *RequestPageItemWhereInput   `json:"where,omitempty"`
	OrderBy *RequestPageItemOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *RequestPageItemConnection) Nodes() []RequestPageItem {
	var nodes []RequestPageItem
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *RequestPageItemConnection) NodesPtr() []*RequestPageItem {
	var nodes []*RequestPageItem
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) RequestPageItemsConnection(params *RequestPageItemsConnectionParams) *RequestPageItemConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RequestPageItemWhereInput", "RequestPageItemOrderByInput", "RequestPageItem"},
		"requestPageItemsConnection",
		[]string{"edges", "pageInfo"})

	return &RequestPageItemConnectionExec{ret}
}

func (client *Client) ReviewContent(params ReviewContentWhereUniqueInput) *ReviewContentExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ReviewContentWhereUniqueInput!", "ReviewContent"},
		"reviewContent",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExec{ret}
}

type ReviewContentsParams struct {
	Where   *ReviewContentWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

func (client *Client) ReviewContents(params *ReviewContentsParams) *ReviewContentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentWhereInput", "ReviewContentOrderByInput", "ReviewContent"},
		"reviewContents",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExecArray{ret}
}

type ReviewContentsConnectionParams struct {
	Where   *ReviewContentWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                     `json:"skip,omitempty"`
	After   *string                    `json:"after,omitempty"`
	Before  *string                    `json:"before,omitempty"`
	First   *int32                     `json:"first,omitempty"`
	Last    *int32                     `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ReviewContentConnection) Nodes() []ReviewContent {
	var nodes []ReviewContent
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ReviewContentConnection) NodesPtr() []*ReviewContent {
	var nodes []*ReviewContent
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ReviewContentsConnection(params *ReviewContentsConnectionParams) *ReviewContentConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentWhereInput", "ReviewContentOrderByInput", "ReviewContent"},
		"reviewContentsConnection",
		[]string{"edges", "pageInfo"})

	return &ReviewContentConnectionExec{ret}
}

func (client *Client) ReviewContentCategory(params ReviewContentCategoryWhereUniqueInput) *ReviewContentCategoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ReviewContentCategoryWhereUniqueInput!", "ReviewContentCategory"},
		"reviewContentCategory",
		[]string{"id", "name", "imageUrl", "createdAt", "updatedAt"})

	return &ReviewContentCategoryExec{ret}
}

type ReviewContentCategoriesParams struct {
	Where   *ReviewContentCategoryWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentCategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                             `json:"skip,omitempty"`
	After   *string                            `json:"after,omitempty"`
	Before  *string                            `json:"before,omitempty"`
	First   *int32                             `json:"first,omitempty"`
	Last    *int32                             `json:"last,omitempty"`
}

func (client *Client) ReviewContentCategories(params *ReviewContentCategoriesParams) *ReviewContentCategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentCategoryWhereInput", "ReviewContentCategoryOrderByInput", "ReviewContentCategory"},
		"reviewContentCategories",
		[]string{"id", "name", "imageUrl", "createdAt", "updatedAt"})

	return &ReviewContentCategoryExecArray{ret}
}

type ReviewContentCategoriesConnectionParams struct {
	Where   *ReviewContentCategoryWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentCategoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                             `json:"skip,omitempty"`
	After   *string                            `json:"after,omitempty"`
	Before  *string                            `json:"before,omitempty"`
	First   *int32                             `json:"first,omitempty"`
	Last    *int32                             `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ReviewContentCategoryConnection) Nodes() []ReviewContentCategory {
	var nodes []ReviewContentCategory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ReviewContentCategoryConnection) NodesPtr() []*ReviewContentCategory {
	var nodes []*ReviewContentCategory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ReviewContentCategoriesConnection(params *ReviewContentCategoriesConnectionParams) *ReviewContentCategoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentCategoryWhereInput", "ReviewContentCategoryOrderByInput", "ReviewContentCategory"},
		"reviewContentCategoriesConnection",
		[]string{"edges", "pageInfo"})

	return &ReviewContentCategoryConnectionExec{ret}
}

func (client *Client) ReviewContentPage(params ReviewContentPageWhereUniqueInput) *ReviewContentPageExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ReviewContentPageWhereUniqueInput!", "ReviewContentPage"},
		"reviewContentPage",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

type ReviewContentPagesParams struct {
	Where   *ReviewContentPageWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentPageOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

func (client *Client) ReviewContentPages(params *ReviewContentPagesParams) *ReviewContentPageExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentPageWhereInput", "ReviewContentPageOrderByInput", "ReviewContentPage"},
		"reviewContentPages",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExecArray{ret}
}

type ReviewContentPagesConnectionParams struct {
	Where   *ReviewContentPageWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentPageOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ReviewContentPageConnection) Nodes() []ReviewContentPage {
	var nodes []ReviewContentPage
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ReviewContentPageConnection) NodesPtr() []*ReviewContentPage {
	var nodes []*ReviewContentPage
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ReviewContentPagesConnection(params *ReviewContentPagesConnectionParams) *ReviewContentPageConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentPageWhereInput", "ReviewContentPageOrderByInput", "ReviewContentPage"},
		"reviewContentPagesConnection",
		[]string{"edges", "pageInfo"})

	return &ReviewContentPageConnectionExec{ret}
}

func (client *Client) ReviewContentPageFeedBack(params ReviewContentPageFeedBackWhereUniqueInput) *ReviewContentPageFeedBackExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ReviewContentPageFeedBackWhereUniqueInput!", "ReviewContentPageFeedBack"},
		"reviewContentPageFeedBack",
		[]string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"})

	return &ReviewContentPageFeedBackExec{ret}
}

type ReviewContentPageFeedBacksParams struct {
	Where   *ReviewContentPageFeedBackWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentPageFeedBackOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                                 `json:"skip,omitempty"`
	After   *string                                `json:"after,omitempty"`
	Before  *string                                `json:"before,omitempty"`
	First   *int32                                 `json:"first,omitempty"`
	Last    *int32                                 `json:"last,omitempty"`
}

func (client *Client) ReviewContentPageFeedBacks(params *ReviewContentPageFeedBacksParams) *ReviewContentPageFeedBackExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentPageFeedBackWhereInput", "ReviewContentPageFeedBackOrderByInput", "ReviewContentPageFeedBack"},
		"reviewContentPageFeedBacks",
		[]string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"})

	return &ReviewContentPageFeedBackExecArray{ret}
}

type ReviewContentPageFeedBacksConnectionParams struct {
	Where   *ReviewContentPageFeedBackWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentPageFeedBackOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                                 `json:"skip,omitempty"`
	After   *string                                `json:"after,omitempty"`
	Before  *string                                `json:"before,omitempty"`
	First   *int32                                 `json:"first,omitempty"`
	Last    *int32                                 `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ReviewContentPageFeedBackConnection) Nodes() []ReviewContentPageFeedBack {
	var nodes []ReviewContentPageFeedBack
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ReviewContentPageFeedBackConnection) NodesPtr() []*ReviewContentPageFeedBack {
	var nodes []*ReviewContentPageFeedBack
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ReviewContentPageFeedBacksConnection(params *ReviewContentPageFeedBacksConnectionParams) *ReviewContentPageFeedBackConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentPageFeedBackWhereInput", "ReviewContentPageFeedBackOrderByInput", "ReviewContentPageFeedBack"},
		"reviewContentPageFeedBacksConnection",
		[]string{"edges", "pageInfo"})

	return &ReviewContentPageFeedBackConnectionExec{ret}
}

func (client *Client) ReviewContentPageViewer(params ReviewContentPageViewerWhereUniqueInput) *ReviewContentPageViewerExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ReviewContentPageViewerWhereUniqueInput!", "ReviewContentPageViewer"},
		"reviewContentPageViewer",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentPageViewerExec{ret}
}

type ReviewContentPageViewersParams struct {
	Where   *ReviewContentPageViewerWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentPageViewerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                               `json:"skip,omitempty"`
	After   *string                              `json:"after,omitempty"`
	Before  *string                              `json:"before,omitempty"`
	First   *int32                               `json:"first,omitempty"`
	Last    *int32                               `json:"last,omitempty"`
}

func (client *Client) ReviewContentPageViewers(params *ReviewContentPageViewersParams) *ReviewContentPageViewerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentPageViewerWhereInput", "ReviewContentPageViewerOrderByInput", "ReviewContentPageViewer"},
		"reviewContentPageViewers",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentPageViewerExecArray{ret}
}

type ReviewContentPageViewersConnectionParams struct {
	Where   *ReviewContentPageViewerWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentPageViewerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                               `json:"skip,omitempty"`
	After   *string                              `json:"after,omitempty"`
	Before  *string                              `json:"before,omitempty"`
	First   *int32                               `json:"first,omitempty"`
	Last    *int32                               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ReviewContentPageViewerConnection) Nodes() []ReviewContentPageViewer {
	var nodes []ReviewContentPageViewer
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ReviewContentPageViewerConnection) NodesPtr() []*ReviewContentPageViewer {
	var nodes []*ReviewContentPageViewer
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ReviewContentPageViewersConnection(params *ReviewContentPageViewersConnectionParams) *ReviewContentPageViewerConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentPageViewerWhereInput", "ReviewContentPageViewerOrderByInput", "ReviewContentPageViewer"},
		"reviewContentPageViewersConnection",
		[]string{"edges", "pageInfo"})

	return &ReviewContentPageViewerConnectionExec{ret}
}

func (client *Client) ReviewContentReviewer(params ReviewContentReviewerWhereUniqueInput) *ReviewContentReviewerExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ReviewContentReviewerWhereUniqueInput!", "ReviewContentReviewer"},
		"reviewContentReviewer",
		[]string{"id", "review", "createdAt", "updatedAt"})

	return &ReviewContentReviewerExec{ret}
}

type ReviewContentReviewersParams struct {
	Where   *ReviewContentReviewerWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentReviewerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                             `json:"skip,omitempty"`
	After   *string                            `json:"after,omitempty"`
	Before  *string                            `json:"before,omitempty"`
	First   *int32                             `json:"first,omitempty"`
	Last    *int32                             `json:"last,omitempty"`
}

func (client *Client) ReviewContentReviewers(params *ReviewContentReviewersParams) *ReviewContentReviewerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentReviewerWhereInput", "ReviewContentReviewerOrderByInput", "ReviewContentReviewer"},
		"reviewContentReviewers",
		[]string{"id", "review", "createdAt", "updatedAt"})

	return &ReviewContentReviewerExecArray{ret}
}

type ReviewContentReviewersConnectionParams struct {
	Where   *ReviewContentReviewerWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentReviewerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                             `json:"skip,omitempty"`
	After   *string                            `json:"after,omitempty"`
	Before  *string                            `json:"before,omitempty"`
	First   *int32                             `json:"first,omitempty"`
	Last    *int32                             `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ReviewContentReviewerConnection) Nodes() []ReviewContentReviewer {
	var nodes []ReviewContentReviewer
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ReviewContentReviewerConnection) NodesPtr() []*ReviewContentReviewer {
	var nodes []*ReviewContentReviewer
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ReviewContentReviewersConnection(params *ReviewContentReviewersConnectionParams) *ReviewContentReviewerConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentReviewerWhereInput", "ReviewContentReviewerOrderByInput", "ReviewContentReviewer"},
		"reviewContentReviewersConnection",
		[]string{"edges", "pageInfo"})

	return &ReviewContentReviewerConnectionExec{ret}
}

func (client *Client) ReviewContentViewer(params ReviewContentViewerWhereUniqueInput) *ReviewContentViewerExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ReviewContentViewerWhereUniqueInput!", "ReviewContentViewer"},
		"reviewContentViewer",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentViewerExec{ret}
}

type ReviewContentViewersParams struct {
	Where   *ReviewContentViewerWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentViewerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                           `json:"skip,omitempty"`
	After   *string                          `json:"after,omitempty"`
	Before  *string                          `json:"before,omitempty"`
	First   *int32                           `json:"first,omitempty"`
	Last    *int32                           `json:"last,omitempty"`
}

func (client *Client) ReviewContentViewers(params *ReviewContentViewersParams) *ReviewContentViewerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentViewerWhereInput", "ReviewContentViewerOrderByInput", "ReviewContentViewer"},
		"reviewContentViewers",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentViewerExecArray{ret}
}

type ReviewContentViewersConnectionParams struct {
	Where   *ReviewContentViewerWhereInput   `json:"where,omitempty"`
	OrderBy *ReviewContentViewerOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                           `json:"skip,omitempty"`
	After   *string                          `json:"after,omitempty"`
	Before  *string                          `json:"before,omitempty"`
	First   *int32                           `json:"first,omitempty"`
	Last    *int32                           `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *ReviewContentViewerConnection) Nodes() []ReviewContentViewer {
	var nodes []ReviewContentViewer
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *ReviewContentViewerConnection) NodesPtr() []*ReviewContentViewer {
	var nodes []*ReviewContentViewer
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) ReviewContentViewersConnection(params *ReviewContentViewersConnectionParams) *ReviewContentViewerConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ReviewContentViewerWhereInput", "ReviewContentViewerOrderByInput", "ReviewContentViewer"},
		"reviewContentViewersConnection",
		[]string{"edges", "pageInfo"})

	return &ReviewContentViewerConnectionExec{ret}
}

func (client *Client) RewardDropAttendingUser(params RewardDropAttendingUserWhereUniqueInput) *RewardDropAttendingUserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"RewardDropAttendingUserWhereUniqueInput!", "RewardDropAttendingUser"},
		"rewardDropAttendingUser",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserExec{ret}
}

type RewardDropAttendingUsersParams struct {
	Where   *RewardDropAttendingUserWhereInput   `json:"where,omitempty"`
	OrderBy *RewardDropAttendingUserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                               `json:"skip,omitempty"`
	After   *string                              `json:"after,omitempty"`
	Before  *string                              `json:"before,omitempty"`
	First   *int32                               `json:"first,omitempty"`
	Last    *int32                               `json:"last,omitempty"`
}

func (client *Client) RewardDropAttendingUsers(params *RewardDropAttendingUsersParams) *RewardDropAttendingUserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RewardDropAttendingUserWhereInput", "RewardDropAttendingUserOrderByInput", "RewardDropAttendingUser"},
		"rewardDropAttendingUsers",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserExecArray{ret}
}

type RewardDropAttendingUsersConnectionParams struct {
	Where   *RewardDropAttendingUserWhereInput   `json:"where,omitempty"`
	OrderBy *RewardDropAttendingUserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                               `json:"skip,omitempty"`
	After   *string                              `json:"after,omitempty"`
	Before  *string                              `json:"before,omitempty"`
	First   *int32                               `json:"first,omitempty"`
	Last    *int32                               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *RewardDropAttendingUserConnection) Nodes() []RewardDropAttendingUser {
	var nodes []RewardDropAttendingUser
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *RewardDropAttendingUserConnection) NodesPtr() []*RewardDropAttendingUser {
	var nodes []*RewardDropAttendingUser
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) RewardDropAttendingUsersConnection(params *RewardDropAttendingUsersConnectionParams) *RewardDropAttendingUserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RewardDropAttendingUserWhereInput", "RewardDropAttendingUserOrderByInput", "RewardDropAttendingUser"},
		"rewardDropAttendingUsersConnection",
		[]string{"edges", "pageInfo"})

	return &RewardDropAttendingUserConnectionExec{ret}
}

func (client *Client) RewardDropEvent(params RewardDropEventWhereUniqueInput) *RewardDropEventExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"RewardDropEventWhereUniqueInput!", "RewardDropEvent"},
		"rewardDropEvent",
		[]string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"})

	return &RewardDropEventExec{ret}
}

type RewardDropEventsParams struct {
	Where   *RewardDropEventWhereInput   `json:"where,omitempty"`
	OrderBy *RewardDropEventOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

func (client *Client) RewardDropEvents(params *RewardDropEventsParams) *RewardDropEventExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RewardDropEventWhereInput", "RewardDropEventOrderByInput", "RewardDropEvent"},
		"rewardDropEvents",
		[]string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"})

	return &RewardDropEventExecArray{ret}
}

type RewardDropEventsConnectionParams struct {
	Where   *RewardDropEventWhereInput   `json:"where,omitempty"`
	OrderBy *RewardDropEventOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                       `json:"skip,omitempty"`
	After   *string                      `json:"after,omitempty"`
	Before  *string                      `json:"before,omitempty"`
	First   *int32                       `json:"first,omitempty"`
	Last    *int32                       `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *RewardDropEventConnection) Nodes() []RewardDropEvent {
	var nodes []RewardDropEvent
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *RewardDropEventConnection) NodesPtr() []*RewardDropEvent {
	var nodes []*RewardDropEvent
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) RewardDropEventsConnection(params *RewardDropEventsConnectionParams) *RewardDropEventConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"RewardDropEventWhereInput", "RewardDropEventOrderByInput", "RewardDropEvent"},
		"rewardDropEventsConnection",
		[]string{"edges", "pageInfo"})

	return &RewardDropEventConnectionExec{ret}
}

func (client *Client) Twitch(params TwitchWhereUniqueInput) *TwitchExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TwitchWhereUniqueInput!", "Twitch"},
		"twitch",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchExec{ret}
}

type TwitchesParams struct {
	Where   *TwitchWhereInput   `json:"where,omitempty"`
	OrderBy *TwitchOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Twitches(params *TwitchesParams) *TwitchExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TwitchWhereInput", "TwitchOrderByInput", "Twitch"},
		"twitches",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchExecArray{ret}
}

type TwitchesConnectionParams struct {
	Where   *TwitchWhereInput   `json:"where,omitempty"`
	OrderBy *TwitchOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *TwitchConnection) Nodes() []Twitch {
	var nodes []Twitch
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *TwitchConnection) NodesPtr() []*Twitch {
	var nodes []*Twitch
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) TwitchesConnection(params *TwitchesConnectionParams) *TwitchConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TwitchWhereInput", "TwitchOrderByInput", "Twitch"},
		"twitchesConnection",
		[]string{"edges", "pageInfo"})

	return &TwitchConnectionExec{ret}
}

func (client *Client) TwitchDailyStatistics(params TwitchDailyStatisticsWhereUniqueInput) *TwitchDailyStatisticsExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"TwitchDailyStatisticsWhereUniqueInput!", "TwitchDailyStatistics"},
		"twitchDailyStatistics",
		[]string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"})

	return &TwitchDailyStatisticsExec{ret}
}

type TwitchDailyStatisticsesParams struct {
	Where   *TwitchDailyStatisticsWhereInput   `json:"where,omitempty"`
	OrderBy *TwitchDailyStatisticsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                             `json:"skip,omitempty"`
	After   *string                            `json:"after,omitempty"`
	Before  *string                            `json:"before,omitempty"`
	First   *int32                             `json:"first,omitempty"`
	Last    *int32                             `json:"last,omitempty"`
}

func (client *Client) TwitchDailyStatisticses(params *TwitchDailyStatisticsesParams) *TwitchDailyStatisticsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TwitchDailyStatisticsWhereInput", "TwitchDailyStatisticsOrderByInput", "TwitchDailyStatistics"},
		"twitchDailyStatisticses",
		[]string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"})

	return &TwitchDailyStatisticsExecArray{ret}
}

type TwitchDailyStatisticsesConnectionParams struct {
	Where   *TwitchDailyStatisticsWhereInput   `json:"where,omitempty"`
	OrderBy *TwitchDailyStatisticsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                             `json:"skip,omitempty"`
	After   *string                            `json:"after,omitempty"`
	Before  *string                            `json:"before,omitempty"`
	First   *int32                             `json:"first,omitempty"`
	Last    *int32                             `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *TwitchDailyStatisticsConnection) Nodes() []TwitchDailyStatistics {
	var nodes []TwitchDailyStatistics
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *TwitchDailyStatisticsConnection) NodesPtr() []*TwitchDailyStatistics {
	var nodes []*TwitchDailyStatistics
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) TwitchDailyStatisticsesConnection(params *TwitchDailyStatisticsesConnectionParams) *TwitchDailyStatisticsConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"TwitchDailyStatisticsWhereInput", "TwitchDailyStatisticsOrderByInput", "TwitchDailyStatistics"},
		"twitchDailyStatisticsesConnection",
		[]string{"edges", "pageInfo"})

	return &TwitchDailyStatisticsConnectionExec{ret}
}

func (client *Client) UpdatePostHistory(params UpdatePostHistoryWhereUniqueInput) *UpdatePostHistoryExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UpdatePostHistoryWhereUniqueInput!", "UpdatePostHistory"},
		"updatePostHistory",
		[]string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"})

	return &UpdatePostHistoryExec{ret}
}

type UpdatePostHistoriesParams struct {
	Where   *UpdatePostHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *UpdatePostHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

func (client *Client) UpdatePostHistories(params *UpdatePostHistoriesParams) *UpdatePostHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UpdatePostHistoryWhereInput", "UpdatePostHistoryOrderByInput", "UpdatePostHistory"},
		"updatePostHistories",
		[]string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"})

	return &UpdatePostHistoryExecArray{ret}
}

type UpdatePostHistoriesConnectionParams struct {
	Where   *UpdatePostHistoryWhereInput   `json:"where,omitempty"`
	OrderBy *UpdatePostHistoryOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                         `json:"skip,omitempty"`
	After   *string                        `json:"after,omitempty"`
	Before  *string                        `json:"before,omitempty"`
	First   *int32                         `json:"first,omitempty"`
	Last    *int32                         `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *UpdatePostHistoryConnection) Nodes() []UpdatePostHistory {
	var nodes []UpdatePostHistory
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *UpdatePostHistoryConnection) NodesPtr() []*UpdatePostHistory {
	var nodes []*UpdatePostHistory
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) UpdatePostHistoriesConnection(params *UpdatePostHistoriesConnectionParams) *UpdatePostHistoryConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UpdatePostHistoryWhereInput", "UpdatePostHistoryOrderByInput", "UpdatePostHistory"},
		"updatePostHistoriesConnection",
		[]string{"edges", "pageInfo"})

	return &UpdatePostHistoryConnectionExec{ret}
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *UserConnection) Nodes() []User {
	var nodes []User
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *UserConnection) NodesPtr() []*User {
	var nodes []*User
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) UsersConnection(params *UsersConnectionParams) *UserConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"usersConnection",
		[]string{"edges", "pageInfo"})

	return &UserConnectionExec{ret}
}

func (client *Client) Verification(params VerificationWhereUniqueInput) *VerificationExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"VerificationWhereUniqueInput!", "Verification"},
		"verification",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExec{ret}
}

type VerificationsParams struct {
	Where   *VerificationWhereInput   `json:"where,omitempty"`
	OrderBy *VerificationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

func (client *Client) Verifications(params *VerificationsParams) *VerificationExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"VerificationWhereInput", "VerificationOrderByInput", "Verification"},
		"verifications",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExecArray{ret}
}

type VerificationsConnectionParams struct {
	Where   *VerificationWhereInput   `json:"where,omitempty"`
	OrderBy *VerificationOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                    `json:"skip,omitempty"`
	After   *string                   `json:"after,omitempty"`
	Before  *string                   `json:"before,omitempty"`
	First   *int32                    `json:"first,omitempty"`
	Last    *int32                    `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *VerificationConnection) Nodes() []Verification {
	var nodes []Verification
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *VerificationConnection) NodesPtr() []*Verification {
	var nodes []*Verification
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) VerificationsConnection(params *VerificationsConnectionParams) *VerificationConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"VerificationWhereInput", "VerificationOrderByInput", "Verification"},
		"verificationsConnection",
		[]string{"edges", "pageInfo"})

	return &VerificationConnectionExec{ret}
}

func (client *Client) Wallet(params WalletWhereUniqueInput) *WalletExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"WalletWhereUniqueInput!", "Wallet"},
		"wallet",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletExec{ret}
}

type WalletsParams struct {
	Where   *WalletWhereInput   `json:"where,omitempty"`
	OrderBy *WalletOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

func (client *Client) Wallets(params *WalletsParams) *WalletExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WalletWhereInput", "WalletOrderByInput", "Wallet"},
		"wallets",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletExecArray{ret}
}

type WalletsConnectionParams struct {
	Where   *WalletWhereInput   `json:"where,omitempty"`
	OrderBy *WalletOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32              `json:"skip,omitempty"`
	After   *string             `json:"after,omitempty"`
	Before  *string             `json:"before,omitempty"`
	First   *int32              `json:"first,omitempty"`
	Last    *int32              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *WalletConnection) Nodes() []Wallet {
	var nodes []Wallet
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *WalletConnection) NodesPtr() []*Wallet {
	var nodes []*Wallet
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) WalletsConnection(params *WalletsConnectionParams) *WalletConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"WalletWhereInput", "WalletOrderByInput", "Wallet"},
		"walletsConnection",
		[]string{"edges", "pageInfo"})

	return &WalletConnectionExec{ret}
}

func (client *Client) Youtube(params YoutubeWhereUniqueInput) *YoutubeExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"YoutubeWhereUniqueInput!", "Youtube"},
		"youtube",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubeExec{ret}
}

type YoutubesParams struct {
	Where   *YoutubeWhereInput   `json:"where,omitempty"`
	OrderBy *YoutubeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Youtubes(params *YoutubesParams) *YoutubeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"YoutubeWhereInput", "YoutubeOrderByInput", "Youtube"},
		"youtubes",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubeExecArray{ret}
}

type YoutubesConnectionParams struct {
	Where   *YoutubeWhereInput   `json:"where,omitempty"`
	OrderBy *YoutubeOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *YoutubeConnection) Nodes() []Youtube {
	var nodes []Youtube
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *YoutubeConnection) NodesPtr() []*Youtube {
	var nodes []*Youtube
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) YoutubesConnection(params *YoutubesConnectionParams) *YoutubeConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"YoutubeWhereInput", "YoutubeOrderByInput", "Youtube"},
		"youtubesConnection",
		[]string{"edges", "pageInfo"})

	return &YoutubeConnectionExec{ret}
}

func (client *Client) YoutubeDailyStatistics(params YoutubeDailyStatisticsWhereUniqueInput) *YoutubeDailyStatisticsExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"YoutubeDailyStatisticsWhereUniqueInput!", "YoutubeDailyStatistics"},
		"youtubeDailyStatistics",
		[]string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"})

	return &YoutubeDailyStatisticsExec{ret}
}

type YoutubeDailyStatisticsesParams struct {
	Where   *YoutubeDailyStatisticsWhereInput   `json:"where,omitempty"`
	OrderBy *YoutubeDailyStatisticsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                              `json:"skip,omitempty"`
	After   *string                             `json:"after,omitempty"`
	Before  *string                             `json:"before,omitempty"`
	First   *int32                              `json:"first,omitempty"`
	Last    *int32                              `json:"last,omitempty"`
}

func (client *Client) YoutubeDailyStatisticses(params *YoutubeDailyStatisticsesParams) *YoutubeDailyStatisticsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"YoutubeDailyStatisticsWhereInput", "YoutubeDailyStatisticsOrderByInput", "YoutubeDailyStatistics"},
		"youtubeDailyStatisticses",
		[]string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"})

	return &YoutubeDailyStatisticsExecArray{ret}
}

type YoutubeDailyStatisticsesConnectionParams struct {
	Where   *YoutubeDailyStatisticsWhereInput   `json:"where,omitempty"`
	OrderBy *YoutubeDailyStatisticsOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32                              `json:"skip,omitempty"`
	After   *string                             `json:"after,omitempty"`
	Before  *string                             `json:"before,omitempty"`
	First   *int32                              `json:"first,omitempty"`
	Last    *int32                              `json:"last,omitempty"`
}

// Nodes return just nodes without cursors. It uses the already fetched edges.
func (s *YoutubeDailyStatisticsConnection) Nodes() []YoutubeDailyStatistics {
	var nodes []YoutubeDailyStatistics
	for _, edge := range s.Edges {
		nodes = append(nodes, edge.Node)
	}
	return nodes
}

// Nodes return just nodes without cursors, but as a slice of pointers. It uses the already fetched edges.
func (s *YoutubeDailyStatisticsConnection) NodesPtr() []*YoutubeDailyStatistics {
	var nodes []*YoutubeDailyStatistics
	for _, edge := range s.Edges {
		item := edge
		nodes = append(nodes, &item.Node)
	}
	return nodes
}

func (client *Client) YoutubeDailyStatisticsesConnection(params *YoutubeDailyStatisticsesConnectionParams) *YoutubeDailyStatisticsConnectionExec {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"YoutubeDailyStatisticsWhereInput", "YoutubeDailyStatisticsOrderByInput", "YoutubeDailyStatistics"},
		"youtubeDailyStatisticsesConnection",
		[]string{"edges", "pageInfo"})

	return &YoutubeDailyStatisticsConnectionExec{ret}
}

func (client *Client) CreateAdminUser(params AdminUserCreateInput) *AdminUserExec {
	ret := client.Client.Create(
		params,
		[2]string{"AdminUserCreateInput!", "AdminUser"},
		"createAdminUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

type AdminUserUpdateParams struct {
	Data  AdminUserUpdateInput      `json:"data"`
	Where AdminUserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAdminUser(params AdminUserUpdateParams) *AdminUserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AdminUserUpdateInput!", "AdminUserWhereUniqueInput!", "AdminUser"},
		"updateAdminUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

type AdminUserUpdateManyParams struct {
	Data  AdminUserUpdateManyMutationInput `json:"data"`
	Where *AdminUserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAdminUsers(params AdminUserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AdminUserUpdateManyMutationInput!", "AdminUserWhereInput"},
		"updateManyAdminUsers")
	return &BatchPayloadExec{exec}
}

type AdminUserUpsertParams struct {
	Where  AdminUserWhereUniqueInput `json:"where"`
	Create AdminUserCreateInput      `json:"create"`
	Update AdminUserUpdateInput      `json:"update"`
}

func (client *Client) UpsertAdminUser(params AdminUserUpsertParams) *AdminUserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AdminUserWhereUniqueInput!", "AdminUserCreateInput!", "AdminUserUpdateInput!", "AdminUser"},
		"upsertAdminUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (client *Client) DeleteAdminUser(params AdminUserWhereUniqueInput) *AdminUserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AdminUserWhereUniqueInput!", "AdminUser"},
		"deleteAdminUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (client *Client) DeleteManyAdminUsers(params *AdminUserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AdminUserWhereInput", "deleteManyAdminUsers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAergoAccount(params AergoAccountCreateInput) *AergoAccountExec {
	ret := client.Client.Create(
		params,
		[2]string{"AergoAccountCreateInput!", "AergoAccount"},
		"createAergoAccount",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountExec{ret}
}

type AergoAccountUpdateParams struct {
	Data  AergoAccountUpdateInput      `json:"data"`
	Where AergoAccountWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAergoAccount(params AergoAccountUpdateParams) *AergoAccountExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AergoAccountUpdateInput!", "AergoAccountWhereUniqueInput!", "AergoAccount"},
		"updateAergoAccount",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountExec{ret}
}

type AergoAccountUpdateManyParams struct {
	Data  AergoAccountUpdateManyMutationInput `json:"data"`
	Where *AergoAccountWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAergoAccounts(params AergoAccountUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AergoAccountUpdateManyMutationInput!", "AergoAccountWhereInput"},
		"updateManyAergoAccounts")
	return &BatchPayloadExec{exec}
}

type AergoAccountUpsertParams struct {
	Where  AergoAccountWhereUniqueInput `json:"where"`
	Create AergoAccountCreateInput      `json:"create"`
	Update AergoAccountUpdateInput      `json:"update"`
}

func (client *Client) UpsertAergoAccount(params AergoAccountUpsertParams) *AergoAccountExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AergoAccountWhereUniqueInput!", "AergoAccountCreateInput!", "AergoAccountUpdateInput!", "AergoAccount"},
		"upsertAergoAccount",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountExec{ret}
}

func (client *Client) DeleteAergoAccount(params AergoAccountWhereUniqueInput) *AergoAccountExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AergoAccountWhereUniqueInput!", "AergoAccount"},
		"deleteAergoAccount",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountExec{ret}
}

func (client *Client) DeleteManyAergoAccounts(params *AergoAccountWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AergoAccountWhereInput", "deleteManyAergoAccounts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAergoAccountHistory(params AergoAccountHistoryCreateInput) *AergoAccountHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"AergoAccountHistoryCreateInput!", "AergoAccountHistory"},
		"createAergoAccountHistory",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExec{ret}
}

type AergoAccountHistoryUpdateParams struct {
	Data  AergoAccountHistoryUpdateInput      `json:"data"`
	Where AergoAccountHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAergoAccountHistory(params AergoAccountHistoryUpdateParams) *AergoAccountHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AergoAccountHistoryUpdateInput!", "AergoAccountHistoryWhereUniqueInput!", "AergoAccountHistory"},
		"updateAergoAccountHistory",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExec{ret}
}

type AergoAccountHistoryUpdateManyParams struct {
	Data  AergoAccountHistoryUpdateManyMutationInput `json:"data"`
	Where *AergoAccountHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAergoAccountHistories(params AergoAccountHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AergoAccountHistoryUpdateManyMutationInput!", "AergoAccountHistoryWhereInput"},
		"updateManyAergoAccountHistories")
	return &BatchPayloadExec{exec}
}

type AergoAccountHistoryUpsertParams struct {
	Where  AergoAccountHistoryWhereUniqueInput `json:"where"`
	Create AergoAccountHistoryCreateInput      `json:"create"`
	Update AergoAccountHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertAergoAccountHistory(params AergoAccountHistoryUpsertParams) *AergoAccountHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AergoAccountHistoryWhereUniqueInput!", "AergoAccountHistoryCreateInput!", "AergoAccountHistoryUpdateInput!", "AergoAccountHistory"},
		"upsertAergoAccountHistory",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExec{ret}
}

func (client *Client) DeleteAergoAccountHistory(params AergoAccountHistoryWhereUniqueInput) *AergoAccountHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AergoAccountHistoryWhereUniqueInput!", "AergoAccountHistory"},
		"deleteAergoAccountHistory",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExec{ret}
}

func (client *Client) DeleteManyAergoAccountHistories(params *AergoAccountHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AergoAccountHistoryWhereInput", "deleteManyAergoAccountHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAfreecaTv(params AfreecaTvCreateInput) *AfreecaTvExec {
	ret := client.Client.Create(
		params,
		[2]string{"AfreecaTVCreateInput!", "AfreecaTV"},
		"createAfreecaTV",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvExec{ret}
}

type AfreecaTvUpdateParams struct {
	Data  AfreecaTvUpdateInput      `json:"data"`
	Where AfreecaTvWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAfreecaTv(params AfreecaTvUpdateParams) *AfreecaTvExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AfreecaTVUpdateInput!", "AfreecaTVWhereUniqueInput!", "AfreecaTV"},
		"updateAfreecaTV",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvExec{ret}
}

type AfreecaTvUpdateManyParams struct {
	Data  AfreecaTvUpdateManyMutationInput `json:"data"`
	Where *AfreecaTvWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAfreecaTVs(params AfreecaTvUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AfreecaTVUpdateManyMutationInput!", "AfreecaTVWhereInput"},
		"updateManyAfreecaTVs")
	return &BatchPayloadExec{exec}
}

type AfreecaTvUpsertParams struct {
	Where  AfreecaTvWhereUniqueInput `json:"where"`
	Create AfreecaTvCreateInput      `json:"create"`
	Update AfreecaTvUpdateInput      `json:"update"`
}

func (client *Client) UpsertAfreecaTv(params AfreecaTvUpsertParams) *AfreecaTvExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AfreecaTVWhereUniqueInput!", "AfreecaTVCreateInput!", "AfreecaTVUpdateInput!", "AfreecaTV"},
		"upsertAfreecaTV",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvExec{ret}
}

func (client *Client) DeleteAfreecaTv(params AfreecaTvWhereUniqueInput) *AfreecaTvExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AfreecaTVWhereUniqueInput!", "AfreecaTV"},
		"deleteAfreecaTV",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvExec{ret}
}

func (client *Client) DeleteManyAfreecaTVs(params *AfreecaTvWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AfreecaTVWhereInput", "deleteManyAfreecaTVs")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAfreecaTvDailyStatistics(params AfreecaTvDailyStatisticsCreateInput) *AfreecaTvDailyStatisticsExec {
	ret := client.Client.Create(
		params,
		[2]string{"AfreecaTVDailyStatisticsCreateInput!", "AfreecaTVDailyStatistics"},
		"createAfreecaTVDailyStatistics",
		[]string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvDailyStatisticsExec{ret}
}

type AfreecaTvDailyStatisticsUpdateParams struct {
	Data  AfreecaTvDailyStatisticsUpdateInput      `json:"data"`
	Where AfreecaTvDailyStatisticsWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAfreecaTvDailyStatistics(params AfreecaTvDailyStatisticsUpdateParams) *AfreecaTvDailyStatisticsExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AfreecaTVDailyStatisticsUpdateInput!", "AfreecaTVDailyStatisticsWhereUniqueInput!", "AfreecaTVDailyStatistics"},
		"updateAfreecaTVDailyStatistics",
		[]string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvDailyStatisticsExec{ret}
}

type AfreecaTvDailyStatisticsUpdateManyParams struct {
	Data  AfreecaTvDailyStatisticsUpdateManyMutationInput `json:"data"`
	Where *AfreecaTvDailyStatisticsWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAfreecaTvDailyStatisticses(params AfreecaTvDailyStatisticsUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AfreecaTVDailyStatisticsUpdateManyMutationInput!", "AfreecaTVDailyStatisticsWhereInput"},
		"updateManyAfreecaTVDailyStatisticses")
	return &BatchPayloadExec{exec}
}

type AfreecaTvDailyStatisticsUpsertParams struct {
	Where  AfreecaTvDailyStatisticsWhereUniqueInput `json:"where"`
	Create AfreecaTvDailyStatisticsCreateInput      `json:"create"`
	Update AfreecaTvDailyStatisticsUpdateInput      `json:"update"`
}

func (client *Client) UpsertAfreecaTvDailyStatistics(params AfreecaTvDailyStatisticsUpsertParams) *AfreecaTvDailyStatisticsExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AfreecaTVDailyStatisticsWhereUniqueInput!", "AfreecaTVDailyStatisticsCreateInput!", "AfreecaTVDailyStatisticsUpdateInput!", "AfreecaTVDailyStatistics"},
		"upsertAfreecaTVDailyStatistics",
		[]string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvDailyStatisticsExec{ret}
}

func (client *Client) DeleteAfreecaTvDailyStatistics(params AfreecaTvDailyStatisticsWhereUniqueInput) *AfreecaTvDailyStatisticsExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AfreecaTVDailyStatisticsWhereUniqueInput!", "AfreecaTVDailyStatistics"},
		"deleteAfreecaTVDailyStatistics",
		[]string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvDailyStatisticsExec{ret}
}

func (client *Client) DeleteManyAfreecaTvDailyStatisticses(params *AfreecaTvDailyStatisticsWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AfreecaTVDailyStatisticsWhereInput", "deleteManyAfreecaTVDailyStatisticses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAirDrop(params AirDropCreateInput) *AirDropExec {
	ret := client.Client.Create(
		params,
		[2]string{"AirDropCreateInput!", "AirDrop"},
		"createAirDrop",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExec{ret}
}

type AirDropUpdateParams struct {
	Data  AirDropUpdateInput      `json:"data"`
	Where AirDropWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAirDrop(params AirDropUpdateParams) *AirDropExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AirDropUpdateInput!", "AirDropWhereUniqueInput!", "AirDrop"},
		"updateAirDrop",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExec{ret}
}

type AirDropUpdateManyParams struct {
	Data  AirDropUpdateManyMutationInput `json:"data"`
	Where *AirDropWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAirDrops(params AirDropUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AirDropUpdateManyMutationInput!", "AirDropWhereInput"},
		"updateManyAirDrops")
	return &BatchPayloadExec{exec}
}

type AirDropUpsertParams struct {
	Where  AirDropWhereUniqueInput `json:"where"`
	Create AirDropCreateInput      `json:"create"`
	Update AirDropUpdateInput      `json:"update"`
}

func (client *Client) UpsertAirDrop(params AirDropUpsertParams) *AirDropExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AirDropWhereUniqueInput!", "AirDropCreateInput!", "AirDropUpdateInput!", "AirDrop"},
		"upsertAirDrop",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExec{ret}
}

func (client *Client) DeleteAirDrop(params AirDropWhereUniqueInput) *AirDropExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AirDropWhereUniqueInput!", "AirDrop"},
		"deleteAirDrop",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExec{ret}
}

func (client *Client) DeleteManyAirDrops(params *AirDropWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AirDropWhereInput", "deleteManyAirDrops")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAirDropHistory(params AirDropHistoryCreateInput) *AirDropHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"AirDropHistoryCreateInput!", "AirDropHistory"},
		"createAirDropHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExec{ret}
}

type AirDropHistoryUpdateParams struct {
	Data  AirDropHistoryUpdateInput      `json:"data"`
	Where AirDropHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAirDropHistory(params AirDropHistoryUpdateParams) *AirDropHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AirDropHistoryUpdateInput!", "AirDropHistoryWhereUniqueInput!", "AirDropHistory"},
		"updateAirDropHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExec{ret}
}

type AirDropHistoryUpdateManyParams struct {
	Data  AirDropHistoryUpdateManyMutationInput `json:"data"`
	Where *AirDropHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAirDropHistories(params AirDropHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AirDropHistoryUpdateManyMutationInput!", "AirDropHistoryWhereInput"},
		"updateManyAirDropHistories")
	return &BatchPayloadExec{exec}
}

type AirDropHistoryUpsertParams struct {
	Where  AirDropHistoryWhereUniqueInput `json:"where"`
	Create AirDropHistoryCreateInput      `json:"create"`
	Update AirDropHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertAirDropHistory(params AirDropHistoryUpsertParams) *AirDropHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AirDropHistoryWhereUniqueInput!", "AirDropHistoryCreateInput!", "AirDropHistoryUpdateInput!", "AirDropHistory"},
		"upsertAirDropHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExec{ret}
}

func (client *Client) DeleteAirDropHistory(params AirDropHistoryWhereUniqueInput) *AirDropHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AirDropHistoryWhereUniqueInput!", "AirDropHistory"},
		"deleteAirDropHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExec{ret}
}

func (client *Client) DeleteManyAirDropHistories(params *AirDropHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AirDropHistoryWhereInput", "deleteManyAirDropHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAirDropMember(params AirDropMemberCreateInput) *AirDropMemberExec {
	ret := client.Client.Create(
		params,
		[2]string{"AirDropMemberCreateInput!", "AirDropMember"},
		"createAirDropMember",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExec{ret}
}

type AirDropMemberUpdateParams struct {
	Data  AirDropMemberUpdateInput      `json:"data"`
	Where AirDropMemberWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAirDropMember(params AirDropMemberUpdateParams) *AirDropMemberExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AirDropMemberUpdateInput!", "AirDropMemberWhereUniqueInput!", "AirDropMember"},
		"updateAirDropMember",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExec{ret}
}

type AirDropMemberUpdateManyParams struct {
	Data  AirDropMemberUpdateManyMutationInput `json:"data"`
	Where *AirDropMemberWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAirDropMembers(params AirDropMemberUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AirDropMemberUpdateManyMutationInput!", "AirDropMemberWhereInput"},
		"updateManyAirDropMembers")
	return &BatchPayloadExec{exec}
}

type AirDropMemberUpsertParams struct {
	Where  AirDropMemberWhereUniqueInput `json:"where"`
	Create AirDropMemberCreateInput      `json:"create"`
	Update AirDropMemberUpdateInput      `json:"update"`
}

func (client *Client) UpsertAirDropMember(params AirDropMemberUpsertParams) *AirDropMemberExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AirDropMemberWhereUniqueInput!", "AirDropMemberCreateInput!", "AirDropMemberUpdateInput!", "AirDropMember"},
		"upsertAirDropMember",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExec{ret}
}

func (client *Client) DeleteAirDropMember(params AirDropMemberWhereUniqueInput) *AirDropMemberExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AirDropMemberWhereUniqueInput!", "AirDropMember"},
		"deleteAirDropMember",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExec{ret}
}

func (client *Client) DeleteManyAirDropMembers(params *AirDropMemberWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AirDropMemberWhereInput", "deleteManyAirDropMembers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateAppVersion(params AppVersionCreateInput) *AppVersionExec {
	ret := client.Client.Create(
		params,
		[2]string{"AppVersionCreateInput!", "AppVersion"},
		"createAppVersion",
		[]string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"})

	return &AppVersionExec{ret}
}

type AppVersionUpdateParams struct {
	Data  AppVersionUpdateInput      `json:"data"`
	Where AppVersionWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAppVersion(params AppVersionUpdateParams) *AppVersionExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AppVersionUpdateInput!", "AppVersionWhereUniqueInput!", "AppVersion"},
		"updateAppVersion",
		[]string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"})

	return &AppVersionExec{ret}
}

type AppVersionUpdateManyParams struct {
	Data  AppVersionUpdateManyMutationInput `json:"data"`
	Where *AppVersionWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAppVersions(params AppVersionUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AppVersionUpdateManyMutationInput!", "AppVersionWhereInput"},
		"updateManyAppVersions")
	return &BatchPayloadExec{exec}
}

type AppVersionUpsertParams struct {
	Where  AppVersionWhereUniqueInput `json:"where"`
	Create AppVersionCreateInput      `json:"create"`
	Update AppVersionUpdateInput      `json:"update"`
}

func (client *Client) UpsertAppVersion(params AppVersionUpsertParams) *AppVersionExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AppVersionWhereUniqueInput!", "AppVersionCreateInput!", "AppVersionUpdateInput!", "AppVersion"},
		"upsertAppVersion",
		[]string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"})

	return &AppVersionExec{ret}
}

func (client *Client) DeleteAppVersion(params AppVersionWhereUniqueInput) *AppVersionExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AppVersionWhereUniqueInput!", "AppVersion"},
		"deleteAppVersion",
		[]string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"})

	return &AppVersionExec{ret}
}

func (client *Client) DeleteManyAppVersions(params *AppVersionWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AppVersionWhereInput", "deleteManyAppVersions")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateBadge(params BadgeCreateInput) *BadgeExec {
	ret := client.Client.Create(
		params,
		[2]string{"BadgeCreateInput!", "Badge"},
		"createBadge",
		[]string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"})

	return &BadgeExec{ret}
}

type BadgeUpdateParams struct {
	Data  BadgeUpdateInput      `json:"data"`
	Where BadgeWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBadge(params BadgeUpdateParams) *BadgeExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BadgeUpdateInput!", "BadgeWhereUniqueInput!", "Badge"},
		"updateBadge",
		[]string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"})

	return &BadgeExec{ret}
}

type BadgeUpdateManyParams struct {
	Data  BadgeUpdateManyMutationInput `json:"data"`
	Where *BadgeWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBadges(params BadgeUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BadgeUpdateManyMutationInput!", "BadgeWhereInput"},
		"updateManyBadges")
	return &BatchPayloadExec{exec}
}

type BadgeUpsertParams struct {
	Where  BadgeWhereUniqueInput `json:"where"`
	Create BadgeCreateInput      `json:"create"`
	Update BadgeUpdateInput      `json:"update"`
}

func (client *Client) UpsertBadge(params BadgeUpsertParams) *BadgeExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BadgeWhereUniqueInput!", "BadgeCreateInput!", "BadgeUpdateInput!", "Badge"},
		"upsertBadge",
		[]string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"})

	return &BadgeExec{ret}
}

func (client *Client) DeleteBadge(params BadgeWhereUniqueInput) *BadgeExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BadgeWhereUniqueInput!", "Badge"},
		"deleteBadge",
		[]string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"})

	return &BadgeExec{ret}
}

func (client *Client) DeleteManyBadges(params *BadgeWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BadgeWhereInput", "deleteManyBadges")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateBadgeVoter(params BadgeVoterCreateInput) *BadgeVoterExec {
	ret := client.Client.Create(
		params,
		[2]string{"BadgeVoterCreateInput!", "BadgeVoter"},
		"createBadgeVoter",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &BadgeVoterExec{ret}
}

type BadgeVoterUpdateParams struct {
	Data  BadgeVoterUpdateInput      `json:"data"`
	Where BadgeVoterWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBadgeVoter(params BadgeVoterUpdateParams) *BadgeVoterExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BadgeVoterUpdateInput!", "BadgeVoterWhereUniqueInput!", "BadgeVoter"},
		"updateBadgeVoter",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &BadgeVoterExec{ret}
}

type BadgeVoterUpdateManyParams struct {
	Data  BadgeVoterUpdateManyMutationInput `json:"data"`
	Where *BadgeVoterWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBadgeVoters(params BadgeVoterUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BadgeVoterUpdateManyMutationInput!", "BadgeVoterWhereInput"},
		"updateManyBadgeVoters")
	return &BatchPayloadExec{exec}
}

type BadgeVoterUpsertParams struct {
	Where  BadgeVoterWhereUniqueInput `json:"where"`
	Create BadgeVoterCreateInput      `json:"create"`
	Update BadgeVoterUpdateInput      `json:"update"`
}

func (client *Client) UpsertBadgeVoter(params BadgeVoterUpsertParams) *BadgeVoterExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BadgeVoterWhereUniqueInput!", "BadgeVoterCreateInput!", "BadgeVoterUpdateInput!", "BadgeVoter"},
		"upsertBadgeVoter",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &BadgeVoterExec{ret}
}

func (client *Client) DeleteBadgeVoter(params BadgeVoterWhereUniqueInput) *BadgeVoterExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BadgeVoterWhereUniqueInput!", "BadgeVoter"},
		"deleteBadgeVoter",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &BadgeVoterExec{ret}
}

func (client *Client) DeleteManyBadgeVoters(params *BadgeVoterWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BadgeVoterWhereInput", "deleteManyBadgeVoters")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateBank(params BankCreateInput) *BankExec {
	ret := client.Client.Create(
		params,
		[2]string{"BankCreateInput!", "Bank"},
		"createBank",
		[]string{"id", "code", "name", "createdAt", "updatedAt"})

	return &BankExec{ret}
}

type BankUpdateParams struct {
	Data  BankUpdateInput      `json:"data"`
	Where BankWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBank(params BankUpdateParams) *BankExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BankUpdateInput!", "BankWhereUniqueInput!", "Bank"},
		"updateBank",
		[]string{"id", "code", "name", "createdAt", "updatedAt"})

	return &BankExec{ret}
}

type BankUpdateManyParams struct {
	Data  BankUpdateManyMutationInput `json:"data"`
	Where *BankWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBanks(params BankUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BankUpdateManyMutationInput!", "BankWhereInput"},
		"updateManyBanks")
	return &BatchPayloadExec{exec}
}

type BankUpsertParams struct {
	Where  BankWhereUniqueInput `json:"where"`
	Create BankCreateInput      `json:"create"`
	Update BankUpdateInput      `json:"update"`
}

func (client *Client) UpsertBank(params BankUpsertParams) *BankExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BankWhereUniqueInput!", "BankCreateInput!", "BankUpdateInput!", "Bank"},
		"upsertBank",
		[]string{"id", "code", "name", "createdAt", "updatedAt"})

	return &BankExec{ret}
}

func (client *Client) DeleteBank(params BankWhereUniqueInput) *BankExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BankWhereUniqueInput!", "Bank"},
		"deleteBank",
		[]string{"id", "code", "name", "createdAt", "updatedAt"})

	return &BankExec{ret}
}

func (client *Client) DeleteManyBanks(params *BankWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BankWhereInput", "deleteManyBanks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateBankAccountVerification(params BankAccountVerificationCreateInput) *BankAccountVerificationExec {
	ret := client.Client.Create(
		params,
		[2]string{"BankAccountVerificationCreateInput!", "BankAccountVerification"},
		"createBankAccountVerification",
		[]string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationExec{ret}
}

type BankAccountVerificationUpdateParams struct {
	Data  BankAccountVerificationUpdateInput      `json:"data"`
	Where BankAccountVerificationWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBankAccountVerification(params BankAccountVerificationUpdateParams) *BankAccountVerificationExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BankAccountVerificationUpdateInput!", "BankAccountVerificationWhereUniqueInput!", "BankAccountVerification"},
		"updateBankAccountVerification",
		[]string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationExec{ret}
}

type BankAccountVerificationUpdateManyParams struct {
	Data  BankAccountVerificationUpdateManyMutationInput `json:"data"`
	Where *BankAccountVerificationWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBankAccountVerifications(params BankAccountVerificationUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BankAccountVerificationUpdateManyMutationInput!", "BankAccountVerificationWhereInput"},
		"updateManyBankAccountVerifications")
	return &BatchPayloadExec{exec}
}

type BankAccountVerificationUpsertParams struct {
	Where  BankAccountVerificationWhereUniqueInput `json:"where"`
	Create BankAccountVerificationCreateInput      `json:"create"`
	Update BankAccountVerificationUpdateInput      `json:"update"`
}

func (client *Client) UpsertBankAccountVerification(params BankAccountVerificationUpsertParams) *BankAccountVerificationExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BankAccountVerificationWhereUniqueInput!", "BankAccountVerificationCreateInput!", "BankAccountVerificationUpdateInput!", "BankAccountVerification"},
		"upsertBankAccountVerification",
		[]string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationExec{ret}
}

func (client *Client) DeleteBankAccountVerification(params BankAccountVerificationWhereUniqueInput) *BankAccountVerificationExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BankAccountVerificationWhereUniqueInput!", "BankAccountVerification"},
		"deleteBankAccountVerification",
		[]string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationExec{ret}
}

func (client *Client) DeleteManyBankAccountVerifications(params *BankAccountVerificationWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BankAccountVerificationWhereInput", "deleteManyBankAccountVerifications")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateBankAccountVerificationTransactionInfo(params BankAccountVerificationTransactionInfoCreateInput) *BankAccountVerificationTransactionInfoExec {
	ret := client.Client.Create(
		params,
		[2]string{"BankAccountVerificationTransactionInfoCreateInput!", "BankAccountVerificationTransactionInfo"},
		"createBankAccountVerificationTransactionInfo",
		[]string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationTransactionInfoExec{ret}
}

type BankAccountVerificationTransactionInfoUpdateParams struct {
	Data  BankAccountVerificationTransactionInfoUpdateInput      `json:"data"`
	Where BankAccountVerificationTransactionInfoWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBankAccountVerificationTransactionInfo(params BankAccountVerificationTransactionInfoUpdateParams) *BankAccountVerificationTransactionInfoExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BankAccountVerificationTransactionInfoUpdateInput!", "BankAccountVerificationTransactionInfoWhereUniqueInput!", "BankAccountVerificationTransactionInfo"},
		"updateBankAccountVerificationTransactionInfo",
		[]string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationTransactionInfoExec{ret}
}

type BankAccountVerificationTransactionInfoUpdateManyParams struct {
	Data  BankAccountVerificationTransactionInfoUpdateManyMutationInput `json:"data"`
	Where *BankAccountVerificationTransactionInfoWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBankAccountVerificationTransactionInfoes(params BankAccountVerificationTransactionInfoUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BankAccountVerificationTransactionInfoUpdateManyMutationInput!", "BankAccountVerificationTransactionInfoWhereInput"},
		"updateManyBankAccountVerificationTransactionInfoes")
	return &BatchPayloadExec{exec}
}

type BankAccountVerificationTransactionInfoUpsertParams struct {
	Where  BankAccountVerificationTransactionInfoWhereUniqueInput `json:"where"`
	Create BankAccountVerificationTransactionInfoCreateInput      `json:"create"`
	Update BankAccountVerificationTransactionInfoUpdateInput      `json:"update"`
}

func (client *Client) UpsertBankAccountVerificationTransactionInfo(params BankAccountVerificationTransactionInfoUpsertParams) *BankAccountVerificationTransactionInfoExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BankAccountVerificationTransactionInfoWhereUniqueInput!", "BankAccountVerificationTransactionInfoCreateInput!", "BankAccountVerificationTransactionInfoUpdateInput!", "BankAccountVerificationTransactionInfo"},
		"upsertBankAccountVerificationTransactionInfo",
		[]string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationTransactionInfoExec{ret}
}

func (client *Client) DeleteBankAccountVerificationTransactionInfo(params BankAccountVerificationTransactionInfoWhereUniqueInput) *BankAccountVerificationTransactionInfoExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BankAccountVerificationTransactionInfoWhereUniqueInput!", "BankAccountVerificationTransactionInfo"},
		"deleteBankAccountVerificationTransactionInfo",
		[]string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationTransactionInfoExec{ret}
}

func (client *Client) DeleteManyBankAccountVerificationTransactionInfoes(params *BankAccountVerificationTransactionInfoWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BankAccountVerificationTransactionInfoWhereInput", "deleteManyBankAccountVerificationTransactionInfoes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateBoard(params BoardCreateInput) *BoardExec {
	ret := client.Client.Create(
		params,
		[2]string{"BoardCreateInput!", "Board"},
		"createBoard",
		[]string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"})

	return &BoardExec{ret}
}

type BoardUpdateParams struct {
	Data  BoardUpdateInput      `json:"data"`
	Where BoardWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateBoard(params BoardUpdateParams) *BoardExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"BoardUpdateInput!", "BoardWhereUniqueInput!", "Board"},
		"updateBoard",
		[]string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"})

	return &BoardExec{ret}
}

type BoardUpdateManyParams struct {
	Data  BoardUpdateManyMutationInput `json:"data"`
	Where *BoardWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyBoards(params BoardUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"BoardUpdateManyMutationInput!", "BoardWhereInput"},
		"updateManyBoards")
	return &BatchPayloadExec{exec}
}

type BoardUpsertParams struct {
	Where  BoardWhereUniqueInput `json:"where"`
	Create BoardCreateInput      `json:"create"`
	Update BoardUpdateInput      `json:"update"`
}

func (client *Client) UpsertBoard(params BoardUpsertParams) *BoardExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"BoardWhereUniqueInput!", "BoardCreateInput!", "BoardUpdateInput!", "Board"},
		"upsertBoard",
		[]string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"})

	return &BoardExec{ret}
}

func (client *Client) DeleteBoard(params BoardWhereUniqueInput) *BoardExec {
	ret := client.Client.Delete(
		params,
		[2]string{"BoardWhereUniqueInput!", "Board"},
		"deleteBoard",
		[]string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"})

	return &BoardExec{ret}
}

func (client *Client) DeleteManyBoards(params *BoardWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "BoardWhereInput", "deleteManyBoards")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCashHistory(params CashHistoryCreateInput) *CashHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"CashHistoryCreateInput!", "CashHistory"},
		"createCashHistory",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExec{ret}
}

type CashHistoryUpdateParams struct {
	Data  CashHistoryUpdateInput      `json:"data"`
	Where CashHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCashHistory(params CashHistoryUpdateParams) *CashHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CashHistoryUpdateInput!", "CashHistoryWhereUniqueInput!", "CashHistory"},
		"updateCashHistory",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExec{ret}
}

type CashHistoryUpdateManyParams struct {
	Data  CashHistoryUpdateManyMutationInput `json:"data"`
	Where *CashHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCashHistories(params CashHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CashHistoryUpdateManyMutationInput!", "CashHistoryWhereInput"},
		"updateManyCashHistories")
	return &BatchPayloadExec{exec}
}

type CashHistoryUpsertParams struct {
	Where  CashHistoryWhereUniqueInput `json:"where"`
	Create CashHistoryCreateInput      `json:"create"`
	Update CashHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertCashHistory(params CashHistoryUpsertParams) *CashHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CashHistoryWhereUniqueInput!", "CashHistoryCreateInput!", "CashHistoryUpdateInput!", "CashHistory"},
		"upsertCashHistory",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExec{ret}
}

func (client *Client) DeleteCashHistory(params CashHistoryWhereUniqueInput) *CashHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CashHistoryWhereUniqueInput!", "CashHistory"},
		"deleteCashHistory",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExec{ret}
}

func (client *Client) DeleteManyCashHistories(params *CashHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CashHistoryWhereInput", "deleteManyCashHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCategory(params CategoryCreateInput) *CategoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"CategoryCreateInput!", "Category"},
		"createCategory",
		[]string{"id", "name", "order_index"})

	return &CategoryExec{ret}
}

type CategoryUpdateParams struct {
	Data  CategoryUpdateInput      `json:"data"`
	Where CategoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCategory(params CategoryUpdateParams) *CategoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CategoryUpdateInput!", "CategoryWhereUniqueInput!", "Category"},
		"updateCategory",
		[]string{"id", "name", "order_index"})

	return &CategoryExec{ret}
}

type CategoryUpdateManyParams struct {
	Data  CategoryUpdateManyMutationInput `json:"data"`
	Where *CategoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCategories(params CategoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CategoryUpdateManyMutationInput!", "CategoryWhereInput"},
		"updateManyCategories")
	return &BatchPayloadExec{exec}
}

type CategoryUpsertParams struct {
	Where  CategoryWhereUniqueInput `json:"where"`
	Create CategoryCreateInput      `json:"create"`
	Update CategoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertCategory(params CategoryUpsertParams) *CategoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CategoryWhereUniqueInput!", "CategoryCreateInput!", "CategoryUpdateInput!", "Category"},
		"upsertCategory",
		[]string{"id", "name", "order_index"})

	return &CategoryExec{ret}
}

func (client *Client) DeleteCategory(params CategoryWhereUniqueInput) *CategoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CategoryWhereUniqueInput!", "Category"},
		"deleteCategory",
		[]string{"id", "name", "order_index"})

	return &CategoryExec{ret}
}

func (client *Client) DeleteManyCategories(params *CategoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CategoryWhereInput", "deleteManyCategories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCoin(params CoinCreateInput) *CoinExec {
	ret := client.Client.Create(
		params,
		[2]string{"CoinCreateInput!", "Coin"},
		"createCoin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

type CoinUpdateParams struct {
	Data  CoinUpdateInput      `json:"data"`
	Where CoinWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCoin(params CoinUpdateParams) *CoinExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CoinUpdateInput!", "CoinWhereUniqueInput!", "Coin"},
		"updateCoin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

type CoinUpdateManyParams struct {
	Data  CoinUpdateManyMutationInput `json:"data"`
	Where *CoinWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCoins(params CoinUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CoinUpdateManyMutationInput!", "CoinWhereInput"},
		"updateManyCoins")
	return &BatchPayloadExec{exec}
}

type CoinUpsertParams struct {
	Where  CoinWhereUniqueInput `json:"where"`
	Create CoinCreateInput      `json:"create"`
	Update CoinUpdateInput      `json:"update"`
}

func (client *Client) UpsertCoin(params CoinUpsertParams) *CoinExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CoinWhereUniqueInput!", "CoinCreateInput!", "CoinUpdateInput!", "Coin"},
		"upsertCoin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (client *Client) DeleteCoin(params CoinWhereUniqueInput) *CoinExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CoinWhereUniqueInput!", "Coin"},
		"deleteCoin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (client *Client) DeleteManyCoins(params *CoinWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CoinWhereInput", "deleteManyCoins")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCoinKline(params CoinKlineCreateInput) *CoinKlineExec {
	ret := client.Client.Create(
		params,
		[2]string{"CoinKlineCreateInput!", "CoinKline"},
		"createCoinKline",
		[]string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"})

	return &CoinKlineExec{ret}
}

type CoinKlineUpdateParams struct {
	Data  CoinKlineUpdateInput      `json:"data"`
	Where CoinKlineWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCoinKline(params CoinKlineUpdateParams) *CoinKlineExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CoinKlineUpdateInput!", "CoinKlineWhereUniqueInput!", "CoinKline"},
		"updateCoinKline",
		[]string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"})

	return &CoinKlineExec{ret}
}

type CoinKlineUpdateManyParams struct {
	Data  CoinKlineUpdateManyMutationInput `json:"data"`
	Where *CoinKlineWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCoinKlines(params CoinKlineUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CoinKlineUpdateManyMutationInput!", "CoinKlineWhereInput"},
		"updateManyCoinKlines")
	return &BatchPayloadExec{exec}
}

type CoinKlineUpsertParams struct {
	Where  CoinKlineWhereUniqueInput `json:"where"`
	Create CoinKlineCreateInput      `json:"create"`
	Update CoinKlineUpdateInput      `json:"update"`
}

func (client *Client) UpsertCoinKline(params CoinKlineUpsertParams) *CoinKlineExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CoinKlineWhereUniqueInput!", "CoinKlineCreateInput!", "CoinKlineUpdateInput!", "CoinKline"},
		"upsertCoinKline",
		[]string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"})

	return &CoinKlineExec{ret}
}

func (client *Client) DeleteCoinKline(params CoinKlineWhereUniqueInput) *CoinKlineExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CoinKlineWhereUniqueInput!", "CoinKline"},
		"deleteCoinKline",
		[]string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"})

	return &CoinKlineExec{ret}
}

func (client *Client) DeleteManyCoinKlines(params *CoinKlineWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CoinKlineWhereInput", "deleteManyCoinKlines")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCoinPriceTable(params CoinPriceTableCreateInput) *CoinPriceTableExec {
	ret := client.Client.Create(
		params,
		[2]string{"CoinPriceTableCreateInput!", "CoinPriceTable"},
		"createCoinPriceTable",
		[]string{"id", "type", "infoValue", "createdAt", "updatedAt"})

	return &CoinPriceTableExec{ret}
}

type CoinPriceTableUpdateParams struct {
	Data  CoinPriceTableUpdateInput      `json:"data"`
	Where CoinPriceTableWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCoinPriceTable(params CoinPriceTableUpdateParams) *CoinPriceTableExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CoinPriceTableUpdateInput!", "CoinPriceTableWhereUniqueInput!", "CoinPriceTable"},
		"updateCoinPriceTable",
		[]string{"id", "type", "infoValue", "createdAt", "updatedAt"})

	return &CoinPriceTableExec{ret}
}

type CoinPriceTableUpdateManyParams struct {
	Data  CoinPriceTableUpdateManyMutationInput `json:"data"`
	Where *CoinPriceTableWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCoinPriceTables(params CoinPriceTableUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CoinPriceTableUpdateManyMutationInput!", "CoinPriceTableWhereInput"},
		"updateManyCoinPriceTables")
	return &BatchPayloadExec{exec}
}

type CoinPriceTableUpsertParams struct {
	Where  CoinPriceTableWhereUniqueInput `json:"where"`
	Create CoinPriceTableCreateInput      `json:"create"`
	Update CoinPriceTableUpdateInput      `json:"update"`
}

func (client *Client) UpsertCoinPriceTable(params CoinPriceTableUpsertParams) *CoinPriceTableExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CoinPriceTableWhereUniqueInput!", "CoinPriceTableCreateInput!", "CoinPriceTableUpdateInput!", "CoinPriceTable"},
		"upsertCoinPriceTable",
		[]string{"id", "type", "infoValue", "createdAt", "updatedAt"})

	return &CoinPriceTableExec{ret}
}

func (client *Client) DeleteCoinPriceTable(params CoinPriceTableWhereUniqueInput) *CoinPriceTableExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CoinPriceTableWhereUniqueInput!", "CoinPriceTable"},
		"deleteCoinPriceTable",
		[]string{"id", "type", "infoValue", "createdAt", "updatedAt"})

	return &CoinPriceTableExec{ret}
}

func (client *Client) DeleteManyCoinPriceTables(params *CoinPriceTableWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CoinPriceTableWhereInput", "deleteManyCoinPriceTables")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateComment(params CommentCreateInput) *CommentExec {
	ret := client.Client.Create(
		params,
		[2]string{"CommentCreateInput!", "Comment"},
		"createComment",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExec{ret}
}

type CommentUpdateParams struct {
	Data  CommentUpdateInput      `json:"data"`
	Where CommentWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateComment(params CommentUpdateParams) *CommentExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CommentUpdateInput!", "CommentWhereUniqueInput!", "Comment"},
		"updateComment",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExec{ret}
}

type CommentUpdateManyParams struct {
	Data  CommentUpdateManyMutationInput `json:"data"`
	Where *CommentWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyComments(params CommentUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CommentUpdateManyMutationInput!", "CommentWhereInput"},
		"updateManyComments")
	return &BatchPayloadExec{exec}
}

type CommentUpsertParams struct {
	Where  CommentWhereUniqueInput `json:"where"`
	Create CommentCreateInput      `json:"create"`
	Update CommentUpdateInput      `json:"update"`
}

func (client *Client) UpsertComment(params CommentUpsertParams) *CommentExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CommentWhereUniqueInput!", "CommentCreateInput!", "CommentUpdateInput!", "Comment"},
		"upsertComment",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExec{ret}
}

func (client *Client) DeleteComment(params CommentWhereUniqueInput) *CommentExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CommentWhereUniqueInput!", "Comment"},
		"deleteComment",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExec{ret}
}

func (client *Client) DeleteManyComments(params *CommentWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CommentWhereInput", "deleteManyComments")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateCommentReply(params CommentReplyCreateInput) *CommentReplyExec {
	ret := client.Client.Create(
		params,
		[2]string{"CommentReplyCreateInput!", "CommentReply"},
		"createCommentReply",
		[]string{"id", "content", "createdAt", "updatedAt", "isDel"})

	return &CommentReplyExec{ret}
}

type CommentReplyUpdateParams struct {
	Data  CommentReplyUpdateInput      `json:"data"`
	Where CommentReplyWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateCommentReply(params CommentReplyUpdateParams) *CommentReplyExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"CommentReplyUpdateInput!", "CommentReplyWhereUniqueInput!", "CommentReply"},
		"updateCommentReply",
		[]string{"id", "content", "createdAt", "updatedAt", "isDel"})

	return &CommentReplyExec{ret}
}

type CommentReplyUpdateManyParams struct {
	Data  CommentReplyUpdateManyMutationInput `json:"data"`
	Where *CommentReplyWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyCommentReplies(params CommentReplyUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"CommentReplyUpdateManyMutationInput!", "CommentReplyWhereInput"},
		"updateManyCommentReplies")
	return &BatchPayloadExec{exec}
}

type CommentReplyUpsertParams struct {
	Where  CommentReplyWhereUniqueInput `json:"where"`
	Create CommentReplyCreateInput      `json:"create"`
	Update CommentReplyUpdateInput      `json:"update"`
}

func (client *Client) UpsertCommentReply(params CommentReplyUpsertParams) *CommentReplyExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"CommentReplyWhereUniqueInput!", "CommentReplyCreateInput!", "CommentReplyUpdateInput!", "CommentReply"},
		"upsertCommentReply",
		[]string{"id", "content", "createdAt", "updatedAt", "isDel"})

	return &CommentReplyExec{ret}
}

func (client *Client) DeleteCommentReply(params CommentReplyWhereUniqueInput) *CommentReplyExec {
	ret := client.Client.Delete(
		params,
		[2]string{"CommentReplyWhereUniqueInput!", "CommentReply"},
		"deleteCommentReply",
		[]string{"id", "content", "createdAt", "updatedAt", "isDel"})

	return &CommentReplyExec{ret}
}

func (client *Client) DeleteManyCommentReplies(params *CommentReplyWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "CommentReplyWhereInput", "deleteManyCommentReplies")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateDevice(params DeviceCreateInput) *DeviceExec {
	ret := client.Client.Create(
		params,
		[2]string{"DeviceCreateInput!", "Device"},
		"createDevice",
		[]string{"id", "code", "name"})

	return &DeviceExec{ret}
}

type DeviceUpdateParams struct {
	Data  DeviceUpdateInput      `json:"data"`
	Where DeviceWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateDevice(params DeviceUpdateParams) *DeviceExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"DeviceUpdateInput!", "DeviceWhereUniqueInput!", "Device"},
		"updateDevice",
		[]string{"id", "code", "name"})

	return &DeviceExec{ret}
}

type DeviceUpdateManyParams struct {
	Data  DeviceUpdateManyMutationInput `json:"data"`
	Where *DeviceWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyDevices(params DeviceUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"DeviceUpdateManyMutationInput!", "DeviceWhereInput"},
		"updateManyDevices")
	return &BatchPayloadExec{exec}
}

type DeviceUpsertParams struct {
	Where  DeviceWhereUniqueInput `json:"where"`
	Create DeviceCreateInput      `json:"create"`
	Update DeviceUpdateInput      `json:"update"`
}

func (client *Client) UpsertDevice(params DeviceUpsertParams) *DeviceExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"DeviceWhereUniqueInput!", "DeviceCreateInput!", "DeviceUpdateInput!", "Device"},
		"upsertDevice",
		[]string{"id", "code", "name"})

	return &DeviceExec{ret}
}

func (client *Client) DeleteDevice(params DeviceWhereUniqueInput) *DeviceExec {
	ret := client.Client.Delete(
		params,
		[2]string{"DeviceWhereUniqueInput!", "Device"},
		"deleteDevice",
		[]string{"id", "code", "name"})

	return &DeviceExec{ret}
}

func (client *Client) DeleteManyDevices(params *DeviceWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "DeviceWhereInput", "deleteManyDevices")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFee(params FeeCreateInput) *FeeExec {
	ret := client.Client.Create(
		params,
		[2]string{"FeeCreateInput!", "Fee"},
		"createFee",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeeExec{ret}
}

type FeeUpdateParams struct {
	Data  FeeUpdateInput      `json:"data"`
	Where FeeWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFee(params FeeUpdateParams) *FeeExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FeeUpdateInput!", "FeeWhereUniqueInput!", "Fee"},
		"updateFee",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeeExec{ret}
}

type FeeUpdateManyParams struct {
	Data  FeeUpdateManyMutationInput `json:"data"`
	Where *FeeWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyFees(params FeeUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"FeeUpdateManyMutationInput!", "FeeWhereInput"},
		"updateManyFees")
	return &BatchPayloadExec{exec}
}

type FeeUpsertParams struct {
	Where  FeeWhereUniqueInput `json:"where"`
	Create FeeCreateInput      `json:"create"`
	Update FeeUpdateInput      `json:"update"`
}

func (client *Client) UpsertFee(params FeeUpsertParams) *FeeExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FeeWhereUniqueInput!", "FeeCreateInput!", "FeeUpdateInput!", "Fee"},
		"upsertFee",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeeExec{ret}
}

func (client *Client) DeleteFee(params FeeWhereUniqueInput) *FeeExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FeeWhereUniqueInput!", "Fee"},
		"deleteFee",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeeExec{ret}
}

func (client *Client) DeleteManyFees(params *FeeWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FeeWhereInput", "deleteManyFees")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFile(params FileCreateInput) *FileExec {
	ret := client.Client.Create(
		params,
		[2]string{"FileCreateInput!", "File"},
		"createFile",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExec{ret}
}

type FileUpdateParams struct {
	Data  FileUpdateInput      `json:"data"`
	Where FileWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFile(params FileUpdateParams) *FileExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FileUpdateInput!", "FileWhereUniqueInput!", "File"},
		"updateFile",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExec{ret}
}

type FileUpdateManyParams struct {
	Data  FileUpdateManyMutationInput `json:"data"`
	Where *FileWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyFiles(params FileUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"FileUpdateManyMutationInput!", "FileWhereInput"},
		"updateManyFiles")
	return &BatchPayloadExec{exec}
}

type FileUpsertParams struct {
	Where  FileWhereUniqueInput `json:"where"`
	Create FileCreateInput      `json:"create"`
	Update FileUpdateInput      `json:"update"`
}

func (client *Client) UpsertFile(params FileUpsertParams) *FileExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FileWhereUniqueInput!", "FileCreateInput!", "FileUpdateInput!", "File"},
		"upsertFile",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExec{ret}
}

func (client *Client) DeleteFile(params FileWhereUniqueInput) *FileExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FileWhereUniqueInput!", "File"},
		"deleteFile",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExec{ret}
}

func (client *Client) DeleteManyFiles(params *FileWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FileWhereInput", "deleteManyFiles")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateFileInfo(params FileInfoCreateInput) *FileInfoExec {
	ret := client.Client.Create(
		params,
		[2]string{"FileInfoCreateInput!", "FileInfo"},
		"createFileInfo",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExec{ret}
}

type FileInfoUpdateParams struct {
	Data  FileInfoUpdateInput      `json:"data"`
	Where FileInfoWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateFileInfo(params FileInfoUpdateParams) *FileInfoExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"FileInfoUpdateInput!", "FileInfoWhereUniqueInput!", "FileInfo"},
		"updateFileInfo",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExec{ret}
}

type FileInfoUpdateManyParams struct {
	Data  FileInfoUpdateManyMutationInput `json:"data"`
	Where *FileInfoWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyFileInfoes(params FileInfoUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"FileInfoUpdateManyMutationInput!", "FileInfoWhereInput"},
		"updateManyFileInfoes")
	return &BatchPayloadExec{exec}
}

type FileInfoUpsertParams struct {
	Where  FileInfoWhereUniqueInput `json:"where"`
	Create FileInfoCreateInput      `json:"create"`
	Update FileInfoUpdateInput      `json:"update"`
}

func (client *Client) UpsertFileInfo(params FileInfoUpsertParams) *FileInfoExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"FileInfoWhereUniqueInput!", "FileInfoCreateInput!", "FileInfoUpdateInput!", "FileInfo"},
		"upsertFileInfo",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExec{ret}
}

func (client *Client) DeleteFileInfo(params FileInfoWhereUniqueInput) *FileInfoExec {
	ret := client.Client.Delete(
		params,
		[2]string{"FileInfoWhereUniqueInput!", "FileInfo"},
		"deleteFileInfo",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExec{ret}
}

func (client *Client) DeleteManyFileInfoes(params *FileInfoWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "FileInfoWhereInput", "deleteManyFileInfoes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateInstagram(params InstagramCreateInput) *InstagramExec {
	ret := client.Client.Create(
		params,
		[2]string{"InstagramCreateInput!", "Instagram"},
		"createInstagram",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramExec{ret}
}

type InstagramUpdateParams struct {
	Data  InstagramUpdateInput      `json:"data"`
	Where InstagramWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateInstagram(params InstagramUpdateParams) *InstagramExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"InstagramUpdateInput!", "InstagramWhereUniqueInput!", "Instagram"},
		"updateInstagram",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramExec{ret}
}

type InstagramUpdateManyParams struct {
	Data  InstagramUpdateManyMutationInput `json:"data"`
	Where *InstagramWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyInstagrams(params InstagramUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"InstagramUpdateManyMutationInput!", "InstagramWhereInput"},
		"updateManyInstagrams")
	return &BatchPayloadExec{exec}
}

type InstagramUpsertParams struct {
	Where  InstagramWhereUniqueInput `json:"where"`
	Create InstagramCreateInput      `json:"create"`
	Update InstagramUpdateInput      `json:"update"`
}

func (client *Client) UpsertInstagram(params InstagramUpsertParams) *InstagramExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"InstagramWhereUniqueInput!", "InstagramCreateInput!", "InstagramUpdateInput!", "Instagram"},
		"upsertInstagram",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramExec{ret}
}

func (client *Client) DeleteInstagram(params InstagramWhereUniqueInput) *InstagramExec {
	ret := client.Client.Delete(
		params,
		[2]string{"InstagramWhereUniqueInput!", "Instagram"},
		"deleteInstagram",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramExec{ret}
}

func (client *Client) DeleteManyInstagrams(params *InstagramWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "InstagramWhereInput", "deleteManyInstagrams")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateInstagramDailyStatistics(params InstagramDailyStatisticsCreateInput) *InstagramDailyStatisticsExec {
	ret := client.Client.Create(
		params,
		[2]string{"InstagramDailyStatisticsCreateInput!", "InstagramDailyStatistics"},
		"createInstagramDailyStatistics",
		[]string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"})

	return &InstagramDailyStatisticsExec{ret}
}

type InstagramDailyStatisticsUpdateParams struct {
	Data  InstagramDailyStatisticsUpdateInput      `json:"data"`
	Where InstagramDailyStatisticsWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateInstagramDailyStatistics(params InstagramDailyStatisticsUpdateParams) *InstagramDailyStatisticsExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"InstagramDailyStatisticsUpdateInput!", "InstagramDailyStatisticsWhereUniqueInput!", "InstagramDailyStatistics"},
		"updateInstagramDailyStatistics",
		[]string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"})

	return &InstagramDailyStatisticsExec{ret}
}

type InstagramDailyStatisticsUpdateManyParams struct {
	Data  InstagramDailyStatisticsUpdateManyMutationInput `json:"data"`
	Where *InstagramDailyStatisticsWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyInstagramDailyStatisticses(params InstagramDailyStatisticsUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"InstagramDailyStatisticsUpdateManyMutationInput!", "InstagramDailyStatisticsWhereInput"},
		"updateManyInstagramDailyStatisticses")
	return &BatchPayloadExec{exec}
}

type InstagramDailyStatisticsUpsertParams struct {
	Where  InstagramDailyStatisticsWhereUniqueInput `json:"where"`
	Create InstagramDailyStatisticsCreateInput      `json:"create"`
	Update InstagramDailyStatisticsUpdateInput      `json:"update"`
}

func (client *Client) UpsertInstagramDailyStatistics(params InstagramDailyStatisticsUpsertParams) *InstagramDailyStatisticsExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"InstagramDailyStatisticsWhereUniqueInput!", "InstagramDailyStatisticsCreateInput!", "InstagramDailyStatisticsUpdateInput!", "InstagramDailyStatistics"},
		"upsertInstagramDailyStatistics",
		[]string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"})

	return &InstagramDailyStatisticsExec{ret}
}

func (client *Client) DeleteInstagramDailyStatistics(params InstagramDailyStatisticsWhereUniqueInput) *InstagramDailyStatisticsExec {
	ret := client.Client.Delete(
		params,
		[2]string{"InstagramDailyStatisticsWhereUniqueInput!", "InstagramDailyStatistics"},
		"deleteInstagramDailyStatistics",
		[]string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"})

	return &InstagramDailyStatisticsExec{ret}
}

func (client *Client) DeleteManyInstagramDailyStatisticses(params *InstagramDailyStatisticsWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "InstagramDailyStatisticsWhereInput", "deleteManyInstagramDailyStatisticses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateInviteCode(params InviteCodeCreateInput) *InviteCodeExec {
	ret := client.Client.Create(
		params,
		[2]string{"InviteCodeCreateInput!", "InviteCode"},
		"createInviteCode",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodeExec{ret}
}

type InviteCodeUpdateParams struct {
	Data  InviteCodeUpdateInput      `json:"data"`
	Where InviteCodeWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateInviteCode(params InviteCodeUpdateParams) *InviteCodeExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"InviteCodeUpdateInput!", "InviteCodeWhereUniqueInput!", "InviteCode"},
		"updateInviteCode",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodeExec{ret}
}

type InviteCodeUpdateManyParams struct {
	Data  InviteCodeUpdateManyMutationInput `json:"data"`
	Where *InviteCodeWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyInviteCodes(params InviteCodeUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"InviteCodeUpdateManyMutationInput!", "InviteCodeWhereInput"},
		"updateManyInviteCodes")
	return &BatchPayloadExec{exec}
}

type InviteCodeUpsertParams struct {
	Where  InviteCodeWhereUniqueInput `json:"where"`
	Create InviteCodeCreateInput      `json:"create"`
	Update InviteCodeUpdateInput      `json:"update"`
}

func (client *Client) UpsertInviteCode(params InviteCodeUpsertParams) *InviteCodeExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"InviteCodeWhereUniqueInput!", "InviteCodeCreateInput!", "InviteCodeUpdateInput!", "InviteCode"},
		"upsertInviteCode",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodeExec{ret}
}

func (client *Client) DeleteInviteCode(params InviteCodeWhereUniqueInput) *InviteCodeExec {
	ret := client.Client.Delete(
		params,
		[2]string{"InviteCodeWhereUniqueInput!", "InviteCode"},
		"deleteInviteCode",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodeExec{ret}
}

func (client *Client) DeleteManyInviteCodes(params *InviteCodeWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "InviteCodeWhereInput", "deleteManyInviteCodes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateInviteUserHistory(params InviteUserHistoryCreateInput) *InviteUserHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"InviteUserHistoryCreateInput!", "InviteUserHistory"},
		"createInviteUserHistory",
		[]string{"id", "createdAt", "updatedAt"})

	return &InviteUserHistoryExec{ret}
}

type InviteUserHistoryUpdateParams struct {
	Data  InviteUserHistoryUpdateInput      `json:"data"`
	Where InviteUserHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateInviteUserHistory(params InviteUserHistoryUpdateParams) *InviteUserHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"InviteUserHistoryUpdateInput!", "InviteUserHistoryWhereUniqueInput!", "InviteUserHistory"},
		"updateInviteUserHistory",
		[]string{"id", "createdAt", "updatedAt"})

	return &InviteUserHistoryExec{ret}
}

type InviteUserHistoryUpsertParams struct {
	Where  InviteUserHistoryWhereUniqueInput `json:"where"`
	Create InviteUserHistoryCreateInput      `json:"create"`
	Update InviteUserHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertInviteUserHistory(params InviteUserHistoryUpsertParams) *InviteUserHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"InviteUserHistoryWhereUniqueInput!", "InviteUserHistoryCreateInput!", "InviteUserHistoryUpdateInput!", "InviteUserHistory"},
		"upsertInviteUserHistory",
		[]string{"id", "createdAt", "updatedAt"})

	return &InviteUserHistoryExec{ret}
}

func (client *Client) DeleteInviteUserHistory(params InviteUserHistoryWhereUniqueInput) *InviteUserHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"InviteUserHistoryWhereUniqueInput!", "InviteUserHistory"},
		"deleteInviteUserHistory",
		[]string{"id", "createdAt", "updatedAt"})

	return &InviteUserHistoryExec{ret}
}

func (client *Client) DeleteManyInviteUserHistories(params *InviteUserHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "InviteUserHistoryWhereInput", "deleteManyInviteUserHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateMaintenance(params MaintenanceCreateInput) *MaintenanceExec {
	ret := client.Client.Create(
		params,
		[2]string{"MaintenanceCreateInput!", "Maintenance"},
		"createMaintenance",
		[]string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"})

	return &MaintenanceExec{ret}
}

type MaintenanceUpdateParams struct {
	Data  MaintenanceUpdateInput      `json:"data"`
	Where MaintenanceWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateMaintenance(params MaintenanceUpdateParams) *MaintenanceExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"MaintenanceUpdateInput!", "MaintenanceWhereUniqueInput!", "Maintenance"},
		"updateMaintenance",
		[]string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"})

	return &MaintenanceExec{ret}
}

type MaintenanceUpdateManyParams struct {
	Data  MaintenanceUpdateManyMutationInput `json:"data"`
	Where *MaintenanceWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyMaintenances(params MaintenanceUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"MaintenanceUpdateManyMutationInput!", "MaintenanceWhereInput"},
		"updateManyMaintenances")
	return &BatchPayloadExec{exec}
}

type MaintenanceUpsertParams struct {
	Where  MaintenanceWhereUniqueInput `json:"where"`
	Create MaintenanceCreateInput      `json:"create"`
	Update MaintenanceUpdateInput      `json:"update"`
}

func (client *Client) UpsertMaintenance(params MaintenanceUpsertParams) *MaintenanceExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"MaintenanceWhereUniqueInput!", "MaintenanceCreateInput!", "MaintenanceUpdateInput!", "Maintenance"},
		"upsertMaintenance",
		[]string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"})

	return &MaintenanceExec{ret}
}

func (client *Client) DeleteMaintenance(params MaintenanceWhereUniqueInput) *MaintenanceExec {
	ret := client.Client.Delete(
		params,
		[2]string{"MaintenanceWhereUniqueInput!", "Maintenance"},
		"deleteMaintenance",
		[]string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"})

	return &MaintenanceExec{ret}
}

func (client *Client) DeleteManyMaintenances(params *MaintenanceWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "MaintenanceWhereInput", "deleteManyMaintenances")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateMotherHistory(params MotherHistoryCreateInput) *MotherHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"MotherHistoryCreateInput!", "MotherHistory"},
		"createMotherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

type MotherHistoryUpdateParams struct {
	Data  MotherHistoryUpdateInput      `json:"data"`
	Where MotherHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateMotherHistory(params MotherHistoryUpdateParams) *MotherHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"MotherHistoryUpdateInput!", "MotherHistoryWhereUniqueInput!", "MotherHistory"},
		"updateMotherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

type MotherHistoryUpdateManyParams struct {
	Data  MotherHistoryUpdateManyMutationInput `json:"data"`
	Where *MotherHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyMotherHistories(params MotherHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"MotherHistoryUpdateManyMutationInput!", "MotherHistoryWhereInput"},
		"updateManyMotherHistories")
	return &BatchPayloadExec{exec}
}

type MotherHistoryUpsertParams struct {
	Where  MotherHistoryWhereUniqueInput `json:"where"`
	Create MotherHistoryCreateInput      `json:"create"`
	Update MotherHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertMotherHistory(params MotherHistoryUpsertParams) *MotherHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"MotherHistoryWhereUniqueInput!", "MotherHistoryCreateInput!", "MotherHistoryUpdateInput!", "MotherHistory"},
		"upsertMotherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (client *Client) DeleteMotherHistory(params MotherHistoryWhereUniqueInput) *MotherHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"MotherHistoryWhereUniqueInput!", "MotherHistory"},
		"deleteMotherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (client *Client) DeleteManyMotherHistories(params *MotherHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "MotherHistoryWhereInput", "deleteManyMotherHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateNotification(params NotificationCreateInput) *NotificationExec {
	ret := client.Client.Create(
		params,
		[2]string{"NotificationCreateInput!", "Notification"},
		"createNotification",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationExec{ret}
}

type NotificationUpdateParams struct {
	Data  NotificationUpdateInput      `json:"data"`
	Where NotificationWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateNotification(params NotificationUpdateParams) *NotificationExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"NotificationUpdateInput!", "NotificationWhereUniqueInput!", "Notification"},
		"updateNotification",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationExec{ret}
}

type NotificationUpdateManyParams struct {
	Data  NotificationUpdateManyMutationInput `json:"data"`
	Where *NotificationWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyNotifications(params NotificationUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"NotificationUpdateManyMutationInput!", "NotificationWhereInput"},
		"updateManyNotifications")
	return &BatchPayloadExec{exec}
}

type NotificationUpsertParams struct {
	Where  NotificationWhereUniqueInput `json:"where"`
	Create NotificationCreateInput      `json:"create"`
	Update NotificationUpdateInput      `json:"update"`
}

func (client *Client) UpsertNotification(params NotificationUpsertParams) *NotificationExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"NotificationWhereUniqueInput!", "NotificationCreateInput!", "NotificationUpdateInput!", "Notification"},
		"upsertNotification",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationExec{ret}
}

func (client *Client) DeleteNotification(params NotificationWhereUniqueInput) *NotificationExec {
	ret := client.Client.Delete(
		params,
		[2]string{"NotificationWhereUniqueInput!", "Notification"},
		"deleteNotification",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationExec{ret}
}

func (client *Client) DeleteManyNotifications(params *NotificationWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "NotificationWhereInput", "deleteManyNotifications")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateOffer(params OfferCreateInput) *OfferExec {
	ret := client.Client.Create(
		params,
		[2]string{"OfferCreateInput!", "Offer"},
		"createOffer",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferExec{ret}
}

type OfferUpdateParams struct {
	Data  OfferUpdateInput      `json:"data"`
	Where OfferWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateOffer(params OfferUpdateParams) *OfferExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"OfferUpdateInput!", "OfferWhereUniqueInput!", "Offer"},
		"updateOffer",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferExec{ret}
}

type OfferUpdateManyParams struct {
	Data  OfferUpdateManyMutationInput `json:"data"`
	Where *OfferWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyOffers(params OfferUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"OfferUpdateManyMutationInput!", "OfferWhereInput"},
		"updateManyOffers")
	return &BatchPayloadExec{exec}
}

type OfferUpsertParams struct {
	Where  OfferWhereUniqueInput `json:"where"`
	Create OfferCreateInput      `json:"create"`
	Update OfferUpdateInput      `json:"update"`
}

func (client *Client) UpsertOffer(params OfferUpsertParams) *OfferExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"OfferWhereUniqueInput!", "OfferCreateInput!", "OfferUpdateInput!", "Offer"},
		"upsertOffer",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferExec{ret}
}

func (client *Client) DeleteOffer(params OfferWhereUniqueInput) *OfferExec {
	ret := client.Client.Delete(
		params,
		[2]string{"OfferWhereUniqueInput!", "Offer"},
		"deleteOffer",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferExec{ret}
}

func (client *Client) DeleteManyOffers(params *OfferWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "OfferWhereInput", "deleteManyOffers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateOfferor(params OfferorCreateInput) *OfferorExec {
	ret := client.Client.Create(
		params,
		[2]string{"OfferorCreateInput!", "Offeror"},
		"createOfferor",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorExec{ret}
}

type OfferorUpdateParams struct {
	Data  OfferorUpdateInput      `json:"data"`
	Where OfferorWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateOfferor(params OfferorUpdateParams) *OfferorExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"OfferorUpdateInput!", "OfferorWhereUniqueInput!", "Offeror"},
		"updateOfferor",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorExec{ret}
}

type OfferorUpdateManyParams struct {
	Data  OfferorUpdateManyMutationInput `json:"data"`
	Where *OfferorWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyOfferors(params OfferorUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"OfferorUpdateManyMutationInput!", "OfferorWhereInput"},
		"updateManyOfferors")
	return &BatchPayloadExec{exec}
}

type OfferorUpsertParams struct {
	Where  OfferorWhereUniqueInput `json:"where"`
	Create OfferorCreateInput      `json:"create"`
	Update OfferorUpdateInput      `json:"update"`
}

func (client *Client) UpsertOfferor(params OfferorUpsertParams) *OfferorExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"OfferorWhereUniqueInput!", "OfferorCreateInput!", "OfferorUpdateInput!", "Offeror"},
		"upsertOfferor",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorExec{ret}
}

func (client *Client) DeleteOfferor(params OfferorWhereUniqueInput) *OfferorExec {
	ret := client.Client.Delete(
		params,
		[2]string{"OfferorWhereUniqueInput!", "Offeror"},
		"deleteOfferor",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorExec{ret}
}

func (client *Client) DeleteManyOfferors(params *OfferorWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "OfferorWhereInput", "deleteManyOfferors")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateOrderDealsHistory(params OrderDealsHistoryCreateInput) *OrderDealsHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"OrderDealsHistoryCreateInput!", "OrderDealsHistory"},
		"createOrderDealsHistory",
		[]string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"})

	return &OrderDealsHistoryExec{ret}
}

type OrderDealsHistoryUpdateParams struct {
	Data  OrderDealsHistoryUpdateInput      `json:"data"`
	Where OrderDealsHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateOrderDealsHistory(params OrderDealsHistoryUpdateParams) *OrderDealsHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"OrderDealsHistoryUpdateInput!", "OrderDealsHistoryWhereUniqueInput!", "OrderDealsHistory"},
		"updateOrderDealsHistory",
		[]string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"})

	return &OrderDealsHistoryExec{ret}
}

type OrderDealsHistoryUpdateManyParams struct {
	Data  OrderDealsHistoryUpdateManyMutationInput `json:"data"`
	Where *OrderDealsHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyOrderDealsHistories(params OrderDealsHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"OrderDealsHistoryUpdateManyMutationInput!", "OrderDealsHistoryWhereInput"},
		"updateManyOrderDealsHistories")
	return &BatchPayloadExec{exec}
}

type OrderDealsHistoryUpsertParams struct {
	Where  OrderDealsHistoryWhereUniqueInput `json:"where"`
	Create OrderDealsHistoryCreateInput      `json:"create"`
	Update OrderDealsHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertOrderDealsHistory(params OrderDealsHistoryUpsertParams) *OrderDealsHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"OrderDealsHistoryWhereUniqueInput!", "OrderDealsHistoryCreateInput!", "OrderDealsHistoryUpdateInput!", "OrderDealsHistory"},
		"upsertOrderDealsHistory",
		[]string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"})

	return &OrderDealsHistoryExec{ret}
}

func (client *Client) DeleteOrderDealsHistory(params OrderDealsHistoryWhereUniqueInput) *OrderDealsHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"OrderDealsHistoryWhereUniqueInput!", "OrderDealsHistory"},
		"deleteOrderDealsHistory",
		[]string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"})

	return &OrderDealsHistoryExec{ret}
}

func (client *Client) DeleteManyOrderDealsHistories(params *OrderDealsHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "OrderDealsHistoryWhereInput", "deleteManyOrderDealsHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateOrderHistory(params OrderHistoryCreateInput) *OrderHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"OrderHistoryCreateInput!", "OrderHistory"},
		"createOrderHistory",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExec{ret}
}

type OrderHistoryUpdateParams struct {
	Data  OrderHistoryUpdateInput      `json:"data"`
	Where OrderHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateOrderHistory(params OrderHistoryUpdateParams) *OrderHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"OrderHistoryUpdateInput!", "OrderHistoryWhereUniqueInput!", "OrderHistory"},
		"updateOrderHistory",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExec{ret}
}

type OrderHistoryUpdateManyParams struct {
	Data  OrderHistoryUpdateManyMutationInput `json:"data"`
	Where *OrderHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyOrderHistories(params OrderHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"OrderHistoryUpdateManyMutationInput!", "OrderHistoryWhereInput"},
		"updateManyOrderHistories")
	return &BatchPayloadExec{exec}
}

type OrderHistoryUpsertParams struct {
	Where  OrderHistoryWhereUniqueInput `json:"where"`
	Create OrderHistoryCreateInput      `json:"create"`
	Update OrderHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertOrderHistory(params OrderHistoryUpsertParams) *OrderHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"OrderHistoryWhereUniqueInput!", "OrderHistoryCreateInput!", "OrderHistoryUpdateInput!", "OrderHistory"},
		"upsertOrderHistory",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExec{ret}
}

func (client *Client) DeleteOrderHistory(params OrderHistoryWhereUniqueInput) *OrderHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"OrderHistoryWhereUniqueInput!", "OrderHistory"},
		"deleteOrderHistory",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExec{ret}
}

func (client *Client) DeleteManyOrderHistories(params *OrderHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "OrderHistoryWhereInput", "deleteManyOrderHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateOrderUserDealsHistory(params OrderUserDealsHistoryCreateInput) *OrderUserDealsHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"OrderUserDealsHistoryCreateInput!", "OrderUserDealsHistory"},
		"createOrderUserDealsHistory",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExec{ret}
}

type OrderUserDealsHistoryUpdateParams struct {
	Data  OrderUserDealsHistoryUpdateInput      `json:"data"`
	Where OrderUserDealsHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateOrderUserDealsHistory(params OrderUserDealsHistoryUpdateParams) *OrderUserDealsHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"OrderUserDealsHistoryUpdateInput!", "OrderUserDealsHistoryWhereUniqueInput!", "OrderUserDealsHistory"},
		"updateOrderUserDealsHistory",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExec{ret}
}

type OrderUserDealsHistoryUpdateManyParams struct {
	Data  OrderUserDealsHistoryUpdateManyMutationInput `json:"data"`
	Where *OrderUserDealsHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyOrderUserDealsHistories(params OrderUserDealsHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"OrderUserDealsHistoryUpdateManyMutationInput!", "OrderUserDealsHistoryWhereInput"},
		"updateManyOrderUserDealsHistories")
	return &BatchPayloadExec{exec}
}

type OrderUserDealsHistoryUpsertParams struct {
	Where  OrderUserDealsHistoryWhereUniqueInput `json:"where"`
	Create OrderUserDealsHistoryCreateInput      `json:"create"`
	Update OrderUserDealsHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertOrderUserDealsHistory(params OrderUserDealsHistoryUpsertParams) *OrderUserDealsHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"OrderUserDealsHistoryWhereUniqueInput!", "OrderUserDealsHistoryCreateInput!", "OrderUserDealsHistoryUpdateInput!", "OrderUserDealsHistory"},
		"upsertOrderUserDealsHistory",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExec{ret}
}

func (client *Client) DeleteOrderUserDealsHistory(params OrderUserDealsHistoryWhereUniqueInput) *OrderUserDealsHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"OrderUserDealsHistoryWhereUniqueInput!", "OrderUserDealsHistory"},
		"deleteOrderUserDealsHistory",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExec{ret}
}

func (client *Client) DeleteManyOrderUserDealsHistories(params *OrderUserDealsHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "OrderUserDealsHistoryWhereInput", "deleteManyOrderUserDealsHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePage(params PageCreateInput) *PageExec {
	ret := client.Client.Create(
		params,
		[2]string{"PageCreateInput!", "Page"},
		"createPage",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

type PageUpdateParams struct {
	Data  PageUpdateInput      `json:"data"`
	Where PageWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePage(params PageUpdateParams) *PageExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PageUpdateInput!", "PageWhereUniqueInput!", "Page"},
		"updatePage",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

type PageUpdateManyParams struct {
	Data  PageUpdateManyMutationInput `json:"data"`
	Where *PageWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPages(params PageUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PageUpdateManyMutationInput!", "PageWhereInput"},
		"updateManyPages")
	return &BatchPayloadExec{exec}
}

type PageUpsertParams struct {
	Where  PageWhereUniqueInput `json:"where"`
	Create PageCreateInput      `json:"create"`
	Update PageUpdateInput      `json:"update"`
}

func (client *Client) UpsertPage(params PageUpsertParams) *PageExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PageWhereUniqueInput!", "PageCreateInput!", "PageUpdateInput!", "Page"},
		"upsertPage",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (client *Client) DeletePage(params PageWhereUniqueInput) *PageExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PageWhereUniqueInput!", "Page"},
		"deletePage",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (client *Client) DeleteManyPages(params *PageWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PageWhereInput", "deleteManyPages")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePageBadge(params PageBadgeCreateInput) *PageBadgeExec {
	ret := client.Client.Create(
		params,
		[2]string{"PageBadgeCreateInput!", "PageBadge"},
		"createPageBadge",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExec{ret}
}

type PageBadgeUpdateParams struct {
	Data  PageBadgeUpdateInput      `json:"data"`
	Where PageBadgeWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePageBadge(params PageBadgeUpdateParams) *PageBadgeExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PageBadgeUpdateInput!", "PageBadgeWhereUniqueInput!", "PageBadge"},
		"updatePageBadge",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExec{ret}
}

type PageBadgeUpdateManyParams struct {
	Data  PageBadgeUpdateManyMutationInput `json:"data"`
	Where *PageBadgeWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPageBadges(params PageBadgeUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PageBadgeUpdateManyMutationInput!", "PageBadgeWhereInput"},
		"updateManyPageBadges")
	return &BatchPayloadExec{exec}
}

type PageBadgeUpsertParams struct {
	Where  PageBadgeWhereUniqueInput `json:"where"`
	Create PageBadgeCreateInput      `json:"create"`
	Update PageBadgeUpdateInput      `json:"update"`
}

func (client *Client) UpsertPageBadge(params PageBadgeUpsertParams) *PageBadgeExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PageBadgeWhereUniqueInput!", "PageBadgeCreateInput!", "PageBadgeUpdateInput!", "PageBadge"},
		"upsertPageBadge",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExec{ret}
}

func (client *Client) DeletePageBadge(params PageBadgeWhereUniqueInput) *PageBadgeExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PageBadgeWhereUniqueInput!", "PageBadge"},
		"deletePageBadge",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExec{ret}
}

func (client *Client) DeleteManyPageBadges(params *PageBadgeWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PageBadgeWhereInput", "deleteManyPageBadges")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePageComment(params PageCommentCreateInput) *PageCommentExec {
	ret := client.Client.Create(
		params,
		[2]string{"PageCommentCreateInput!", "PageComment"},
		"createPageComment",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExec{ret}
}

type PageCommentUpdateParams struct {
	Data  PageCommentUpdateInput      `json:"data"`
	Where PageCommentWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePageComment(params PageCommentUpdateParams) *PageCommentExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PageCommentUpdateInput!", "PageCommentWhereUniqueInput!", "PageComment"},
		"updatePageComment",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExec{ret}
}

type PageCommentUpdateManyParams struct {
	Data  PageCommentUpdateManyMutationInput `json:"data"`
	Where *PageCommentWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPageComments(params PageCommentUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PageCommentUpdateManyMutationInput!", "PageCommentWhereInput"},
		"updateManyPageComments")
	return &BatchPayloadExec{exec}
}

type PageCommentUpsertParams struct {
	Where  PageCommentWhereUniqueInput `json:"where"`
	Create PageCommentCreateInput      `json:"create"`
	Update PageCommentUpdateInput      `json:"update"`
}

func (client *Client) UpsertPageComment(params PageCommentUpsertParams) *PageCommentExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PageCommentWhereUniqueInput!", "PageCommentCreateInput!", "PageCommentUpdateInput!", "PageComment"},
		"upsertPageComment",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExec{ret}
}

func (client *Client) DeletePageComment(params PageCommentWhereUniqueInput) *PageCommentExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PageCommentWhereUniqueInput!", "PageComment"},
		"deletePageComment",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExec{ret}
}

func (client *Client) DeleteManyPageComments(params *PageCommentWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PageCommentWhereInput", "deleteManyPageComments")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePageCommentReply(params PageCommentReplyCreateInput) *PageCommentReplyExec {
	ret := client.Client.Create(
		params,
		[2]string{"PageCommentReplyCreateInput!", "PageCommentReply"},
		"createPageCommentReply",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentReplyExec{ret}
}

type PageCommentReplyUpdateParams struct {
	Data  PageCommentReplyUpdateInput      `json:"data"`
	Where PageCommentReplyWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePageCommentReply(params PageCommentReplyUpdateParams) *PageCommentReplyExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PageCommentReplyUpdateInput!", "PageCommentReplyWhereUniqueInput!", "PageCommentReply"},
		"updatePageCommentReply",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentReplyExec{ret}
}

type PageCommentReplyUpdateManyParams struct {
	Data  PageCommentReplyUpdateManyMutationInput `json:"data"`
	Where *PageCommentReplyWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPageCommentReplies(params PageCommentReplyUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PageCommentReplyUpdateManyMutationInput!", "PageCommentReplyWhereInput"},
		"updateManyPageCommentReplies")
	return &BatchPayloadExec{exec}
}

type PageCommentReplyUpsertParams struct {
	Where  PageCommentReplyWhereUniqueInput `json:"where"`
	Create PageCommentReplyCreateInput      `json:"create"`
	Update PageCommentReplyUpdateInput      `json:"update"`
}

func (client *Client) UpsertPageCommentReply(params PageCommentReplyUpsertParams) *PageCommentReplyExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PageCommentReplyWhereUniqueInput!", "PageCommentReplyCreateInput!", "PageCommentReplyUpdateInput!", "PageCommentReply"},
		"upsertPageCommentReply",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentReplyExec{ret}
}

func (client *Client) DeletePageCommentReply(params PageCommentReplyWhereUniqueInput) *PageCommentReplyExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PageCommentReplyWhereUniqueInput!", "PageCommentReply"},
		"deletePageCommentReply",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentReplyExec{ret}
}

func (client *Client) DeleteManyPageCommentReplies(params *PageCommentReplyWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PageCommentReplyWhereInput", "deleteManyPageCommentReplies")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePageFan(params PageFanCreateInput) *PageFanExec {
	ret := client.Client.Create(
		params,
		[2]string{"PageFanCreateInput!", "PageFan"},
		"createPageFan",
		[]string{"id", "createdAt", "updatedAt"})

	return &PageFanExec{ret}
}

type PageFanUpdateParams struct {
	Data  PageFanUpdateInput      `json:"data"`
	Where PageFanWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePageFan(params PageFanUpdateParams) *PageFanExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PageFanUpdateInput!", "PageFanWhereUniqueInput!", "PageFan"},
		"updatePageFan",
		[]string{"id", "createdAt", "updatedAt"})

	return &PageFanExec{ret}
}

type PageFanUpsertParams struct {
	Where  PageFanWhereUniqueInput `json:"where"`
	Create PageFanCreateInput      `json:"create"`
	Update PageFanUpdateInput      `json:"update"`
}

func (client *Client) UpsertPageFan(params PageFanUpsertParams) *PageFanExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PageFanWhereUniqueInput!", "PageFanCreateInput!", "PageFanUpdateInput!", "PageFan"},
		"upsertPageFan",
		[]string{"id", "createdAt", "updatedAt"})

	return &PageFanExec{ret}
}

func (client *Client) DeletePageFan(params PageFanWhereUniqueInput) *PageFanExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PageFanWhereUniqueInput!", "PageFan"},
		"deletePageFan",
		[]string{"id", "createdAt", "updatedAt"})

	return &PageFanExec{ret}
}

func (client *Client) DeleteManyPageFans(params *PageFanWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PageFanWhereInput", "deleteManyPageFans")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePaymentHistory(params PaymentHistoryCreateInput) *PaymentHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"PaymentHistoryCreateInput!", "PaymentHistory"},
		"createPaymentHistory",
		[]string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"})

	return &PaymentHistoryExec{ret}
}

type PaymentHistoryUpdateParams struct {
	Data  PaymentHistoryUpdateInput      `json:"data"`
	Where PaymentHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePaymentHistory(params PaymentHistoryUpdateParams) *PaymentHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PaymentHistoryUpdateInput!", "PaymentHistoryWhereUniqueInput!", "PaymentHistory"},
		"updatePaymentHistory",
		[]string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"})

	return &PaymentHistoryExec{ret}
}

type PaymentHistoryUpdateManyParams struct {
	Data  PaymentHistoryUpdateManyMutationInput `json:"data"`
	Where *PaymentHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPaymentHistories(params PaymentHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PaymentHistoryUpdateManyMutationInput!", "PaymentHistoryWhereInput"},
		"updateManyPaymentHistories")
	return &BatchPayloadExec{exec}
}

type PaymentHistoryUpsertParams struct {
	Where  PaymentHistoryWhereUniqueInput `json:"where"`
	Create PaymentHistoryCreateInput      `json:"create"`
	Update PaymentHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertPaymentHistory(params PaymentHistoryUpsertParams) *PaymentHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PaymentHistoryWhereUniqueInput!", "PaymentHistoryCreateInput!", "PaymentHistoryUpdateInput!", "PaymentHistory"},
		"upsertPaymentHistory",
		[]string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"})

	return &PaymentHistoryExec{ret}
}

func (client *Client) DeletePaymentHistory(params PaymentHistoryWhereUniqueInput) *PaymentHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PaymentHistoryWhereUniqueInput!", "PaymentHistory"},
		"deletePaymentHistory",
		[]string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"})

	return &PaymentHistoryExec{ret}
}

func (client *Client) DeleteManyPaymentHistories(params *PaymentHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PaymentHistoryWhereInput", "deleteManyPaymentHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePhoneVerification(params PhoneVerificationCreateInput) *PhoneVerificationExec {
	ret := client.Client.Create(
		params,
		[2]string{"PhoneVerificationCreateInput!", "PhoneVerification"},
		"createPhoneVerification",
		[]string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"})

	return &PhoneVerificationExec{ret}
}

type PhoneVerificationUpdateParams struct {
	Data  PhoneVerificationUpdateInput      `json:"data"`
	Where PhoneVerificationWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePhoneVerification(params PhoneVerificationUpdateParams) *PhoneVerificationExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PhoneVerificationUpdateInput!", "PhoneVerificationWhereUniqueInput!", "PhoneVerification"},
		"updatePhoneVerification",
		[]string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"})

	return &PhoneVerificationExec{ret}
}

type PhoneVerificationUpdateManyParams struct {
	Data  PhoneVerificationUpdateManyMutationInput `json:"data"`
	Where *PhoneVerificationWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPhoneVerifications(params PhoneVerificationUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PhoneVerificationUpdateManyMutationInput!", "PhoneVerificationWhereInput"},
		"updateManyPhoneVerifications")
	return &BatchPayloadExec{exec}
}

type PhoneVerificationUpsertParams struct {
	Where  PhoneVerificationWhereUniqueInput `json:"where"`
	Create PhoneVerificationCreateInput      `json:"create"`
	Update PhoneVerificationUpdateInput      `json:"update"`
}

func (client *Client) UpsertPhoneVerification(params PhoneVerificationUpsertParams) *PhoneVerificationExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PhoneVerificationWhereUniqueInput!", "PhoneVerificationCreateInput!", "PhoneVerificationUpdateInput!", "PhoneVerification"},
		"upsertPhoneVerification",
		[]string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"})

	return &PhoneVerificationExec{ret}
}

func (client *Client) DeletePhoneVerification(params PhoneVerificationWhereUniqueInput) *PhoneVerificationExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PhoneVerificationWhereUniqueInput!", "PhoneVerification"},
		"deletePhoneVerification",
		[]string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"})

	return &PhoneVerificationExec{ret}
}

func (client *Client) DeleteManyPhoneVerifications(params *PhoneVerificationWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PhoneVerificationWhereInput", "deleteManyPhoneVerifications")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePost(params PostCreateInput) *PostExec {
	ret := client.Client.Create(
		params,
		[2]string{"PostCreateInput!", "Post"},
		"createPost",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

type PostUpdateParams struct {
	Data  PostUpdateInput      `json:"data"`
	Where PostWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePost(params PostUpdateParams) *PostExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PostUpdateInput!", "PostWhereUniqueInput!", "Post"},
		"updatePost",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

type PostUpdateManyParams struct {
	Data  PostUpdateManyMutationInput `json:"data"`
	Where *PostWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPosts(params PostUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PostUpdateManyMutationInput!", "PostWhereInput"},
		"updateManyPosts")
	return &BatchPayloadExec{exec}
}

type PostUpsertParams struct {
	Where  PostWhereUniqueInput `json:"where"`
	Create PostCreateInput      `json:"create"`
	Update PostUpdateInput      `json:"update"`
}

func (client *Client) UpsertPost(params PostUpsertParams) *PostExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PostWhereUniqueInput!", "PostCreateInput!", "PostUpdateInput!", "Post"},
		"upsertPost",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (client *Client) DeletePost(params PostWhereUniqueInput) *PostExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PostWhereUniqueInput!", "Post"},
		"deletePost",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (client *Client) DeleteManyPosts(params *PostWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PostWhereInput", "deleteManyPosts")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreatePostRewardHistory(params PostRewardHistoryCreateInput) *PostRewardHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"PostRewardHistoryCreateInput!", "PostRewardHistory"},
		"createPostRewardHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExec{ret}
}

type PostRewardHistoryUpdateParams struct {
	Data  PostRewardHistoryUpdateInput      `json:"data"`
	Where PostRewardHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdatePostRewardHistory(params PostRewardHistoryUpdateParams) *PostRewardHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"PostRewardHistoryUpdateInput!", "PostRewardHistoryWhereUniqueInput!", "PostRewardHistory"},
		"updatePostRewardHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExec{ret}
}

type PostRewardHistoryUpdateManyParams struct {
	Data  PostRewardHistoryUpdateManyMutationInput `json:"data"`
	Where *PostRewardHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyPostRewardHistories(params PostRewardHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"PostRewardHistoryUpdateManyMutationInput!", "PostRewardHistoryWhereInput"},
		"updateManyPostRewardHistories")
	return &BatchPayloadExec{exec}
}

type PostRewardHistoryUpsertParams struct {
	Where  PostRewardHistoryWhereUniqueInput `json:"where"`
	Create PostRewardHistoryCreateInput      `json:"create"`
	Update PostRewardHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertPostRewardHistory(params PostRewardHistoryUpsertParams) *PostRewardHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"PostRewardHistoryWhereUniqueInput!", "PostRewardHistoryCreateInput!", "PostRewardHistoryUpdateInput!", "PostRewardHistory"},
		"upsertPostRewardHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExec{ret}
}

func (client *Client) DeletePostRewardHistory(params PostRewardHistoryWhereUniqueInput) *PostRewardHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"PostRewardHistoryWhereUniqueInput!", "PostRewardHistory"},
		"deletePostRewardHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExec{ret}
}

func (client *Client) DeleteManyPostRewardHistories(params *PostRewardHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "PostRewardHistoryWhereInput", "deleteManyPostRewardHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateQuestExpenditureHistory(params QuestExpenditureHistoryCreateInput) *QuestExpenditureHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"QuestExpenditureHistoryCreateInput!", "QuestExpenditureHistory"},
		"createQuestExpenditureHistory",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExec{ret}
}

type QuestExpenditureHistoryUpdateParams struct {
	Data  QuestExpenditureHistoryUpdateInput      `json:"data"`
	Where QuestExpenditureHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateQuestExpenditureHistory(params QuestExpenditureHistoryUpdateParams) *QuestExpenditureHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"QuestExpenditureHistoryUpdateInput!", "QuestExpenditureHistoryWhereUniqueInput!", "QuestExpenditureHistory"},
		"updateQuestExpenditureHistory",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExec{ret}
}

type QuestExpenditureHistoryUpdateManyParams struct {
	Data  QuestExpenditureHistoryUpdateManyMutationInput `json:"data"`
	Where *QuestExpenditureHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyQuestExpenditureHistories(params QuestExpenditureHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"QuestExpenditureHistoryUpdateManyMutationInput!", "QuestExpenditureHistoryWhereInput"},
		"updateManyQuestExpenditureHistories")
	return &BatchPayloadExec{exec}
}

type QuestExpenditureHistoryUpsertParams struct {
	Where  QuestExpenditureHistoryWhereUniqueInput `json:"where"`
	Create QuestExpenditureHistoryCreateInput      `json:"create"`
	Update QuestExpenditureHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertQuestExpenditureHistory(params QuestExpenditureHistoryUpsertParams) *QuestExpenditureHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"QuestExpenditureHistoryWhereUniqueInput!", "QuestExpenditureHistoryCreateInput!", "QuestExpenditureHistoryUpdateInput!", "QuestExpenditureHistory"},
		"upsertQuestExpenditureHistory",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExec{ret}
}

func (client *Client) DeleteQuestExpenditureHistory(params QuestExpenditureHistoryWhereUniqueInput) *QuestExpenditureHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"QuestExpenditureHistoryWhereUniqueInput!", "QuestExpenditureHistory"},
		"deleteQuestExpenditureHistory",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExec{ret}
}

func (client *Client) DeleteManyQuestExpenditureHistories(params *QuestExpenditureHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "QuestExpenditureHistoryWhereInput", "deleteManyQuestExpenditureHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateQuestMember(params QuestMemberCreateInput) *QuestMemberExec {
	ret := client.Client.Create(
		params,
		[2]string{"QuestMemberCreateInput!", "QuestMember"},
		"createQuestMember",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberExec{ret}
}

type QuestMemberUpdateParams struct {
	Data  QuestMemberUpdateInput      `json:"data"`
	Where QuestMemberWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateQuestMember(params QuestMemberUpdateParams) *QuestMemberExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"QuestMemberUpdateInput!", "QuestMemberWhereUniqueInput!", "QuestMember"},
		"updateQuestMember",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberExec{ret}
}

type QuestMemberUpdateManyParams struct {
	Data  QuestMemberUpdateManyMutationInput `json:"data"`
	Where *QuestMemberWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyQuestMembers(params QuestMemberUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"QuestMemberUpdateManyMutationInput!", "QuestMemberWhereInput"},
		"updateManyQuestMembers")
	return &BatchPayloadExec{exec}
}

type QuestMemberUpsertParams struct {
	Where  QuestMemberWhereUniqueInput `json:"where"`
	Create QuestMemberCreateInput      `json:"create"`
	Update QuestMemberUpdateInput      `json:"update"`
}

func (client *Client) UpsertQuestMember(params QuestMemberUpsertParams) *QuestMemberExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"QuestMemberWhereUniqueInput!", "QuestMemberCreateInput!", "QuestMemberUpdateInput!", "QuestMember"},
		"upsertQuestMember",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberExec{ret}
}

func (client *Client) DeleteQuestMember(params QuestMemberWhereUniqueInput) *QuestMemberExec {
	ret := client.Client.Delete(
		params,
		[2]string{"QuestMemberWhereUniqueInput!", "QuestMember"},
		"deleteQuestMember",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberExec{ret}
}

func (client *Client) DeleteManyQuestMembers(params *QuestMemberWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "QuestMemberWhereInput", "deleteManyQuestMembers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateReport(params ReportCreateInput) *ReportExec {
	ret := client.Client.Create(
		params,
		[2]string{"ReportCreateInput!", "Report"},
		"createReport",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportExec{ret}
}

type ReportUpdateParams struct {
	Data  ReportUpdateInput      `json:"data"`
	Where ReportWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateReport(params ReportUpdateParams) *ReportExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ReportUpdateInput!", "ReportWhereUniqueInput!", "Report"},
		"updateReport",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportExec{ret}
}

type ReportUpdateManyParams struct {
	Data  ReportUpdateManyMutationInput `json:"data"`
	Where *ReportWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyReports(params ReportUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ReportUpdateManyMutationInput!", "ReportWhereInput"},
		"updateManyReports")
	return &BatchPayloadExec{exec}
}

type ReportUpsertParams struct {
	Where  ReportWhereUniqueInput `json:"where"`
	Create ReportCreateInput      `json:"create"`
	Update ReportUpdateInput      `json:"update"`
}

func (client *Client) UpsertReport(params ReportUpsertParams) *ReportExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ReportWhereUniqueInput!", "ReportCreateInput!", "ReportUpdateInput!", "Report"},
		"upsertReport",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportExec{ret}
}

func (client *Client) DeleteReport(params ReportWhereUniqueInput) *ReportExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ReportWhereUniqueInput!", "Report"},
		"deleteReport",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportExec{ret}
}

func (client *Client) DeleteManyReports(params *ReportWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ReportWhereInput", "deleteManyReports")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateRequestPageItem(params RequestPageItemCreateInput) *RequestPageItemExec {
	ret := client.Client.Create(
		params,
		[2]string{"RequestPageItemCreateInput!", "RequestPageItem"},
		"createRequestPageItem",
		[]string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"})

	return &RequestPageItemExec{ret}
}

type RequestPageItemUpdateParams struct {
	Data  RequestPageItemUpdateInput      `json:"data"`
	Where RequestPageItemWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateRequestPageItem(params RequestPageItemUpdateParams) *RequestPageItemExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"RequestPageItemUpdateInput!", "RequestPageItemWhereUniqueInput!", "RequestPageItem"},
		"updateRequestPageItem",
		[]string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"})

	return &RequestPageItemExec{ret}
}

type RequestPageItemUpdateManyParams struct {
	Data  RequestPageItemUpdateManyMutationInput `json:"data"`
	Where *RequestPageItemWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyRequestPageItems(params RequestPageItemUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"RequestPageItemUpdateManyMutationInput!", "RequestPageItemWhereInput"},
		"updateManyRequestPageItems")
	return &BatchPayloadExec{exec}
}

type RequestPageItemUpsertParams struct {
	Where  RequestPageItemWhereUniqueInput `json:"where"`
	Create RequestPageItemCreateInput      `json:"create"`
	Update RequestPageItemUpdateInput      `json:"update"`
}

func (client *Client) UpsertRequestPageItem(params RequestPageItemUpsertParams) *RequestPageItemExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"RequestPageItemWhereUniqueInput!", "RequestPageItemCreateInput!", "RequestPageItemUpdateInput!", "RequestPageItem"},
		"upsertRequestPageItem",
		[]string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"})

	return &RequestPageItemExec{ret}
}

func (client *Client) DeleteRequestPageItem(params RequestPageItemWhereUniqueInput) *RequestPageItemExec {
	ret := client.Client.Delete(
		params,
		[2]string{"RequestPageItemWhereUniqueInput!", "RequestPageItem"},
		"deleteRequestPageItem",
		[]string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"})

	return &RequestPageItemExec{ret}
}

func (client *Client) DeleteManyRequestPageItems(params *RequestPageItemWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "RequestPageItemWhereInput", "deleteManyRequestPageItems")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateReviewContent(params ReviewContentCreateInput) *ReviewContentExec {
	ret := client.Client.Create(
		params,
		[2]string{"ReviewContentCreateInput!", "ReviewContent"},
		"createReviewContent",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExec{ret}
}

type ReviewContentUpdateParams struct {
	Data  ReviewContentUpdateInput      `json:"data"`
	Where ReviewContentWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateReviewContent(params ReviewContentUpdateParams) *ReviewContentExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ReviewContentUpdateInput!", "ReviewContentWhereUniqueInput!", "ReviewContent"},
		"updateReviewContent",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExec{ret}
}

type ReviewContentUpdateManyParams struct {
	Data  ReviewContentUpdateManyMutationInput `json:"data"`
	Where *ReviewContentWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyReviewContents(params ReviewContentUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ReviewContentUpdateManyMutationInput!", "ReviewContentWhereInput"},
		"updateManyReviewContents")
	return &BatchPayloadExec{exec}
}

type ReviewContentUpsertParams struct {
	Where  ReviewContentWhereUniqueInput `json:"where"`
	Create ReviewContentCreateInput      `json:"create"`
	Update ReviewContentUpdateInput      `json:"update"`
}

func (client *Client) UpsertReviewContent(params ReviewContentUpsertParams) *ReviewContentExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ReviewContentWhereUniqueInput!", "ReviewContentCreateInput!", "ReviewContentUpdateInput!", "ReviewContent"},
		"upsertReviewContent",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExec{ret}
}

func (client *Client) DeleteReviewContent(params ReviewContentWhereUniqueInput) *ReviewContentExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ReviewContentWhereUniqueInput!", "ReviewContent"},
		"deleteReviewContent",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExec{ret}
}

func (client *Client) DeleteManyReviewContents(params *ReviewContentWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ReviewContentWhereInput", "deleteManyReviewContents")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateReviewContentCategory(params ReviewContentCategoryCreateInput) *ReviewContentCategoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"ReviewContentCategoryCreateInput!", "ReviewContentCategory"},
		"createReviewContentCategory",
		[]string{"id", "name", "imageUrl", "createdAt", "updatedAt"})

	return &ReviewContentCategoryExec{ret}
}

type ReviewContentCategoryUpdateParams struct {
	Data  ReviewContentCategoryUpdateInput      `json:"data"`
	Where ReviewContentCategoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateReviewContentCategory(params ReviewContentCategoryUpdateParams) *ReviewContentCategoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ReviewContentCategoryUpdateInput!", "ReviewContentCategoryWhereUniqueInput!", "ReviewContentCategory"},
		"updateReviewContentCategory",
		[]string{"id", "name", "imageUrl", "createdAt", "updatedAt"})

	return &ReviewContentCategoryExec{ret}
}

type ReviewContentCategoryUpdateManyParams struct {
	Data  ReviewContentCategoryUpdateManyMutationInput `json:"data"`
	Where *ReviewContentCategoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyReviewContentCategories(params ReviewContentCategoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ReviewContentCategoryUpdateManyMutationInput!", "ReviewContentCategoryWhereInput"},
		"updateManyReviewContentCategories")
	return &BatchPayloadExec{exec}
}

type ReviewContentCategoryUpsertParams struct {
	Where  ReviewContentCategoryWhereUniqueInput `json:"where"`
	Create ReviewContentCategoryCreateInput      `json:"create"`
	Update ReviewContentCategoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertReviewContentCategory(params ReviewContentCategoryUpsertParams) *ReviewContentCategoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ReviewContentCategoryWhereUniqueInput!", "ReviewContentCategoryCreateInput!", "ReviewContentCategoryUpdateInput!", "ReviewContentCategory"},
		"upsertReviewContentCategory",
		[]string{"id", "name", "imageUrl", "createdAt", "updatedAt"})

	return &ReviewContentCategoryExec{ret}
}

func (client *Client) DeleteReviewContentCategory(params ReviewContentCategoryWhereUniqueInput) *ReviewContentCategoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ReviewContentCategoryWhereUniqueInput!", "ReviewContentCategory"},
		"deleteReviewContentCategory",
		[]string{"id", "name", "imageUrl", "createdAt", "updatedAt"})

	return &ReviewContentCategoryExec{ret}
}

func (client *Client) DeleteManyReviewContentCategories(params *ReviewContentCategoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ReviewContentCategoryWhereInput", "deleteManyReviewContentCategories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateReviewContentPage(params ReviewContentPageCreateInput) *ReviewContentPageExec {
	ret := client.Client.Create(
		params,
		[2]string{"ReviewContentPageCreateInput!", "ReviewContentPage"},
		"createReviewContentPage",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

type ReviewContentPageUpdateParams struct {
	Data  ReviewContentPageUpdateInput      `json:"data"`
	Where ReviewContentPageWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateReviewContentPage(params ReviewContentPageUpdateParams) *ReviewContentPageExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ReviewContentPageUpdateInput!", "ReviewContentPageWhereUniqueInput!", "ReviewContentPage"},
		"updateReviewContentPage",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

type ReviewContentPageUpdateManyParams struct {
	Data  ReviewContentPageUpdateManyMutationInput `json:"data"`
	Where *ReviewContentPageWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyReviewContentPages(params ReviewContentPageUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ReviewContentPageUpdateManyMutationInput!", "ReviewContentPageWhereInput"},
		"updateManyReviewContentPages")
	return &BatchPayloadExec{exec}
}

type ReviewContentPageUpsertParams struct {
	Where  ReviewContentPageWhereUniqueInput `json:"where"`
	Create ReviewContentPageCreateInput      `json:"create"`
	Update ReviewContentPageUpdateInput      `json:"update"`
}

func (client *Client) UpsertReviewContentPage(params ReviewContentPageUpsertParams) *ReviewContentPageExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ReviewContentPageWhereUniqueInput!", "ReviewContentPageCreateInput!", "ReviewContentPageUpdateInput!", "ReviewContentPage"},
		"upsertReviewContentPage",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

func (client *Client) DeleteReviewContentPage(params ReviewContentPageWhereUniqueInput) *ReviewContentPageExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ReviewContentPageWhereUniqueInput!", "ReviewContentPage"},
		"deleteReviewContentPage",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

func (client *Client) DeleteManyReviewContentPages(params *ReviewContentPageWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ReviewContentPageWhereInput", "deleteManyReviewContentPages")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateReviewContentPageFeedBack(params ReviewContentPageFeedBackCreateInput) *ReviewContentPageFeedBackExec {
	ret := client.Client.Create(
		params,
		[2]string{"ReviewContentPageFeedBackCreateInput!", "ReviewContentPageFeedBack"},
		"createReviewContentPageFeedBack",
		[]string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"})

	return &ReviewContentPageFeedBackExec{ret}
}

type ReviewContentPageFeedBackUpdateParams struct {
	Data  ReviewContentPageFeedBackUpdateInput      `json:"data"`
	Where ReviewContentPageFeedBackWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateReviewContentPageFeedBack(params ReviewContentPageFeedBackUpdateParams) *ReviewContentPageFeedBackExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ReviewContentPageFeedBackUpdateInput!", "ReviewContentPageFeedBackWhereUniqueInput!", "ReviewContentPageFeedBack"},
		"updateReviewContentPageFeedBack",
		[]string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"})

	return &ReviewContentPageFeedBackExec{ret}
}

type ReviewContentPageFeedBackUpdateManyParams struct {
	Data  ReviewContentPageFeedBackUpdateManyMutationInput `json:"data"`
	Where *ReviewContentPageFeedBackWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyReviewContentPageFeedBacks(params ReviewContentPageFeedBackUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ReviewContentPageFeedBackUpdateManyMutationInput!", "ReviewContentPageFeedBackWhereInput"},
		"updateManyReviewContentPageFeedBacks")
	return &BatchPayloadExec{exec}
}

type ReviewContentPageFeedBackUpsertParams struct {
	Where  ReviewContentPageFeedBackWhereUniqueInput `json:"where"`
	Create ReviewContentPageFeedBackCreateInput      `json:"create"`
	Update ReviewContentPageFeedBackUpdateInput      `json:"update"`
}

func (client *Client) UpsertReviewContentPageFeedBack(params ReviewContentPageFeedBackUpsertParams) *ReviewContentPageFeedBackExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ReviewContentPageFeedBackWhereUniqueInput!", "ReviewContentPageFeedBackCreateInput!", "ReviewContentPageFeedBackUpdateInput!", "ReviewContentPageFeedBack"},
		"upsertReviewContentPageFeedBack",
		[]string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"})

	return &ReviewContentPageFeedBackExec{ret}
}

func (client *Client) DeleteReviewContentPageFeedBack(params ReviewContentPageFeedBackWhereUniqueInput) *ReviewContentPageFeedBackExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ReviewContentPageFeedBackWhereUniqueInput!", "ReviewContentPageFeedBack"},
		"deleteReviewContentPageFeedBack",
		[]string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"})

	return &ReviewContentPageFeedBackExec{ret}
}

func (client *Client) DeleteManyReviewContentPageFeedBacks(params *ReviewContentPageFeedBackWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ReviewContentPageFeedBackWhereInput", "deleteManyReviewContentPageFeedBacks")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateReviewContentPageViewer(params ReviewContentPageViewerCreateInput) *ReviewContentPageViewerExec {
	ret := client.Client.Create(
		params,
		[2]string{"ReviewContentPageViewerCreateInput!", "ReviewContentPageViewer"},
		"createReviewContentPageViewer",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentPageViewerExec{ret}
}

type ReviewContentPageViewerUpdateParams struct {
	Data  ReviewContentPageViewerUpdateInput      `json:"data"`
	Where ReviewContentPageViewerWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateReviewContentPageViewer(params ReviewContentPageViewerUpdateParams) *ReviewContentPageViewerExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ReviewContentPageViewerUpdateInput!", "ReviewContentPageViewerWhereUniqueInput!", "ReviewContentPageViewer"},
		"updateReviewContentPageViewer",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentPageViewerExec{ret}
}

type ReviewContentPageViewerUpdateManyParams struct {
	Data  ReviewContentPageViewerUpdateManyMutationInput `json:"data"`
	Where *ReviewContentPageViewerWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyReviewContentPageViewers(params ReviewContentPageViewerUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ReviewContentPageViewerUpdateManyMutationInput!", "ReviewContentPageViewerWhereInput"},
		"updateManyReviewContentPageViewers")
	return &BatchPayloadExec{exec}
}

type ReviewContentPageViewerUpsertParams struct {
	Where  ReviewContentPageViewerWhereUniqueInput `json:"where"`
	Create ReviewContentPageViewerCreateInput      `json:"create"`
	Update ReviewContentPageViewerUpdateInput      `json:"update"`
}

func (client *Client) UpsertReviewContentPageViewer(params ReviewContentPageViewerUpsertParams) *ReviewContentPageViewerExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ReviewContentPageViewerWhereUniqueInput!", "ReviewContentPageViewerCreateInput!", "ReviewContentPageViewerUpdateInput!", "ReviewContentPageViewer"},
		"upsertReviewContentPageViewer",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentPageViewerExec{ret}
}

func (client *Client) DeleteReviewContentPageViewer(params ReviewContentPageViewerWhereUniqueInput) *ReviewContentPageViewerExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ReviewContentPageViewerWhereUniqueInput!", "ReviewContentPageViewer"},
		"deleteReviewContentPageViewer",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentPageViewerExec{ret}
}

func (client *Client) DeleteManyReviewContentPageViewers(params *ReviewContentPageViewerWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ReviewContentPageViewerWhereInput", "deleteManyReviewContentPageViewers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateReviewContentReviewer(params ReviewContentReviewerCreateInput) *ReviewContentReviewerExec {
	ret := client.Client.Create(
		params,
		[2]string{"ReviewContentReviewerCreateInput!", "ReviewContentReviewer"},
		"createReviewContentReviewer",
		[]string{"id", "review", "createdAt", "updatedAt"})

	return &ReviewContentReviewerExec{ret}
}

type ReviewContentReviewerUpdateParams struct {
	Data  ReviewContentReviewerUpdateInput      `json:"data"`
	Where ReviewContentReviewerWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateReviewContentReviewer(params ReviewContentReviewerUpdateParams) *ReviewContentReviewerExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ReviewContentReviewerUpdateInput!", "ReviewContentReviewerWhereUniqueInput!", "ReviewContentReviewer"},
		"updateReviewContentReviewer",
		[]string{"id", "review", "createdAt", "updatedAt"})

	return &ReviewContentReviewerExec{ret}
}

type ReviewContentReviewerUpdateManyParams struct {
	Data  ReviewContentReviewerUpdateManyMutationInput `json:"data"`
	Where *ReviewContentReviewerWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyReviewContentReviewers(params ReviewContentReviewerUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ReviewContentReviewerUpdateManyMutationInput!", "ReviewContentReviewerWhereInput"},
		"updateManyReviewContentReviewers")
	return &BatchPayloadExec{exec}
}

type ReviewContentReviewerUpsertParams struct {
	Where  ReviewContentReviewerWhereUniqueInput `json:"where"`
	Create ReviewContentReviewerCreateInput      `json:"create"`
	Update ReviewContentReviewerUpdateInput      `json:"update"`
}

func (client *Client) UpsertReviewContentReviewer(params ReviewContentReviewerUpsertParams) *ReviewContentReviewerExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ReviewContentReviewerWhereUniqueInput!", "ReviewContentReviewerCreateInput!", "ReviewContentReviewerUpdateInput!", "ReviewContentReviewer"},
		"upsertReviewContentReviewer",
		[]string{"id", "review", "createdAt", "updatedAt"})

	return &ReviewContentReviewerExec{ret}
}

func (client *Client) DeleteReviewContentReviewer(params ReviewContentReviewerWhereUniqueInput) *ReviewContentReviewerExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ReviewContentReviewerWhereUniqueInput!", "ReviewContentReviewer"},
		"deleteReviewContentReviewer",
		[]string{"id", "review", "createdAt", "updatedAt"})

	return &ReviewContentReviewerExec{ret}
}

func (client *Client) DeleteManyReviewContentReviewers(params *ReviewContentReviewerWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ReviewContentReviewerWhereInput", "deleteManyReviewContentReviewers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateReviewContentViewer(params ReviewContentViewerCreateInput) *ReviewContentViewerExec {
	ret := client.Client.Create(
		params,
		[2]string{"ReviewContentViewerCreateInput!", "ReviewContentViewer"},
		"createReviewContentViewer",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentViewerExec{ret}
}

type ReviewContentViewerUpdateParams struct {
	Data  ReviewContentViewerUpdateInput      `json:"data"`
	Where ReviewContentViewerWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateReviewContentViewer(params ReviewContentViewerUpdateParams) *ReviewContentViewerExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ReviewContentViewerUpdateInput!", "ReviewContentViewerWhereUniqueInput!", "ReviewContentViewer"},
		"updateReviewContentViewer",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentViewerExec{ret}
}

type ReviewContentViewerUpdateManyParams struct {
	Data  ReviewContentViewerUpdateManyMutationInput `json:"data"`
	Where *ReviewContentViewerWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyReviewContentViewers(params ReviewContentViewerUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ReviewContentViewerUpdateManyMutationInput!", "ReviewContentViewerWhereInput"},
		"updateManyReviewContentViewers")
	return &BatchPayloadExec{exec}
}

type ReviewContentViewerUpsertParams struct {
	Where  ReviewContentViewerWhereUniqueInput `json:"where"`
	Create ReviewContentViewerCreateInput      `json:"create"`
	Update ReviewContentViewerUpdateInput      `json:"update"`
}

func (client *Client) UpsertReviewContentViewer(params ReviewContentViewerUpsertParams) *ReviewContentViewerExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ReviewContentViewerWhereUniqueInput!", "ReviewContentViewerCreateInput!", "ReviewContentViewerUpdateInput!", "ReviewContentViewer"},
		"upsertReviewContentViewer",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentViewerExec{ret}
}

func (client *Client) DeleteReviewContentViewer(params ReviewContentViewerWhereUniqueInput) *ReviewContentViewerExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ReviewContentViewerWhereUniqueInput!", "ReviewContentViewer"},
		"deleteReviewContentViewer",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentViewerExec{ret}
}

func (client *Client) DeleteManyReviewContentViewers(params *ReviewContentViewerWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ReviewContentViewerWhereInput", "deleteManyReviewContentViewers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateRewardDropAttendingUser(params RewardDropAttendingUserCreateInput) *RewardDropAttendingUserExec {
	ret := client.Client.Create(
		params,
		[2]string{"RewardDropAttendingUserCreateInput!", "RewardDropAttendingUser"},
		"createRewardDropAttendingUser",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserExec{ret}
}

type RewardDropAttendingUserUpdateParams struct {
	Data  RewardDropAttendingUserUpdateInput      `json:"data"`
	Where RewardDropAttendingUserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateRewardDropAttendingUser(params RewardDropAttendingUserUpdateParams) *RewardDropAttendingUserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"RewardDropAttendingUserUpdateInput!", "RewardDropAttendingUserWhereUniqueInput!", "RewardDropAttendingUser"},
		"updateRewardDropAttendingUser",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserExec{ret}
}

type RewardDropAttendingUserUpdateManyParams struct {
	Data  RewardDropAttendingUserUpdateManyMutationInput `json:"data"`
	Where *RewardDropAttendingUserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyRewardDropAttendingUsers(params RewardDropAttendingUserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"RewardDropAttendingUserUpdateManyMutationInput!", "RewardDropAttendingUserWhereInput"},
		"updateManyRewardDropAttendingUsers")
	return &BatchPayloadExec{exec}
}

type RewardDropAttendingUserUpsertParams struct {
	Where  RewardDropAttendingUserWhereUniqueInput `json:"where"`
	Create RewardDropAttendingUserCreateInput      `json:"create"`
	Update RewardDropAttendingUserUpdateInput      `json:"update"`
}

func (client *Client) UpsertRewardDropAttendingUser(params RewardDropAttendingUserUpsertParams) *RewardDropAttendingUserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"RewardDropAttendingUserWhereUniqueInput!", "RewardDropAttendingUserCreateInput!", "RewardDropAttendingUserUpdateInput!", "RewardDropAttendingUser"},
		"upsertRewardDropAttendingUser",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserExec{ret}
}

func (client *Client) DeleteRewardDropAttendingUser(params RewardDropAttendingUserWhereUniqueInput) *RewardDropAttendingUserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"RewardDropAttendingUserWhereUniqueInput!", "RewardDropAttendingUser"},
		"deleteRewardDropAttendingUser",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserExec{ret}
}

func (client *Client) DeleteManyRewardDropAttendingUsers(params *RewardDropAttendingUserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "RewardDropAttendingUserWhereInput", "deleteManyRewardDropAttendingUsers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateRewardDropEvent(params RewardDropEventCreateInput) *RewardDropEventExec {
	ret := client.Client.Create(
		params,
		[2]string{"RewardDropEventCreateInput!", "RewardDropEvent"},
		"createRewardDropEvent",
		[]string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"})

	return &RewardDropEventExec{ret}
}

type RewardDropEventUpdateParams struct {
	Data  RewardDropEventUpdateInput      `json:"data"`
	Where RewardDropEventWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateRewardDropEvent(params RewardDropEventUpdateParams) *RewardDropEventExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"RewardDropEventUpdateInput!", "RewardDropEventWhereUniqueInput!", "RewardDropEvent"},
		"updateRewardDropEvent",
		[]string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"})

	return &RewardDropEventExec{ret}
}

type RewardDropEventUpdateManyParams struct {
	Data  RewardDropEventUpdateManyMutationInput `json:"data"`
	Where *RewardDropEventWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyRewardDropEvents(params RewardDropEventUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"RewardDropEventUpdateManyMutationInput!", "RewardDropEventWhereInput"},
		"updateManyRewardDropEvents")
	return &BatchPayloadExec{exec}
}

type RewardDropEventUpsertParams struct {
	Where  RewardDropEventWhereUniqueInput `json:"where"`
	Create RewardDropEventCreateInput      `json:"create"`
	Update RewardDropEventUpdateInput      `json:"update"`
}

func (client *Client) UpsertRewardDropEvent(params RewardDropEventUpsertParams) *RewardDropEventExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"RewardDropEventWhereUniqueInput!", "RewardDropEventCreateInput!", "RewardDropEventUpdateInput!", "RewardDropEvent"},
		"upsertRewardDropEvent",
		[]string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"})

	return &RewardDropEventExec{ret}
}

func (client *Client) DeleteRewardDropEvent(params RewardDropEventWhereUniqueInput) *RewardDropEventExec {
	ret := client.Client.Delete(
		params,
		[2]string{"RewardDropEventWhereUniqueInput!", "RewardDropEvent"},
		"deleteRewardDropEvent",
		[]string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"})

	return &RewardDropEventExec{ret}
}

func (client *Client) DeleteManyRewardDropEvents(params *RewardDropEventWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "RewardDropEventWhereInput", "deleteManyRewardDropEvents")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTwitch(params TwitchCreateInput) *TwitchExec {
	ret := client.Client.Create(
		params,
		[2]string{"TwitchCreateInput!", "Twitch"},
		"createTwitch",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchExec{ret}
}

type TwitchUpdateParams struct {
	Data  TwitchUpdateInput      `json:"data"`
	Where TwitchWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTwitch(params TwitchUpdateParams) *TwitchExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TwitchUpdateInput!", "TwitchWhereUniqueInput!", "Twitch"},
		"updateTwitch",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchExec{ret}
}

type TwitchUpdateManyParams struct {
	Data  TwitchUpdateManyMutationInput `json:"data"`
	Where *TwitchWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTwitches(params TwitchUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TwitchUpdateManyMutationInput!", "TwitchWhereInput"},
		"updateManyTwitches")
	return &BatchPayloadExec{exec}
}

type TwitchUpsertParams struct {
	Where  TwitchWhereUniqueInput `json:"where"`
	Create TwitchCreateInput      `json:"create"`
	Update TwitchUpdateInput      `json:"update"`
}

func (client *Client) UpsertTwitch(params TwitchUpsertParams) *TwitchExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TwitchWhereUniqueInput!", "TwitchCreateInput!", "TwitchUpdateInput!", "Twitch"},
		"upsertTwitch",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchExec{ret}
}

func (client *Client) DeleteTwitch(params TwitchWhereUniqueInput) *TwitchExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TwitchWhereUniqueInput!", "Twitch"},
		"deleteTwitch",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchExec{ret}
}

func (client *Client) DeleteManyTwitches(params *TwitchWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TwitchWhereInput", "deleteManyTwitches")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateTwitchDailyStatistics(params TwitchDailyStatisticsCreateInput) *TwitchDailyStatisticsExec {
	ret := client.Client.Create(
		params,
		[2]string{"TwitchDailyStatisticsCreateInput!", "TwitchDailyStatistics"},
		"createTwitchDailyStatistics",
		[]string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"})

	return &TwitchDailyStatisticsExec{ret}
}

type TwitchDailyStatisticsUpdateParams struct {
	Data  TwitchDailyStatisticsUpdateInput      `json:"data"`
	Where TwitchDailyStatisticsWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateTwitchDailyStatistics(params TwitchDailyStatisticsUpdateParams) *TwitchDailyStatisticsExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"TwitchDailyStatisticsUpdateInput!", "TwitchDailyStatisticsWhereUniqueInput!", "TwitchDailyStatistics"},
		"updateTwitchDailyStatistics",
		[]string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"})

	return &TwitchDailyStatisticsExec{ret}
}

type TwitchDailyStatisticsUpdateManyParams struct {
	Data  TwitchDailyStatisticsUpdateManyMutationInput `json:"data"`
	Where *TwitchDailyStatisticsWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyTwitchDailyStatisticses(params TwitchDailyStatisticsUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"TwitchDailyStatisticsUpdateManyMutationInput!", "TwitchDailyStatisticsWhereInput"},
		"updateManyTwitchDailyStatisticses")
	return &BatchPayloadExec{exec}
}

type TwitchDailyStatisticsUpsertParams struct {
	Where  TwitchDailyStatisticsWhereUniqueInput `json:"where"`
	Create TwitchDailyStatisticsCreateInput      `json:"create"`
	Update TwitchDailyStatisticsUpdateInput      `json:"update"`
}

func (client *Client) UpsertTwitchDailyStatistics(params TwitchDailyStatisticsUpsertParams) *TwitchDailyStatisticsExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"TwitchDailyStatisticsWhereUniqueInput!", "TwitchDailyStatisticsCreateInput!", "TwitchDailyStatisticsUpdateInput!", "TwitchDailyStatistics"},
		"upsertTwitchDailyStatistics",
		[]string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"})

	return &TwitchDailyStatisticsExec{ret}
}

func (client *Client) DeleteTwitchDailyStatistics(params TwitchDailyStatisticsWhereUniqueInput) *TwitchDailyStatisticsExec {
	ret := client.Client.Delete(
		params,
		[2]string{"TwitchDailyStatisticsWhereUniqueInput!", "TwitchDailyStatistics"},
		"deleteTwitchDailyStatistics",
		[]string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"})

	return &TwitchDailyStatisticsExec{ret}
}

func (client *Client) DeleteManyTwitchDailyStatisticses(params *TwitchDailyStatisticsWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "TwitchDailyStatisticsWhereInput", "deleteManyTwitchDailyStatisticses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUpdatePostHistory(params UpdatePostHistoryCreateInput) *UpdatePostHistoryExec {
	ret := client.Client.Create(
		params,
		[2]string{"UpdatePostHistoryCreateInput!", "UpdatePostHistory"},
		"createUpdatePostHistory",
		[]string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"})

	return &UpdatePostHistoryExec{ret}
}

type UpdatePostHistoryUpdateParams struct {
	Data  UpdatePostHistoryUpdateInput      `json:"data"`
	Where UpdatePostHistoryWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUpdatePostHistory(params UpdatePostHistoryUpdateParams) *UpdatePostHistoryExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UpdatePostHistoryUpdateInput!", "UpdatePostHistoryWhereUniqueInput!", "UpdatePostHistory"},
		"updateUpdatePostHistory",
		[]string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"})

	return &UpdatePostHistoryExec{ret}
}

type UpdatePostHistoryUpdateManyParams struct {
	Data  UpdatePostHistoryUpdateManyMutationInput `json:"data"`
	Where *UpdatePostHistoryWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUpdatePostHistories(params UpdatePostHistoryUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UpdatePostHistoryUpdateManyMutationInput!", "UpdatePostHistoryWhereInput"},
		"updateManyUpdatePostHistories")
	return &BatchPayloadExec{exec}
}

type UpdatePostHistoryUpsertParams struct {
	Where  UpdatePostHistoryWhereUniqueInput `json:"where"`
	Create UpdatePostHistoryCreateInput      `json:"create"`
	Update UpdatePostHistoryUpdateInput      `json:"update"`
}

func (client *Client) UpsertUpdatePostHistory(params UpdatePostHistoryUpsertParams) *UpdatePostHistoryExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UpdatePostHistoryWhereUniqueInput!", "UpdatePostHistoryCreateInput!", "UpdatePostHistoryUpdateInput!", "UpdatePostHistory"},
		"upsertUpdatePostHistory",
		[]string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"})

	return &UpdatePostHistoryExec{ret}
}

func (client *Client) DeleteUpdatePostHistory(params UpdatePostHistoryWhereUniqueInput) *UpdatePostHistoryExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UpdatePostHistoryWhereUniqueInput!", "UpdatePostHistory"},
		"deleteUpdatePostHistory",
		[]string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"})

	return &UpdatePostHistoryExec{ret}
}

func (client *Client) DeleteManyUpdatePostHistories(params *UpdatePostHistoryWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UpdatePostHistoryWhereInput", "deleteManyUpdatePostHistories")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateVerification(params VerificationCreateInput) *VerificationExec {
	ret := client.Client.Create(
		params,
		[2]string{"VerificationCreateInput!", "Verification"},
		"createVerification",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExec{ret}
}

type VerificationUpdateParams struct {
	Data  VerificationUpdateInput      `json:"data"`
	Where VerificationWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateVerification(params VerificationUpdateParams) *VerificationExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"VerificationUpdateInput!", "VerificationWhereUniqueInput!", "Verification"},
		"updateVerification",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExec{ret}
}

type VerificationUpdateManyParams struct {
	Data  VerificationUpdateManyMutationInput `json:"data"`
	Where *VerificationWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyVerifications(params VerificationUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"VerificationUpdateManyMutationInput!", "VerificationWhereInput"},
		"updateManyVerifications")
	return &BatchPayloadExec{exec}
}

type VerificationUpsertParams struct {
	Where  VerificationWhereUniqueInput `json:"where"`
	Create VerificationCreateInput      `json:"create"`
	Update VerificationUpdateInput      `json:"update"`
}

func (client *Client) UpsertVerification(params VerificationUpsertParams) *VerificationExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"VerificationWhereUniqueInput!", "VerificationCreateInput!", "VerificationUpdateInput!", "Verification"},
		"upsertVerification",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExec{ret}
}

func (client *Client) DeleteVerification(params VerificationWhereUniqueInput) *VerificationExec {
	ret := client.Client.Delete(
		params,
		[2]string{"VerificationWhereUniqueInput!", "Verification"},
		"deleteVerification",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExec{ret}
}

func (client *Client) DeleteManyVerifications(params *VerificationWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "VerificationWhereInput", "deleteManyVerifications")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateWallet(params WalletCreateInput) *WalletExec {
	ret := client.Client.Create(
		params,
		[2]string{"WalletCreateInput!", "Wallet"},
		"createWallet",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletExec{ret}
}

type WalletUpdateParams struct {
	Data  WalletUpdateInput      `json:"data"`
	Where WalletWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateWallet(params WalletUpdateParams) *WalletExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"WalletUpdateInput!", "WalletWhereUniqueInput!", "Wallet"},
		"updateWallet",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletExec{ret}
}

type WalletUpdateManyParams struct {
	Data  WalletUpdateManyMutationInput `json:"data"`
	Where *WalletWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyWallets(params WalletUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"WalletUpdateManyMutationInput!", "WalletWhereInput"},
		"updateManyWallets")
	return &BatchPayloadExec{exec}
}

type WalletUpsertParams struct {
	Where  WalletWhereUniqueInput `json:"where"`
	Create WalletCreateInput      `json:"create"`
	Update WalletUpdateInput      `json:"update"`
}

func (client *Client) UpsertWallet(params WalletUpsertParams) *WalletExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"WalletWhereUniqueInput!", "WalletCreateInput!", "WalletUpdateInput!", "Wallet"},
		"upsertWallet",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletExec{ret}
}

func (client *Client) DeleteWallet(params WalletWhereUniqueInput) *WalletExec {
	ret := client.Client.Delete(
		params,
		[2]string{"WalletWhereUniqueInput!", "Wallet"},
		"deleteWallet",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletExec{ret}
}

func (client *Client) DeleteManyWallets(params *WalletWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "WalletWhereInput", "deleteManyWallets")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateYoutube(params YoutubeCreateInput) *YoutubeExec {
	ret := client.Client.Create(
		params,
		[2]string{"YoutubeCreateInput!", "Youtube"},
		"createYoutube",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubeExec{ret}
}

type YoutubeUpdateParams struct {
	Data  YoutubeUpdateInput      `json:"data"`
	Where YoutubeWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateYoutube(params YoutubeUpdateParams) *YoutubeExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"YoutubeUpdateInput!", "YoutubeWhereUniqueInput!", "Youtube"},
		"updateYoutube",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubeExec{ret}
}

type YoutubeUpdateManyParams struct {
	Data  YoutubeUpdateManyMutationInput `json:"data"`
	Where *YoutubeWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyYoutubes(params YoutubeUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"YoutubeUpdateManyMutationInput!", "YoutubeWhereInput"},
		"updateManyYoutubes")
	return &BatchPayloadExec{exec}
}

type YoutubeUpsertParams struct {
	Where  YoutubeWhereUniqueInput `json:"where"`
	Create YoutubeCreateInput      `json:"create"`
	Update YoutubeUpdateInput      `json:"update"`
}

func (client *Client) UpsertYoutube(params YoutubeUpsertParams) *YoutubeExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"YoutubeWhereUniqueInput!", "YoutubeCreateInput!", "YoutubeUpdateInput!", "Youtube"},
		"upsertYoutube",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubeExec{ret}
}

func (client *Client) DeleteYoutube(params YoutubeWhereUniqueInput) *YoutubeExec {
	ret := client.Client.Delete(
		params,
		[2]string{"YoutubeWhereUniqueInput!", "Youtube"},
		"deleteYoutube",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubeExec{ret}
}

func (client *Client) DeleteManyYoutubes(params *YoutubeWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "YoutubeWhereInput", "deleteManyYoutubes")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateYoutubeDailyStatistics(params YoutubeDailyStatisticsCreateInput) *YoutubeDailyStatisticsExec {
	ret := client.Client.Create(
		params,
		[2]string{"YoutubeDailyStatisticsCreateInput!", "YoutubeDailyStatistics"},
		"createYoutubeDailyStatistics",
		[]string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"})

	return &YoutubeDailyStatisticsExec{ret}
}

type YoutubeDailyStatisticsUpdateParams struct {
	Data  YoutubeDailyStatisticsUpdateInput      `json:"data"`
	Where YoutubeDailyStatisticsWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateYoutubeDailyStatistics(params YoutubeDailyStatisticsUpdateParams) *YoutubeDailyStatisticsExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"YoutubeDailyStatisticsUpdateInput!", "YoutubeDailyStatisticsWhereUniqueInput!", "YoutubeDailyStatistics"},
		"updateYoutubeDailyStatistics",
		[]string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"})

	return &YoutubeDailyStatisticsExec{ret}
}

type YoutubeDailyStatisticsUpdateManyParams struct {
	Data  YoutubeDailyStatisticsUpdateManyMutationInput `json:"data"`
	Where *YoutubeDailyStatisticsWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyYoutubeDailyStatisticses(params YoutubeDailyStatisticsUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"YoutubeDailyStatisticsUpdateManyMutationInput!", "YoutubeDailyStatisticsWhereInput"},
		"updateManyYoutubeDailyStatisticses")
	return &BatchPayloadExec{exec}
}

type YoutubeDailyStatisticsUpsertParams struct {
	Where  YoutubeDailyStatisticsWhereUniqueInput `json:"where"`
	Create YoutubeDailyStatisticsCreateInput      `json:"create"`
	Update YoutubeDailyStatisticsUpdateInput      `json:"update"`
}

func (client *Client) UpsertYoutubeDailyStatistics(params YoutubeDailyStatisticsUpsertParams) *YoutubeDailyStatisticsExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"YoutubeDailyStatisticsWhereUniqueInput!", "YoutubeDailyStatisticsCreateInput!", "YoutubeDailyStatisticsUpdateInput!", "YoutubeDailyStatistics"},
		"upsertYoutubeDailyStatistics",
		[]string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"})

	return &YoutubeDailyStatisticsExec{ret}
}

func (client *Client) DeleteYoutubeDailyStatistics(params YoutubeDailyStatisticsWhereUniqueInput) *YoutubeDailyStatisticsExec {
	ret := client.Client.Delete(
		params,
		[2]string{"YoutubeDailyStatisticsWhereUniqueInput!", "YoutubeDailyStatistics"},
		"deleteYoutubeDailyStatistics",
		[]string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"})

	return &YoutubeDailyStatisticsExec{ret}
}

func (client *Client) DeleteManyYoutubeDailyStatisticses(params *YoutubeDailyStatisticsWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "YoutubeDailyStatisticsWhereInput", "deleteManyYoutubeDailyStatisticses")
	return &BatchPayloadExec{exec}
}

type Role string

const (
	RoleAdmin Role = "ADMIN"
	RoleUser  Role = "USER"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc                         UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc                        UserOrderByInput = "id_DESC"
	UserOrderByInputRoleAsc                       UserOrderByInput = "role_ASC"
	UserOrderByInputRoleDesc                      UserOrderByInput = "role_DESC"
	UserOrderByInputFirebaseUidAsc                UserOrderByInput = "firebaseUID_ASC"
	UserOrderByInputFirebaseUidDesc               UserOrderByInput = "firebaseUID_DESC"
	UserOrderByInputProviderAsc                   UserOrderByInput = "provider_ASC"
	UserOrderByInputProviderDesc                  UserOrderByInput = "provider_DESC"
	UserOrderByInputNickNameAsc                   UserOrderByInput = "nickName_ASC"
	UserOrderByInputNickNameDesc                  UserOrderByInput = "nickName_DESC"
	UserOrderByInputEmailAsc                      UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc                     UserOrderByInput = "email_DESC"
	UserOrderByInputBackupEmailAsc                UserOrderByInput = "backupEmail_ASC"
	UserOrderByInputBackupEmailDesc               UserOrderByInput = "backupEmail_DESC"
	UserOrderByInputDeviceIdAsc                   UserOrderByInput = "deviceId_ASC"
	UserOrderByInputDeviceIdDesc                  UserOrderByInput = "deviceId_DESC"
	UserOrderByInputPlatformAsc                   UserOrderByInput = "platform_ASC"
	UserOrderByInputPlatformDesc                  UserOrderByInput = "platform_DESC"
	UserOrderByInputFcmTokenAsc                   UserOrderByInput = "fcmToken_ASC"
	UserOrderByInputFcmTokenDesc                  UserOrderByInput = "fcmToken_DESC"
	UserOrderByInputLinkedFacebookAsc             UserOrderByInput = "linkedFacebook_ASC"
	UserOrderByInputLinkedFacebookDesc            UserOrderByInput = "linkedFacebook_DESC"
	UserOrderByInputLinkedTwitterAsc              UserOrderByInput = "linkedTwitter_ASC"
	UserOrderByInputLinkedTwitterDesc             UserOrderByInput = "linkedTwitter_DESC"
	UserOrderByInputLinkedInstagramAsc            UserOrderByInput = "linkedInstagram_ASC"
	UserOrderByInputLinkedInstagramDesc           UserOrderByInput = "linkedInstagram_DESC"
	UserOrderByInputLinkedYoutubeAsc              UserOrderByInput = "linkedYoutube_ASC"
	UserOrderByInputLinkedYoutubeDesc             UserOrderByInput = "linkedYoutube_DESC"
	UserOrderByInputLinkedTwitchAsc               UserOrderByInput = "linkedTwitch_ASC"
	UserOrderByInputLinkedTwitchDesc              UserOrderByInput = "linkedTwitch_DESC"
	UserOrderByInputContentProviderAsc            UserOrderByInput = "contentProvider_ASC"
	UserOrderByInputContentProviderDesc           UserOrderByInput = "contentProvider_DESC"
	UserOrderByInputContentIdAsc                  UserOrderByInput = "contentId_ASC"
	UserOrderByInputContentIdDesc                 UserOrderByInput = "contentId_DESC"
	UserOrderByInputRevokeTokenKeyAsc             UserOrderByInput = "revokeTokenKey_ASC"
	UserOrderByInputRevokeTokenKeyDesc            UserOrderByInput = "revokeTokenKey_DESC"
	UserOrderByInputSubscribePushNotificationAsc  UserOrderByInput = "subscribePushNotification_ASC"
	UserOrderByInputSubscribePushNotificationDesc UserOrderByInput = "subscribePushNotification_DESC"
	UserOrderByInputSubscribeEmailAsc             UserOrderByInput = "subscribeEmail_ASC"
	UserOrderByInputSubscribeEmailDesc            UserOrderByInput = "subscribeEmail_DESC"
	UserOrderByInputDeletedAtAsc                  UserOrderByInput = "deletedAt_ASC"
	UserOrderByInputDeletedAtDesc                 UserOrderByInput = "deletedAt_DESC"
	UserOrderByInputCreatedAtAsc                  UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc                 UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc                  UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc                 UserOrderByInput = "updatedAt_DESC"
	UserOrderByInputStatusAsc                     UserOrderByInput = "status_ASC"
	UserOrderByInputStatusDesc                    UserOrderByInput = "status_DESC"
	UserOrderByInputNumIdAsc                      UserOrderByInput = "numId_ASC"
	UserOrderByInputNumIdDesc                     UserOrderByInput = "numId_DESC"
	UserOrderByInputUserRankAsc                   UserOrderByInput = "userRank_ASC"
	UserOrderByInputUserRankDesc                  UserOrderByInput = "userRank_DESC"
)

type CategoryOrderByInput string

const (
	CategoryOrderByInputIDAsc          CategoryOrderByInput = "id_ASC"
	CategoryOrderByInputIDDesc         CategoryOrderByInput = "id_DESC"
	CategoryOrderByInputNameAsc        CategoryOrderByInput = "name_ASC"
	CategoryOrderByInputNameDesc       CategoryOrderByInput = "name_DESC"
	CategoryOrderByInputOrderIndexAsc  CategoryOrderByInput = "order_index_ASC"
	CategoryOrderByInputOrderIndexDesc CategoryOrderByInput = "order_index_DESC"
)

type PostOrderByInput string

const (
	PostOrderByInputIDAsc                     PostOrderByInput = "id_ASC"
	PostOrderByInputIDDesc                    PostOrderByInput = "id_DESC"
	PostOrderByInputTypeAsc                   PostOrderByInput = "type_ASC"
	PostOrderByInputTypeDesc                  PostOrderByInput = "type_DESC"
	PostOrderByInputPayTypeAsc                PostOrderByInput = "payType_ASC"
	PostOrderByInputPayTypeDesc               PostOrderByInput = "payType_DESC"
	PostOrderByInputContentAsc                PostOrderByInput = "content_ASC"
	PostOrderByInputContentDesc               PostOrderByInput = "content_DESC"
	PostOrderByInputQuestTitleAsc             PostOrderByInput = "questTitle_ASC"
	PostOrderByInputQuestTitleDesc            PostOrderByInput = "questTitle_DESC"
	PostOrderByInputQuestCostAsc              PostOrderByInput = "questCost_ASC"
	PostOrderByInputQuestCostDesc             PostOrderByInput = "questCost_DESC"
	PostOrderByInputQuestMinMemberCountAsc    PostOrderByInput = "questMinMemberCount_ASC"
	PostOrderByInputQuestMinMemberCountDesc   PostOrderByInput = "questMinMemberCount_DESC"
	PostOrderByInputQuestLimitMemberCountAsc  PostOrderByInput = "questLimitMemberCount_ASC"
	PostOrderByInputQuestLimitMemberCountDesc PostOrderByInput = "questLimitMemberCount_DESC"
	PostOrderByInputQuestToDateAsc            PostOrderByInput = "questToDate_ASC"
	PostOrderByInputQuestToDateDesc           PostOrderByInput = "questToDate_DESC"
	PostOrderByInputQuestStatusAsc            PostOrderByInput = "questStatus_ASC"
	PostOrderByInputQuestStatusDesc           PostOrderByInput = "questStatus_DESC"
	PostOrderByInputCreatedAtAsc              PostOrderByInput = "createdAt_ASC"
	PostOrderByInputCreatedAtDesc             PostOrderByInput = "createdAt_DESC"
	PostOrderByInputUpdatedAtAsc              PostOrderByInput = "updatedAt_ASC"
	PostOrderByInputUpdatedAtDesc             PostOrderByInput = "updatedAt_DESC"
	PostOrderByInputIsBannerAsc               PostOrderByInput = "isBanner_ASC"
	PostOrderByInputIsBannerDesc              PostOrderByInput = "isBanner_DESC"
	PostOrderByInputIsDelAsc                  PostOrderByInput = "isDel_ASC"
	PostOrderByInputIsDelDesc                 PostOrderByInput = "isDel_DESC"
	PostOrderByInputEnableEarlyAccessAsc      PostOrderByInput = "enableEarlyAccess_ASC"
	PostOrderByInputEnableEarlyAccessDesc     PostOrderByInput = "enableEarlyAccess_DESC"
	PostOrderByInputPublicAccessAtAsc         PostOrderByInput = "publicAccessAt_ASC"
	PostOrderByInputPublicAccessAtDesc        PostOrderByInput = "publicAccessAt_DESC"
	PostOrderByInputOrderIndexAsc             PostOrderByInput = "order_index_ASC"
	PostOrderByInputOrderIndexDesc            PostOrderByInput = "order_index_DESC"
)

type WalletOrderByInput string

const (
	WalletOrderByInputIDAsc                          WalletOrderByInput = "id_ASC"
	WalletOrderByInputIDDesc                         WalletOrderByInput = "id_DESC"
	WalletOrderByInputNumIdCoinNameAsc               WalletOrderByInput = "numIdCoinName_ASC"
	WalletOrderByInputNumIdCoinNameDesc              WalletOrderByInput = "numIdCoinName_DESC"
	WalletOrderByInputCumulativePurchaseQuantityAsc  WalletOrderByInput = "cumulativePurchaseQuantity_ASC"
	WalletOrderByInputCumulativePurchaseQuantityDesc WalletOrderByInput = "cumulativePurchaseQuantity_DESC"
	WalletOrderByInputCumulativePurchaseValueAsc     WalletOrderByInput = "cumulativePurchaseValue_ASC"
	WalletOrderByInputCumulativePurchaseValueDesc    WalletOrderByInput = "cumulativePurchaseValue_DESC"
	WalletOrderByInputCreatedAtAsc                   WalletOrderByInput = "createdAt_ASC"
	WalletOrderByInputCreatedAtDesc                  WalletOrderByInput = "createdAt_DESC"
)

type OfferorOrderByInput string

const (
	OfferorOrderByInputIDAsc         OfferorOrderByInput = "id_ASC"
	OfferorOrderByInputIDDesc        OfferorOrderByInput = "id_DESC"
	OfferorOrderByInputPriceAsc      OfferorOrderByInput = "price_ASC"
	OfferorOrderByInputPriceDesc     OfferorOrderByInput = "price_DESC"
	OfferorOrderByInputCreatedAtAsc  OfferorOrderByInput = "createdAt_ASC"
	OfferorOrderByInputCreatedAtDesc OfferorOrderByInput = "createdAt_DESC"
	OfferorOrderByInputUpdatedAtAsc  OfferorOrderByInput = "updatedAt_ASC"
	OfferorOrderByInputUpdatedAtDesc OfferorOrderByInput = "updatedAt_DESC"
)

type OrderHistoryOrderByInput string

const (
	OrderHistoryOrderByInputIDAsc           OrderHistoryOrderByInput = "id_ASC"
	OrderHistoryOrderByInputIDDesc          OrderHistoryOrderByInput = "id_DESC"
	OrderHistoryOrderByInputTypeAsc         OrderHistoryOrderByInput = "type_ASC"
	OrderHistoryOrderByInputTypeDesc        OrderHistoryOrderByInput = "type_DESC"
	OrderHistoryOrderByInputOrderNumAsc     OrderHistoryOrderByInput = "orderNum_ASC"
	OrderHistoryOrderByInputOrderNumDesc    OrderHistoryOrderByInput = "orderNum_DESC"
	OrderHistoryOrderByInputOrderPriceAsc   OrderHistoryOrderByInput = "orderPrice_ASC"
	OrderHistoryOrderByInputOrderPriceDesc  OrderHistoryOrderByInput = "orderPrice_DESC"
	OrderHistoryOrderByInputDealPriceAsc    OrderHistoryOrderByInput = "dealPrice_ASC"
	OrderHistoryOrderByInputDealPriceDesc   OrderHistoryOrderByInput = "dealPrice_DESC"
	OrderHistoryOrderByInputOrderQtyAsc     OrderHistoryOrderByInput = "orderQty_ASC"
	OrderHistoryOrderByInputOrderQtyDesc    OrderHistoryOrderByInput = "orderQty_DESC"
	OrderHistoryOrderByInputDealQtyAsc      OrderHistoryOrderByInput = "dealQty_ASC"
	OrderHistoryOrderByInputDealQtyDesc     OrderHistoryOrderByInput = "dealQty_DESC"
	OrderHistoryOrderByInputLeftQtyAsc      OrderHistoryOrderByInput = "leftQty_ASC"
	OrderHistoryOrderByInputLeftQtyDesc     OrderHistoryOrderByInput = "leftQty_DESC"
	OrderHistoryOrderByInputDealFeeAsc      OrderHistoryOrderByInput = "dealFee_ASC"
	OrderHistoryOrderByInputDealFeeDesc     OrderHistoryOrderByInput = "dealFee_DESC"
	OrderHistoryOrderByInputTakerFeeAsc     OrderHistoryOrderByInput = "takerFee_ASC"
	OrderHistoryOrderByInputTakerFeeDesc    OrderHistoryOrderByInput = "takerFee_DESC"
	OrderHistoryOrderByInputMakerFeeAsc     OrderHistoryOrderByInput = "makerFee_ASC"
	OrderHistoryOrderByInputMakerFeeDesc    OrderHistoryOrderByInput = "makerFee_DESC"
	OrderHistoryOrderByInputMemoAsc         OrderHistoryOrderByInput = "memo_ASC"
	OrderHistoryOrderByInputMemoDesc        OrderHistoryOrderByInput = "memo_DESC"
	OrderHistoryOrderByInputDescriptionAsc  OrderHistoryOrderByInput = "description_ASC"
	OrderHistoryOrderByInputDescriptionDesc OrderHistoryOrderByInput = "description_DESC"
	OrderHistoryOrderByInputOffsetAsc       OrderHistoryOrderByInput = "offset_ASC"
	OrderHistoryOrderByInputOffsetDesc      OrderHistoryOrderByInput = "offset_DESC"
	OrderHistoryOrderByInputIsCancelAsc     OrderHistoryOrderByInput = "isCancel_ASC"
	OrderHistoryOrderByInputIsCancelDesc    OrderHistoryOrderByInput = "isCancel_DESC"
	OrderHistoryOrderByInputCreatedAtAsc    OrderHistoryOrderByInput = "createdAt_ASC"
	OrderHistoryOrderByInputCreatedAtDesc   OrderHistoryOrderByInput = "createdAt_DESC"
	OrderHistoryOrderByInputUpdatedAtAsc    OrderHistoryOrderByInput = "updatedAt_ASC"
	OrderHistoryOrderByInputUpdatedAtDesc   OrderHistoryOrderByInput = "updatedAt_DESC"
)

type AergoAccountHistoryOrderByInput string

const (
	AergoAccountHistoryOrderByInputIDAsc           AergoAccountHistoryOrderByInput = "id_ASC"
	AergoAccountHistoryOrderByInputIDDesc          AergoAccountHistoryOrderByInput = "id_DESC"
	AergoAccountHistoryOrderByInputTypeAsc         AergoAccountHistoryOrderByInput = "type_ASC"
	AergoAccountHistoryOrderByInputTypeDesc        AergoAccountHistoryOrderByInput = "type_DESC"
	AergoAccountHistoryOrderByInputAergoAmountAsc  AergoAccountHistoryOrderByInput = "aergoAmount_ASC"
	AergoAccountHistoryOrderByInputAergoAmountDesc AergoAccountHistoryOrderByInput = "aergoAmount_DESC"
	AergoAccountHistoryOrderByInputAmountFeeAsc    AergoAccountHistoryOrderByInput = "amount_fee_ASC"
	AergoAccountHistoryOrderByInputAmountFeeDesc   AergoAccountHistoryOrderByInput = "amount_fee_DESC"
	AergoAccountHistoryOrderByInputAmountAsc       AergoAccountHistoryOrderByInput = "amount_ASC"
	AergoAccountHistoryOrderByInputAmountDesc      AergoAccountHistoryOrderByInput = "amount_DESC"
	AergoAccountHistoryOrderByInputMarketPriceAsc  AergoAccountHistoryOrderByInput = "marketPrice_ASC"
	AergoAccountHistoryOrderByInputMarketPriceDesc AergoAccountHistoryOrderByInput = "marketPrice_DESC"
	AergoAccountHistoryOrderByInputTxHashAsc       AergoAccountHistoryOrderByInput = "txHash_ASC"
	AergoAccountHistoryOrderByInputTxHashDesc      AergoAccountHistoryOrderByInput = "txHash_DESC"
	AergoAccountHistoryOrderByInputMemoAsc         AergoAccountHistoryOrderByInput = "memo_ASC"
	AergoAccountHistoryOrderByInputMemoDesc        AergoAccountHistoryOrderByInput = "memo_DESC"
	AergoAccountHistoryOrderByInputDescriptionAsc  AergoAccountHistoryOrderByInput = "description_ASC"
	AergoAccountHistoryOrderByInputDescriptionDesc AergoAccountHistoryOrderByInput = "description_DESC"
	AergoAccountHistoryOrderByInputBlockNoAsc      AergoAccountHistoryOrderByInput = "blockNo_ASC"
	AergoAccountHistoryOrderByInputBlockNoDesc     AergoAccountHistoryOrderByInput = "blockNo_DESC"
	AergoAccountHistoryOrderByInputStatusAsc       AergoAccountHistoryOrderByInput = "status_ASC"
	AergoAccountHistoryOrderByInputStatusDesc      AergoAccountHistoryOrderByInput = "status_DESC"
	AergoAccountHistoryOrderByInputCreatedAtAsc    AergoAccountHistoryOrderByInput = "createdAt_ASC"
	AergoAccountHistoryOrderByInputCreatedAtDesc   AergoAccountHistoryOrderByInput = "createdAt_DESC"
	AergoAccountHistoryOrderByInputUpdatedAtAsc    AergoAccountHistoryOrderByInput = "updatedAt_ASC"
	AergoAccountHistoryOrderByInputUpdatedAtDesc   AergoAccountHistoryOrderByInput = "updatedAt_DESC"
)

type AirDropMemberOrderByInput string

const (
	AirDropMemberOrderByInputIDAsc         AirDropMemberOrderByInput = "id_ASC"
	AirDropMemberOrderByInputIDDesc        AirDropMemberOrderByInput = "id_DESC"
	AirDropMemberOrderByInputDropNumAsc    AirDropMemberOrderByInput = "dropNum_ASC"
	AirDropMemberOrderByInputDropNumDesc   AirDropMemberOrderByInput = "dropNum_DESC"
	AirDropMemberOrderByInputQtyAsc        AirDropMemberOrderByInput = "qty_ASC"
	AirDropMemberOrderByInputQtyDesc       AirDropMemberOrderByInput = "qty_DESC"
	AirDropMemberOrderByInputCreatedAtAsc  AirDropMemberOrderByInput = "createdAt_ASC"
	AirDropMemberOrderByInputCreatedAtDesc AirDropMemberOrderByInput = "createdAt_DESC"
	AirDropMemberOrderByInputUpdatedAtAsc  AirDropMemberOrderByInput = "updatedAt_ASC"
	AirDropMemberOrderByInputUpdatedAtDesc AirDropMemberOrderByInput = "updatedAt_DESC"
	AirDropMemberOrderByInputIsDelAsc      AirDropMemberOrderByInput = "isDel_ASC"
	AirDropMemberOrderByInputIsDelDesc     AirDropMemberOrderByInput = "isDel_DESC"
)

type AirDropHistoryOrderByInput string

const (
	AirDropHistoryOrderByInputIDAsc            AirDropHistoryOrderByInput = "id_ASC"
	AirDropHistoryOrderByInputIDDesc           AirDropHistoryOrderByInput = "id_DESC"
	AirDropHistoryOrderByInputTypeAsc          AirDropHistoryOrderByInput = "type_ASC"
	AirDropHistoryOrderByInputTypeDesc         AirDropHistoryOrderByInput = "type_DESC"
	AirDropHistoryOrderByInputDescriptionAsc   AirDropHistoryOrderByInput = "description_ASC"
	AirDropHistoryOrderByInputDescriptionDesc  AirDropHistoryOrderByInput = "description_DESC"
	AirDropHistoryOrderByInputQtyAsc           AirDropHistoryOrderByInput = "qty_ASC"
	AirDropHistoryOrderByInputQtyDesc          AirDropHistoryOrderByInput = "qty_DESC"
	AirDropHistoryOrderByInputCurrentPriceAsc  AirDropHistoryOrderByInput = "currentPrice_ASC"
	AirDropHistoryOrderByInputCurrentPriceDesc AirDropHistoryOrderByInput = "currentPrice_DESC"
	AirDropHistoryOrderByInputMemoAsc          AirDropHistoryOrderByInput = "memo_ASC"
	AirDropHistoryOrderByInputMemoDesc         AirDropHistoryOrderByInput = "memo_DESC"
	AirDropHistoryOrderByInputCreatedAtAsc     AirDropHistoryOrderByInput = "createdAt_ASC"
	AirDropHistoryOrderByInputCreatedAtDesc    AirDropHistoryOrderByInput = "createdAt_DESC"
	AirDropHistoryOrderByInputUpdatedAtAsc     AirDropHistoryOrderByInput = "updatedAt_ASC"
	AirDropHistoryOrderByInputUpdatedAtDesc    AirDropHistoryOrderByInput = "updatedAt_DESC"
)

type CommentReplyOrderByInput string

const (
	CommentReplyOrderByInputIDAsc         CommentReplyOrderByInput = "id_ASC"
	CommentReplyOrderByInputIDDesc        CommentReplyOrderByInput = "id_DESC"
	CommentReplyOrderByInputContentAsc    CommentReplyOrderByInput = "content_ASC"
	CommentReplyOrderByInputContentDesc   CommentReplyOrderByInput = "content_DESC"
	CommentReplyOrderByInputCreatedAtAsc  CommentReplyOrderByInput = "createdAt_ASC"
	CommentReplyOrderByInputCreatedAtDesc CommentReplyOrderByInput = "createdAt_DESC"
	CommentReplyOrderByInputUpdatedAtAsc  CommentReplyOrderByInput = "updatedAt_ASC"
	CommentReplyOrderByInputUpdatedAtDesc CommentReplyOrderByInput = "updatedAt_DESC"
	CommentReplyOrderByInputIsDelAsc      CommentReplyOrderByInput = "isDel_ASC"
	CommentReplyOrderByInputIsDelDesc     CommentReplyOrderByInput = "isDel_DESC"
)

type OrderUserDealsHistoryOrderByInput string

const (
	OrderUserDealsHistoryOrderByInputIDAsc           OrderUserDealsHistoryOrderByInput = "id_ASC"
	OrderUserDealsHistoryOrderByInputIDDesc          OrderUserDealsHistoryOrderByInput = "id_DESC"
	OrderUserDealsHistoryOrderByInputTypeAsc         OrderUserDealsHistoryOrderByInput = "type_ASC"
	OrderUserDealsHistoryOrderByInputTypeDesc        OrderUserDealsHistoryOrderByInput = "type_DESC"
	OrderUserDealsHistoryOrderByInputRoleAsc         OrderUserDealsHistoryOrderByInput = "role_ASC"
	OrderUserDealsHistoryOrderByInputRoleDesc        OrderUserDealsHistoryOrderByInput = "role_DESC"
	OrderUserDealsHistoryOrderByInputDealIdAsc       OrderUserDealsHistoryOrderByInput = "dealId_ASC"
	OrderUserDealsHistoryOrderByInputDealIdDesc      OrderUserDealsHistoryOrderByInput = "dealId_DESC"
	OrderUserDealsHistoryOrderByInputUniqueKeyAsc    OrderUserDealsHistoryOrderByInput = "uniqueKey_ASC"
	OrderUserDealsHistoryOrderByInputUniqueKeyDesc   OrderUserDealsHistoryOrderByInput = "uniqueKey_DESC"
	OrderUserDealsHistoryOrderByInputUniqueIdAsc     OrderUserDealsHistoryOrderByInput = "uniqueId_ASC"
	OrderUserDealsHistoryOrderByInputUniqueIdDesc    OrderUserDealsHistoryOrderByInput = "uniqueId_DESC"
	OrderUserDealsHistoryOrderByInputDealPriceAsc    OrderUserDealsHistoryOrderByInput = "dealPrice_ASC"
	OrderUserDealsHistoryOrderByInputDealPriceDesc   OrderUserDealsHistoryOrderByInput = "dealPrice_DESC"
	OrderUserDealsHistoryOrderByInputDealQtyAsc      OrderUserDealsHistoryOrderByInput = "dealQty_ASC"
	OrderUserDealsHistoryOrderByInputDealQtyDesc     OrderUserDealsHistoryOrderByInput = "dealQty_DESC"
	OrderUserDealsHistoryOrderByInputFeeAsc          OrderUserDealsHistoryOrderByInput = "fee_ASC"
	OrderUserDealsHistoryOrderByInputFeeDesc         OrderUserDealsHistoryOrderByInput = "fee_DESC"
	OrderUserDealsHistoryOrderByInputDealOrderIdAsc  OrderUserDealsHistoryOrderByInput = "dealOrderId_ASC"
	OrderUserDealsHistoryOrderByInputDealOrderIdDesc OrderUserDealsHistoryOrderByInput = "dealOrderId_DESC"
	OrderUserDealsHistoryOrderByInputTimeAsc         OrderUserDealsHistoryOrderByInput = "time_ASC"
	OrderUserDealsHistoryOrderByInputTimeDesc        OrderUserDealsHistoryOrderByInput = "time_DESC"
	OrderUserDealsHistoryOrderByInputCreatedAtAsc    OrderUserDealsHistoryOrderByInput = "createdAt_ASC"
	OrderUserDealsHistoryOrderByInputCreatedAtDesc   OrderUserDealsHistoryOrderByInput = "createdAt_DESC"
	OrderUserDealsHistoryOrderByInputUpdatedAtAsc    OrderUserDealsHistoryOrderByInput = "updatedAt_ASC"
	OrderUserDealsHistoryOrderByInputUpdatedAtDesc   OrderUserDealsHistoryOrderByInput = "updatedAt_DESC"
)

type OrderDealsHistoryOrderByInput string

const (
	OrderDealsHistoryOrderByInputIDAsc         OrderDealsHistoryOrderByInput = "id_ASC"
	OrderDealsHistoryOrderByInputIDDesc        OrderDealsHistoryOrderByInput = "id_DESC"
	OrderDealsHistoryOrderByInputTypeAsc       OrderDealsHistoryOrderByInput = "type_ASC"
	OrderDealsHistoryOrderByInputTypeDesc      OrderDealsHistoryOrderByInput = "type_DESC"
	OrderDealsHistoryOrderByInputDealIdAsc     OrderDealsHistoryOrderByInput = "dealId_ASC"
	OrderDealsHistoryOrderByInputDealIdDesc    OrderDealsHistoryOrderByInput = "dealId_DESC"
	OrderDealsHistoryOrderByInputDealPriceAsc  OrderDealsHistoryOrderByInput = "dealPrice_ASC"
	OrderDealsHistoryOrderByInputDealPriceDesc OrderDealsHistoryOrderByInput = "dealPrice_DESC"
	OrderDealsHistoryOrderByInputDealQtyAsc    OrderDealsHistoryOrderByInput = "dealQty_ASC"
	OrderDealsHistoryOrderByInputDealQtyDesc   OrderDealsHistoryOrderByInput = "dealQty_DESC"
	OrderDealsHistoryOrderByInputTimeAsc       OrderDealsHistoryOrderByInput = "time_ASC"
	OrderDealsHistoryOrderByInputTimeDesc      OrderDealsHistoryOrderByInput = "time_DESC"
	OrderDealsHistoryOrderByInputCreatedAtAsc  OrderDealsHistoryOrderByInput = "createdAt_ASC"
	OrderDealsHistoryOrderByInputCreatedAtDesc OrderDealsHistoryOrderByInput = "createdAt_DESC"
	OrderDealsHistoryOrderByInputUpdatedAtAsc  OrderDealsHistoryOrderByInput = "updatedAt_ASC"
	OrderDealsHistoryOrderByInputUpdatedAtDesc OrderDealsHistoryOrderByInput = "updatedAt_DESC"
)

type MotherHistoryOrderByInput string

const (
	MotherHistoryOrderByInputIDAsc         MotherHistoryOrderByInput = "id_ASC"
	MotherHistoryOrderByInputIDDesc        MotherHistoryOrderByInput = "id_DESC"
	MotherHistoryOrderByInputTypeAsc       MotherHistoryOrderByInput = "type_ASC"
	MotherHistoryOrderByInputTypeDesc      MotherHistoryOrderByInput = "type_DESC"
	MotherHistoryOrderByInputRoleTimeAsc   MotherHistoryOrderByInput = "roleTime_ASC"
	MotherHistoryOrderByInputRoleTimeDesc  MotherHistoryOrderByInput = "roleTime_DESC"
	MotherHistoryOrderByInputCreatedAtAsc  MotherHistoryOrderByInput = "createdAt_ASC"
	MotherHistoryOrderByInputCreatedAtDesc MotherHistoryOrderByInput = "createdAt_DESC"
	MotherHistoryOrderByInputUpdatedAtAsc  MotherHistoryOrderByInput = "updatedAt_ASC"
	MotherHistoryOrderByInputUpdatedAtDesc MotherHistoryOrderByInput = "updatedAt_DESC"
)

type CoinKlineOrderByInput string

const (
	CoinKlineOrderByInputIDAsc         CoinKlineOrderByInput = "id_ASC"
	CoinKlineOrderByInputIDDesc        CoinKlineOrderByInput = "id_DESC"
	CoinKlineOrderByInputOpenAsc       CoinKlineOrderByInput = "open_ASC"
	CoinKlineOrderByInputOpenDesc      CoinKlineOrderByInput = "open_DESC"
	CoinKlineOrderByInputCloseAsc      CoinKlineOrderByInput = "close_ASC"
	CoinKlineOrderByInputCloseDesc     CoinKlineOrderByInput = "close_DESC"
	CoinKlineOrderByInputHighAsc       CoinKlineOrderByInput = "high_ASC"
	CoinKlineOrderByInputHighDesc      CoinKlineOrderByInput = "high_DESC"
	CoinKlineOrderByInputLowAsc        CoinKlineOrderByInput = "low_ASC"
	CoinKlineOrderByInputLowDesc       CoinKlineOrderByInput = "low_DESC"
	CoinKlineOrderByInputVolumeAsc     CoinKlineOrderByInput = "volume_ASC"
	CoinKlineOrderByInputVolumeDesc    CoinKlineOrderByInput = "volume_DESC"
	CoinKlineOrderByInputDealAsc       CoinKlineOrderByInput = "deal_ASC"
	CoinKlineOrderByInputDealDesc      CoinKlineOrderByInput = "deal_DESC"
	CoinKlineOrderByInputCreatedAtAsc  CoinKlineOrderByInput = "createdAt_ASC"
	CoinKlineOrderByInputCreatedAtDesc CoinKlineOrderByInput = "createdAt_DESC"
	CoinKlineOrderByInputUpdatedAtAsc  CoinKlineOrderByInput = "updatedAt_ASC"
	CoinKlineOrderByInputUpdatedAtDesc CoinKlineOrderByInput = "updatedAt_DESC"
)

type FileInfoOrderByInput string

const (
	FileInfoOrderByInputIDAsc            FileInfoOrderByInput = "id_ASC"
	FileInfoOrderByInputIDDesc           FileInfoOrderByInput = "id_DESC"
	FileInfoOrderByInputTempFileIdAsc    FileInfoOrderByInput = "tempFileId_ASC"
	FileInfoOrderByInputTempFileIdDesc   FileInfoOrderByInput = "tempFileId_DESC"
	FileInfoOrderByInputLocationPathAsc  FileInfoOrderByInput = "locationPath_ASC"
	FileInfoOrderByInputLocationPathDesc FileInfoOrderByInput = "locationPath_DESC"
	FileInfoOrderByInputNameAsc          FileInfoOrderByInput = "name_ASC"
	FileInfoOrderByInputNameDesc         FileInfoOrderByInput = "name_DESC"
	FileInfoOrderByInputContentTypeAsc   FileInfoOrderByInput = "contentType_ASC"
	FileInfoOrderByInputContentTypeDesc  FileInfoOrderByInput = "contentType_DESC"
	FileInfoOrderByInputUrlAsc           FileInfoOrderByInput = "url_ASC"
	FileInfoOrderByInputUrlDesc          FileInfoOrderByInput = "url_DESC"
	FileInfoOrderByInputIsVideoAsc       FileInfoOrderByInput = "isVideo_ASC"
	FileInfoOrderByInputIsVideoDesc      FileInfoOrderByInput = "isVideo_DESC"
	FileInfoOrderByInputIsDelAsc         FileInfoOrderByInput = "isDel_ASC"
	FileInfoOrderByInputIsDelDesc        FileInfoOrderByInput = "isDel_DESC"
	FileInfoOrderByInputCreatedAtAsc     FileInfoOrderByInput = "createdAt_ASC"
	FileInfoOrderByInputCreatedAtDesc    FileInfoOrderByInput = "createdAt_DESC"
)

type QuestMemberOrderByInput string

const (
	QuestMemberOrderByInputIDAsc         QuestMemberOrderByInput = "id_ASC"
	QuestMemberOrderByInputIDDesc        QuestMemberOrderByInput = "id_DESC"
	QuestMemberOrderByInputNoteAsc       QuestMemberOrderByInput = "note_ASC"
	QuestMemberOrderByInputNoteDesc      QuestMemberOrderByInput = "note_DESC"
	QuestMemberOrderByInputCreatedAtAsc  QuestMemberOrderByInput = "createdAt_ASC"
	QuestMemberOrderByInputCreatedAtDesc QuestMemberOrderByInput = "createdAt_DESC"
	QuestMemberOrderByInputIsDelAsc      QuestMemberOrderByInput = "isDel_ASC"
	QuestMemberOrderByInputIsDelDesc     QuestMemberOrderByInput = "isDel_DESC"
)

type QuestExpenditureHistoryOrderByInput string

const (
	QuestExpenditureHistoryOrderByInputIDAsc            QuestExpenditureHistoryOrderByInput = "id_ASC"
	QuestExpenditureHistoryOrderByInputIDDesc           QuestExpenditureHistoryOrderByInput = "id_DESC"
	QuestExpenditureHistoryOrderByInputTypeAsc          QuestExpenditureHistoryOrderByInput = "type_ASC"
	QuestExpenditureHistoryOrderByInputTypeDesc         QuestExpenditureHistoryOrderByInput = "type_DESC"
	QuestExpenditureHistoryOrderByInputPayTypeAsc       QuestExpenditureHistoryOrderByInput = "payType_ASC"
	QuestExpenditureHistoryOrderByInputPayTypeDesc      QuestExpenditureHistoryOrderByInput = "payType_DESC"
	QuestExpenditureHistoryOrderByInputOrderNumAsc      QuestExpenditureHistoryOrderByInput = "orderNum_ASC"
	QuestExpenditureHistoryOrderByInputOrderNumDesc     QuestExpenditureHistoryOrderByInput = "orderNum_DESC"
	QuestExpenditureHistoryOrderByInputDescriptionAsc   QuestExpenditureHistoryOrderByInput = "description_ASC"
	QuestExpenditureHistoryOrderByInputDescriptionDesc  QuestExpenditureHistoryOrderByInput = "description_DESC"
	QuestExpenditureHistoryOrderByInputPriceAsc         QuestExpenditureHistoryOrderByInput = "price_ASC"
	QuestExpenditureHistoryOrderByInputPriceDesc        QuestExpenditureHistoryOrderByInput = "price_DESC"
	QuestExpenditureHistoryOrderByInputQtyAsc           QuestExpenditureHistoryOrderByInput = "qty_ASC"
	QuestExpenditureHistoryOrderByInputQtyDesc          QuestExpenditureHistoryOrderByInput = "qty_DESC"
	QuestExpenditureHistoryOrderByInputOPriceAsc        QuestExpenditureHistoryOrderByInput = "oPrice_ASC"
	QuestExpenditureHistoryOrderByInputOPriceDesc       QuestExpenditureHistoryOrderByInput = "oPrice_DESC"
	QuestExpenditureHistoryOrderByInputCurrentPriceAsc  QuestExpenditureHistoryOrderByInput = "currentPrice_ASC"
	QuestExpenditureHistoryOrderByInputCurrentPriceDesc QuestExpenditureHistoryOrderByInput = "currentPrice_DESC"
	QuestExpenditureHistoryOrderByInputMemoAsc          QuestExpenditureHistoryOrderByInput = "memo_ASC"
	QuestExpenditureHistoryOrderByInputMemoDesc         QuestExpenditureHistoryOrderByInput = "memo_DESC"
	QuestExpenditureHistoryOrderByInputCreatedAtAsc     QuestExpenditureHistoryOrderByInput = "createdAt_ASC"
	QuestExpenditureHistoryOrderByInputCreatedAtDesc    QuestExpenditureHistoryOrderByInput = "createdAt_DESC"
	QuestExpenditureHistoryOrderByInputUpdatedAtAsc     QuestExpenditureHistoryOrderByInput = "updatedAt_ASC"
	QuestExpenditureHistoryOrderByInputUpdatedAtDesc    QuestExpenditureHistoryOrderByInput = "updatedAt_DESC"
)

type PostRewardHistoryOrderByInput string

const (
	PostRewardHistoryOrderByInputIDAsc            PostRewardHistoryOrderByInput = "id_ASC"
	PostRewardHistoryOrderByInputIDDesc           PostRewardHistoryOrderByInput = "id_DESC"
	PostRewardHistoryOrderByInputTypeAsc          PostRewardHistoryOrderByInput = "type_ASC"
	PostRewardHistoryOrderByInputTypeDesc         PostRewardHistoryOrderByInput = "type_DESC"
	PostRewardHistoryOrderByInputDescriptionAsc   PostRewardHistoryOrderByInput = "description_ASC"
	PostRewardHistoryOrderByInputDescriptionDesc  PostRewardHistoryOrderByInput = "description_DESC"
	PostRewardHistoryOrderByInputQtyAsc           PostRewardHistoryOrderByInput = "qty_ASC"
	PostRewardHistoryOrderByInputQtyDesc          PostRewardHistoryOrderByInput = "qty_DESC"
	PostRewardHistoryOrderByInputCurrentPriceAsc  PostRewardHistoryOrderByInput = "currentPrice_ASC"
	PostRewardHistoryOrderByInputCurrentPriceDesc PostRewardHistoryOrderByInput = "currentPrice_DESC"
	PostRewardHistoryOrderByInputMemoAsc          PostRewardHistoryOrderByInput = "memo_ASC"
	PostRewardHistoryOrderByInputMemoDesc         PostRewardHistoryOrderByInput = "memo_DESC"
	PostRewardHistoryOrderByInputCreatedAtAsc     PostRewardHistoryOrderByInput = "createdAt_ASC"
	PostRewardHistoryOrderByInputCreatedAtDesc    PostRewardHistoryOrderByInput = "createdAt_DESC"
	PostRewardHistoryOrderByInputUpdatedAtAsc     PostRewardHistoryOrderByInput = "updatedAt_ASC"
	PostRewardHistoryOrderByInputUpdatedAtDesc    PostRewardHistoryOrderByInput = "updatedAt_DESC"
)

type CommentOrderByInput string

const (
	CommentOrderByInputIDAsc         CommentOrderByInput = "id_ASC"
	CommentOrderByInputIDDesc        CommentOrderByInput = "id_DESC"
	CommentOrderByInputTypeAsc       CommentOrderByInput = "type_ASC"
	CommentOrderByInputTypeDesc      CommentOrderByInput = "type_DESC"
	CommentOrderByInputContentAsc    CommentOrderByInput = "content_ASC"
	CommentOrderByInputContentDesc   CommentOrderByInput = "content_DESC"
	CommentOrderByInputUrlAsc        CommentOrderByInput = "url_ASC"
	CommentOrderByInputUrlDesc       CommentOrderByInput = "url_DESC"
	CommentOrderByInputCreatedAtAsc  CommentOrderByInput = "createdAt_ASC"
	CommentOrderByInputCreatedAtDesc CommentOrderByInput = "createdAt_DESC"
	CommentOrderByInputUpdatedAtAsc  CommentOrderByInput = "updatedAt_ASC"
	CommentOrderByInputUpdatedAtDesc CommentOrderByInput = "updatedAt_DESC"
	CommentOrderByInputIsDelAsc      CommentOrderByInput = "isDel_ASC"
	CommentOrderByInputIsDelDesc     CommentOrderByInput = "isDel_DESC"
)

type UpdatePostHistoryOrderByInput string

const (
	UpdatePostHistoryOrderByInputIDAsc              UpdatePostHistoryOrderByInput = "id_ASC"
	UpdatePostHistoryOrderByInputIDDesc             UpdatePostHistoryOrderByInput = "id_DESC"
	UpdatePostHistoryOrderByInputActionAsc          UpdatePostHistoryOrderByInput = "action_ASC"
	UpdatePostHistoryOrderByInputActionDesc         UpdatePostHistoryOrderByInput = "action_DESC"
	UpdatePostHistoryOrderByInputBeforeContentAsc   UpdatePostHistoryOrderByInput = "beforeContent_ASC"
	UpdatePostHistoryOrderByInputBeforeContentDesc  UpdatePostHistoryOrderByInput = "beforeContent_DESC"
	UpdatePostHistoryOrderByInputBeforeImageUrlAsc  UpdatePostHistoryOrderByInput = "beforeImageUrl_ASC"
	UpdatePostHistoryOrderByInputBeforeImageUrlDesc UpdatePostHistoryOrderByInput = "beforeImageUrl_DESC"
	UpdatePostHistoryOrderByInputCreatedAtAsc       UpdatePostHistoryOrderByInput = "createdAt_ASC"
	UpdatePostHistoryOrderByInputCreatedAtDesc      UpdatePostHistoryOrderByInput = "createdAt_DESC"
)

type CoinOrderByInput string

const (
	CoinOrderByInputIDAsc               CoinOrderByInput = "id_ASC"
	CoinOrderByInputIDDesc              CoinOrderByInput = "id_DESC"
	CoinOrderByInputNameAsc             CoinOrderByInput = "name_ASC"
	CoinOrderByInputNameDesc            CoinOrderByInput = "name_DESC"
	CoinOrderByInputQtyAsc              CoinOrderByInput = "qty_ASC"
	CoinOrderByInputQtyDesc             CoinOrderByInput = "qty_DESC"
	CoinOrderByInputStandardPriceAsc    CoinOrderByInput = "standardPrice_ASC"
	CoinOrderByInputStandardPriceDesc   CoinOrderByInput = "standardPrice_DESC"
	CoinOrderByInputCurrentPriceAsc     CoinOrderByInput = "currentPrice_ASC"
	CoinOrderByInputCurrentPriceDesc    CoinOrderByInput = "currentPrice_DESC"
	CoinOrderByInputDescriptionAsc      CoinOrderByInput = "description_ASC"
	CoinOrderByInputDescriptionDesc     CoinOrderByInput = "description_DESC"
	CoinOrderByInputStatusAsc           CoinOrderByInput = "status_ASC"
	CoinOrderByInputStatusDesc          CoinOrderByInput = "status_DESC"
	CoinOrderByInputWeightAsc           CoinOrderByInput = "weight_ASC"
	CoinOrderByInputWeightDesc          CoinOrderByInput = "weight_DESC"
	CoinOrderByInputDeployTxhashAsc     CoinOrderByInput = "deployTxhash_ASC"
	CoinOrderByInputDeployTxhashDesc    CoinOrderByInput = "deployTxhash_DESC"
	CoinOrderByInputContractAddressAsc  CoinOrderByInput = "contractAddress_ASC"
	CoinOrderByInputContractAddressDesc CoinOrderByInput = "contractAddress_DESC"
	CoinOrderByInputODdaAsc             CoinOrderByInput = "oDDA_ASC"
	CoinOrderByInputODdaDesc            CoinOrderByInput = "oDDA_DESC"
	CoinOrderByInputCreatedAtAsc        CoinOrderByInput = "createdAt_ASC"
	CoinOrderByInputCreatedAtDesc       CoinOrderByInput = "createdAt_DESC"
	CoinOrderByInputUpdatedAtAsc        CoinOrderByInput = "updatedAt_ASC"
	CoinOrderByInputUpdatedAtDesc       CoinOrderByInput = "updatedAt_DESC"
)

type FileOrderByInput string

const (
	FileOrderByInputIDAsc            FileOrderByInput = "id_ASC"
	FileOrderByInputIDDesc           FileOrderByInput = "id_DESC"
	FileOrderByInputLocationPathAsc  FileOrderByInput = "locationPath_ASC"
	FileOrderByInputLocationPathDesc FileOrderByInput = "locationPath_DESC"
	FileOrderByInputNameAsc          FileOrderByInput = "name_ASC"
	FileOrderByInputNameDesc         FileOrderByInput = "name_DESC"
	FileOrderByInputContentTypeAsc   FileOrderByInput = "contentType_ASC"
	FileOrderByInputContentTypeDesc  FileOrderByInput = "contentType_DESC"
	FileOrderByInputUrlAsc           FileOrderByInput = "url_ASC"
	FileOrderByInputUrlDesc          FileOrderByInput = "url_DESC"
	FileOrderByInputCreatedAtAsc     FileOrderByInput = "createdAt_ASC"
	FileOrderByInputCreatedAtDesc    FileOrderByInput = "createdAt_DESC"
	FileOrderByInputIsDelAsc         FileOrderByInput = "isDel_ASC"
	FileOrderByInputIsDelDesc        FileOrderByInput = "isDel_DESC"
)

type ReportOrderByInput string

const (
	ReportOrderByInputIDAsc          ReportOrderByInput = "id_ASC"
	ReportOrderByInputIDDesc         ReportOrderByInput = "id_DESC"
	ReportOrderByInputTypeAsc        ReportOrderByInput = "type_ASC"
	ReportOrderByInputTypeDesc       ReportOrderByInput = "type_DESC"
	ReportOrderByInputReportTypeAsc  ReportOrderByInput = "reportType_ASC"
	ReportOrderByInputReportTypeDesc ReportOrderByInput = "reportType_DESC"
	ReportOrderByInputCreatedAtAsc   ReportOrderByInput = "createdAt_ASC"
	ReportOrderByInputCreatedAtDesc  ReportOrderByInput = "createdAt_DESC"
)

type RewardDropAttendingUserOrderByInput string

const (
	RewardDropAttendingUserOrderByInputIDAsc         RewardDropAttendingUserOrderByInput = "id_ASC"
	RewardDropAttendingUserOrderByInputIDDesc        RewardDropAttendingUserOrderByInput = "id_DESC"
	RewardDropAttendingUserOrderByInputMemoAsc       RewardDropAttendingUserOrderByInput = "memo_ASC"
	RewardDropAttendingUserOrderByInputMemoDesc      RewardDropAttendingUserOrderByInput = "memo_DESC"
	RewardDropAttendingUserOrderByInputIsDelAsc      RewardDropAttendingUserOrderByInput = "isDel_ASC"
	RewardDropAttendingUserOrderByInputIsDelDesc     RewardDropAttendingUserOrderByInput = "isDel_DESC"
	RewardDropAttendingUserOrderByInputCreatedAtAsc  RewardDropAttendingUserOrderByInput = "createdAt_ASC"
	RewardDropAttendingUserOrderByInputCreatedAtDesc RewardDropAttendingUserOrderByInput = "createdAt_DESC"
)

type CashHistoryOrderByInput string

const (
	CashHistoryOrderByInputIDAsc           CashHistoryOrderByInput = "id_ASC"
	CashHistoryOrderByInputIDDesc          CashHistoryOrderByInput = "id_DESC"
	CashHistoryOrderByInputTypeAsc         CashHistoryOrderByInput = "type_ASC"
	CashHistoryOrderByInputTypeDesc        CashHistoryOrderByInput = "type_DESC"
	CashHistoryOrderByInputPropertyAsc     CashHistoryOrderByInput = "property_ASC"
	CashHistoryOrderByInputPropertyDesc    CashHistoryOrderByInput = "property_DESC"
	CashHistoryOrderByInputOrderNumAsc     CashHistoryOrderByInput = "orderNum_ASC"
	CashHistoryOrderByInputOrderNumDesc    CashHistoryOrderByInput = "orderNum_DESC"
	CashHistoryOrderByInputDescriptionAsc  CashHistoryOrderByInput = "description_ASC"
	CashHistoryOrderByInputDescriptionDesc CashHistoryOrderByInput = "description_DESC"
	CashHistoryOrderByInputPriceAsc        CashHistoryOrderByInput = "price_ASC"
	CashHistoryOrderByInputPriceDesc       CashHistoryOrderByInput = "price_DESC"
	CashHistoryOrderByInputOPriceAsc       CashHistoryOrderByInput = "oPrice_ASC"
	CashHistoryOrderByInputOPriceDesc      CashHistoryOrderByInput = "oPrice_DESC"
	CashHistoryOrderByInputOPriceBackAsc   CashHistoryOrderByInput = "oPriceBack_ASC"
	CashHistoryOrderByInputOPriceBackDesc  CashHistoryOrderByInput = "oPriceBack_DESC"
	CashHistoryOrderByInputQtyAsc          CashHistoryOrderByInput = "qty_ASC"
	CashHistoryOrderByInputQtyDesc         CashHistoryOrderByInput = "qty_DESC"
	CashHistoryOrderByInputMemoAsc         CashHistoryOrderByInput = "memo_ASC"
	CashHistoryOrderByInputMemoDesc        CashHistoryOrderByInput = "memo_DESC"
	CashHistoryOrderByInputCreatedAtAsc    CashHistoryOrderByInput = "createdAt_ASC"
	CashHistoryOrderByInputCreatedAtDesc   CashHistoryOrderByInput = "createdAt_DESC"
	CashHistoryOrderByInputUpdatedAtAsc    CashHistoryOrderByInput = "updatedAt_ASC"
	CashHistoryOrderByInputUpdatedAtDesc   CashHistoryOrderByInput = "updatedAt_DESC"
)

type FeeOrderByInput string

const (
	FeeOrderByInputIDAsc                 FeeOrderByInput = "id_ASC"
	FeeOrderByInputIDDesc                FeeOrderByInput = "id_DESC"
	FeeOrderByInputTypeAsc               FeeOrderByInput = "type_ASC"
	FeeOrderByInputTypeDesc              FeeOrderByInput = "type_DESC"
	FeeOrderByInputKeyAsc                FeeOrderByInput = "key_ASC"
	FeeOrderByInputKeyDesc               FeeOrderByInput = "key_DESC"
	FeeOrderByInputMemoAsc               FeeOrderByInput = "memo_ASC"
	FeeOrderByInputMemoDesc              FeeOrderByInput = "memo_DESC"
	FeeOrderByInputRankAsc               FeeOrderByInput = "rank_ASC"
	FeeOrderByInputRankDesc              FeeOrderByInput = "rank_DESC"
	FeeOrderByInputAskTakerFeeAsc        FeeOrderByInput = "askTakerFee_ASC"
	FeeOrderByInputAskTakerFeeDesc       FeeOrderByInput = "askTakerFee_DESC"
	FeeOrderByInputAskMakerFeeAsc        FeeOrderByInput = "askMakerFee_ASC"
	FeeOrderByInputAskMakerFeeDesc       FeeOrderByInput = "askMakerFee_DESC"
	FeeOrderByInputBidTakerFeeAsc        FeeOrderByInput = "bidTakerFee_ASC"
	FeeOrderByInputBidTakerFeeDesc       FeeOrderByInput = "bidTakerFee_DESC"
	FeeOrderByInputBidMakerFeeAsc        FeeOrderByInput = "bidMakerFee_ASC"
	FeeOrderByInputBidMakerFeeDesc       FeeOrderByInput = "bidMakerFee_DESC"
	FeeOrderByInputMyCoinAskTakerFeeAsc  FeeOrderByInput = "myCoinAskTakerFee_ASC"
	FeeOrderByInputMyCoinAskTakerFeeDesc FeeOrderByInput = "myCoinAskTakerFee_DESC"
	FeeOrderByInputMyCoinAskMakerFeeAsc  FeeOrderByInput = "myCoinAskMakerFee_ASC"
	FeeOrderByInputMyCoinAskMakerFeeDesc FeeOrderByInput = "myCoinAskMakerFee_DESC"
	FeeOrderByInputMyCoinBidTakerFeeAsc  FeeOrderByInput = "myCoinBidTakerFee_ASC"
	FeeOrderByInputMyCoinBidTakerFeeDesc FeeOrderByInput = "myCoinBidTakerFee_DESC"
	FeeOrderByInputMyCoinBidMakerFeeAsc  FeeOrderByInput = "myCoinBidMakerFee_ASC"
	FeeOrderByInputMyCoinBidMakerFeeDesc FeeOrderByInput = "myCoinBidMakerFee_DESC"
	FeeOrderByInputCreatedAtAsc          FeeOrderByInput = "createdAt_ASC"
	FeeOrderByInputCreatedAtDesc         FeeOrderByInput = "createdAt_DESC"
	FeeOrderByInputUpdatedAtAsc          FeeOrderByInput = "updatedAt_ASC"
	FeeOrderByInputUpdatedAtDesc         FeeOrderByInput = "updatedAt_DESC"
)

type InviteUserHistoryOrderByInput string

const (
	InviteUserHistoryOrderByInputIDAsc         InviteUserHistoryOrderByInput = "id_ASC"
	InviteUserHistoryOrderByInputIDDesc        InviteUserHistoryOrderByInput = "id_DESC"
	InviteUserHistoryOrderByInputCreatedAtAsc  InviteUserHistoryOrderByInput = "createdAt_ASC"
	InviteUserHistoryOrderByInputCreatedAtDesc InviteUserHistoryOrderByInput = "createdAt_DESC"
	InviteUserHistoryOrderByInputUpdatedAtAsc  InviteUserHistoryOrderByInput = "updatedAt_ASC"
	InviteUserHistoryOrderByInputUpdatedAtDesc InviteUserHistoryOrderByInput = "updatedAt_DESC"
)

type PageBadgeOrderByInput string

const (
	PageBadgeOrderByInputIDAsc         PageBadgeOrderByInput = "id_ASC"
	PageBadgeOrderByInputIDDesc        PageBadgeOrderByInput = "id_DESC"
	PageBadgeOrderByInputVoteAsc       PageBadgeOrderByInput = "vote_ASC"
	PageBadgeOrderByInputVoteDesc      PageBadgeOrderByInput = "vote_DESC"
	PageBadgeOrderByInputCreatedAtAsc  PageBadgeOrderByInput = "createdAt_ASC"
	PageBadgeOrderByInputCreatedAtDesc PageBadgeOrderByInput = "createdAt_DESC"
	PageBadgeOrderByInputUpdatedAtAsc  PageBadgeOrderByInput = "updatedAt_ASC"
	PageBadgeOrderByInputUpdatedAtDesc PageBadgeOrderByInput = "updatedAt_DESC"
)

type BadgeVoterOrderByInput string

const (
	BadgeVoterOrderByInputIDAsc         BadgeVoterOrderByInput = "id_ASC"
	BadgeVoterOrderByInputIDDesc        BadgeVoterOrderByInput = "id_DESC"
	BadgeVoterOrderByInputIpAsc         BadgeVoterOrderByInput = "ip_ASC"
	BadgeVoterOrderByInputIpDesc        BadgeVoterOrderByInput = "ip_DESC"
	BadgeVoterOrderByInputCreatedAtAsc  BadgeVoterOrderByInput = "createdAt_ASC"
	BadgeVoterOrderByInputCreatedAtDesc BadgeVoterOrderByInput = "createdAt_DESC"
	BadgeVoterOrderByInputUpdatedAtAsc  BadgeVoterOrderByInput = "updatedAt_ASC"
	BadgeVoterOrderByInputUpdatedAtDesc BadgeVoterOrderByInput = "updatedAt_DESC"
)

type ReviewContentCategoryOrderByInput string

const (
	ReviewContentCategoryOrderByInputIDAsc         ReviewContentCategoryOrderByInput = "id_ASC"
	ReviewContentCategoryOrderByInputIDDesc        ReviewContentCategoryOrderByInput = "id_DESC"
	ReviewContentCategoryOrderByInputNameAsc       ReviewContentCategoryOrderByInput = "name_ASC"
	ReviewContentCategoryOrderByInputNameDesc      ReviewContentCategoryOrderByInput = "name_DESC"
	ReviewContentCategoryOrderByInputImageUrlAsc   ReviewContentCategoryOrderByInput = "imageUrl_ASC"
	ReviewContentCategoryOrderByInputImageUrlDesc  ReviewContentCategoryOrderByInput = "imageUrl_DESC"
	ReviewContentCategoryOrderByInputCreatedAtAsc  ReviewContentCategoryOrderByInput = "createdAt_ASC"
	ReviewContentCategoryOrderByInputCreatedAtDesc ReviewContentCategoryOrderByInput = "createdAt_DESC"
	ReviewContentCategoryOrderByInputUpdatedAtAsc  ReviewContentCategoryOrderByInput = "updatedAt_ASC"
	ReviewContentCategoryOrderByInputUpdatedAtDesc ReviewContentCategoryOrderByInput = "updatedAt_DESC"
)

type ReviewContentPageViewerOrderByInput string

const (
	ReviewContentPageViewerOrderByInputIDAsc         ReviewContentPageViewerOrderByInput = "id_ASC"
	ReviewContentPageViewerOrderByInputIDDesc        ReviewContentPageViewerOrderByInput = "id_DESC"
	ReviewContentPageViewerOrderByInputIpAsc         ReviewContentPageViewerOrderByInput = "ip_ASC"
	ReviewContentPageViewerOrderByInputIpDesc        ReviewContentPageViewerOrderByInput = "ip_DESC"
	ReviewContentPageViewerOrderByInputCreatedAtAsc  ReviewContentPageViewerOrderByInput = "createdAt_ASC"
	ReviewContentPageViewerOrderByInputCreatedAtDesc ReviewContentPageViewerOrderByInput = "createdAt_DESC"
	ReviewContentPageViewerOrderByInputUpdatedAtAsc  ReviewContentPageViewerOrderByInput = "updatedAt_ASC"
	ReviewContentPageViewerOrderByInputUpdatedAtDesc ReviewContentPageViewerOrderByInput = "updatedAt_DESC"
)

type ReviewContentOrderByInput string

const (
	ReviewContentOrderByInputIDAsc               ReviewContentOrderByInput = "id_ASC"
	ReviewContentOrderByInputIDDesc              ReviewContentOrderByInput = "id_DESC"
	ReviewContentOrderByInputPreviewImageUrlAsc  ReviewContentOrderByInput = "previewImageUrl_ASC"
	ReviewContentOrderByInputPreviewImageUrlDesc ReviewContentOrderByInput = "previewImageUrl_DESC"
	ReviewContentOrderByInputTitleAsc            ReviewContentOrderByInput = "title_ASC"
	ReviewContentOrderByInputTitleDesc           ReviewContentOrderByInput = "title_DESC"
	ReviewContentOrderByInputTypeAsc             ReviewContentOrderByInput = "type_ASC"
	ReviewContentOrderByInputTypeDesc            ReviewContentOrderByInput = "type_DESC"
	ReviewContentOrderByInputUrlAsc              ReviewContentOrderByInput = "url_ASC"
	ReviewContentOrderByInputUrlDesc             ReviewContentOrderByInput = "url_DESC"
	ReviewContentOrderByInputReviewAsc           ReviewContentOrderByInput = "review_ASC"
	ReviewContentOrderByInputReviewDesc          ReviewContentOrderByInput = "review_DESC"
	ReviewContentOrderByInputVideoIdAsc          ReviewContentOrderByInput = "videoId_ASC"
	ReviewContentOrderByInputVideoIdDesc         ReviewContentOrderByInput = "videoId_DESC"
	ReviewContentOrderByInputContentIdAsc        ReviewContentOrderByInput = "contentId_ASC"
	ReviewContentOrderByInputContentIdDesc       ReviewContentOrderByInput = "contentId_DESC"
	ReviewContentOrderByInputCreatedAtAsc        ReviewContentOrderByInput = "createdAt_ASC"
	ReviewContentOrderByInputCreatedAtDesc       ReviewContentOrderByInput = "createdAt_DESC"
	ReviewContentOrderByInputUpdatedAtAsc        ReviewContentOrderByInput = "updatedAt_ASC"
	ReviewContentOrderByInputUpdatedAtDesc       ReviewContentOrderByInput = "updatedAt_DESC"
)

type PageCommentOrderByInput string

const (
	PageCommentOrderByInputIDAsc                 PageCommentOrderByInput = "id_ASC"
	PageCommentOrderByInputIDDesc                PageCommentOrderByInput = "id_DESC"
	PageCommentOrderByInputContentAsc            PageCommentOrderByInput = "content_ASC"
	PageCommentOrderByInputContentDesc           PageCommentOrderByInput = "content_DESC"
	PageCommentOrderByInputIpAddressAsc          PageCommentOrderByInput = "ipAddress_ASC"
	PageCommentOrderByInputIpAddressDesc         PageCommentOrderByInput = "ipAddress_DESC"
	PageCommentOrderByInputImageUrlAsc           PageCommentOrderByInput = "imageUrl_ASC"
	PageCommentOrderByInputImageUrlDesc          PageCommentOrderByInput = "imageUrl_DESC"
	PageCommentOrderByInputThumbnailImageUrlAsc  PageCommentOrderByInput = "thumbnailImageUrl_ASC"
	PageCommentOrderByInputThumbnailImageUrlDesc PageCommentOrderByInput = "thumbnailImageUrl_DESC"
	PageCommentOrderByInputCreatedAtAsc          PageCommentOrderByInput = "createdAt_ASC"
	PageCommentOrderByInputCreatedAtDesc         PageCommentOrderByInput = "createdAt_DESC"
	PageCommentOrderByInputUpdatedAtAsc          PageCommentOrderByInput = "updatedAt_ASC"
	PageCommentOrderByInputUpdatedAtDesc         PageCommentOrderByInput = "updatedAt_DESC"
	PageCommentOrderByInputIsDelAsc              PageCommentOrderByInput = "isDel_ASC"
	PageCommentOrderByInputIsDelDesc             PageCommentOrderByInput = "isDel_DESC"
)

type PageCommentReplyOrderByInput string

const (
	PageCommentReplyOrderByInputIDAsc                 PageCommentReplyOrderByInput = "id_ASC"
	PageCommentReplyOrderByInputIDDesc                PageCommentReplyOrderByInput = "id_DESC"
	PageCommentReplyOrderByInputContentAsc            PageCommentReplyOrderByInput = "content_ASC"
	PageCommentReplyOrderByInputContentDesc           PageCommentReplyOrderByInput = "content_DESC"
	PageCommentReplyOrderByInputIpAddressAsc          PageCommentReplyOrderByInput = "ipAddress_ASC"
	PageCommentReplyOrderByInputIpAddressDesc         PageCommentReplyOrderByInput = "ipAddress_DESC"
	PageCommentReplyOrderByInputImageUrlAsc           PageCommentReplyOrderByInput = "imageUrl_ASC"
	PageCommentReplyOrderByInputImageUrlDesc          PageCommentReplyOrderByInput = "imageUrl_DESC"
	PageCommentReplyOrderByInputThumbnailImageUrlAsc  PageCommentReplyOrderByInput = "thumbnailImageUrl_ASC"
	PageCommentReplyOrderByInputThumbnailImageUrlDesc PageCommentReplyOrderByInput = "thumbnailImageUrl_DESC"
	PageCommentReplyOrderByInputCreatedAtAsc          PageCommentReplyOrderByInput = "createdAt_ASC"
	PageCommentReplyOrderByInputCreatedAtDesc         PageCommentReplyOrderByInput = "createdAt_DESC"
	PageCommentReplyOrderByInputUpdatedAtAsc          PageCommentReplyOrderByInput = "updatedAt_ASC"
	PageCommentReplyOrderByInputUpdatedAtDesc         PageCommentReplyOrderByInput = "updatedAt_DESC"
	PageCommentReplyOrderByInputIsDelAsc              PageCommentReplyOrderByInput = "isDel_ASC"
	PageCommentReplyOrderByInputIsDelDesc             PageCommentReplyOrderByInput = "isDel_DESC"
)

type ReviewContentPageFeedBackOrderByInput string

const (
	ReviewContentPageFeedBackOrderByInputIDAsc         ReviewContentPageFeedBackOrderByInput = "id_ASC"
	ReviewContentPageFeedBackOrderByInputIDDesc        ReviewContentPageFeedBackOrderByInput = "id_DESC"
	ReviewContentPageFeedBackOrderByInputIsLikeAsc     ReviewContentPageFeedBackOrderByInput = "isLike_ASC"
	ReviewContentPageFeedBackOrderByInputIsLikeDesc    ReviewContentPageFeedBackOrderByInput = "isLike_DESC"
	ReviewContentPageFeedBackOrderByInputMessageAsc    ReviewContentPageFeedBackOrderByInput = "message_ASC"
	ReviewContentPageFeedBackOrderByInputMessageDesc   ReviewContentPageFeedBackOrderByInput = "message_DESC"
	ReviewContentPageFeedBackOrderByInputIpAddressAsc  ReviewContentPageFeedBackOrderByInput = "ipAddress_ASC"
	ReviewContentPageFeedBackOrderByInputIpAddressDesc ReviewContentPageFeedBackOrderByInput = "ipAddress_DESC"
	ReviewContentPageFeedBackOrderByInputCreatedAtAsc  ReviewContentPageFeedBackOrderByInput = "createdAt_ASC"
	ReviewContentPageFeedBackOrderByInputCreatedAtDesc ReviewContentPageFeedBackOrderByInput = "createdAt_DESC"
	ReviewContentPageFeedBackOrderByInputUpdatedAtAsc  ReviewContentPageFeedBackOrderByInput = "updatedAt_ASC"
	ReviewContentPageFeedBackOrderByInputUpdatedAtDesc ReviewContentPageFeedBackOrderByInput = "updatedAt_DESC"
)

type ReviewContentViewerOrderByInput string

const (
	ReviewContentViewerOrderByInputIDAsc         ReviewContentViewerOrderByInput = "id_ASC"
	ReviewContentViewerOrderByInputIDDesc        ReviewContentViewerOrderByInput = "id_DESC"
	ReviewContentViewerOrderByInputIpAsc         ReviewContentViewerOrderByInput = "ip_ASC"
	ReviewContentViewerOrderByInputIpDesc        ReviewContentViewerOrderByInput = "ip_DESC"
	ReviewContentViewerOrderByInputCreatedAtAsc  ReviewContentViewerOrderByInput = "createdAt_ASC"
	ReviewContentViewerOrderByInputCreatedAtDesc ReviewContentViewerOrderByInput = "createdAt_DESC"
	ReviewContentViewerOrderByInputUpdatedAtAsc  ReviewContentViewerOrderByInput = "updatedAt_ASC"
	ReviewContentViewerOrderByInputUpdatedAtDesc ReviewContentViewerOrderByInput = "updatedAt_DESC"
)

type ReviewContentReviewerOrderByInput string

const (
	ReviewContentReviewerOrderByInputIDAsc         ReviewContentReviewerOrderByInput = "id_ASC"
	ReviewContentReviewerOrderByInputIDDesc        ReviewContentReviewerOrderByInput = "id_DESC"
	ReviewContentReviewerOrderByInputReviewAsc     ReviewContentReviewerOrderByInput = "review_ASC"
	ReviewContentReviewerOrderByInputReviewDesc    ReviewContentReviewerOrderByInput = "review_DESC"
	ReviewContentReviewerOrderByInputCreatedAtAsc  ReviewContentReviewerOrderByInput = "createdAt_ASC"
	ReviewContentReviewerOrderByInputCreatedAtDesc ReviewContentReviewerOrderByInput = "createdAt_DESC"
	ReviewContentReviewerOrderByInputUpdatedAtAsc  ReviewContentReviewerOrderByInput = "updatedAt_ASC"
	ReviewContentReviewerOrderByInputUpdatedAtDesc ReviewContentReviewerOrderByInput = "updatedAt_DESC"
)

type YoutubeDailyStatisticsOrderByInput string

const (
	YoutubeDailyStatisticsOrderByInputIDAsc               YoutubeDailyStatisticsOrderByInput = "id_ASC"
	YoutubeDailyStatisticsOrderByInputIDDesc              YoutubeDailyStatisticsOrderByInput = "id_DESC"
	YoutubeDailyStatisticsOrderByInputDateAsc             YoutubeDailyStatisticsOrderByInput = "date_ASC"
	YoutubeDailyStatisticsOrderByInputDateDesc            YoutubeDailyStatisticsOrderByInput = "date_DESC"
	YoutubeDailyStatisticsOrderByInputVideoCountAsc       YoutubeDailyStatisticsOrderByInput = "videoCount_ASC"
	YoutubeDailyStatisticsOrderByInputVideoCountDesc      YoutubeDailyStatisticsOrderByInput = "videoCount_DESC"
	YoutubeDailyStatisticsOrderByInputSubscriberCountAsc  YoutubeDailyStatisticsOrderByInput = "subscriberCount_ASC"
	YoutubeDailyStatisticsOrderByInputSubscriberCountDesc YoutubeDailyStatisticsOrderByInput = "subscriberCount_DESC"
	YoutubeDailyStatisticsOrderByInputVideoViewCountAsc   YoutubeDailyStatisticsOrderByInput = "videoViewCount_ASC"
	YoutubeDailyStatisticsOrderByInputVideoViewCountDesc  YoutubeDailyStatisticsOrderByInput = "videoViewCount_DESC"
	YoutubeDailyStatisticsOrderByInputCreatedAtAsc        YoutubeDailyStatisticsOrderByInput = "createdAt_ASC"
	YoutubeDailyStatisticsOrderByInputCreatedAtDesc       YoutubeDailyStatisticsOrderByInput = "createdAt_DESC"
	YoutubeDailyStatisticsOrderByInputUpdatedAtAsc        YoutubeDailyStatisticsOrderByInput = "updatedAt_ASC"
	YoutubeDailyStatisticsOrderByInputUpdatedAtDesc       YoutubeDailyStatisticsOrderByInput = "updatedAt_DESC"
)

type TwitchDailyStatisticsOrderByInput string

const (
	TwitchDailyStatisticsOrderByInputIDAsc                TwitchDailyStatisticsOrderByInput = "id_ASC"
	TwitchDailyStatisticsOrderByInputIDDesc               TwitchDailyStatisticsOrderByInput = "id_DESC"
	TwitchDailyStatisticsOrderByInputDateAsc              TwitchDailyStatisticsOrderByInput = "date_ASC"
	TwitchDailyStatisticsOrderByInputDateDesc             TwitchDailyStatisticsOrderByInput = "date_DESC"
	TwitchDailyStatisticsOrderByInputFollowerCountAsc     TwitchDailyStatisticsOrderByInput = "followerCount_ASC"
	TwitchDailyStatisticsOrderByInputFollowerCountDesc    TwitchDailyStatisticsOrderByInput = "followerCount_DESC"
	TwitchDailyStatisticsOrderByInputFollowingCountAsc    TwitchDailyStatisticsOrderByInput = "followingCount_ASC"
	TwitchDailyStatisticsOrderByInputFollowingCountDesc   TwitchDailyStatisticsOrderByInput = "followingCount_DESC"
	TwitchDailyStatisticsOrderByInputChannelViewCountAsc  TwitchDailyStatisticsOrderByInput = "channelViewCount_ASC"
	TwitchDailyStatisticsOrderByInputChannelViewCountDesc TwitchDailyStatisticsOrderByInput = "channelViewCount_DESC"
	TwitchDailyStatisticsOrderByInputCreatedAtAsc         TwitchDailyStatisticsOrderByInput = "createdAt_ASC"
	TwitchDailyStatisticsOrderByInputCreatedAtDesc        TwitchDailyStatisticsOrderByInput = "createdAt_DESC"
	TwitchDailyStatisticsOrderByInputUpdatedAtAsc         TwitchDailyStatisticsOrderByInput = "updatedAt_ASC"
	TwitchDailyStatisticsOrderByInputUpdatedAtDesc        TwitchDailyStatisticsOrderByInput = "updatedAt_DESC"
)

type InstagramDailyStatisticsOrderByInput string

const (
	InstagramDailyStatisticsOrderByInputIDAsc              InstagramDailyStatisticsOrderByInput = "id_ASC"
	InstagramDailyStatisticsOrderByInputIDDesc             InstagramDailyStatisticsOrderByInput = "id_DESC"
	InstagramDailyStatisticsOrderByInputDateAsc            InstagramDailyStatisticsOrderByInput = "date_ASC"
	InstagramDailyStatisticsOrderByInputDateDesc           InstagramDailyStatisticsOrderByInput = "date_DESC"
	InstagramDailyStatisticsOrderByInputPostCountAsc       InstagramDailyStatisticsOrderByInput = "postCount_ASC"
	InstagramDailyStatisticsOrderByInputPostCountDesc      InstagramDailyStatisticsOrderByInput = "postCount_DESC"
	InstagramDailyStatisticsOrderByInputFollowerCountAsc   InstagramDailyStatisticsOrderByInput = "followerCount_ASC"
	InstagramDailyStatisticsOrderByInputFollowerCountDesc  InstagramDailyStatisticsOrderByInput = "followerCount_DESC"
	InstagramDailyStatisticsOrderByInputFollowingCountAsc  InstagramDailyStatisticsOrderByInput = "followingCount_ASC"
	InstagramDailyStatisticsOrderByInputFollowingCountDesc InstagramDailyStatisticsOrderByInput = "followingCount_DESC"
	InstagramDailyStatisticsOrderByInputCreatedAtAsc       InstagramDailyStatisticsOrderByInput = "createdAt_ASC"
	InstagramDailyStatisticsOrderByInputCreatedAtDesc      InstagramDailyStatisticsOrderByInput = "createdAt_DESC"
	InstagramDailyStatisticsOrderByInputUpdatedAtAsc       InstagramDailyStatisticsOrderByInput = "updatedAt_ASC"
	InstagramDailyStatisticsOrderByInputUpdatedAtDesc      InstagramDailyStatisticsOrderByInput = "updatedAt_DESC"
)

type AfreecaTvDailyStatisticsOrderByInput string

const (
	AfreecaTvDailyStatisticsOrderByInputIDAsc             AfreecaTvDailyStatisticsOrderByInput = "id_ASC"
	AfreecaTvDailyStatisticsOrderByInputIDDesc            AfreecaTvDailyStatisticsOrderByInput = "id_DESC"
	AfreecaTvDailyStatisticsOrderByInputDateAsc           AfreecaTvDailyStatisticsOrderByInput = "date_ASC"
	AfreecaTvDailyStatisticsOrderByInputDateDesc          AfreecaTvDailyStatisticsOrderByInput = "date_DESC"
	AfreecaTvDailyStatisticsOrderByInputFollowerCountAsc  AfreecaTvDailyStatisticsOrderByInput = "followerCount_ASC"
	AfreecaTvDailyStatisticsOrderByInputFollowerCountDesc AfreecaTvDailyStatisticsOrderByInput = "followerCount_DESC"
	AfreecaTvDailyStatisticsOrderByInputViewCountAsc      AfreecaTvDailyStatisticsOrderByInput = "viewCount_ASC"
	AfreecaTvDailyStatisticsOrderByInputViewCountDesc     AfreecaTvDailyStatisticsOrderByInput = "viewCount_DESC"
	AfreecaTvDailyStatisticsOrderByInputVisitCountAsc     AfreecaTvDailyStatisticsOrderByInput = "visitCount_ASC"
	AfreecaTvDailyStatisticsOrderByInputVisitCountDesc    AfreecaTvDailyStatisticsOrderByInput = "visitCount_DESC"
	AfreecaTvDailyStatisticsOrderByInputFanCountAsc       AfreecaTvDailyStatisticsOrderByInput = "fanCount_ASC"
	AfreecaTvDailyStatisticsOrderByInputFanCountDesc      AfreecaTvDailyStatisticsOrderByInput = "fanCount_DESC"
	AfreecaTvDailyStatisticsOrderByInputCreatedAtAsc      AfreecaTvDailyStatisticsOrderByInput = "createdAt_ASC"
	AfreecaTvDailyStatisticsOrderByInputCreatedAtDesc     AfreecaTvDailyStatisticsOrderByInput = "createdAt_DESC"
	AfreecaTvDailyStatisticsOrderByInputUpdatedAtAsc      AfreecaTvDailyStatisticsOrderByInput = "updatedAt_ASC"
	AfreecaTvDailyStatisticsOrderByInputUpdatedAtDesc     AfreecaTvDailyStatisticsOrderByInput = "updatedAt_DESC"
)

type PageFanOrderByInput string

const (
	PageFanOrderByInputIDAsc         PageFanOrderByInput = "id_ASC"
	PageFanOrderByInputIDDesc        PageFanOrderByInput = "id_DESC"
	PageFanOrderByInputCreatedAtAsc  PageFanOrderByInput = "createdAt_ASC"
	PageFanOrderByInputCreatedAtDesc PageFanOrderByInput = "createdAt_DESC"
	PageFanOrderByInputUpdatedAtAsc  PageFanOrderByInput = "updatedAt_ASC"
	PageFanOrderByInputUpdatedAtDesc PageFanOrderByInput = "updatedAt_DESC"
)

type RequestPageItemOrderByInput string

const (
	RequestPageItemOrderByInputIDAsc         RequestPageItemOrderByInput = "id_ASC"
	RequestPageItemOrderByInputIDDesc        RequestPageItemOrderByInput = "id_DESC"
	RequestPageItemOrderByInputTypeAsc       RequestPageItemOrderByInput = "type_ASC"
	RequestPageItemOrderByInputTypeDesc      RequestPageItemOrderByInput = "type_DESC"
	RequestPageItemOrderByInputNoteAsc       RequestPageItemOrderByInput = "note_ASC"
	RequestPageItemOrderByInputNoteDesc      RequestPageItemOrderByInput = "note_DESC"
	RequestPageItemOrderByInputIpAddressAsc  RequestPageItemOrderByInput = "ipAddress_ASC"
	RequestPageItemOrderByInputIpAddressDesc RequestPageItemOrderByInput = "ipAddress_DESC"
	RequestPageItemOrderByInputCreatedAtAsc  RequestPageItemOrderByInput = "createdAt_ASC"
	RequestPageItemOrderByInputCreatedAtDesc RequestPageItemOrderByInput = "createdAt_DESC"
	RequestPageItemOrderByInputUpdatedAtAsc  RequestPageItemOrderByInput = "updatedAt_ASC"
	RequestPageItemOrderByInputUpdatedAtDesc RequestPageItemOrderByInput = "updatedAt_DESC"
)

type ReviewContentPageOrderByInput string

const (
	ReviewContentPageOrderByInputIDAsc          ReviewContentPageOrderByInput = "id_ASC"
	ReviewContentPageOrderByInputIDDesc         ReviewContentPageOrderByInput = "id_DESC"
	ReviewContentPageOrderByInputTitleAsc       ReviewContentPageOrderByInput = "title_ASC"
	ReviewContentPageOrderByInputTitleDesc      ReviewContentPageOrderByInput = "title_DESC"
	ReviewContentPageOrderByInputSubTitleAsc    ReviewContentPageOrderByInput = "subTitle_ASC"
	ReviewContentPageOrderByInputSubTitleDesc   ReviewContentPageOrderByInput = "subTitle_DESC"
	ReviewContentPageOrderByInputMessageAsc     ReviewContentPageOrderByInput = "message_ASC"
	ReviewContentPageOrderByInputMessageDesc    ReviewContentPageOrderByInput = "message_DESC"
	ReviewContentPageOrderByInputReleasedAtAsc  ReviewContentPageOrderByInput = "releasedAt_ASC"
	ReviewContentPageOrderByInputReleasedAtDesc ReviewContentPageOrderByInput = "releasedAt_DESC"
	ReviewContentPageOrderByInputIsDraftsAsc    ReviewContentPageOrderByInput = "isDrafts_ASC"
	ReviewContentPageOrderByInputIsDraftsDesc   ReviewContentPageOrderByInput = "isDrafts_DESC"
	ReviewContentPageOrderByInputIsDelAsc       ReviewContentPageOrderByInput = "isDel_ASC"
	ReviewContentPageOrderByInputIsDelDesc      ReviewContentPageOrderByInput = "isDel_DESC"
	ReviewContentPageOrderByInputCreatedAtAsc   ReviewContentPageOrderByInput = "createdAt_ASC"
	ReviewContentPageOrderByInputCreatedAtDesc  ReviewContentPageOrderByInput = "createdAt_DESC"
	ReviewContentPageOrderByInputUpdatedAtAsc   ReviewContentPageOrderByInput = "updatedAt_ASC"
	ReviewContentPageOrderByInputUpdatedAtDesc  ReviewContentPageOrderByInput = "updatedAt_DESC"
)

type AdminUserOrderByInput string

const (
	AdminUserOrderByInputIDAsc         AdminUserOrderByInput = "id_ASC"
	AdminUserOrderByInputIDDesc        AdminUserOrderByInput = "id_DESC"
	AdminUserOrderByInputRoleAsc       AdminUserOrderByInput = "role_ASC"
	AdminUserOrderByInputRoleDesc      AdminUserOrderByInput = "role_DESC"
	AdminUserOrderByInputEmailAsc      AdminUserOrderByInput = "email_ASC"
	AdminUserOrderByInputEmailDesc     AdminUserOrderByInput = "email_DESC"
	AdminUserOrderByInputPasswordAsc   AdminUserOrderByInput = "password_ASC"
	AdminUserOrderByInputPasswordDesc  AdminUserOrderByInput = "password_DESC"
	AdminUserOrderByInputNickNameAsc   AdminUserOrderByInput = "nickName_ASC"
	AdminUserOrderByInputNickNameDesc  AdminUserOrderByInput = "nickName_DESC"
	AdminUserOrderByInputOtpKeyAsc     AdminUserOrderByInput = "otpKey_ASC"
	AdminUserOrderByInputOtpKeyDesc    AdminUserOrderByInput = "otpKey_DESC"
	AdminUserOrderByInputLevelAsc      AdminUserOrderByInput = "level_ASC"
	AdminUserOrderByInputLevelDesc     AdminUserOrderByInput = "level_DESC"
	AdminUserOrderByInputCreatedAtAsc  AdminUserOrderByInput = "createdAt_ASC"
	AdminUserOrderByInputCreatedAtDesc AdminUserOrderByInput = "createdAt_DESC"
	AdminUserOrderByInputUpdatedAtAsc  AdminUserOrderByInput = "updatedAt_ASC"
	AdminUserOrderByInputUpdatedAtDesc AdminUserOrderByInput = "updatedAt_DESC"
)

type AergoAccountOrderByInput string

const (
	AergoAccountOrderByInputIDAsc               AergoAccountOrderByInput = "id_ASC"
	AergoAccountOrderByInputIDDesc              AergoAccountOrderByInput = "id_DESC"
	AergoAccountOrderByInputContractAddressAsc  AergoAccountOrderByInput = "contractAddress_ASC"
	AergoAccountOrderByInputContractAddressDesc AergoAccountOrderByInput = "contractAddress_DESC"
	AergoAccountOrderByInputAmountAsc           AergoAccountOrderByInput = "amount_ASC"
	AergoAccountOrderByInputAmountDesc          AergoAccountOrderByInput = "amount_DESC"
	AergoAccountOrderByInputLatestBlockAsc      AergoAccountOrderByInput = "latestBlock_ASC"
	AergoAccountOrderByInputLatestBlockDesc     AergoAccountOrderByInput = "latestBlock_DESC"
	AergoAccountOrderByInputCreatedAtAsc        AergoAccountOrderByInput = "createdAt_ASC"
	AergoAccountOrderByInputCreatedAtDesc       AergoAccountOrderByInput = "createdAt_DESC"
	AergoAccountOrderByInputUpdatedAtAsc        AergoAccountOrderByInput = "updatedAt_ASC"
	AergoAccountOrderByInputUpdatedAtDesc       AergoAccountOrderByInput = "updatedAt_DESC"
)

type AfreecaTvOrderByInput string

const (
	AfreecaTvOrderByInputIDAsc             AfreecaTvOrderByInput = "id_ASC"
	AfreecaTvOrderByInputIDDesc            AfreecaTvOrderByInput = "id_DESC"
	AfreecaTvOrderByInputStationNoAsc      AfreecaTvOrderByInput = "stationNo_ASC"
	AfreecaTvOrderByInputStationNoDesc     AfreecaTvOrderByInput = "stationNo_DESC"
	AfreecaTvOrderByInputStationNameAsc    AfreecaTvOrderByInput = "stationName_ASC"
	AfreecaTvOrderByInputStationNameDesc   AfreecaTvOrderByInput = "stationName_DESC"
	AfreecaTvOrderByInputStationTitleAsc   AfreecaTvOrderByInput = "stationTitle_ASC"
	AfreecaTvOrderByInputStationTitleDesc  AfreecaTvOrderByInput = "stationTitle_DESC"
	AfreecaTvOrderByInputUserIdAsc         AfreecaTvOrderByInput = "userId_ASC"
	AfreecaTvOrderByInputUserIdDesc        AfreecaTvOrderByInput = "userId_DESC"
	AfreecaTvOrderByInputUserNameAsc       AfreecaTvOrderByInput = "userName_ASC"
	AfreecaTvOrderByInputUserNameDesc      AfreecaTvOrderByInput = "userName_DESC"
	AfreecaTvOrderByInputAvatarUrlAsc      AfreecaTvOrderByInput = "avatarUrl_ASC"
	AfreecaTvOrderByInputAvatarUrlDesc     AfreecaTvOrderByInput = "avatarUrl_DESC"
	AfreecaTvOrderByInputDescriptionAsc    AfreecaTvOrderByInput = "description_ASC"
	AfreecaTvOrderByInputDescriptionDesc   AfreecaTvOrderByInput = "description_DESC"
	AfreecaTvOrderByInputPageUrlAsc        AfreecaTvOrderByInput = "pageUrl_ASC"
	AfreecaTvOrderByInputPageUrlDesc       AfreecaTvOrderByInput = "pageUrl_DESC"
	AfreecaTvOrderByInputFollowerCountAsc  AfreecaTvOrderByInput = "followerCount_ASC"
	AfreecaTvOrderByInputFollowerCountDesc AfreecaTvOrderByInput = "followerCount_DESC"
	AfreecaTvOrderByInputViewCountAsc      AfreecaTvOrderByInput = "viewCount_ASC"
	AfreecaTvOrderByInputViewCountDesc     AfreecaTvOrderByInput = "viewCount_DESC"
	AfreecaTvOrderByInputVisitCountAsc     AfreecaTvOrderByInput = "visitCount_ASC"
	AfreecaTvOrderByInputVisitCountDesc    AfreecaTvOrderByInput = "visitCount_DESC"
	AfreecaTvOrderByInputFanCountAsc       AfreecaTvOrderByInput = "fanCount_ASC"
	AfreecaTvOrderByInputFanCountDesc      AfreecaTvOrderByInput = "fanCount_DESC"
	AfreecaTvOrderByInputCreatedAtAsc      AfreecaTvOrderByInput = "createdAt_ASC"
	AfreecaTvOrderByInputCreatedAtDesc     AfreecaTvOrderByInput = "createdAt_DESC"
	AfreecaTvOrderByInputUpdatedAtAsc      AfreecaTvOrderByInput = "updatedAt_ASC"
	AfreecaTvOrderByInputUpdatedAtDesc     AfreecaTvOrderByInput = "updatedAt_DESC"
)

type AirDropOrderByInput string

const (
	AirDropOrderByInputIDAsc                 AirDropOrderByInput = "id_ASC"
	AirDropOrderByInputIDDesc                AirDropOrderByInput = "id_DESC"
	AirDropOrderByInputStatusAsc             AirDropOrderByInput = "status_ASC"
	AirDropOrderByInputStatusDesc            AirDropOrderByInput = "status_DESC"
	AirDropOrderByInputDeployTxhashAsc       AirDropOrderByInput = "deployTxhash_ASC"
	AirDropOrderByInputDeployTxhashDesc      AirDropOrderByInput = "deployTxhash_DESC"
	AirDropOrderByInputContractAddressAsc    AirDropOrderByInput = "contractAddress_ASC"
	AirDropOrderByInputContractAddressDesc   AirDropOrderByInput = "contractAddress_DESC"
	AirDropOrderByInputRandomArrayStringAsc  AirDropOrderByInput = "randomArrayString_ASC"
	AirDropOrderByInputRandomArrayStringDesc AirDropOrderByInput = "randomArrayString_DESC"
	AirDropOrderByInputAmountAsc             AirDropOrderByInput = "amount_ASC"
	AirDropOrderByInputAmountDesc            AirDropOrderByInput = "amount_DESC"
	AirDropOrderByInputLeftAsc               AirDropOrderByInput = "left_ASC"
	AirDropOrderByInputLeftDesc              AirDropOrderByInput = "left_DESC"
	AirDropOrderByInputToDateAsc             AirDropOrderByInput = "toDate_ASC"
	AirDropOrderByInputToDateDesc            AirDropOrderByInput = "toDate_DESC"
	AirDropOrderByInputCreatedAtAsc          AirDropOrderByInput = "createdAt_ASC"
	AirDropOrderByInputCreatedAtDesc         AirDropOrderByInput = "createdAt_DESC"
	AirDropOrderByInputUpdatedAtAsc          AirDropOrderByInput = "updatedAt_ASC"
	AirDropOrderByInputUpdatedAtDesc         AirDropOrderByInput = "updatedAt_DESC"
	AirDropOrderByInputIsDelAsc              AirDropOrderByInput = "isDel_ASC"
	AirDropOrderByInputIsDelDesc             AirDropOrderByInput = "isDel_DESC"
)

type DeviceOrderByInput string

const (
	DeviceOrderByInputIDAsc    DeviceOrderByInput = "id_ASC"
	DeviceOrderByInputIDDesc   DeviceOrderByInput = "id_DESC"
	DeviceOrderByInputCodeAsc  DeviceOrderByInput = "code_ASC"
	DeviceOrderByInputCodeDesc DeviceOrderByInput = "code_DESC"
	DeviceOrderByInputNameAsc  DeviceOrderByInput = "name_ASC"
	DeviceOrderByInputNameDesc DeviceOrderByInput = "name_DESC"
)

type MaintenanceOrderByInput string

const (
	MaintenanceOrderByInputIDAsc         MaintenanceOrderByInput = "id_ASC"
	MaintenanceOrderByInputIDDesc        MaintenanceOrderByInput = "id_DESC"
	MaintenanceOrderByInputTypeAsc       MaintenanceOrderByInput = "type_ASC"
	MaintenanceOrderByInputTypeDesc      MaintenanceOrderByInput = "type_DESC"
	MaintenanceOrderByInputNoteAsc       MaintenanceOrderByInput = "note_ASC"
	MaintenanceOrderByInputNoteDesc      MaintenanceOrderByInput = "note_DESC"
	MaintenanceOrderByInputFromDateAsc   MaintenanceOrderByInput = "fromDate_ASC"
	MaintenanceOrderByInputFromDateDesc  MaintenanceOrderByInput = "fromDate_DESC"
	MaintenanceOrderByInputToDateAsc     MaintenanceOrderByInput = "toDate_ASC"
	MaintenanceOrderByInputToDateDesc    MaintenanceOrderByInput = "toDate_DESC"
	MaintenanceOrderByInputCreatedAtAsc  MaintenanceOrderByInput = "createdAt_ASC"
	MaintenanceOrderByInputCreatedAtDesc MaintenanceOrderByInput = "createdAt_DESC"
	MaintenanceOrderByInputUpdatedAtAsc  MaintenanceOrderByInput = "updatedAt_ASC"
	MaintenanceOrderByInputUpdatedAtDesc MaintenanceOrderByInput = "updatedAt_DESC"
	MaintenanceOrderByInputIsDelAsc      MaintenanceOrderByInput = "isDel_ASC"
	MaintenanceOrderByInputIsDelDesc     MaintenanceOrderByInput = "isDel_DESC"
)

type AppVersionOrderByInput string

const (
	AppVersionOrderByInputIDAsc          AppVersionOrderByInput = "id_ASC"
	AppVersionOrderByInputIDDesc         AppVersionOrderByInput = "id_DESC"
	AppVersionOrderByInputVersionAsc     AppVersionOrderByInput = "version_ASC"
	AppVersionOrderByInputVersionDesc    AppVersionOrderByInput = "version_DESC"
	AppVersionOrderByInputTypeAsc        AppVersionOrderByInput = "type_ASC"
	AppVersionOrderByInputTypeDesc       AppVersionOrderByInput = "type_DESC"
	AppVersionOrderByInputNoteAsc        AppVersionOrderByInput = "note_ASC"
	AppVersionOrderByInputNoteDesc       AppVersionOrderByInput = "note_DESC"
	AppVersionOrderByInputReleasedAtAsc  AppVersionOrderByInput = "releasedAt_ASC"
	AppVersionOrderByInputReleasedAtDesc AppVersionOrderByInput = "releasedAt_DESC"
	AppVersionOrderByInputCreatedAtAsc   AppVersionOrderByInput = "createdAt_ASC"
	AppVersionOrderByInputCreatedAtDesc  AppVersionOrderByInput = "createdAt_DESC"
	AppVersionOrderByInputUpdatedAtAsc   AppVersionOrderByInput = "updatedAt_ASC"
	AppVersionOrderByInputUpdatedAtDesc  AppVersionOrderByInput = "updatedAt_DESC"
	AppVersionOrderByInputIsDelAsc       AppVersionOrderByInput = "isDel_ASC"
	AppVersionOrderByInputIsDelDesc      AppVersionOrderByInput = "isDel_DESC"
)

type BadgeOrderByInput string

const (
	BadgeOrderByInputIDAsc           BadgeOrderByInput = "id_ASC"
	BadgeOrderByInputIDDesc          BadgeOrderByInput = "id_DESC"
	BadgeOrderByInputNameAsc         BadgeOrderByInput = "name_ASC"
	BadgeOrderByInputNameDesc        BadgeOrderByInput = "name_DESC"
	BadgeOrderByInputImageUrlAsc     BadgeOrderByInput = "imageUrl_ASC"
	BadgeOrderByInputImageUrlDesc    BadgeOrderByInput = "imageUrl_DESC"
	BadgeOrderByInputDescriptionAsc  BadgeOrderByInput = "description_ASC"
	BadgeOrderByInputDescriptionDesc BadgeOrderByInput = "description_DESC"
	BadgeOrderByInputOrderIndexAsc   BadgeOrderByInput = "orderIndex_ASC"
	BadgeOrderByInputOrderIndexDesc  BadgeOrderByInput = "orderIndex_DESC"
	BadgeOrderByInputCreatedAtAsc    BadgeOrderByInput = "createdAt_ASC"
	BadgeOrderByInputCreatedAtDesc   BadgeOrderByInput = "createdAt_DESC"
	BadgeOrderByInputUpdatedAtAsc    BadgeOrderByInput = "updatedAt_ASC"
	BadgeOrderByInputUpdatedAtDesc   BadgeOrderByInput = "updatedAt_DESC"
)

type BankOrderByInput string

const (
	BankOrderByInputIDAsc         BankOrderByInput = "id_ASC"
	BankOrderByInputIDDesc        BankOrderByInput = "id_DESC"
	BankOrderByInputCodeAsc       BankOrderByInput = "code_ASC"
	BankOrderByInputCodeDesc      BankOrderByInput = "code_DESC"
	BankOrderByInputNameAsc       BankOrderByInput = "name_ASC"
	BankOrderByInputNameDesc      BankOrderByInput = "name_DESC"
	BankOrderByInputCreatedAtAsc  BankOrderByInput = "createdAt_ASC"
	BankOrderByInputCreatedAtDesc BankOrderByInput = "createdAt_DESC"
	BankOrderByInputUpdatedAtAsc  BankOrderByInput = "updatedAt_ASC"
	BankOrderByInputUpdatedAtDesc BankOrderByInput = "updatedAt_DESC"
)

type BankAccountVerificationOrderByInput string

const (
	BankAccountVerificationOrderByInputIDAsc             BankAccountVerificationOrderByInput = "id_ASC"
	BankAccountVerificationOrderByInputIDDesc            BankAccountVerificationOrderByInput = "id_DESC"
	BankAccountVerificationOrderByInputHolderNameAsc     BankAccountVerificationOrderByInput = "holderName_ASC"
	BankAccountVerificationOrderByInputHolderNameDesc    BankAccountVerificationOrderByInput = "holderName_DESC"
	BankAccountVerificationOrderByInputAccountNumberAsc  BankAccountVerificationOrderByInput = "accountNumber_ASC"
	BankAccountVerificationOrderByInputAccountNumberDesc BankAccountVerificationOrderByInput = "accountNumber_DESC"
	BankAccountVerificationOrderByInputVerifyAtAsc       BankAccountVerificationOrderByInput = "verifyAt_ASC"
	BankAccountVerificationOrderByInputVerifyAtDesc      BankAccountVerificationOrderByInput = "verifyAt_DESC"
	BankAccountVerificationOrderByInputCreatedAtAsc      BankAccountVerificationOrderByInput = "createdAt_ASC"
	BankAccountVerificationOrderByInputCreatedAtDesc     BankAccountVerificationOrderByInput = "createdAt_DESC"
	BankAccountVerificationOrderByInputUpdatedAtAsc      BankAccountVerificationOrderByInput = "updatedAt_ASC"
	BankAccountVerificationOrderByInputUpdatedAtDesc     BankAccountVerificationOrderByInput = "updatedAt_DESC"
)

type BankAccountVerificationTransactionInfoOrderByInput string

const (
	BankAccountVerificationTransactionInfoOrderByInputIDAsc             BankAccountVerificationTransactionInfoOrderByInput = "id_ASC"
	BankAccountVerificationTransactionInfoOrderByInputIDDesc            BankAccountVerificationTransactionInfoOrderByInput = "id_DESC"
	BankAccountVerificationTransactionInfoOrderByInputTransactionDtAsc  BankAccountVerificationTransactionInfoOrderByInput = "transactionDt_ASC"
	BankAccountVerificationTransactionInfoOrderByInputTransactionDtDesc BankAccountVerificationTransactionInfoOrderByInput = "transactionDt_DESC"
	BankAccountVerificationTransactionInfoOrderByInputTransactionNoAsc  BankAccountVerificationTransactionInfoOrderByInput = "transactionNo_ASC"
	BankAccountVerificationTransactionInfoOrderByInputTransactionNoDesc BankAccountVerificationTransactionInfoOrderByInput = "transactionNo_DESC"
	BankAccountVerificationTransactionInfoOrderByInputExpireAtAsc       BankAccountVerificationTransactionInfoOrderByInput = "expireAt_ASC"
	BankAccountVerificationTransactionInfoOrderByInputExpireAtDesc      BankAccountVerificationTransactionInfoOrderByInput = "expireAt_DESC"
	BankAccountVerificationTransactionInfoOrderByInputCreatedAtAsc      BankAccountVerificationTransactionInfoOrderByInput = "createdAt_ASC"
	BankAccountVerificationTransactionInfoOrderByInputCreatedAtDesc     BankAccountVerificationTransactionInfoOrderByInput = "createdAt_DESC"
	BankAccountVerificationTransactionInfoOrderByInputUpdatedAtAsc      BankAccountVerificationTransactionInfoOrderByInput = "updatedAt_ASC"
	BankAccountVerificationTransactionInfoOrderByInputUpdatedAtDesc     BankAccountVerificationTransactionInfoOrderByInput = "updatedAt_DESC"
)

type BoardOrderByInput string

const (
	BoardOrderByInputIDAsc         BoardOrderByInput = "id_ASC"
	BoardOrderByInputIDDesc        BoardOrderByInput = "id_DESC"
	BoardOrderByInputTypeAsc       BoardOrderByInput = "type_ASC"
	BoardOrderByInputTypeDesc      BoardOrderByInput = "type_DESC"
	BoardOrderByInputTitleAsc      BoardOrderByInput = "title_ASC"
	BoardOrderByInputTitleDesc     BoardOrderByInput = "title_DESC"
	BoardOrderByInputContentAsc    BoardOrderByInput = "content_ASC"
	BoardOrderByInputContentDesc   BoardOrderByInput = "content_DESC"
	BoardOrderByInputCreatedAtAsc  BoardOrderByInput = "createdAt_ASC"
	BoardOrderByInputCreatedAtDesc BoardOrderByInput = "createdAt_DESC"
	BoardOrderByInputUpdatedAtAsc  BoardOrderByInput = "updatedAt_ASC"
	BoardOrderByInputUpdatedAtDesc BoardOrderByInput = "updatedAt_DESC"
	BoardOrderByInputIsDelAsc      BoardOrderByInput = "isDel_ASC"
	BoardOrderByInputIsDelDesc     BoardOrderByInput = "isDel_DESC"
)

type CoinPriceTableOrderByInput string

const (
	CoinPriceTableOrderByInputIDAsc         CoinPriceTableOrderByInput = "id_ASC"
	CoinPriceTableOrderByInputIDDesc        CoinPriceTableOrderByInput = "id_DESC"
	CoinPriceTableOrderByInputTypeAsc       CoinPriceTableOrderByInput = "type_ASC"
	CoinPriceTableOrderByInputTypeDesc      CoinPriceTableOrderByInput = "type_DESC"
	CoinPriceTableOrderByInputCreatedAtAsc  CoinPriceTableOrderByInput = "createdAt_ASC"
	CoinPriceTableOrderByInputCreatedAtDesc CoinPriceTableOrderByInput = "createdAt_DESC"
	CoinPriceTableOrderByInputUpdatedAtAsc  CoinPriceTableOrderByInput = "updatedAt_ASC"
	CoinPriceTableOrderByInputUpdatedAtDesc CoinPriceTableOrderByInput = "updatedAt_DESC"
)

type InstagramOrderByInput string

const (
	InstagramOrderByInputIDAsc              InstagramOrderByInput = "id_ASC"
	InstagramOrderByInputIDDesc             InstagramOrderByInput = "id_DESC"
	InstagramOrderByInputUserIdAsc          InstagramOrderByInput = "userId_ASC"
	InstagramOrderByInputUserIdDesc         InstagramOrderByInput = "userId_DESC"
	InstagramOrderByInputUserNoAsc          InstagramOrderByInput = "userNo_ASC"
	InstagramOrderByInputUserNoDesc         InstagramOrderByInput = "userNo_DESC"
	InstagramOrderByInputUserNameAsc        InstagramOrderByInput = "userName_ASC"
	InstagramOrderByInputUserNameDesc       InstagramOrderByInput = "userName_DESC"
	InstagramOrderByInputPostCountAsc       InstagramOrderByInput = "postCount_ASC"
	InstagramOrderByInputPostCountDesc      InstagramOrderByInput = "postCount_DESC"
	InstagramOrderByInputFollowerCountAsc   InstagramOrderByInput = "followerCount_ASC"
	InstagramOrderByInputFollowerCountDesc  InstagramOrderByInput = "followerCount_DESC"
	InstagramOrderByInputFollowingCountAsc  InstagramOrderByInput = "followingCount_ASC"
	InstagramOrderByInputFollowingCountDesc InstagramOrderByInput = "followingCount_DESC"
	InstagramOrderByInputAvatarUrlAsc       InstagramOrderByInput = "avatarUrl_ASC"
	InstagramOrderByInputAvatarUrlDesc      InstagramOrderByInput = "avatarUrl_DESC"
	InstagramOrderByInputDescriptionAsc     InstagramOrderByInput = "description_ASC"
	InstagramOrderByInputDescriptionDesc    InstagramOrderByInput = "description_DESC"
	InstagramOrderByInputPageUrlAsc         InstagramOrderByInput = "pageUrl_ASC"
	InstagramOrderByInputPageUrlDesc        InstagramOrderByInput = "pageUrl_DESC"
	InstagramOrderByInputCreatedAtAsc       InstagramOrderByInput = "createdAt_ASC"
	InstagramOrderByInputCreatedAtDesc      InstagramOrderByInput = "createdAt_DESC"
	InstagramOrderByInputUpdatedAtAsc       InstagramOrderByInput = "updatedAt_ASC"
	InstagramOrderByInputUpdatedAtDesc      InstagramOrderByInput = "updatedAt_DESC"
)

type InviteCodeOrderByInput string

const (
	InviteCodeOrderByInputIDAsc         InviteCodeOrderByInput = "id_ASC"
	InviteCodeOrderByInputIDDesc        InviteCodeOrderByInput = "id_DESC"
	InviteCodeOrderByInputNumIdAsc      InviteCodeOrderByInput = "numId_ASC"
	InviteCodeOrderByInputNumIdDesc     InviteCodeOrderByInput = "numId_DESC"
	InviteCodeOrderByInputCodeAsc       InviteCodeOrderByInput = "code_ASC"
	InviteCodeOrderByInputCodeDesc      InviteCodeOrderByInput = "code_DESC"
	InviteCodeOrderByInputCreatedAtAsc  InviteCodeOrderByInput = "createdAt_ASC"
	InviteCodeOrderByInputCreatedAtDesc InviteCodeOrderByInput = "createdAt_DESC"
	InviteCodeOrderByInputUpdatedAtAsc  InviteCodeOrderByInput = "updatedAt_ASC"
	InviteCodeOrderByInputUpdatedAtDesc InviteCodeOrderByInput = "updatedAt_DESC"
)

type NotificationOrderByInput string

const (
	NotificationOrderByInputIDAsc           NotificationOrderByInput = "id_ASC"
	NotificationOrderByInputIDDesc          NotificationOrderByInput = "id_DESC"
	NotificationOrderByInputNotiTypeAsc     NotificationOrderByInput = "notiType_ASC"
	NotificationOrderByInputNotiTypeDesc    NotificationOrderByInput = "notiType_DESC"
	NotificationOrderByInputPushTypeAsc     NotificationOrderByInput = "pushType_ASC"
	NotificationOrderByInputPushTypeDesc    NotificationOrderByInput = "pushType_DESC"
	NotificationOrderByInputPushStateAsc    NotificationOrderByInput = "pushState_ASC"
	NotificationOrderByInputPushStateDesc   NotificationOrderByInput = "pushState_DESC"
	NotificationOrderByInputTopicAsc        NotificationOrderByInput = "topic_ASC"
	NotificationOrderByInputTopicDesc       NotificationOrderByInput = "topic_DESC"
	NotificationOrderByInputLinkTypeAsc     NotificationOrderByInput = "linkType_ASC"
	NotificationOrderByInputLinkTypeDesc    NotificationOrderByInput = "linkType_DESC"
	NotificationOrderByInputLinkValueAsc    NotificationOrderByInput = "linkValue_ASC"
	NotificationOrderByInputLinkValueDesc   NotificationOrderByInput = "linkValue_DESC"
	NotificationOrderByInputMessageAsc      NotificationOrderByInput = "message_ASC"
	NotificationOrderByInputMessageDesc     NotificationOrderByInput = "message_DESC"
	NotificationOrderByInputImageAsc        NotificationOrderByInput = "image_ASC"
	NotificationOrderByInputImageDesc       NotificationOrderByInput = "image_DESC"
	NotificationOrderByInputPublishTypeAsc  NotificationOrderByInput = "publishType_ASC"
	NotificationOrderByInputPublishTypeDesc NotificationOrderByInput = "publishType_DESC"
	NotificationOrderByInputPublishDateAsc  NotificationOrderByInput = "publishDate_ASC"
	NotificationOrderByInputPublishDateDesc NotificationOrderByInput = "publishDate_DESC"
	NotificationOrderByInputCreatedAtAsc    NotificationOrderByInput = "createdAt_ASC"
	NotificationOrderByInputCreatedAtDesc   NotificationOrderByInput = "createdAt_DESC"
	NotificationOrderByInputUpdatedAtAsc    NotificationOrderByInput = "updatedAt_ASC"
	NotificationOrderByInputUpdatedAtDesc   NotificationOrderByInput = "updatedAt_DESC"
	NotificationOrderByInputIsDelAsc        NotificationOrderByInput = "isDel_ASC"
	NotificationOrderByInputIsDelDesc       NotificationOrderByInput = "isDel_DESC"
)

type OfferOrderByInput string

const (
	OfferOrderByInputIDAsc         OfferOrderByInput = "id_ASC"
	OfferOrderByInputIDDesc        OfferOrderByInput = "id_DESC"
	OfferOrderByInputQtyAsc        OfferOrderByInput = "qty_ASC"
	OfferOrderByInputQtyDesc       OfferOrderByInput = "qty_DESC"
	OfferOrderByInputFromDateAsc   OfferOrderByInput = "fromDate_ASC"
	OfferOrderByInputFromDateDesc  OfferOrderByInput = "fromDate_DESC"
	OfferOrderByInputToDateAsc     OfferOrderByInput = "toDate_ASC"
	OfferOrderByInputToDateDesc    OfferOrderByInput = "toDate_DESC"
	OfferOrderByInputCreatedAtAsc  OfferOrderByInput = "createdAt_ASC"
	OfferOrderByInputCreatedAtDesc OfferOrderByInput = "createdAt_DESC"
	OfferOrderByInputUpdatedAtAsc  OfferOrderByInput = "updatedAt_ASC"
	OfferOrderByInputUpdatedAtDesc OfferOrderByInput = "updatedAt_DESC"
)

type PageOrderByInput string

const (
	PageOrderByInputIDAsc           PageOrderByInput = "id_ASC"
	PageOrderByInputIDDesc          PageOrderByInput = "id_DESC"
	PageOrderByInputPageIdAsc       PageOrderByInput = "pageId_ASC"
	PageOrderByInputPageIdDesc      PageOrderByInput = "pageId_DESC"
	PageOrderByInputNickNameAsc     PageOrderByInput = "nickName_ASC"
	PageOrderByInputNickNameDesc    PageOrderByInput = "nickName_DESC"
	PageOrderByInputAvatarUrlAsc    PageOrderByInput = "avatarUrl_ASC"
	PageOrderByInputAvatarUrlDesc   PageOrderByInput = "avatarUrl_DESC"
	PageOrderByInputCoverUrlAsc     PageOrderByInput = "coverUrl_ASC"
	PageOrderByInputCoverUrlDesc    PageOrderByInput = "coverUrl_DESC"
	PageOrderByInputDescriptionAsc  PageOrderByInput = "description_ASC"
	PageOrderByInputDescriptionDesc PageOrderByInput = "description_DESC"
	PageOrderByInputCreatedAtAsc    PageOrderByInput = "createdAt_ASC"
	PageOrderByInputCreatedAtDesc   PageOrderByInput = "createdAt_DESC"
	PageOrderByInputUpdatedAtAsc    PageOrderByInput = "updatedAt_ASC"
	PageOrderByInputUpdatedAtDesc   PageOrderByInput = "updatedAt_DESC"
)

type PaymentHistoryOrderByInput string

const (
	PaymentHistoryOrderByInputIDAsc                PaymentHistoryOrderByInput = "id_ASC"
	PaymentHistoryOrderByInputIDDesc               PaymentHistoryOrderByInput = "id_DESC"
	PaymentHistoryOrderByInputCodeAsc              PaymentHistoryOrderByInput = "code_ASC"
	PaymentHistoryOrderByInputCodeDesc             PaymentHistoryOrderByInput = "code_DESC"
	PaymentHistoryOrderByInputMessageAsc           PaymentHistoryOrderByInput = "message_ASC"
	PaymentHistoryOrderByInputMessageDesc          PaymentHistoryOrderByInput = "message_DESC"
	PaymentHistoryOrderByInputOrderNoAsc           PaymentHistoryOrderByInput = "order_no_ASC"
	PaymentHistoryOrderByInputOrderNoDesc          PaymentHistoryOrderByInput = "order_no_DESC"
	PaymentHistoryOrderByInputServiceNameAsc       PaymentHistoryOrderByInput = "service_name_ASC"
	PaymentHistoryOrderByInputServiceNameDesc      PaymentHistoryOrderByInput = "service_name_DESC"
	PaymentHistoryOrderByInputProductNameAsc       PaymentHistoryOrderByInput = "product_name_ASC"
	PaymentHistoryOrderByInputProductNameDesc      PaymentHistoryOrderByInput = "product_name_DESC"
	PaymentHistoryOrderByInputCustomParameterAsc   PaymentHistoryOrderByInput = "custom_parameter_ASC"
	PaymentHistoryOrderByInputCustomParameterDesc  PaymentHistoryOrderByInput = "custom_parameter_DESC"
	PaymentHistoryOrderByInputTidAsc               PaymentHistoryOrderByInput = "tid_ASC"
	PaymentHistoryOrderByInputTidDesc              PaymentHistoryOrderByInput = "tid_DESC"
	PaymentHistoryOrderByInputCidAsc               PaymentHistoryOrderByInput = "cid_ASC"
	PaymentHistoryOrderByInputCidDesc              PaymentHistoryOrderByInput = "cid_DESC"
	PaymentHistoryOrderByInputAmountAsc            PaymentHistoryOrderByInput = "amount_ASC"
	PaymentHistoryOrderByInputAmountDesc           PaymentHistoryOrderByInput = "amount_DESC"
	PaymentHistoryOrderByInputAmountFeeAsc         PaymentHistoryOrderByInput = "amount_fee_ASC"
	PaymentHistoryOrderByInputAmountFeeDesc        PaymentHistoryOrderByInput = "amount_fee_DESC"
	PaymentHistoryOrderByInputAmountWithoutFeeAsc  PaymentHistoryOrderByInput = "amount_without_fee_ASC"
	PaymentHistoryOrderByInputAmountWithoutFeeDesc PaymentHistoryOrderByInput = "amount_without_fee_DESC"
	PaymentHistoryOrderByInputPgcodeAsc            PaymentHistoryOrderByInput = "pgcode_ASC"
	PaymentHistoryOrderByInputPgcodeDesc           PaymentHistoryOrderByInput = "pgcode_DESC"
	PaymentHistoryOrderByInputPayInfoAsc           PaymentHistoryOrderByInput = "pay_info_ASC"
	PaymentHistoryOrderByInputPayInfoDesc          PaymentHistoryOrderByInput = "pay_info_DESC"
	PaymentHistoryOrderByInputDomesticFlagAsc      PaymentHistoryOrderByInput = "domestic_flag_ASC"
	PaymentHistoryOrderByInputDomesticFlagDesc     PaymentHistoryOrderByInput = "domestic_flag_DESC"
	PaymentHistoryOrderByInputTransactionDateAsc   PaymentHistoryOrderByInput = "transaction_date_ASC"
	PaymentHistoryOrderByInputTransactionDateDesc  PaymentHistoryOrderByInput = "transaction_date_DESC"
	PaymentHistoryOrderByInputInstallMonthAsc      PaymentHistoryOrderByInput = "install_month_ASC"
	PaymentHistoryOrderByInputInstallMonthDesc     PaymentHistoryOrderByInput = "install_month_DESC"
	PaymentHistoryOrderByInputCardInfoAsc          PaymentHistoryOrderByInput = "card_info_ASC"
	PaymentHistoryOrderByInputCardInfoDesc         PaymentHistoryOrderByInput = "card_info_DESC"
	PaymentHistoryOrderByInputPayhashAsc           PaymentHistoryOrderByInput = "payhash_ASC"
	PaymentHistoryOrderByInputPayhashDesc          PaymentHistoryOrderByInput = "payhash_DESC"
	PaymentHistoryOrderByInputAccountNoAsc         PaymentHistoryOrderByInput = "account_no_ASC"
	PaymentHistoryOrderByInputAccountNoDesc        PaymentHistoryOrderByInput = "account_no_DESC"
	PaymentHistoryOrderByInputAccountNameAsc       PaymentHistoryOrderByInput = "account_name_ASC"
	PaymentHistoryOrderByInputAccountNameDesc      PaymentHistoryOrderByInput = "account_name_DESC"
	PaymentHistoryOrderByInputBankCodeAsc          PaymentHistoryOrderByInput = "bank_code_ASC"
	PaymentHistoryOrderByInputBankCodeDesc         PaymentHistoryOrderByInput = "bank_code_DESC"
	PaymentHistoryOrderByInputBankNameAsc          PaymentHistoryOrderByInput = "bank_name_ASC"
	PaymentHistoryOrderByInputBankNameDesc         PaymentHistoryOrderByInput = "bank_name_DESC"
	PaymentHistoryOrderByInputExpireDateAsc        PaymentHistoryOrderByInput = "expire_date_ASC"
	PaymentHistoryOrderByInputExpireDateDesc       PaymentHistoryOrderByInput = "expire_date_DESC"
	PaymentHistoryOrderByInputExpireTimeAsc        PaymentHistoryOrderByInput = "expire_time_ASC"
	PaymentHistoryOrderByInputExpireTimeDesc       PaymentHistoryOrderByInput = "expire_time_DESC"
	PaymentHistoryOrderByInputIssueTidAsc          PaymentHistoryOrderByInput = "issue_tid_ASC"
	PaymentHistoryOrderByInputIssueTidDesc         PaymentHistoryOrderByInput = "issue_tid_DESC"
	PaymentHistoryOrderByInputCreatedAtAsc         PaymentHistoryOrderByInput = "createdAt_ASC"
	PaymentHistoryOrderByInputCreatedAtDesc        PaymentHistoryOrderByInput = "createdAt_DESC"
)

type PhoneVerificationOrderByInput string

const (
	PhoneVerificationOrderByInputIDAsc           PhoneVerificationOrderByInput = "id_ASC"
	PhoneVerificationOrderByInputIDDesc          PhoneVerificationOrderByInput = "id_DESC"
	PhoneVerificationOrderByInputNameAsc         PhoneVerificationOrderByInput = "name_ASC"
	PhoneVerificationOrderByInputNameDesc        PhoneVerificationOrderByInput = "name_DESC"
	PhoneVerificationOrderByInputBirthAsc        PhoneVerificationOrderByInput = "birth_ASC"
	PhoneVerificationOrderByInputBirthDesc       PhoneVerificationOrderByInput = "birth_DESC"
	PhoneVerificationOrderByInputForeignerAsc    PhoneVerificationOrderByInput = "foreigner_ASC"
	PhoneVerificationOrderByInputForeignerDesc   PhoneVerificationOrderByInput = "foreigner_DESC"
	PhoneVerificationOrderByInputGenderAsc       PhoneVerificationOrderByInput = "gender_ASC"
	PhoneVerificationOrderByInputGenderDesc      PhoneVerificationOrderByInput = "gender_DESC"
	PhoneVerificationOrderByInputPhoneNumberAsc  PhoneVerificationOrderByInput = "phoneNumber_ASC"
	PhoneVerificationOrderByInputPhoneNumberDesc PhoneVerificationOrderByInput = "phoneNumber_DESC"
	PhoneVerificationOrderByInputCiAsc           PhoneVerificationOrderByInput = "CI_ASC"
	PhoneVerificationOrderByInputCiDesc          PhoneVerificationOrderByInput = "CI_DESC"
	PhoneVerificationOrderByInputDiAsc           PhoneVerificationOrderByInput = "DI_ASC"
	PhoneVerificationOrderByInputDiDesc          PhoneVerificationOrderByInput = "DI_DESC"
	PhoneVerificationOrderByInputImpUidAsc       PhoneVerificationOrderByInput = "imp_uid_ASC"
	PhoneVerificationOrderByInputImpUidDesc      PhoneVerificationOrderByInput = "imp_uid_DESC"
	PhoneVerificationOrderByInputMerchantUidAsc  PhoneVerificationOrderByInput = "merchant_uid_ASC"
	PhoneVerificationOrderByInputMerchantUidDesc PhoneVerificationOrderByInput = "merchant_uid_DESC"
	PhoneVerificationOrderByInputCreatedAtAsc    PhoneVerificationOrderByInput = "createdAt_ASC"
	PhoneVerificationOrderByInputCreatedAtDesc   PhoneVerificationOrderByInput = "createdAt_DESC"
	PhoneVerificationOrderByInputUpdatedAtAsc    PhoneVerificationOrderByInput = "updatedAt_ASC"
	PhoneVerificationOrderByInputUpdatedAtDesc   PhoneVerificationOrderByInput = "updatedAt_DESC"
)

type RewardDropEventOrderByInput string

const (
	RewardDropEventOrderByInputIDAsc              RewardDropEventOrderByInput = "id_ASC"
	RewardDropEventOrderByInputIDDesc             RewardDropEventOrderByInput = "id_DESC"
	RewardDropEventOrderByInputEventIdAsc         RewardDropEventOrderByInput = "eventID_ASC"
	RewardDropEventOrderByInputEventIdDesc        RewardDropEventOrderByInput = "eventID_DESC"
	RewardDropEventOrderByInputTypeAsc            RewardDropEventOrderByInput = "type_ASC"
	RewardDropEventOrderByInputTypeDesc           RewardDropEventOrderByInput = "type_DESC"
	RewardDropEventOrderByInputTitleAsc           RewardDropEventOrderByInput = "title_ASC"
	RewardDropEventOrderByInputTitleDesc          RewardDropEventOrderByInput = "title_DESC"
	RewardDropEventOrderByInputCashAsc            RewardDropEventOrderByInput = "cash_ASC"
	RewardDropEventOrderByInputCashDesc           RewardDropEventOrderByInput = "cash_DESC"
	RewardDropEventOrderByInputQtyAsc             RewardDropEventOrderByInput = "qty_ASC"
	RewardDropEventOrderByInputQtyDesc            RewardDropEventOrderByInput = "qty_DESC"
	RewardDropEventOrderByInputLimitUserCountAsc  RewardDropEventOrderByInput = "limitUserCount_ASC"
	RewardDropEventOrderByInputLimitUserCountDesc RewardDropEventOrderByInput = "limitUserCount_DESC"
	RewardDropEventOrderByInputFromDateAsc        RewardDropEventOrderByInput = "fromDate_ASC"
	RewardDropEventOrderByInputFromDateDesc       RewardDropEventOrderByInput = "fromDate_DESC"
	RewardDropEventOrderByInputToDateAsc          RewardDropEventOrderByInput = "toDate_ASC"
	RewardDropEventOrderByInputToDateDesc         RewardDropEventOrderByInput = "toDate_DESC"
	RewardDropEventOrderByInputIsDelAsc           RewardDropEventOrderByInput = "isDel_ASC"
	RewardDropEventOrderByInputIsDelDesc          RewardDropEventOrderByInput = "isDel_DESC"
	RewardDropEventOrderByInputCreatedAtAsc       RewardDropEventOrderByInput = "createdAt_ASC"
	RewardDropEventOrderByInputCreatedAtDesc      RewardDropEventOrderByInput = "createdAt_DESC"
)

type TwitchOrderByInput string

const (
	TwitchOrderByInputIDAsc                TwitchOrderByInput = "id_ASC"
	TwitchOrderByInputIDDesc               TwitchOrderByInput = "id_DESC"
	TwitchOrderByInputUserIdAsc            TwitchOrderByInput = "userId_ASC"
	TwitchOrderByInputUserIdDesc           TwitchOrderByInput = "userId_DESC"
	TwitchOrderByInputUserNoAsc            TwitchOrderByInput = "userNo_ASC"
	TwitchOrderByInputUserNoDesc           TwitchOrderByInput = "userNo_DESC"
	TwitchOrderByInputUserNameAsc          TwitchOrderByInput = "userName_ASC"
	TwitchOrderByInputUserNameDesc         TwitchOrderByInput = "userName_DESC"
	TwitchOrderByInputFollowerCountAsc     TwitchOrderByInput = "followerCount_ASC"
	TwitchOrderByInputFollowerCountDesc    TwitchOrderByInput = "followerCount_DESC"
	TwitchOrderByInputFollowingCountAsc    TwitchOrderByInput = "followingCount_ASC"
	TwitchOrderByInputFollowingCountDesc   TwitchOrderByInput = "followingCount_DESC"
	TwitchOrderByInputChannelTypeAsc       TwitchOrderByInput = "channelType_ASC"
	TwitchOrderByInputChannelTypeDesc      TwitchOrderByInput = "channelType_DESC"
	TwitchOrderByInputChannelViewCountAsc  TwitchOrderByInput = "channelViewCount_ASC"
	TwitchOrderByInputChannelViewCountDesc TwitchOrderByInput = "channelViewCount_DESC"
	TwitchOrderByInputAvatarUrlAsc         TwitchOrderByInput = "avatarUrl_ASC"
	TwitchOrderByInputAvatarUrlDesc        TwitchOrderByInput = "avatarUrl_DESC"
	TwitchOrderByInputCoverUrlAsc          TwitchOrderByInput = "coverUrl_ASC"
	TwitchOrderByInputCoverUrlDesc         TwitchOrderByInput = "coverUrl_DESC"
	TwitchOrderByInputDescriptionAsc       TwitchOrderByInput = "description_ASC"
	TwitchOrderByInputDescriptionDesc      TwitchOrderByInput = "description_DESC"
	TwitchOrderByInputPageUrlAsc           TwitchOrderByInput = "pageUrl_ASC"
	TwitchOrderByInputPageUrlDesc          TwitchOrderByInput = "pageUrl_DESC"
	TwitchOrderByInputCreatedAtAsc         TwitchOrderByInput = "createdAt_ASC"
	TwitchOrderByInputCreatedAtDesc        TwitchOrderByInput = "createdAt_DESC"
	TwitchOrderByInputUpdatedAtAsc         TwitchOrderByInput = "updatedAt_ASC"
	TwitchOrderByInputUpdatedAtDesc        TwitchOrderByInput = "updatedAt_DESC"
)

type VerificationOrderByInput string

const (
	VerificationOrderByInputIDAsc              VerificationOrderByInput = "id_ASC"
	VerificationOrderByInputIDDesc             VerificationOrderByInput = "id_DESC"
	VerificationOrderByInputLevelAsc           VerificationOrderByInput = "level_ASC"
	VerificationOrderByInputLevelDesc          VerificationOrderByInput = "level_DESC"
	VerificationOrderByInputHasEmailAsc        VerificationOrderByInput = "hasEmail_ASC"
	VerificationOrderByInputHasEmailDesc       VerificationOrderByInput = "hasEmail_DESC"
	VerificationOrderByInputHasPinAsc          VerificationOrderByInput = "hasPin_ASC"
	VerificationOrderByInputHasPinDesc         VerificationOrderByInput = "hasPin_DESC"
	VerificationOrderByInputHasPhoneAsc        VerificationOrderByInput = "hasPhone_ASC"
	VerificationOrderByInputHasPhoneDesc       VerificationOrderByInput = "hasPhone_DESC"
	VerificationOrderByInputHasBankAccountAsc  VerificationOrderByInput = "hasBankAccount_ASC"
	VerificationOrderByInputHasBankAccountDesc VerificationOrderByInput = "hasBankAccount_DESC"
	VerificationOrderByInputHasInterAsc        VerificationOrderByInput = "hasInter_ASC"
	VerificationOrderByInputHasInterDesc       VerificationOrderByInput = "hasInter_DESC"
	VerificationOrderByInputPinNumberAsc       VerificationOrderByInput = "pinNumber_ASC"
	VerificationOrderByInputPinNumberDesc      VerificationOrderByInput = "pinNumber_DESC"
	VerificationOrderByInputCreatedAtAsc       VerificationOrderByInput = "createdAt_ASC"
	VerificationOrderByInputCreatedAtDesc      VerificationOrderByInput = "createdAt_DESC"
	VerificationOrderByInputUpdatedAtAsc       VerificationOrderByInput = "updatedAt_ASC"
	VerificationOrderByInputUpdatedAtDesc      VerificationOrderByInput = "updatedAt_DESC"
)

type YoutubeOrderByInput string

const (
	YoutubeOrderByInputIDAsc               YoutubeOrderByInput = "id_ASC"
	YoutubeOrderByInputIDDesc              YoutubeOrderByInput = "id_DESC"
	YoutubeOrderByInputChannelIdAsc        YoutubeOrderByInput = "channelId_ASC"
	YoutubeOrderByInputChannelIdDesc       YoutubeOrderByInput = "channelId_DESC"
	YoutubeOrderByInputChannelTypeAsc      YoutubeOrderByInput = "channelType_ASC"
	YoutubeOrderByInputChannelTypeDesc     YoutubeOrderByInput = "channelType_DESC"
	YoutubeOrderByInputChannelNameAsc      YoutubeOrderByInput = "channelName_ASC"
	YoutubeOrderByInputChannelNameDesc     YoutubeOrderByInput = "channelName_DESC"
	YoutubeOrderByInputUserNameAsc         YoutubeOrderByInput = "userName_ASC"
	YoutubeOrderByInputUserNameDesc        YoutubeOrderByInput = "userName_DESC"
	YoutubeOrderByInputVideoCountAsc       YoutubeOrderByInput = "videoCount_ASC"
	YoutubeOrderByInputVideoCountDesc      YoutubeOrderByInput = "videoCount_DESC"
	YoutubeOrderByInputSubscriberCountAsc  YoutubeOrderByInput = "subscriberCount_ASC"
	YoutubeOrderByInputSubscriberCountDesc YoutubeOrderByInput = "subscriberCount_DESC"
	YoutubeOrderByInputVideoViewCountAsc   YoutubeOrderByInput = "videoViewCount_ASC"
	YoutubeOrderByInputVideoViewCountDesc  YoutubeOrderByInput = "videoViewCount_DESC"
	YoutubeOrderByInputThumbnailUrlAsc     YoutubeOrderByInput = "thumbnailUrl_ASC"
	YoutubeOrderByInputThumbnailUrlDesc    YoutubeOrderByInput = "thumbnailUrl_DESC"
	YoutubeOrderByInputBannerUrlAsc        YoutubeOrderByInput = "bannerUrl_ASC"
	YoutubeOrderByInputBannerUrlDesc       YoutubeOrderByInput = "bannerUrl_DESC"
	YoutubeOrderByInputDescriptionAsc      YoutubeOrderByInput = "description_ASC"
	YoutubeOrderByInputDescriptionDesc     YoutubeOrderByInput = "description_DESC"
	YoutubeOrderByInputPublishedAtAsc      YoutubeOrderByInput = "publishedAt_ASC"
	YoutubeOrderByInputPublishedAtDesc     YoutubeOrderByInput = "publishedAt_DESC"
	YoutubeOrderByInputCountryAsc          YoutubeOrderByInput = "country_ASC"
	YoutubeOrderByInputCountryDesc         YoutubeOrderByInput = "country_DESC"
	YoutubeOrderByInputPageUrlAsc          YoutubeOrderByInput = "pageUrl_ASC"
	YoutubeOrderByInputPageUrlDesc         YoutubeOrderByInput = "pageUrl_DESC"
	YoutubeOrderByInputCreatedAtAsc        YoutubeOrderByInput = "createdAt_ASC"
	YoutubeOrderByInputCreatedAtDesc       YoutubeOrderByInput = "createdAt_DESC"
	YoutubeOrderByInputUpdatedAtAsc        YoutubeOrderByInput = "updatedAt_ASC"
	YoutubeOrderByInputUpdatedAtDesc       YoutubeOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type AdminUserWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	Email    *string `json:"email,omitempty"`
	NickName *string `json:"nickName,omitempty"`
}

type UserWhereInput struct {
	ID                             *string                            `json:"id,omitempty"`
	IDNot                          *string                            `json:"id_not,omitempty"`
	IDIn                           []string                           `json:"id_in,omitempty"`
	IDNotIn                        []string                           `json:"id_not_in,omitempty"`
	IDLt                           *string                            `json:"id_lt,omitempty"`
	IDLte                          *string                            `json:"id_lte,omitempty"`
	IDGt                           *string                            `json:"id_gt,omitempty"`
	IDGte                          *string                            `json:"id_gte,omitempty"`
	IDContains                     *string                            `json:"id_contains,omitempty"`
	IDNotContains                  *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                            `json:"id_not_ends_with,omitempty"`
	Role                           *Role                              `json:"role,omitempty"`
	RoleNot                        *Role                              `json:"role_not,omitempty"`
	RoleIn                         []Role                             `json:"role_in,omitempty"`
	RoleNotIn                      []Role                             `json:"role_not_in,omitempty"`
	FirebaseUid                    *string                            `json:"firebaseUID,omitempty"`
	FirebaseUidNot                 *string                            `json:"firebaseUID_not,omitempty"`
	FirebaseUidIn                  []string                           `json:"firebaseUID_in,omitempty"`
	FirebaseUidNotIn               []string                           `json:"firebaseUID_not_in,omitempty"`
	FirebaseUidLt                  *string                            `json:"firebaseUID_lt,omitempty"`
	FirebaseUidLte                 *string                            `json:"firebaseUID_lte,omitempty"`
	FirebaseUidGt                  *string                            `json:"firebaseUID_gt,omitempty"`
	FirebaseUidGte                 *string                            `json:"firebaseUID_gte,omitempty"`
	FirebaseUidContains            *string                            `json:"firebaseUID_contains,omitempty"`
	FirebaseUidNotContains         *string                            `json:"firebaseUID_not_contains,omitempty"`
	FirebaseUidStartsWith          *string                            `json:"firebaseUID_starts_with,omitempty"`
	FirebaseUidNotStartsWith       *string                            `json:"firebaseUID_not_starts_with,omitempty"`
	FirebaseUidEndsWith            *string                            `json:"firebaseUID_ends_with,omitempty"`
	FirebaseUidNotEndsWith         *string                            `json:"firebaseUID_not_ends_with,omitempty"`
	Provider                       *string                            `json:"provider,omitempty"`
	ProviderNot                    *string                            `json:"provider_not,omitempty"`
	ProviderIn                     []string                           `json:"provider_in,omitempty"`
	ProviderNotIn                  []string                           `json:"provider_not_in,omitempty"`
	ProviderLt                     *string                            `json:"provider_lt,omitempty"`
	ProviderLte                    *string                            `json:"provider_lte,omitempty"`
	ProviderGt                     *string                            `json:"provider_gt,omitempty"`
	ProviderGte                    *string                            `json:"provider_gte,omitempty"`
	ProviderContains               *string                            `json:"provider_contains,omitempty"`
	ProviderNotContains            *string                            `json:"provider_not_contains,omitempty"`
	ProviderStartsWith             *string                            `json:"provider_starts_with,omitempty"`
	ProviderNotStartsWith          *string                            `json:"provider_not_starts_with,omitempty"`
	ProviderEndsWith               *string                            `json:"provider_ends_with,omitempty"`
	ProviderNotEndsWith            *string                            `json:"provider_not_ends_with,omitempty"`
	NickName                       *string                            `json:"nickName,omitempty"`
	NickNameNot                    *string                            `json:"nickName_not,omitempty"`
	NickNameIn                     []string                           `json:"nickName_in,omitempty"`
	NickNameNotIn                  []string                           `json:"nickName_not_in,omitempty"`
	NickNameLt                     *string                            `json:"nickName_lt,omitempty"`
	NickNameLte                    *string                            `json:"nickName_lte,omitempty"`
	NickNameGt                     *string                            `json:"nickName_gt,omitempty"`
	NickNameGte                    *string                            `json:"nickName_gte,omitempty"`
	NickNameContains               *string                            `json:"nickName_contains,omitempty"`
	NickNameNotContains            *string                            `json:"nickName_not_contains,omitempty"`
	NickNameStartsWith             *string                            `json:"nickName_starts_with,omitempty"`
	NickNameNotStartsWith          *string                            `json:"nickName_not_starts_with,omitempty"`
	NickNameEndsWith               *string                            `json:"nickName_ends_with,omitempty"`
	NickNameNotEndsWith            *string                            `json:"nickName_not_ends_with,omitempty"`
	Email                          *string                            `json:"email,omitempty"`
	EmailNot                       *string                            `json:"email_not,omitempty"`
	EmailIn                        []string                           `json:"email_in,omitempty"`
	EmailNotIn                     []string                           `json:"email_not_in,omitempty"`
	EmailLt                        *string                            `json:"email_lt,omitempty"`
	EmailLte                       *string                            `json:"email_lte,omitempty"`
	EmailGt                        *string                            `json:"email_gt,omitempty"`
	EmailGte                       *string                            `json:"email_gte,omitempty"`
	EmailContains                  *string                            `json:"email_contains,omitempty"`
	EmailNotContains               *string                            `json:"email_not_contains,omitempty"`
	EmailStartsWith                *string                            `json:"email_starts_with,omitempty"`
	EmailNotStartsWith             *string                            `json:"email_not_starts_with,omitempty"`
	EmailEndsWith                  *string                            `json:"email_ends_with,omitempty"`
	EmailNotEndsWith               *string                            `json:"email_not_ends_with,omitempty"`
	BackupEmail                    *string                            `json:"backupEmail,omitempty"`
	BackupEmailNot                 *string                            `json:"backupEmail_not,omitempty"`
	BackupEmailIn                  []string                           `json:"backupEmail_in,omitempty"`
	BackupEmailNotIn               []string                           `json:"backupEmail_not_in,omitempty"`
	BackupEmailLt                  *string                            `json:"backupEmail_lt,omitempty"`
	BackupEmailLte                 *string                            `json:"backupEmail_lte,omitempty"`
	BackupEmailGt                  *string                            `json:"backupEmail_gt,omitempty"`
	BackupEmailGte                 *string                            `json:"backupEmail_gte,omitempty"`
	BackupEmailContains            *string                            `json:"backupEmail_contains,omitempty"`
	BackupEmailNotContains         *string                            `json:"backupEmail_not_contains,omitempty"`
	BackupEmailStartsWith          *string                            `json:"backupEmail_starts_with,omitempty"`
	BackupEmailNotStartsWith       *string                            `json:"backupEmail_not_starts_with,omitempty"`
	BackupEmailEndsWith            *string                            `json:"backupEmail_ends_with,omitempty"`
	BackupEmailNotEndsWith         *string                            `json:"backupEmail_not_ends_with,omitempty"`
	DeviceId                       *string                            `json:"deviceId,omitempty"`
	DeviceIdNot                    *string                            `json:"deviceId_not,omitempty"`
	DeviceIdIn                     []string                           `json:"deviceId_in,omitempty"`
	DeviceIdNotIn                  []string                           `json:"deviceId_not_in,omitempty"`
	DeviceIdLt                     *string                            `json:"deviceId_lt,omitempty"`
	DeviceIdLte                    *string                            `json:"deviceId_lte,omitempty"`
	DeviceIdGt                     *string                            `json:"deviceId_gt,omitempty"`
	DeviceIdGte                    *string                            `json:"deviceId_gte,omitempty"`
	DeviceIdContains               *string                            `json:"deviceId_contains,omitempty"`
	DeviceIdNotContains            *string                            `json:"deviceId_not_contains,omitempty"`
	DeviceIdStartsWith             *string                            `json:"deviceId_starts_with,omitempty"`
	DeviceIdNotStartsWith          *string                            `json:"deviceId_not_starts_with,omitempty"`
	DeviceIdEndsWith               *string                            `json:"deviceId_ends_with,omitempty"`
	DeviceIdNotEndsWith            *string                            `json:"deviceId_not_ends_with,omitempty"`
	Platform                       *string                            `json:"platform,omitempty"`
	PlatformNot                    *string                            `json:"platform_not,omitempty"`
	PlatformIn                     []string                           `json:"platform_in,omitempty"`
	PlatformNotIn                  []string                           `json:"platform_not_in,omitempty"`
	PlatformLt                     *string                            `json:"platform_lt,omitempty"`
	PlatformLte                    *string                            `json:"platform_lte,omitempty"`
	PlatformGt                     *string                            `json:"platform_gt,omitempty"`
	PlatformGte                    *string                            `json:"platform_gte,omitempty"`
	PlatformContains               *string                            `json:"platform_contains,omitempty"`
	PlatformNotContains            *string                            `json:"platform_not_contains,omitempty"`
	PlatformStartsWith             *string                            `json:"platform_starts_with,omitempty"`
	PlatformNotStartsWith          *string                            `json:"platform_not_starts_with,omitempty"`
	PlatformEndsWith               *string                            `json:"platform_ends_with,omitempty"`
	PlatformNotEndsWith            *string                            `json:"platform_not_ends_with,omitempty"`
	FcmToken                       *string                            `json:"fcmToken,omitempty"`
	FcmTokenNot                    *string                            `json:"fcmToken_not,omitempty"`
	FcmTokenIn                     []string                           `json:"fcmToken_in,omitempty"`
	FcmTokenNotIn                  []string                           `json:"fcmToken_not_in,omitempty"`
	FcmTokenLt                     *string                            `json:"fcmToken_lt,omitempty"`
	FcmTokenLte                    *string                            `json:"fcmToken_lte,omitempty"`
	FcmTokenGt                     *string                            `json:"fcmToken_gt,omitempty"`
	FcmTokenGte                    *string                            `json:"fcmToken_gte,omitempty"`
	FcmTokenContains               *string                            `json:"fcmToken_contains,omitempty"`
	FcmTokenNotContains            *string                            `json:"fcmToken_not_contains,omitempty"`
	FcmTokenStartsWith             *string                            `json:"fcmToken_starts_with,omitempty"`
	FcmTokenNotStartsWith          *string                            `json:"fcmToken_not_starts_with,omitempty"`
	FcmTokenEndsWith               *string                            `json:"fcmToken_ends_with,omitempty"`
	FcmTokenNotEndsWith            *string                            `json:"fcmToken_not_ends_with,omitempty"`
	FeedCategoriesEvery            *CategoryWhereInput                `json:"feedCategories_every,omitempty"`
	FeedCategoriesSome             *CategoryWhereInput                `json:"feedCategories_some,omitempty"`
	FeedCategoriesNone             *CategoryWhereInput                `json:"feedCategories_none,omitempty"`
	LinkedFacebook                 *string                            `json:"linkedFacebook,omitempty"`
	LinkedFacebookNot              *string                            `json:"linkedFacebook_not,omitempty"`
	LinkedFacebookIn               []string                           `json:"linkedFacebook_in,omitempty"`
	LinkedFacebookNotIn            []string                           `json:"linkedFacebook_not_in,omitempty"`
	LinkedFacebookLt               *string                            `json:"linkedFacebook_lt,omitempty"`
	LinkedFacebookLte              *string                            `json:"linkedFacebook_lte,omitempty"`
	LinkedFacebookGt               *string                            `json:"linkedFacebook_gt,omitempty"`
	LinkedFacebookGte              *string                            `json:"linkedFacebook_gte,omitempty"`
	LinkedFacebookContains         *string                            `json:"linkedFacebook_contains,omitempty"`
	LinkedFacebookNotContains      *string                            `json:"linkedFacebook_not_contains,omitempty"`
	LinkedFacebookStartsWith       *string                            `json:"linkedFacebook_starts_with,omitempty"`
	LinkedFacebookNotStartsWith    *string                            `json:"linkedFacebook_not_starts_with,omitempty"`
	LinkedFacebookEndsWith         *string                            `json:"linkedFacebook_ends_with,omitempty"`
	LinkedFacebookNotEndsWith      *string                            `json:"linkedFacebook_not_ends_with,omitempty"`
	LinkedTwitter                  *string                            `json:"linkedTwitter,omitempty"`
	LinkedTwitterNot               *string                            `json:"linkedTwitter_not,omitempty"`
	LinkedTwitterIn                []string                           `json:"linkedTwitter_in,omitempty"`
	LinkedTwitterNotIn             []string                           `json:"linkedTwitter_not_in,omitempty"`
	LinkedTwitterLt                *string                            `json:"linkedTwitter_lt,omitempty"`
	LinkedTwitterLte               *string                            `json:"linkedTwitter_lte,omitempty"`
	LinkedTwitterGt                *string                            `json:"linkedTwitter_gt,omitempty"`
	LinkedTwitterGte               *string                            `json:"linkedTwitter_gte,omitempty"`
	LinkedTwitterContains          *string                            `json:"linkedTwitter_contains,omitempty"`
	LinkedTwitterNotContains       *string                            `json:"linkedTwitter_not_contains,omitempty"`
	LinkedTwitterStartsWith        *string                            `json:"linkedTwitter_starts_with,omitempty"`
	LinkedTwitterNotStartsWith     *string                            `json:"linkedTwitter_not_starts_with,omitempty"`
	LinkedTwitterEndsWith          *string                            `json:"linkedTwitter_ends_with,omitempty"`
	LinkedTwitterNotEndsWith       *string                            `json:"linkedTwitter_not_ends_with,omitempty"`
	LinkedInstagram                *string                            `json:"linkedInstagram,omitempty"`
	LinkedInstagramNot             *string                            `json:"linkedInstagram_not,omitempty"`
	LinkedInstagramIn              []string                           `json:"linkedInstagram_in,omitempty"`
	LinkedInstagramNotIn           []string                           `json:"linkedInstagram_not_in,omitempty"`
	LinkedInstagramLt              *string                            `json:"linkedInstagram_lt,omitempty"`
	LinkedInstagramLte             *string                            `json:"linkedInstagram_lte,omitempty"`
	LinkedInstagramGt              *string                            `json:"linkedInstagram_gt,omitempty"`
	LinkedInstagramGte             *string                            `json:"linkedInstagram_gte,omitempty"`
	LinkedInstagramContains        *string                            `json:"linkedInstagram_contains,omitempty"`
	LinkedInstagramNotContains     *string                            `json:"linkedInstagram_not_contains,omitempty"`
	LinkedInstagramStartsWith      *string                            `json:"linkedInstagram_starts_with,omitempty"`
	LinkedInstagramNotStartsWith   *string                            `json:"linkedInstagram_not_starts_with,omitempty"`
	LinkedInstagramEndsWith        *string                            `json:"linkedInstagram_ends_with,omitempty"`
	LinkedInstagramNotEndsWith     *string                            `json:"linkedInstagram_not_ends_with,omitempty"`
	LinkedYoutube                  *string                            `json:"linkedYoutube,omitempty"`
	LinkedYoutubeNot               *string                            `json:"linkedYoutube_not,omitempty"`
	LinkedYoutubeIn                []string                           `json:"linkedYoutube_in,omitempty"`
	LinkedYoutubeNotIn             []string                           `json:"linkedYoutube_not_in,omitempty"`
	LinkedYoutubeLt                *string                            `json:"linkedYoutube_lt,omitempty"`
	LinkedYoutubeLte               *string                            `json:"linkedYoutube_lte,omitempty"`
	LinkedYoutubeGt                *string                            `json:"linkedYoutube_gt,omitempty"`
	LinkedYoutubeGte               *string                            `json:"linkedYoutube_gte,omitempty"`
	LinkedYoutubeContains          *string                            `json:"linkedYoutube_contains,omitempty"`
	LinkedYoutubeNotContains       *string                            `json:"linkedYoutube_not_contains,omitempty"`
	LinkedYoutubeStartsWith        *string                            `json:"linkedYoutube_starts_with,omitempty"`
	LinkedYoutubeNotStartsWith     *string                            `json:"linkedYoutube_not_starts_with,omitempty"`
	LinkedYoutubeEndsWith          *string                            `json:"linkedYoutube_ends_with,omitempty"`
	LinkedYoutubeNotEndsWith       *string                            `json:"linkedYoutube_not_ends_with,omitempty"`
	LinkedTwitch                   *string                            `json:"linkedTwitch,omitempty"`
	LinkedTwitchNot                *string                            `json:"linkedTwitch_not,omitempty"`
	LinkedTwitchIn                 []string                           `json:"linkedTwitch_in,omitempty"`
	LinkedTwitchNotIn              []string                           `json:"linkedTwitch_not_in,omitempty"`
	LinkedTwitchLt                 *string                            `json:"linkedTwitch_lt,omitempty"`
	LinkedTwitchLte                *string                            `json:"linkedTwitch_lte,omitempty"`
	LinkedTwitchGt                 *string                            `json:"linkedTwitch_gt,omitempty"`
	LinkedTwitchGte                *string                            `json:"linkedTwitch_gte,omitempty"`
	LinkedTwitchContains           *string                            `json:"linkedTwitch_contains,omitempty"`
	LinkedTwitchNotContains        *string                            `json:"linkedTwitch_not_contains,omitempty"`
	LinkedTwitchStartsWith         *string                            `json:"linkedTwitch_starts_with,omitempty"`
	LinkedTwitchNotStartsWith      *string                            `json:"linkedTwitch_not_starts_with,omitempty"`
	LinkedTwitchEndsWith           *string                            `json:"linkedTwitch_ends_with,omitempty"`
	LinkedTwitchNotEndsWith        *string                            `json:"linkedTwitch_not_ends_with,omitempty"`
	ContentProvider                *string                            `json:"contentProvider,omitempty"`
	ContentProviderNot             *string                            `json:"contentProvider_not,omitempty"`
	ContentProviderIn              []string                           `json:"contentProvider_in,omitempty"`
	ContentProviderNotIn           []string                           `json:"contentProvider_not_in,omitempty"`
	ContentProviderLt              *string                            `json:"contentProvider_lt,omitempty"`
	ContentProviderLte             *string                            `json:"contentProvider_lte,omitempty"`
	ContentProviderGt              *string                            `json:"contentProvider_gt,omitempty"`
	ContentProviderGte             *string                            `json:"contentProvider_gte,omitempty"`
	ContentProviderContains        *string                            `json:"contentProvider_contains,omitempty"`
	ContentProviderNotContains     *string                            `json:"contentProvider_not_contains,omitempty"`
	ContentProviderStartsWith      *string                            `json:"contentProvider_starts_with,omitempty"`
	ContentProviderNotStartsWith   *string                            `json:"contentProvider_not_starts_with,omitempty"`
	ContentProviderEndsWith        *string                            `json:"contentProvider_ends_with,omitempty"`
	ContentProviderNotEndsWith     *string                            `json:"contentProvider_not_ends_with,omitempty"`
	ContentId                      *string                            `json:"contentId,omitempty"`
	ContentIdNot                   *string                            `json:"contentId_not,omitempty"`
	ContentIdIn                    []string                           `json:"contentId_in,omitempty"`
	ContentIdNotIn                 []string                           `json:"contentId_not_in,omitempty"`
	ContentIdLt                    *string                            `json:"contentId_lt,omitempty"`
	ContentIdLte                   *string                            `json:"contentId_lte,omitempty"`
	ContentIdGt                    *string                            `json:"contentId_gt,omitempty"`
	ContentIdGte                   *string                            `json:"contentId_gte,omitempty"`
	ContentIdContains              *string                            `json:"contentId_contains,omitempty"`
	ContentIdNotContains           *string                            `json:"contentId_not_contains,omitempty"`
	ContentIdStartsWith            *string                            `json:"contentId_starts_with,omitempty"`
	ContentIdNotStartsWith         *string                            `json:"contentId_not_starts_with,omitempty"`
	ContentIdEndsWith              *string                            `json:"contentId_ends_with,omitempty"`
	ContentIdNotEndsWith           *string                            `json:"contentId_not_ends_with,omitempty"`
	RevokeTokenKey                 *string                            `json:"revokeTokenKey,omitempty"`
	RevokeTokenKeyNot              *string                            `json:"revokeTokenKey_not,omitempty"`
	RevokeTokenKeyIn               []string                           `json:"revokeTokenKey_in,omitempty"`
	RevokeTokenKeyNotIn            []string                           `json:"revokeTokenKey_not_in,omitempty"`
	RevokeTokenKeyLt               *string                            `json:"revokeTokenKey_lt,omitempty"`
	RevokeTokenKeyLte              *string                            `json:"revokeTokenKey_lte,omitempty"`
	RevokeTokenKeyGt               *string                            `json:"revokeTokenKey_gt,omitempty"`
	RevokeTokenKeyGte              *string                            `json:"revokeTokenKey_gte,omitempty"`
	RevokeTokenKeyContains         *string                            `json:"revokeTokenKey_contains,omitempty"`
	RevokeTokenKeyNotContains      *string                            `json:"revokeTokenKey_not_contains,omitempty"`
	RevokeTokenKeyStartsWith       *string                            `json:"revokeTokenKey_starts_with,omitempty"`
	RevokeTokenKeyNotStartsWith    *string                            `json:"revokeTokenKey_not_starts_with,omitempty"`
	RevokeTokenKeyEndsWith         *string                            `json:"revokeTokenKey_ends_with,omitempty"`
	RevokeTokenKeyNotEndsWith      *string                            `json:"revokeTokenKey_not_ends_with,omitempty"`
	SubscribePushNotification      *bool                              `json:"subscribePushNotification,omitempty"`
	SubscribePushNotificationNot   *bool                              `json:"subscribePushNotification_not,omitempty"`
	SubscribeEmail                 *bool                              `json:"subscribeEmail,omitempty"`
	SubscribeEmailNot              *bool                              `json:"subscribeEmail_not,omitempty"`
	Coin                           *CoinWhereInput                    `json:"coin,omitempty"`
	Verification                   *VerificationWhereInput            `json:"verification,omitempty"`
	WalletsEvery                   *WalletWhereInput                  `json:"wallets_every,omitempty"`
	WalletsSome                    *WalletWhereInput                  `json:"wallets_some,omitempty"`
	WalletsNone                    *WalletWhereInput                  `json:"wallets_none,omitempty"`
	PostsEvery                     *PostWhereInput                    `json:"posts_every,omitempty"`
	PostsSome                      *PostWhereInput                    `json:"posts_some,omitempty"`
	PostsNone                      *PostWhereInput                    `json:"posts_none,omitempty"`
	RequestPostsEvery              *PostWhereInput                    `json:"requestPosts_every,omitempty"`
	RequestPostsSome               *PostWhereInput                    `json:"requestPosts_some,omitempty"`
	RequestPostsNone               *PostWhereInput                    `json:"requestPosts_none,omitempty"`
	CommentsEvery                  *CommentWhereInput                 `json:"comments_every,omitempty"`
	CommentsSome                   *CommentWhereInput                 `json:"comments_some,omitempty"`
	CommentsNone                   *CommentWhereInput                 `json:"comments_none,omitempty"`
	FilesEvery                     *FileWhereInput                    `json:"files_every,omitempty"`
	FilesSome                      *FileWhereInput                    `json:"files_some,omitempty"`
	FilesNone                      *FileWhereInput                    `json:"files_none,omitempty"`
	FileListEvery                  *FileInfoWhereInput                `json:"fileList_every,omitempty"`
	FileListSome                   *FileInfoWhereInput                `json:"fileList_some,omitempty"`
	FileListNone                   *FileInfoWhereInput                `json:"fileList_none,omitempty"`
	LikesEvery                     *PostWhereInput                    `json:"likes_every,omitempty"`
	LikesSome                      *PostWhereInput                    `json:"likes_some,omitempty"`
	LikesNone                      *PostWhereInput                    `json:"likes_none,omitempty"`
	ViewsEvery                     *PostWhereInput                    `json:"views_every,omitempty"`
	ViewsSome                      *PostWhereInput                    `json:"views_some,omitempty"`
	ViewsNone                      *PostWhereInput                    `json:"views_none,omitempty"`
	JoinOfferEvery                 *OfferorWhereInput                 `json:"joinOffer_every,omitempty"`
	JoinOfferSome                  *OfferorWhereInput                 `json:"joinOffer_some,omitempty"`
	JoinOfferNone                  *OfferorWhereInput                 `json:"joinOffer_none,omitempty"`
	MyReportEvery                  *ReportWhereInput                  `json:"myReport_every,omitempty"`
	MyReportSome                   *ReportWhereInput                  `json:"myReport_some,omitempty"`
	MyReportNone                   *ReportWhereInput                  `json:"myReport_none,omitempty"`
	TargetReportEvery              *ReportWhereInput                  `json:"targetReport_every,omitempty"`
	TargetReportSome               *ReportWhereInput                  `json:"targetReport_some,omitempty"`
	TargetReportNone               *ReportWhereInput                  `json:"targetReport_none,omitempty"`
	JoinedQuestsEvery              *QuestMemberWhereInput             `json:"joinedQuests_every,omitempty"`
	JoinedQuestsSome               *QuestMemberWhereInput             `json:"joinedQuests_some,omitempty"`
	JoinedQuestsNone               *QuestMemberWhereInput             `json:"joinedQuests_none,omitempty"`
	AdminUser                      *AdminUserWhereInput               `json:"adminUser,omitempty"`
	DeletedAt                      *string                            `json:"deletedAt,omitempty"`
	DeletedAtNot                   *string                            `json:"deletedAt_not,omitempty"`
	DeletedAtIn                    []string                           `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn                 []string                           `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt                    *string                            `json:"deletedAt_lt,omitempty"`
	DeletedAtLte                   *string                            `json:"deletedAt_lte,omitempty"`
	DeletedAtGt                    *string                            `json:"deletedAt_gt,omitempty"`
	DeletedAtGte                   *string                            `json:"deletedAt_gte,omitempty"`
	CreatedAt                      *string                            `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                            `json:"updatedAt_gte,omitempty"`
	Status                         *int32                             `json:"status,omitempty"`
	StatusNot                      *int32                             `json:"status_not,omitempty"`
	StatusIn                       []int32                            `json:"status_in,omitempty"`
	StatusNotIn                    []int32                            `json:"status_not_in,omitempty"`
	StatusLt                       *int32                             `json:"status_lt,omitempty"`
	StatusLte                      *int32                             `json:"status_lte,omitempty"`
	StatusGt                       *int32                             `json:"status_gt,omitempty"`
	StatusGte                      *int32                             `json:"status_gte,omitempty"`
	NumId                          *int32                             `json:"numId,omitempty"`
	NumIdNot                       *int32                             `json:"numId_not,omitempty"`
	NumIdIn                        []int32                            `json:"numId_in,omitempty"`
	NumIdNotIn                     []int32                            `json:"numId_not_in,omitempty"`
	NumIdLt                        *int32                             `json:"numId_lt,omitempty"`
	NumIdLte                       *int32                             `json:"numId_lte,omitempty"`
	NumIdGt                        *int32                             `json:"numId_gt,omitempty"`
	NumIdGte                       *int32                             `json:"numId_gte,omitempty"`
	AttendingRewardDropEvery       *RewardDropAttendingUserWhereInput `json:"attendingRewardDrop_every,omitempty"`
	AttendingRewardDropSome        *RewardDropAttendingUserWhereInput `json:"attendingRewardDrop_some,omitempty"`
	AttendingRewardDropNone        *RewardDropAttendingUserWhereInput `json:"attendingRewardDrop_none,omitempty"`
	MotherHistoriesEvery           *MotherHistoryWhereInput           `json:"motherHistories_every,omitempty"`
	MotherHistoriesSome            *MotherHistoryWhereInput           `json:"motherHistories_some,omitempty"`
	MotherHistoriesNone            *MotherHistoryWhereInput           `json:"motherHistories_none,omitempty"`
	OrderHistoriesEvery            *OrderHistoryWhereInput            `json:"orderHistories_every,omitempty"`
	OrderHistoriesSome             *OrderHistoryWhereInput            `json:"orderHistories_some,omitempty"`
	OrderHistoriesNone             *OrderHistoryWhereInput            `json:"orderHistories_none,omitempty"`
	OrderUserDealsHistoriesEvery   *OrderUserDealsHistoryWhereInput   `json:"orderUserDealsHistories_every,omitempty"`
	OrderUserDealsHistoriesSome    *OrderUserDealsHistoryWhereInput   `json:"orderUserDealsHistories_some,omitempty"`
	OrderUserDealsHistoriesNone    *OrderUserDealsHistoryWhereInput   `json:"orderUserDealsHistories_none,omitempty"`
	CashHistoriesEvery             *CashHistoryWhereInput             `json:"cashHistories_every,omitempty"`
	CashHistoriesSome              *CashHistoryWhereInput             `json:"cashHistories_some,omitempty"`
	CashHistoriesNone              *CashHistoryWhereInput             `json:"cashHistories_none,omitempty"`
	QuestExpenditureHistoriesEvery *QuestExpenditureHistoryWhereInput `json:"questExpenditureHistories_every,omitempty"`
	QuestExpenditureHistoriesSome  *QuestExpenditureHistoryWhereInput `json:"questExpenditureHistories_some,omitempty"`
	QuestExpenditureHistoriesNone  *QuestExpenditureHistoryWhereInput `json:"questExpenditureHistories_none,omitempty"`
	AirDropHistoriesEvery          *AirDropHistoryWhereInput          `json:"airDropHistories_every,omitempty"`
	AirDropHistoriesSome           *AirDropHistoryWhereInput          `json:"airDropHistories_some,omitempty"`
	AirDropHistoriesNone           *AirDropHistoryWhereInput          `json:"airDropHistories_none,omitempty"`
	AirDropMembersEvery            *AirDropMemberWhereInput           `json:"airDropMembers_every,omitempty"`
	AirDropMembersSome             *AirDropMemberWhereInput           `json:"airDropMembers_some,omitempty"`
	AirDropMembersNone             *AirDropMemberWhereInput           `json:"airDropMembers_none,omitempty"`
	PostRewardHistoriesEvery       *PostRewardHistoryWhereInput       `json:"postRewardHistories_every,omitempty"`
	PostRewardHistoriesSome        *PostRewardHistoryWhereInput       `json:"postRewardHistories_some,omitempty"`
	PostRewardHistoriesNone        *PostRewardHistoryWhereInput       `json:"postRewardHistories_none,omitempty"`
	UserRank                       *int32                             `json:"userRank,omitempty"`
	UserRankNot                    *int32                             `json:"userRank_not,omitempty"`
	UserRankIn                     []int32                            `json:"userRank_in,omitempty"`
	UserRankNotIn                  []int32                            `json:"userRank_not_in,omitempty"`
	UserRankLt                     *int32                             `json:"userRank_lt,omitempty"`
	UserRankLte                    *int32                             `json:"userRank_lte,omitempty"`
	UserRankGt                     *int32                             `json:"userRank_gt,omitempty"`
	UserRankGte                    *int32                             `json:"userRank_gte,omitempty"`
	AergoAccount                   *AergoAccountWhereInput            `json:"aergoAccount,omitempty"`
	UserRankFee                    *FeeWhereInput                     `json:"userRankFee,omitempty"`
	EventFeeEvery                  *FeeWhereInput                     `json:"eventFee_every,omitempty"`
	EventFeeSome                   *FeeWhereInput                     `json:"eventFee_some,omitempty"`
	EventFeeNone                   *FeeWhereInput                     `json:"eventFee_none,omitempty"`
	InviteCode                     *InviteCodeWhereInput              `json:"inviteCode,omitempty"`
	Page                           *PageWhereInput                    `json:"page,omitempty"`
	And                            []UserWhereInput                   `json:"AND,omitempty"`
	Or                             []UserWhereInput                   `json:"OR,omitempty"`
	Not                            []UserWhereInput                   `json:"NOT,omitempty"`
}

type CategoryWhereInput struct {
	ID                *string              `json:"id,omitempty"`
	IDNot             *string              `json:"id_not,omitempty"`
	IDIn              []string             `json:"id_in,omitempty"`
	IDNotIn           []string             `json:"id_not_in,omitempty"`
	IDLt              *string              `json:"id_lt,omitempty"`
	IDLte             *string              `json:"id_lte,omitempty"`
	IDGt              *string              `json:"id_gt,omitempty"`
	IDGte             *string              `json:"id_gte,omitempty"`
	IDContains        *string              `json:"id_contains,omitempty"`
	IDNotContains     *string              `json:"id_not_contains,omitempty"`
	IDStartsWith      *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string              `json:"id_not_ends_with,omitempty"`
	Name              *string              `json:"name,omitempty"`
	NameNot           *string              `json:"name_not,omitempty"`
	NameIn            []string             `json:"name_in,omitempty"`
	NameNotIn         []string             `json:"name_not_in,omitempty"`
	NameLt            *string              `json:"name_lt,omitempty"`
	NameLte           *string              `json:"name_lte,omitempty"`
	NameGt            *string              `json:"name_gt,omitempty"`
	NameGte           *string              `json:"name_gte,omitempty"`
	NameContains      *string              `json:"name_contains,omitempty"`
	NameNotContains   *string              `json:"name_not_contains,omitempty"`
	NameStartsWith    *string              `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string              `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string              `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string              `json:"name_not_ends_with,omitempty"`
	PostsEvery        *PostWhereInput      `json:"posts_every,omitempty"`
	PostsSome         *PostWhereInput      `json:"posts_some,omitempty"`
	PostsNone         *PostWhereInput      `json:"posts_none,omitempty"`
	FeedUsersEvery    *UserWhereInput      `json:"feedUsers_every,omitempty"`
	FeedUsersSome     *UserWhereInput      `json:"feedUsers_some,omitempty"`
	FeedUsersNone     *UserWhereInput      `json:"feedUsers_none,omitempty"`
	CoinsEvery        *CoinWhereInput      `json:"coins_every,omitempty"`
	CoinsSome         *CoinWhereInput      `json:"coins_some,omitempty"`
	CoinsNone         *CoinWhereInput      `json:"coins_none,omitempty"`
	OrderIndex        *float64             `json:"order_index,omitempty"`
	OrderIndexNot     *float64             `json:"order_index_not,omitempty"`
	OrderIndexIn      []float64            `json:"order_index_in,omitempty"`
	OrderIndexNotIn   []float64            `json:"order_index_not_in,omitempty"`
	OrderIndexLt      *float64             `json:"order_index_lt,omitempty"`
	OrderIndexLte     *float64             `json:"order_index_lte,omitempty"`
	OrderIndexGt      *float64             `json:"order_index_gt,omitempty"`
	OrderIndexGte     *float64             `json:"order_index_gte,omitempty"`
	And               []CategoryWhereInput `json:"AND,omitempty"`
	Or                []CategoryWhereInput `json:"OR,omitempty"`
	Not               []CategoryWhereInput `json:"NOT,omitempty"`
}

type PostWhereInput struct {
	ID                             *string                            `json:"id,omitempty"`
	IDNot                          *string                            `json:"id_not,omitempty"`
	IDIn                           []string                           `json:"id_in,omitempty"`
	IDNotIn                        []string                           `json:"id_not_in,omitempty"`
	IDLt                           *string                            `json:"id_lt,omitempty"`
	IDLte                          *string                            `json:"id_lte,omitempty"`
	IDGt                           *string                            `json:"id_gt,omitempty"`
	IDGte                          *string                            `json:"id_gte,omitempty"`
	IDContains                     *string                            `json:"id_contains,omitempty"`
	IDNotContains                  *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                            `json:"id_not_ends_with,omitempty"`
	Type                           *int32                             `json:"type,omitempty"`
	TypeNot                        *int32                             `json:"type_not,omitempty"`
	TypeIn                         []int32                            `json:"type_in,omitempty"`
	TypeNotIn                      []int32                            `json:"type_not_in,omitempty"`
	TypeLt                         *int32                             `json:"type_lt,omitempty"`
	TypeLte                        *int32                             `json:"type_lte,omitempty"`
	TypeGt                         *int32                             `json:"type_gt,omitempty"`
	TypeGte                        *int32                             `json:"type_gte,omitempty"`
	PayType                        *int32                             `json:"payType,omitempty"`
	PayTypeNot                     *int32                             `json:"payType_not,omitempty"`
	PayTypeIn                      []int32                            `json:"payType_in,omitempty"`
	PayTypeNotIn                   []int32                            `json:"payType_not_in,omitempty"`
	PayTypeLt                      *int32                             `json:"payType_lt,omitempty"`
	PayTypeLte                     *int32                             `json:"payType_lte,omitempty"`
	PayTypeGt                      *int32                             `json:"payType_gt,omitempty"`
	PayTypeGte                     *int32                             `json:"payType_gte,omitempty"`
	CategoriesEvery                *CategoryWhereInput                `json:"categories_every,omitempty"`
	CategoriesSome                 *CategoryWhereInput                `json:"categories_some,omitempty"`
	CategoriesNone                 *CategoryWhereInput                `json:"categories_none,omitempty"`
	Content                        *string                            `json:"content,omitempty"`
	ContentNot                     *string                            `json:"content_not,omitempty"`
	ContentIn                      []string                           `json:"content_in,omitempty"`
	ContentNotIn                   []string                           `json:"content_not_in,omitempty"`
	ContentLt                      *string                            `json:"content_lt,omitempty"`
	ContentLte                     *string                            `json:"content_lte,omitempty"`
	ContentGt                      *string                            `json:"content_gt,omitempty"`
	ContentGte                     *string                            `json:"content_gte,omitempty"`
	ContentContains                *string                            `json:"content_contains,omitempty"`
	ContentNotContains             *string                            `json:"content_not_contains,omitempty"`
	ContentStartsWith              *string                            `json:"content_starts_with,omitempty"`
	ContentNotStartsWith           *string                            `json:"content_not_starts_with,omitempty"`
	ContentEndsWith                *string                            `json:"content_ends_with,omitempty"`
	ContentNotEndsWith             *string                            `json:"content_not_ends_with,omitempty"`
	ToUser                         *UserWhereInput                    `json:"toUser,omitempty"`
	Owner                          *UserWhereInput                    `json:"owner,omitempty"`
	Coin                           *CoinWhereInput                    `json:"coin,omitempty"`
	AirDrop                        *AirDropWhereInput                 `json:"airDrop,omitempty"`
	Image                          *FileWhereInput                    `json:"image,omitempty"`
	FileListEvery                  *FileInfoWhereInput                `json:"fileList_every,omitempty"`
	FileListSome                   *FileInfoWhereInput                `json:"fileList_some,omitempty"`
	FileListNone                   *FileInfoWhereInput                `json:"fileList_none,omitempty"`
	QuestTitle                     *string                            `json:"questTitle,omitempty"`
	QuestTitleNot                  *string                            `json:"questTitle_not,omitempty"`
	QuestTitleIn                   []string                           `json:"questTitle_in,omitempty"`
	QuestTitleNotIn                []string                           `json:"questTitle_not_in,omitempty"`
	QuestTitleLt                   *string                            `json:"questTitle_lt,omitempty"`
	QuestTitleLte                  *string                            `json:"questTitle_lte,omitempty"`
	QuestTitleGt                   *string                            `json:"questTitle_gt,omitempty"`
	QuestTitleGte                  *string                            `json:"questTitle_gte,omitempty"`
	QuestTitleContains             *string                            `json:"questTitle_contains,omitempty"`
	QuestTitleNotContains          *string                            `json:"questTitle_not_contains,omitempty"`
	QuestTitleStartsWith           *string                            `json:"questTitle_starts_with,omitempty"`
	QuestTitleNotStartsWith        *string                            `json:"questTitle_not_starts_with,omitempty"`
	QuestTitleEndsWith             *string                            `json:"questTitle_ends_with,omitempty"`
	QuestTitleNotEndsWith          *string                            `json:"questTitle_not_ends_with,omitempty"`
	QuestCost                      *float64                           `json:"questCost,omitempty"`
	QuestCostNot                   *float64                           `json:"questCost_not,omitempty"`
	QuestCostIn                    []float64                          `json:"questCost_in,omitempty"`
	QuestCostNotIn                 []float64                          `json:"questCost_not_in,omitempty"`
	QuestCostLt                    *float64                           `json:"questCost_lt,omitempty"`
	QuestCostLte                   *float64                           `json:"questCost_lte,omitempty"`
	QuestCostGt                    *float64                           `json:"questCost_gt,omitempty"`
	QuestCostGte                   *float64                           `json:"questCost_gte,omitempty"`
	QuestMinMemberCount            *int32                             `json:"questMinMemberCount,omitempty"`
	QuestMinMemberCountNot         *int32                             `json:"questMinMemberCount_not,omitempty"`
	QuestMinMemberCountIn          []int32                            `json:"questMinMemberCount_in,omitempty"`
	QuestMinMemberCountNotIn       []int32                            `json:"questMinMemberCount_not_in,omitempty"`
	QuestMinMemberCountLt          *int32                             `json:"questMinMemberCount_lt,omitempty"`
	QuestMinMemberCountLte         *int32                             `json:"questMinMemberCount_lte,omitempty"`
	QuestMinMemberCountGt          *int32                             `json:"questMinMemberCount_gt,omitempty"`
	QuestMinMemberCountGte         *int32                             `json:"questMinMemberCount_gte,omitempty"`
	QuestLimitMemberCount          *int32                             `json:"questLimitMemberCount,omitempty"`
	QuestLimitMemberCountNot       *int32                             `json:"questLimitMemberCount_not,omitempty"`
	QuestLimitMemberCountIn        []int32                            `json:"questLimitMemberCount_in,omitempty"`
	QuestLimitMemberCountNotIn     []int32                            `json:"questLimitMemberCount_not_in,omitempty"`
	QuestLimitMemberCountLt        *int32                             `json:"questLimitMemberCount_lt,omitempty"`
	QuestLimitMemberCountLte       *int32                             `json:"questLimitMemberCount_lte,omitempty"`
	QuestLimitMemberCountGt        *int32                             `json:"questLimitMemberCount_gt,omitempty"`
	QuestLimitMemberCountGte       *int32                             `json:"questLimitMemberCount_gte,omitempty"`
	QuestToDate                    *string                            `json:"questToDate,omitempty"`
	QuestToDateNot                 *string                            `json:"questToDate_not,omitempty"`
	QuestToDateIn                  []string                           `json:"questToDate_in,omitempty"`
	QuestToDateNotIn               []string                           `json:"questToDate_not_in,omitempty"`
	QuestToDateLt                  *string                            `json:"questToDate_lt,omitempty"`
	QuestToDateLte                 *string                            `json:"questToDate_lte,omitempty"`
	QuestToDateGt                  *string                            `json:"questToDate_gt,omitempty"`
	QuestToDateGte                 *string                            `json:"questToDate_gte,omitempty"`
	QuestMembersEvery              *QuestMemberWhereInput             `json:"questMembers_every,omitempty"`
	QuestMembersSome               *QuestMemberWhereInput             `json:"questMembers_some,omitempty"`
	QuestMembersNone               *QuestMemberWhereInput             `json:"questMembers_none,omitempty"`
	QuestStatus                    *int32                             `json:"questStatus,omitempty"`
	QuestStatusNot                 *int32                             `json:"questStatus_not,omitempty"`
	QuestStatusIn                  []int32                            `json:"questStatus_in,omitempty"`
	QuestStatusNotIn               []int32                            `json:"questStatus_not_in,omitempty"`
	QuestStatusLt                  *int32                             `json:"questStatus_lt,omitempty"`
	QuestStatusLte                 *int32                             `json:"questStatus_lte,omitempty"`
	QuestStatusGt                  *int32                             `json:"questStatus_gt,omitempty"`
	QuestStatusGte                 *int32                             `json:"questStatus_gte,omitempty"`
	MotherHistoriesEvery           *MotherHistoryWhereInput           `json:"motherHistories_every,omitempty"`
	MotherHistoriesSome            *MotherHistoryWhereInput           `json:"motherHistories_some,omitempty"`
	MotherHistoriesNone            *MotherHistoryWhereInput           `json:"motherHistories_none,omitempty"`
	QuestExpenditureHistoriesEvery *QuestExpenditureHistoryWhereInput `json:"questExpenditureHistories_every,omitempty"`
	QuestExpenditureHistoriesSome  *QuestExpenditureHistoryWhereInput `json:"questExpenditureHistories_some,omitempty"`
	QuestExpenditureHistoriesNone  *QuestExpenditureHistoryWhereInput `json:"questExpenditureHistories_none,omitempty"`
	PostRewardHistoriesEvery       *PostRewardHistoryWhereInput       `json:"postRewardHistories_every,omitempty"`
	PostRewardHistoriesSome        *PostRewardHistoryWhereInput       `json:"postRewardHistories_some,omitempty"`
	PostRewardHistoriesNone        *PostRewardHistoryWhereInput       `json:"postRewardHistories_none,omitempty"`
	CommentsEvery                  *CommentWhereInput                 `json:"comments_every,omitempty"`
	CommentsSome                   *CommentWhereInput                 `json:"comments_some,omitempty"`
	CommentsNone                   *CommentWhereInput                 `json:"comments_none,omitempty"`
	LikesEvery                     *UserWhereInput                    `json:"likes_every,omitempty"`
	LikesSome                      *UserWhereInput                    `json:"likes_some,omitempty"`
	LikesNone                      *UserWhereInput                    `json:"likes_none,omitempty"`
	ViewsEvery                     *UserWhereInput                    `json:"views_every,omitempty"`
	ViewsSome                      *UserWhereInput                    `json:"views_some,omitempty"`
	ViewsNone                      *UserWhereInput                    `json:"views_none,omitempty"`
	CreatedAt                      *string                            `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                            `json:"updatedAt_gte,omitempty"`
	UpdateHistoriesEvery           *UpdatePostHistoryWhereInput       `json:"updateHistories_every,omitempty"`
	UpdateHistoriesSome            *UpdatePostHistoryWhereInput       `json:"updateHistories_some,omitempty"`
	UpdateHistoriesNone            *UpdatePostHistoryWhereInput       `json:"updateHistories_none,omitempty"`
	IsBanner                       *bool                              `json:"isBanner,omitempty"`
	IsBannerNot                    *bool                              `json:"isBanner_not,omitempty"`
	IsDel                          *bool                              `json:"isDel,omitempty"`
	IsDelNot                       *bool                              `json:"isDel_not,omitempty"`
	EnableEarlyAccess              *bool                              `json:"enableEarlyAccess,omitempty"`
	EnableEarlyAccessNot           *bool                              `json:"enableEarlyAccess_not,omitempty"`
	PublicAccessAt                 *string                            `json:"publicAccessAt,omitempty"`
	PublicAccessAtNot              *string                            `json:"publicAccessAt_not,omitempty"`
	PublicAccessAtIn               []string                           `json:"publicAccessAt_in,omitempty"`
	PublicAccessAtNotIn            []string                           `json:"publicAccessAt_not_in,omitempty"`
	PublicAccessAtLt               *string                            `json:"publicAccessAt_lt,omitempty"`
	PublicAccessAtLte              *string                            `json:"publicAccessAt_lte,omitempty"`
	PublicAccessAtGt               *string                            `json:"publicAccessAt_gt,omitempty"`
	PublicAccessAtGte              *string                            `json:"publicAccessAt_gte,omitempty"`
	OrderIndex                     *float64                           `json:"order_index,omitempty"`
	OrderIndexNot                  *float64                           `json:"order_index_not,omitempty"`
	OrderIndexIn                   []float64                          `json:"order_index_in,omitempty"`
	OrderIndexNotIn                []float64                          `json:"order_index_not_in,omitempty"`
	OrderIndexLt                   *float64                           `json:"order_index_lt,omitempty"`
	OrderIndexLte                  *float64                           `json:"order_index_lte,omitempty"`
	OrderIndexGt                   *float64                           `json:"order_index_gt,omitempty"`
	OrderIndexGte                  *float64                           `json:"order_index_gte,omitempty"`
	And                            []PostWhereInput                   `json:"AND,omitempty"`
	Or                             []PostWhereInput                   `json:"OR,omitempty"`
	Not                            []PostWhereInput                   `json:"NOT,omitempty"`
}

type CoinWhereInput struct {
	ID                           *string                          `json:"id,omitempty"`
	IDNot                        *string                          `json:"id_not,omitempty"`
	IDIn                         []string                         `json:"id_in,omitempty"`
	IDNotIn                      []string                         `json:"id_not_in,omitempty"`
	IDLt                         *string                          `json:"id_lt,omitempty"`
	IDLte                        *string                          `json:"id_lte,omitempty"`
	IDGt                         *string                          `json:"id_gt,omitempty"`
	IDGte                        *string                          `json:"id_gte,omitempty"`
	IDContains                   *string                          `json:"id_contains,omitempty"`
	IDNotContains                *string                          `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                          `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                          `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                          `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                          `json:"id_not_ends_with,omitempty"`
	CategoriesEvery              *CategoryWhereInput              `json:"categories_every,omitempty"`
	CategoriesSome               *CategoryWhereInput              `json:"categories_some,omitempty"`
	CategoriesNone               *CategoryWhereInput              `json:"categories_none,omitempty"`
	Name                         *string                          `json:"name,omitempty"`
	NameNot                      *string                          `json:"name_not,omitempty"`
	NameIn                       []string                         `json:"name_in,omitempty"`
	NameNotIn                    []string                         `json:"name_not_in,omitempty"`
	NameLt                       *string                          `json:"name_lt,omitempty"`
	NameLte                      *string                          `json:"name_lte,omitempty"`
	NameGt                       *string                          `json:"name_gt,omitempty"`
	NameGte                      *string                          `json:"name_gte,omitempty"`
	NameContains                 *string                          `json:"name_contains,omitempty"`
	NameNotContains              *string                          `json:"name_not_contains,omitempty"`
	NameStartsWith               *string                          `json:"name_starts_with,omitempty"`
	NameNotStartsWith            *string                          `json:"name_not_starts_with,omitempty"`
	NameEndsWith                 *string                          `json:"name_ends_with,omitempty"`
	NameNotEndsWith              *string                          `json:"name_not_ends_with,omitempty"`
	Qty                          *float64                         `json:"qty,omitempty"`
	QtyNot                       *float64                         `json:"qty_not,omitempty"`
	QtyIn                        []float64                        `json:"qty_in,omitempty"`
	QtyNotIn                     []float64                        `json:"qty_not_in,omitempty"`
	QtyLt                        *float64                         `json:"qty_lt,omitempty"`
	QtyLte                       *float64                         `json:"qty_lte,omitempty"`
	QtyGt                        *float64                         `json:"qty_gt,omitempty"`
	QtyGte                       *float64                         `json:"qty_gte,omitempty"`
	StandardPrice                *float64                         `json:"standardPrice,omitempty"`
	StandardPriceNot             *float64                         `json:"standardPrice_not,omitempty"`
	StandardPriceIn              []float64                        `json:"standardPrice_in,omitempty"`
	StandardPriceNotIn           []float64                        `json:"standardPrice_not_in,omitempty"`
	StandardPriceLt              *float64                         `json:"standardPrice_lt,omitempty"`
	StandardPriceLte             *float64                         `json:"standardPrice_lte,omitempty"`
	StandardPriceGt              *float64                         `json:"standardPrice_gt,omitempty"`
	StandardPriceGte             *float64                         `json:"standardPrice_gte,omitempty"`
	CurrentPrice                 *float64                         `json:"currentPrice,omitempty"`
	CurrentPriceNot              *float64                         `json:"currentPrice_not,omitempty"`
	CurrentPriceIn               []float64                        `json:"currentPrice_in,omitempty"`
	CurrentPriceNotIn            []float64                        `json:"currentPrice_not_in,omitempty"`
	CurrentPriceLt               *float64                         `json:"currentPrice_lt,omitempty"`
	CurrentPriceLte              *float64                         `json:"currentPrice_lte,omitempty"`
	CurrentPriceGt               *float64                         `json:"currentPrice_gt,omitempty"`
	CurrentPriceGte              *float64                         `json:"currentPrice_gte,omitempty"`
	Image                        *FileWhereInput                  `json:"image,omitempty"`
	Picture                      *FileInfoWhereInput              `json:"picture,omitempty"`
	Description                  *string                          `json:"description,omitempty"`
	DescriptionNot               *string                          `json:"description_not,omitempty"`
	DescriptionIn                []string                         `json:"description_in,omitempty"`
	DescriptionNotIn             []string                         `json:"description_not_in,omitempty"`
	DescriptionLt                *string                          `json:"description_lt,omitempty"`
	DescriptionLte               *string                          `json:"description_lte,omitempty"`
	DescriptionGt                *string                          `json:"description_gt,omitempty"`
	DescriptionGte               *string                          `json:"description_gte,omitempty"`
	DescriptionContains          *string                          `json:"description_contains,omitempty"`
	DescriptionNotContains       *string                          `json:"description_not_contains,omitempty"`
	DescriptionStartsWith        *string                          `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith     *string                          `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith          *string                          `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith       *string                          `json:"description_not_ends_with,omitempty"`
	WalletsEvery                 *WalletWhereInput                `json:"wallets_every,omitempty"`
	WalletsSome                  *WalletWhereInput                `json:"wallets_some,omitempty"`
	WalletsNone                  *WalletWhereInput                `json:"wallets_none,omitempty"`
	Owner                        *UserWhereInput                  `json:"owner,omitempty"`
	PostsEvery                   *PostWhereInput                  `json:"posts_every,omitempty"`
	PostsSome                    *PostWhereInput                  `json:"posts_some,omitempty"`
	PostsNone                    *PostWhereInput                  `json:"posts_none,omitempty"`
	Offer                        *OfferWhereInput                 `json:"offer,omitempty"`
	Status                       *int32                           `json:"status,omitempty"`
	StatusNot                    *int32                           `json:"status_not,omitempty"`
	StatusIn                     []int32                          `json:"status_in,omitempty"`
	StatusNotIn                  []int32                          `json:"status_not_in,omitempty"`
	StatusLt                     *int32                           `json:"status_lt,omitempty"`
	StatusLte                    *int32                           `json:"status_lte,omitempty"`
	StatusGt                     *int32                           `json:"status_gt,omitempty"`
	StatusGte                    *int32                           `json:"status_gte,omitempty"`
	Weight                       *string                          `json:"weight,omitempty"`
	WeightNot                    *string                          `json:"weight_not,omitempty"`
	WeightIn                     []string                         `json:"weight_in,omitempty"`
	WeightNotIn                  []string                         `json:"weight_not_in,omitempty"`
	WeightLt                     *string                          `json:"weight_lt,omitempty"`
	WeightLte                    *string                          `json:"weight_lte,omitempty"`
	WeightGt                     *string                          `json:"weight_gt,omitempty"`
	WeightGte                    *string                          `json:"weight_gte,omitempty"`
	WeightContains               *string                          `json:"weight_contains,omitempty"`
	WeightNotContains            *string                          `json:"weight_not_contains,omitempty"`
	WeightStartsWith             *string                          `json:"weight_starts_with,omitempty"`
	WeightNotStartsWith          *string                          `json:"weight_not_starts_with,omitempty"`
	WeightEndsWith               *string                          `json:"weight_ends_with,omitempty"`
	WeightNotEndsWith            *string                          `json:"weight_not_ends_with,omitempty"`
	OrderHistoriesEvery          *OrderHistoryWhereInput          `json:"orderHistories_every,omitempty"`
	OrderHistoriesSome           *OrderHistoryWhereInput          `json:"orderHistories_some,omitempty"`
	OrderHistoriesNone           *OrderHistoryWhereInput          `json:"orderHistories_none,omitempty"`
	OrderDealsHistoriesEvery     *OrderDealsHistoryWhereInput     `json:"orderDealsHistories_every,omitempty"`
	OrderDealsHistoriesSome      *OrderDealsHistoryWhereInput     `json:"orderDealsHistories_some,omitempty"`
	OrderDealsHistoriesNone      *OrderDealsHistoryWhereInput     `json:"orderDealsHistories_none,omitempty"`
	OrderUserDealsHistoriesEvery *OrderUserDealsHistoryWhereInput `json:"orderUserDealsHistories_every,omitempty"`
	OrderUserDealsHistoriesSome  *OrderUserDealsHistoryWhereInput `json:"orderUserDealsHistories_some,omitempty"`
	OrderUserDealsHistoriesNone  *OrderUserDealsHistoryWhereInput `json:"orderUserDealsHistories_none,omitempty"`
	MotherHistoriesEvery         *MotherHistoryWhereInput         `json:"motherHistories_every,omitempty"`
	MotherHistoriesSome          *MotherHistoryWhereInput         `json:"motherHistories_some,omitempty"`
	MotherHistoriesNone          *MotherHistoryWhereInput         `json:"motherHistories_none,omitempty"`
	CoinPriceTable               *CoinPriceTableWhereInput        `json:"coinPriceTable,omitempty"`
	CoinKlineEvery               *CoinKlineWhereInput             `json:"coinKline_every,omitempty"`
	CoinKlineSome                *CoinKlineWhereInput             `json:"coinKline_some,omitempty"`
	CoinKlineNone                *CoinKlineWhereInput             `json:"coinKline_none,omitempty"`
	DeployTxhash                 *string                          `json:"deployTxhash,omitempty"`
	DeployTxhashNot              *string                          `json:"deployTxhash_not,omitempty"`
	DeployTxhashIn               []string                         `json:"deployTxhash_in,omitempty"`
	DeployTxhashNotIn            []string                         `json:"deployTxhash_not_in,omitempty"`
	DeployTxhashLt               *string                          `json:"deployTxhash_lt,omitempty"`
	DeployTxhashLte              *string                          `json:"deployTxhash_lte,omitempty"`
	DeployTxhashGt               *string                          `json:"deployTxhash_gt,omitempty"`
	DeployTxhashGte              *string                          `json:"deployTxhash_gte,omitempty"`
	DeployTxhashContains         *string                          `json:"deployTxhash_contains,omitempty"`
	DeployTxhashNotContains      *string                          `json:"deployTxhash_not_contains,omitempty"`
	DeployTxhashStartsWith       *string                          `json:"deployTxhash_starts_with,omitempty"`
	DeployTxhashNotStartsWith    *string                          `json:"deployTxhash_not_starts_with,omitempty"`
	DeployTxhashEndsWith         *string                          `json:"deployTxhash_ends_with,omitempty"`
	DeployTxhashNotEndsWith      *string                          `json:"deployTxhash_not_ends_with,omitempty"`
	ContractAddress              *string                          `json:"contractAddress,omitempty"`
	ContractAddressNot           *string                          `json:"contractAddress_not,omitempty"`
	ContractAddressIn            []string                         `json:"contractAddress_in,omitempty"`
	ContractAddressNotIn         []string                         `json:"contractAddress_not_in,omitempty"`
	ContractAddressLt            *string                          `json:"contractAddress_lt,omitempty"`
	ContractAddressLte           *string                          `json:"contractAddress_lte,omitempty"`
	ContractAddressGt            *string                          `json:"contractAddress_gt,omitempty"`
	ContractAddressGte           *string                          `json:"contractAddress_gte,omitempty"`
	ContractAddressContains      *string                          `json:"contractAddress_contains,omitempty"`
	ContractAddressNotContains   *string                          `json:"contractAddress_not_contains,omitempty"`
	ContractAddressStartsWith    *string                          `json:"contractAddress_starts_with,omitempty"`
	ContractAddressNotStartsWith *string                          `json:"contractAddress_not_starts_with,omitempty"`
	ContractAddressEndsWith      *string                          `json:"contractAddress_ends_with,omitempty"`
	ContractAddressNotEndsWith   *string                          `json:"contractAddress_not_ends_with,omitempty"`
	ODda                         *float64                         `json:"oDDA,omitempty"`
	ODdaNot                      *float64                         `json:"oDDA_not,omitempty"`
	ODdaIn                       []float64                        `json:"oDDA_in,omitempty"`
	ODdaNotIn                    []float64                        `json:"oDDA_not_in,omitempty"`
	ODdaLt                       *float64                         `json:"oDDA_lt,omitempty"`
	ODdaLte                      *float64                         `json:"oDDA_lte,omitempty"`
	ODdaGt                       *float64                         `json:"oDDA_gt,omitempty"`
	ODdaGte                      *float64                         `json:"oDDA_gte,omitempty"`
	CreatedAt                    *string                          `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                          `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                          `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                          `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                          `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                          `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                          `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                          `json:"updatedAt_gte,omitempty"`
	And                          []CoinWhereInput                 `json:"AND,omitempty"`
	Or                           []CoinWhereInput                 `json:"OR,omitempty"`
	Not                          []CoinWhereInput                 `json:"NOT,omitempty"`
}

type FileWhereInput struct {
	ID                        *string          `json:"id,omitempty"`
	IDNot                     *string          `json:"id_not,omitempty"`
	IDIn                      []string         `json:"id_in,omitempty"`
	IDNotIn                   []string         `json:"id_not_in,omitempty"`
	IDLt                      *string          `json:"id_lt,omitempty"`
	IDLte                     *string          `json:"id_lte,omitempty"`
	IDGt                      *string          `json:"id_gt,omitempty"`
	IDGte                     *string          `json:"id_gte,omitempty"`
	IDContains                *string          `json:"id_contains,omitempty"`
	IDNotContains             *string          `json:"id_not_contains,omitempty"`
	IDStartsWith              *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string          `json:"id_not_ends_with,omitempty"`
	Coin                      *CoinWhereInput  `json:"coin,omitempty"`
	Post                      *PostWhereInput  `json:"post,omitempty"`
	LocationPath              *string          `json:"locationPath,omitempty"`
	LocationPathNot           *string          `json:"locationPath_not,omitempty"`
	LocationPathIn            []string         `json:"locationPath_in,omitempty"`
	LocationPathNotIn         []string         `json:"locationPath_not_in,omitempty"`
	LocationPathLt            *string          `json:"locationPath_lt,omitempty"`
	LocationPathLte           *string          `json:"locationPath_lte,omitempty"`
	LocationPathGt            *string          `json:"locationPath_gt,omitempty"`
	LocationPathGte           *string          `json:"locationPath_gte,omitempty"`
	LocationPathContains      *string          `json:"locationPath_contains,omitempty"`
	LocationPathNotContains   *string          `json:"locationPath_not_contains,omitempty"`
	LocationPathStartsWith    *string          `json:"locationPath_starts_with,omitempty"`
	LocationPathNotStartsWith *string          `json:"locationPath_not_starts_with,omitempty"`
	LocationPathEndsWith      *string          `json:"locationPath_ends_with,omitempty"`
	LocationPathNotEndsWith   *string          `json:"locationPath_not_ends_with,omitempty"`
	Name                      *string          `json:"name,omitempty"`
	NameNot                   *string          `json:"name_not,omitempty"`
	NameIn                    []string         `json:"name_in,omitempty"`
	NameNotIn                 []string         `json:"name_not_in,omitempty"`
	NameLt                    *string          `json:"name_lt,omitempty"`
	NameLte                   *string          `json:"name_lte,omitempty"`
	NameGt                    *string          `json:"name_gt,omitempty"`
	NameGte                   *string          `json:"name_gte,omitempty"`
	NameContains              *string          `json:"name_contains,omitempty"`
	NameNotContains           *string          `json:"name_not_contains,omitempty"`
	NameStartsWith            *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith         *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith              *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith           *string          `json:"name_not_ends_with,omitempty"`
	ContentType               *string          `json:"contentType,omitempty"`
	ContentTypeNot            *string          `json:"contentType_not,omitempty"`
	ContentTypeIn             []string         `json:"contentType_in,omitempty"`
	ContentTypeNotIn          []string         `json:"contentType_not_in,omitempty"`
	ContentTypeLt             *string          `json:"contentType_lt,omitempty"`
	ContentTypeLte            *string          `json:"contentType_lte,omitempty"`
	ContentTypeGt             *string          `json:"contentType_gt,omitempty"`
	ContentTypeGte            *string          `json:"contentType_gte,omitempty"`
	ContentTypeContains       *string          `json:"contentType_contains,omitempty"`
	ContentTypeNotContains    *string          `json:"contentType_not_contains,omitempty"`
	ContentTypeStartsWith     *string          `json:"contentType_starts_with,omitempty"`
	ContentTypeNotStartsWith  *string          `json:"contentType_not_starts_with,omitempty"`
	ContentTypeEndsWith       *string          `json:"contentType_ends_with,omitempty"`
	ContentTypeNotEndsWith    *string          `json:"contentType_not_ends_with,omitempty"`
	Url                       *string          `json:"url,omitempty"`
	UrlNot                    *string          `json:"url_not,omitempty"`
	UrlIn                     []string         `json:"url_in,omitempty"`
	UrlNotIn                  []string         `json:"url_not_in,omitempty"`
	UrlLt                     *string          `json:"url_lt,omitempty"`
	UrlLte                    *string          `json:"url_lte,omitempty"`
	UrlGt                     *string          `json:"url_gt,omitempty"`
	UrlGte                    *string          `json:"url_gte,omitempty"`
	UrlContains               *string          `json:"url_contains,omitempty"`
	UrlNotContains            *string          `json:"url_not_contains,omitempty"`
	UrlStartsWith             *string          `json:"url_starts_with,omitempty"`
	UrlNotStartsWith          *string          `json:"url_not_starts_with,omitempty"`
	UrlEndsWith               *string          `json:"url_ends_with,omitempty"`
	UrlNotEndsWith            *string          `json:"url_not_ends_with,omitempty"`
	Owner                     *UserWhereInput  `json:"owner,omitempty"`
	CreatedAt                 *string          `json:"createdAt,omitempty"`
	CreatedAtNot              *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string          `json:"createdAt_gte,omitempty"`
	IsDel                     *bool            `json:"isDel,omitempty"`
	IsDelNot                  *bool            `json:"isDel_not,omitempty"`
	And                       []FileWhereInput `json:"AND,omitempty"`
	Or                        []FileWhereInput `json:"OR,omitempty"`
	Not                       []FileWhereInput `json:"NOT,omitempty"`
}

type FileInfoWhereInput struct {
	ID                        *string              `json:"id,omitempty"`
	IDNot                     *string              `json:"id_not,omitempty"`
	IDIn                      []string             `json:"id_in,omitempty"`
	IDNotIn                   []string             `json:"id_not_in,omitempty"`
	IDLt                      *string              `json:"id_lt,omitempty"`
	IDLte                     *string              `json:"id_lte,omitempty"`
	IDGt                      *string              `json:"id_gt,omitempty"`
	IDGte                     *string              `json:"id_gte,omitempty"`
	IDContains                *string              `json:"id_contains,omitempty"`
	IDNotContains             *string              `json:"id_not_contains,omitempty"`
	IDStartsWith              *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string              `json:"id_not_ends_with,omitempty"`
	Coin                      *CoinWhereInput      `json:"coin,omitempty"`
	Post                      *PostWhereInput      `json:"post,omitempty"`
	TempFileId                *string              `json:"tempFileId,omitempty"`
	TempFileIdNot             *string              `json:"tempFileId_not,omitempty"`
	TempFileIdIn              []string             `json:"tempFileId_in,omitempty"`
	TempFileIdNotIn           []string             `json:"tempFileId_not_in,omitempty"`
	TempFileIdLt              *string              `json:"tempFileId_lt,omitempty"`
	TempFileIdLte             *string              `json:"tempFileId_lte,omitempty"`
	TempFileIdGt              *string              `json:"tempFileId_gt,omitempty"`
	TempFileIdGte             *string              `json:"tempFileId_gte,omitempty"`
	TempFileIdContains        *string              `json:"tempFileId_contains,omitempty"`
	TempFileIdNotContains     *string              `json:"tempFileId_not_contains,omitempty"`
	TempFileIdStartsWith      *string              `json:"tempFileId_starts_with,omitempty"`
	TempFileIdNotStartsWith   *string              `json:"tempFileId_not_starts_with,omitempty"`
	TempFileIdEndsWith        *string              `json:"tempFileId_ends_with,omitempty"`
	TempFileIdNotEndsWith     *string              `json:"tempFileId_not_ends_with,omitempty"`
	LocationPath              *string              `json:"locationPath,omitempty"`
	LocationPathNot           *string              `json:"locationPath_not,omitempty"`
	LocationPathIn            []string             `json:"locationPath_in,omitempty"`
	LocationPathNotIn         []string             `json:"locationPath_not_in,omitempty"`
	LocationPathLt            *string              `json:"locationPath_lt,omitempty"`
	LocationPathLte           *string              `json:"locationPath_lte,omitempty"`
	LocationPathGt            *string              `json:"locationPath_gt,omitempty"`
	LocationPathGte           *string              `json:"locationPath_gte,omitempty"`
	LocationPathContains      *string              `json:"locationPath_contains,omitempty"`
	LocationPathNotContains   *string              `json:"locationPath_not_contains,omitempty"`
	LocationPathStartsWith    *string              `json:"locationPath_starts_with,omitempty"`
	LocationPathNotStartsWith *string              `json:"locationPath_not_starts_with,omitempty"`
	LocationPathEndsWith      *string              `json:"locationPath_ends_with,omitempty"`
	LocationPathNotEndsWith   *string              `json:"locationPath_not_ends_with,omitempty"`
	Name                      *string              `json:"name,omitempty"`
	NameNot                   *string              `json:"name_not,omitempty"`
	NameIn                    []string             `json:"name_in,omitempty"`
	NameNotIn                 []string             `json:"name_not_in,omitempty"`
	NameLt                    *string              `json:"name_lt,omitempty"`
	NameLte                   *string              `json:"name_lte,omitempty"`
	NameGt                    *string              `json:"name_gt,omitempty"`
	NameGte                   *string              `json:"name_gte,omitempty"`
	NameContains              *string              `json:"name_contains,omitempty"`
	NameNotContains           *string              `json:"name_not_contains,omitempty"`
	NameStartsWith            *string              `json:"name_starts_with,omitempty"`
	NameNotStartsWith         *string              `json:"name_not_starts_with,omitempty"`
	NameEndsWith              *string              `json:"name_ends_with,omitempty"`
	NameNotEndsWith           *string              `json:"name_not_ends_with,omitempty"`
	ContentType               *string              `json:"contentType,omitempty"`
	ContentTypeNot            *string              `json:"contentType_not,omitempty"`
	ContentTypeIn             []string             `json:"contentType_in,omitempty"`
	ContentTypeNotIn          []string             `json:"contentType_not_in,omitempty"`
	ContentTypeLt             *string              `json:"contentType_lt,omitempty"`
	ContentTypeLte            *string              `json:"contentType_lte,omitempty"`
	ContentTypeGt             *string              `json:"contentType_gt,omitempty"`
	ContentTypeGte            *string              `json:"contentType_gte,omitempty"`
	ContentTypeContains       *string              `json:"contentType_contains,omitempty"`
	ContentTypeNotContains    *string              `json:"contentType_not_contains,omitempty"`
	ContentTypeStartsWith     *string              `json:"contentType_starts_with,omitempty"`
	ContentTypeNotStartsWith  *string              `json:"contentType_not_starts_with,omitempty"`
	ContentTypeEndsWith       *string              `json:"contentType_ends_with,omitempty"`
	ContentTypeNotEndsWith    *string              `json:"contentType_not_ends_with,omitempty"`
	Url                       *string              `json:"url,omitempty"`
	UrlNot                    *string              `json:"url_not,omitempty"`
	UrlIn                     []string             `json:"url_in,omitempty"`
	UrlNotIn                  []string             `json:"url_not_in,omitempty"`
	UrlLt                     *string              `json:"url_lt,omitempty"`
	UrlLte                    *string              `json:"url_lte,omitempty"`
	UrlGt                     *string              `json:"url_gt,omitempty"`
	UrlGte                    *string              `json:"url_gte,omitempty"`
	UrlContains               *string              `json:"url_contains,omitempty"`
	UrlNotContains            *string              `json:"url_not_contains,omitempty"`
	UrlStartsWith             *string              `json:"url_starts_with,omitempty"`
	UrlNotStartsWith          *string              `json:"url_not_starts_with,omitempty"`
	UrlEndsWith               *string              `json:"url_ends_with,omitempty"`
	UrlNotEndsWith            *string              `json:"url_not_ends_with,omitempty"`
	Owner                     *UserWhereInput      `json:"owner,omitempty"`
	IsVideo                   *bool                `json:"isVideo,omitempty"`
	IsVideoNot                *bool                `json:"isVideo_not,omitempty"`
	IsDel                     *bool                `json:"isDel,omitempty"`
	IsDelNot                  *bool                `json:"isDel_not,omitempty"`
	CreatedAt                 *string              `json:"createdAt,omitempty"`
	CreatedAtNot              *string              `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string              `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string              `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string              `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string              `json:"createdAt_gte,omitempty"`
	And                       []FileInfoWhereInput `json:"AND,omitempty"`
	Or                        []FileInfoWhereInput `json:"OR,omitempty"`
	Not                       []FileInfoWhereInput `json:"NOT,omitempty"`
}

type WalletWhereInput struct {
	ID                              *string            `json:"id,omitempty"`
	IDNot                           *string            `json:"id_not,omitempty"`
	IDIn                            []string           `json:"id_in,omitempty"`
	IDNotIn                         []string           `json:"id_not_in,omitempty"`
	IDLt                            *string            `json:"id_lt,omitempty"`
	IDLte                           *string            `json:"id_lte,omitempty"`
	IDGt                            *string            `json:"id_gt,omitempty"`
	IDGte                           *string            `json:"id_gte,omitempty"`
	IDContains                      *string            `json:"id_contains,omitempty"`
	IDNotContains                   *string            `json:"id_not_contains,omitempty"`
	IDStartsWith                    *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith                 *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith                      *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith                   *string            `json:"id_not_ends_with,omitempty"`
	Coin                            *CoinWhereInput    `json:"coin,omitempty"`
	Owner                           *UserWhereInput    `json:"owner,omitempty"`
	NumIdCoinName                   *string            `json:"numIdCoinName,omitempty"`
	NumIdCoinNameNot                *string            `json:"numIdCoinName_not,omitempty"`
	NumIdCoinNameIn                 []string           `json:"numIdCoinName_in,omitempty"`
	NumIdCoinNameNotIn              []string           `json:"numIdCoinName_not_in,omitempty"`
	NumIdCoinNameLt                 *string            `json:"numIdCoinName_lt,omitempty"`
	NumIdCoinNameLte                *string            `json:"numIdCoinName_lte,omitempty"`
	NumIdCoinNameGt                 *string            `json:"numIdCoinName_gt,omitempty"`
	NumIdCoinNameGte                *string            `json:"numIdCoinName_gte,omitempty"`
	NumIdCoinNameContains           *string            `json:"numIdCoinName_contains,omitempty"`
	NumIdCoinNameNotContains        *string            `json:"numIdCoinName_not_contains,omitempty"`
	NumIdCoinNameStartsWith         *string            `json:"numIdCoinName_starts_with,omitempty"`
	NumIdCoinNameNotStartsWith      *string            `json:"numIdCoinName_not_starts_with,omitempty"`
	NumIdCoinNameEndsWith           *string            `json:"numIdCoinName_ends_with,omitempty"`
	NumIdCoinNameNotEndsWith        *string            `json:"numIdCoinName_not_ends_with,omitempty"`
	CumulativePurchaseQuantity      *float64           `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseQuantityNot   *float64           `json:"cumulativePurchaseQuantity_not,omitempty"`
	CumulativePurchaseQuantityIn    []float64          `json:"cumulativePurchaseQuantity_in,omitempty"`
	CumulativePurchaseQuantityNotIn []float64          `json:"cumulativePurchaseQuantity_not_in,omitempty"`
	CumulativePurchaseQuantityLt    *float64           `json:"cumulativePurchaseQuantity_lt,omitempty"`
	CumulativePurchaseQuantityLte   *float64           `json:"cumulativePurchaseQuantity_lte,omitempty"`
	CumulativePurchaseQuantityGt    *float64           `json:"cumulativePurchaseQuantity_gt,omitempty"`
	CumulativePurchaseQuantityGte   *float64           `json:"cumulativePurchaseQuantity_gte,omitempty"`
	CumulativePurchaseValue         *float64           `json:"cumulativePurchaseValue,omitempty"`
	CumulativePurchaseValueNot      *float64           `json:"cumulativePurchaseValue_not,omitempty"`
	CumulativePurchaseValueIn       []float64          `json:"cumulativePurchaseValue_in,omitempty"`
	CumulativePurchaseValueNotIn    []float64          `json:"cumulativePurchaseValue_not_in,omitempty"`
	CumulativePurchaseValueLt       *float64           `json:"cumulativePurchaseValue_lt,omitempty"`
	CumulativePurchaseValueLte      *float64           `json:"cumulativePurchaseValue_lte,omitempty"`
	CumulativePurchaseValueGt       *float64           `json:"cumulativePurchaseValue_gt,omitempty"`
	CumulativePurchaseValueGte      *float64           `json:"cumulativePurchaseValue_gte,omitempty"`
	CreatedAt                       *string            `json:"createdAt,omitempty"`
	CreatedAtNot                    *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn                     []string           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                  []string           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                     *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte                    *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt                     *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte                    *string            `json:"createdAt_gte,omitempty"`
	And                             []WalletWhereInput `json:"AND,omitempty"`
	Or                              []WalletWhereInput `json:"OR,omitempty"`
	Not                             []WalletWhereInput `json:"NOT,omitempty"`
}

type OfferWhereInput struct {
	ID              *string            `json:"id,omitempty"`
	IDNot           *string            `json:"id_not,omitempty"`
	IDIn            []string           `json:"id_in,omitempty"`
	IDNotIn         []string           `json:"id_not_in,omitempty"`
	IDLt            *string            `json:"id_lt,omitempty"`
	IDLte           *string            `json:"id_lte,omitempty"`
	IDGt            *string            `json:"id_gt,omitempty"`
	IDGte           *string            `json:"id_gte,omitempty"`
	IDContains      *string            `json:"id_contains,omitempty"`
	IDNotContains   *string            `json:"id_not_contains,omitempty"`
	IDStartsWith    *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string            `json:"id_not_ends_with,omitempty"`
	Coin            *CoinWhereInput    `json:"coin,omitempty"`
	Qty             *int32             `json:"qty,omitempty"`
	QtyNot          *int32             `json:"qty_not,omitempty"`
	QtyIn           []int32            `json:"qty_in,omitempty"`
	QtyNotIn        []int32            `json:"qty_not_in,omitempty"`
	QtyLt           *int32             `json:"qty_lt,omitempty"`
	QtyLte          *int32             `json:"qty_lte,omitempty"`
	QtyGt           *int32             `json:"qty_gt,omitempty"`
	QtyGte          *int32             `json:"qty_gte,omitempty"`
	OfferorEvery    *OfferorWhereInput `json:"offeror_every,omitempty"`
	OfferorSome     *OfferorWhereInput `json:"offeror_some,omitempty"`
	OfferorNone     *OfferorWhereInput `json:"offeror_none,omitempty"`
	FromDate        *string            `json:"fromDate,omitempty"`
	FromDateNot     *string            `json:"fromDate_not,omitempty"`
	FromDateIn      []string           `json:"fromDate_in,omitempty"`
	FromDateNotIn   []string           `json:"fromDate_not_in,omitempty"`
	FromDateLt      *string            `json:"fromDate_lt,omitempty"`
	FromDateLte     *string            `json:"fromDate_lte,omitempty"`
	FromDateGt      *string            `json:"fromDate_gt,omitempty"`
	FromDateGte     *string            `json:"fromDate_gte,omitempty"`
	ToDate          *string            `json:"toDate,omitempty"`
	ToDateNot       *string            `json:"toDate_not,omitempty"`
	ToDateIn        []string           `json:"toDate_in,omitempty"`
	ToDateNotIn     []string           `json:"toDate_not_in,omitempty"`
	ToDateLt        *string            `json:"toDate_lt,omitempty"`
	ToDateLte       *string            `json:"toDate_lte,omitempty"`
	ToDateGt        *string            `json:"toDate_gt,omitempty"`
	ToDateGte       *string            `json:"toDate_gte,omitempty"`
	CreatedAt       *string            `json:"createdAt,omitempty"`
	CreatedAtNot    *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string            `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string            `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string            `json:"updatedAt_gte,omitempty"`
	And             []OfferWhereInput  `json:"AND,omitempty"`
	Or              []OfferWhereInput  `json:"OR,omitempty"`
	Not             []OfferWhereInput  `json:"NOT,omitempty"`
}

type OfferorWhereInput struct {
	ID              *string             `json:"id,omitempty"`
	IDNot           *string             `json:"id_not,omitempty"`
	IDIn            []string            `json:"id_in,omitempty"`
	IDNotIn         []string            `json:"id_not_in,omitempty"`
	IDLt            *string             `json:"id_lt,omitempty"`
	IDLte           *string             `json:"id_lte,omitempty"`
	IDGt            *string             `json:"id_gt,omitempty"`
	IDGte           *string             `json:"id_gte,omitempty"`
	IDContains      *string             `json:"id_contains,omitempty"`
	IDNotContains   *string             `json:"id_not_contains,omitempty"`
	IDStartsWith    *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string             `json:"id_not_ends_with,omitempty"`
	Price           *int32              `json:"price,omitempty"`
	PriceNot        *int32              `json:"price_not,omitempty"`
	PriceIn         []int32             `json:"price_in,omitempty"`
	PriceNotIn      []int32             `json:"price_not_in,omitempty"`
	PriceLt         *int32              `json:"price_lt,omitempty"`
	PriceLte        *int32              `json:"price_lte,omitempty"`
	PriceGt         *int32              `json:"price_gt,omitempty"`
	PriceGte        *int32              `json:"price_gte,omitempty"`
	Offer           *OfferWhereInput    `json:"offer,omitempty"`
	User            *UserWhereInput     `json:"user,omitempty"`
	CreatedAt       *string             `json:"createdAt,omitempty"`
	CreatedAtNot    *string             `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string             `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string             `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string             `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string             `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string             `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string             `json:"updatedAt_gte,omitempty"`
	And             []OfferorWhereInput `json:"AND,omitempty"`
	Or              []OfferorWhereInput `json:"OR,omitempty"`
	Not             []OfferorWhereInput `json:"NOT,omitempty"`
}

type OrderHistoryWhereInput struct {
	ID                           *string                          `json:"id,omitempty"`
	IDNot                        *string                          `json:"id_not,omitempty"`
	IDIn                         []string                         `json:"id_in,omitempty"`
	IDNotIn                      []string                         `json:"id_not_in,omitempty"`
	IDLt                         *string                          `json:"id_lt,omitempty"`
	IDLte                        *string                          `json:"id_lte,omitempty"`
	IDGt                         *string                          `json:"id_gt,omitempty"`
	IDGte                        *string                          `json:"id_gte,omitempty"`
	IDContains                   *string                          `json:"id_contains,omitempty"`
	IDNotContains                *string                          `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                          `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                          `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                          `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                          `json:"id_not_ends_with,omitempty"`
	Type                         *int32                           `json:"type,omitempty"`
	TypeNot                      *int32                           `json:"type_not,omitempty"`
	TypeIn                       []int32                          `json:"type_in,omitempty"`
	TypeNotIn                    []int32                          `json:"type_not_in,omitempty"`
	TypeLt                       *int32                           `json:"type_lt,omitempty"`
	TypeLte                      *int32                           `json:"type_lte,omitempty"`
	TypeGt                       *int32                           `json:"type_gt,omitempty"`
	TypeGte                      *int32                           `json:"type_gte,omitempty"`
	OrderNum                     *int32                           `json:"orderNum,omitempty"`
	OrderNumNot                  *int32                           `json:"orderNum_not,omitempty"`
	OrderNumIn                   []int32                          `json:"orderNum_in,omitempty"`
	OrderNumNotIn                []int32                          `json:"orderNum_not_in,omitempty"`
	OrderNumLt                   *int32                           `json:"orderNum_lt,omitempty"`
	OrderNumLte                  *int32                           `json:"orderNum_lte,omitempty"`
	OrderNumGt                   *int32                           `json:"orderNum_gt,omitempty"`
	OrderNumGte                  *int32                           `json:"orderNum_gte,omitempty"`
	User                         *UserWhereInput                  `json:"user,omitempty"`
	Coin                         *CoinWhereInput                  `json:"coin,omitempty"`
	MotherHistory                *MotherHistoryWhereInput         `json:"motherHistory,omitempty"`
	OrderUserDealsHistoriesEvery *OrderUserDealsHistoryWhereInput `json:"orderUserDealsHistories_every,omitempty"`
	OrderUserDealsHistoriesSome  *OrderUserDealsHistoryWhereInput `json:"orderUserDealsHistories_some,omitempty"`
	OrderUserDealsHistoriesNone  *OrderUserDealsHistoryWhereInput `json:"orderUserDealsHistories_none,omitempty"`
	OrderPrice                   *float64                         `json:"orderPrice,omitempty"`
	OrderPriceNot                *float64                         `json:"orderPrice_not,omitempty"`
	OrderPriceIn                 []float64                        `json:"orderPrice_in,omitempty"`
	OrderPriceNotIn              []float64                        `json:"orderPrice_not_in,omitempty"`
	OrderPriceLt                 *float64                         `json:"orderPrice_lt,omitempty"`
	OrderPriceLte                *float64                         `json:"orderPrice_lte,omitempty"`
	OrderPriceGt                 *float64                         `json:"orderPrice_gt,omitempty"`
	OrderPriceGte                *float64                         `json:"orderPrice_gte,omitempty"`
	DealPrice                    *float64                         `json:"dealPrice,omitempty"`
	DealPriceNot                 *float64                         `json:"dealPrice_not,omitempty"`
	DealPriceIn                  []float64                        `json:"dealPrice_in,omitempty"`
	DealPriceNotIn               []float64                        `json:"dealPrice_not_in,omitempty"`
	DealPriceLt                  *float64                         `json:"dealPrice_lt,omitempty"`
	DealPriceLte                 *float64                         `json:"dealPrice_lte,omitempty"`
	DealPriceGt                  *float64                         `json:"dealPrice_gt,omitempty"`
	DealPriceGte                 *float64                         `json:"dealPrice_gte,omitempty"`
	OrderQty                     *float64                         `json:"orderQty,omitempty"`
	OrderQtyNot                  *float64                         `json:"orderQty_not,omitempty"`
	OrderQtyIn                   []float64                        `json:"orderQty_in,omitempty"`
	OrderQtyNotIn                []float64                        `json:"orderQty_not_in,omitempty"`
	OrderQtyLt                   *float64                         `json:"orderQty_lt,omitempty"`
	OrderQtyLte                  *float64                         `json:"orderQty_lte,omitempty"`
	OrderQtyGt                   *float64                         `json:"orderQty_gt,omitempty"`
	OrderQtyGte                  *float64                         `json:"orderQty_gte,omitempty"`
	DealQty                      *float64                         `json:"dealQty,omitempty"`
	DealQtyNot                   *float64                         `json:"dealQty_not,omitempty"`
	DealQtyIn                    []float64                        `json:"dealQty_in,omitempty"`
	DealQtyNotIn                 []float64                        `json:"dealQty_not_in,omitempty"`
	DealQtyLt                    *float64                         `json:"dealQty_lt,omitempty"`
	DealQtyLte                   *float64                         `json:"dealQty_lte,omitempty"`
	DealQtyGt                    *float64                         `json:"dealQty_gt,omitempty"`
	DealQtyGte                   *float64                         `json:"dealQty_gte,omitempty"`
	LeftQty                      *float64                         `json:"leftQty,omitempty"`
	LeftQtyNot                   *float64                         `json:"leftQty_not,omitempty"`
	LeftQtyIn                    []float64                        `json:"leftQty_in,omitempty"`
	LeftQtyNotIn                 []float64                        `json:"leftQty_not_in,omitempty"`
	LeftQtyLt                    *float64                         `json:"leftQty_lt,omitempty"`
	LeftQtyLte                   *float64                         `json:"leftQty_lte,omitempty"`
	LeftQtyGt                    *float64                         `json:"leftQty_gt,omitempty"`
	LeftQtyGte                   *float64                         `json:"leftQty_gte,omitempty"`
	DealFee                      *float64                         `json:"dealFee,omitempty"`
	DealFeeNot                   *float64                         `json:"dealFee_not,omitempty"`
	DealFeeIn                    []float64                        `json:"dealFee_in,omitempty"`
	DealFeeNotIn                 []float64                        `json:"dealFee_not_in,omitempty"`
	DealFeeLt                    *float64                         `json:"dealFee_lt,omitempty"`
	DealFeeLte                   *float64                         `json:"dealFee_lte,omitempty"`
	DealFeeGt                    *float64                         `json:"dealFee_gt,omitempty"`
	DealFeeGte                   *float64                         `json:"dealFee_gte,omitempty"`
	TakerFee                     *float64                         `json:"takerFee,omitempty"`
	TakerFeeNot                  *float64                         `json:"takerFee_not,omitempty"`
	TakerFeeIn                   []float64                        `json:"takerFee_in,omitempty"`
	TakerFeeNotIn                []float64                        `json:"takerFee_not_in,omitempty"`
	TakerFeeLt                   *float64                         `json:"takerFee_lt,omitempty"`
	TakerFeeLte                  *float64                         `json:"takerFee_lte,omitempty"`
	TakerFeeGt                   *float64                         `json:"takerFee_gt,omitempty"`
	TakerFeeGte                  *float64                         `json:"takerFee_gte,omitempty"`
	MakerFee                     *float64                         `json:"makerFee,omitempty"`
	MakerFeeNot                  *float64                         `json:"makerFee_not,omitempty"`
	MakerFeeIn                   []float64                        `json:"makerFee_in,omitempty"`
	MakerFeeNotIn                []float64                        `json:"makerFee_not_in,omitempty"`
	MakerFeeLt                   *float64                         `json:"makerFee_lt,omitempty"`
	MakerFeeLte                  *float64                         `json:"makerFee_lte,omitempty"`
	MakerFeeGt                   *float64                         `json:"makerFee_gt,omitempty"`
	MakerFeeGte                  *float64                         `json:"makerFee_gte,omitempty"`
	Memo                         *string                          `json:"memo,omitempty"`
	MemoNot                      *string                          `json:"memo_not,omitempty"`
	MemoIn                       []string                         `json:"memo_in,omitempty"`
	MemoNotIn                    []string                         `json:"memo_not_in,omitempty"`
	MemoLt                       *string                          `json:"memo_lt,omitempty"`
	MemoLte                      *string                          `json:"memo_lte,omitempty"`
	MemoGt                       *string                          `json:"memo_gt,omitempty"`
	MemoGte                      *string                          `json:"memo_gte,omitempty"`
	MemoContains                 *string                          `json:"memo_contains,omitempty"`
	MemoNotContains              *string                          `json:"memo_not_contains,omitempty"`
	MemoStartsWith               *string                          `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith            *string                          `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith                 *string                          `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith              *string                          `json:"memo_not_ends_with,omitempty"`
	Description                  *string                          `json:"description,omitempty"`
	DescriptionNot               *string                          `json:"description_not,omitempty"`
	DescriptionIn                []string                         `json:"description_in,omitempty"`
	DescriptionNotIn             []string                         `json:"description_not_in,omitempty"`
	DescriptionLt                *string                          `json:"description_lt,omitempty"`
	DescriptionLte               *string                          `json:"description_lte,omitempty"`
	DescriptionGt                *string                          `json:"description_gt,omitempty"`
	DescriptionGte               *string                          `json:"description_gte,omitempty"`
	DescriptionContains          *string                          `json:"description_contains,omitempty"`
	DescriptionNotContains       *string                          `json:"description_not_contains,omitempty"`
	DescriptionStartsWith        *string                          `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith     *string                          `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith          *string                          `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith       *string                          `json:"description_not_ends_with,omitempty"`
	Offset                       *int32                           `json:"offset,omitempty"`
	OffsetNot                    *int32                           `json:"offset_not,omitempty"`
	OffsetIn                     []int32                          `json:"offset_in,omitempty"`
	OffsetNotIn                  []int32                          `json:"offset_not_in,omitempty"`
	OffsetLt                     *int32                           `json:"offset_lt,omitempty"`
	OffsetLte                    *int32                           `json:"offset_lte,omitempty"`
	OffsetGt                     *int32                           `json:"offset_gt,omitempty"`
	OffsetGte                    *int32                           `json:"offset_gte,omitempty"`
	IsCancel                     *bool                            `json:"isCancel,omitempty"`
	IsCancelNot                  *bool                            `json:"isCancel_not,omitempty"`
	CreatedAt                    *string                          `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                          `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                          `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                          `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                          `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                          `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                          `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                          `json:"updatedAt_gte,omitempty"`
	And                          []OrderHistoryWhereInput         `json:"AND,omitempty"`
	Or                           []OrderHistoryWhereInput         `json:"OR,omitempty"`
	Not                          []OrderHistoryWhereInput         `json:"NOT,omitempty"`
}

type MotherHistoryWhereInput struct {
	ID                      *string                            `json:"id,omitempty"`
	IDNot                   *string                            `json:"id_not,omitempty"`
	IDIn                    []string                           `json:"id_in,omitempty"`
	IDNotIn                 []string                           `json:"id_not_in,omitempty"`
	IDLt                    *string                            `json:"id_lt,omitempty"`
	IDLte                   *string                            `json:"id_lte,omitempty"`
	IDGt                    *string                            `json:"id_gt,omitempty"`
	IDGte                   *string                            `json:"id_gte,omitempty"`
	IDContains              *string                            `json:"id_contains,omitempty"`
	IDNotContains           *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith            *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith         *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith              *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith           *string                            `json:"id_not_ends_with,omitempty"`
	Type                    *int32                             `json:"type,omitempty"`
	TypeNot                 *int32                             `json:"type_not,omitempty"`
	TypeIn                  []int32                            `json:"type_in,omitempty"`
	TypeNotIn               []int32                            `json:"type_not_in,omitempty"`
	TypeLt                  *int32                             `json:"type_lt,omitempty"`
	TypeLte                 *int32                             `json:"type_lte,omitempty"`
	TypeGt                  *int32                             `json:"type_gt,omitempty"`
	TypeGte                 *int32                             `json:"type_gte,omitempty"`
	RoleTime                *string                            `json:"roleTime,omitempty"`
	RoleTimeNot             *string                            `json:"roleTime_not,omitempty"`
	RoleTimeIn              []string                           `json:"roleTime_in,omitempty"`
	RoleTimeNotIn           []string                           `json:"roleTime_not_in,omitempty"`
	RoleTimeLt              *string                            `json:"roleTime_lt,omitempty"`
	RoleTimeLte             *string                            `json:"roleTime_lte,omitempty"`
	RoleTimeGt              *string                            `json:"roleTime_gt,omitempty"`
	RoleTimeGte             *string                            `json:"roleTime_gte,omitempty"`
	Coin                    *CoinWhereInput                    `json:"coin,omitempty"`
	User                    *UserWhereInput                    `json:"user,omitempty"`
	Post                    *PostWhereInput                    `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryWhereInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryWhereInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryWhereInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryWhereInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryWhereInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryWhereInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryWhereInput       `json:"postRewardHistory,omitempty"`
	CreatedAt               *string                            `json:"createdAt,omitempty"`
	CreatedAtNot            *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn             []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn          []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt             *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte            *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt             *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte            *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt               *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot            *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn             []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn          []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt             *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte            *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt             *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte            *string                            `json:"updatedAt_gte,omitempty"`
	And                     []MotherHistoryWhereInput          `json:"AND,omitempty"`
	Or                      []MotherHistoryWhereInput          `json:"OR,omitempty"`
	Not                     []MotherHistoryWhereInput          `json:"NOT,omitempty"`
}

type OrderUserDealsHistoryWhereInput struct {
	ID                     *string                           `json:"id,omitempty"`
	IDNot                  *string                           `json:"id_not,omitempty"`
	IDIn                   []string                          `json:"id_in,omitempty"`
	IDNotIn                []string                          `json:"id_not_in,omitempty"`
	IDLt                   *string                           `json:"id_lt,omitempty"`
	IDLte                  *string                           `json:"id_lte,omitempty"`
	IDGt                   *string                           `json:"id_gt,omitempty"`
	IDGte                  *string                           `json:"id_gte,omitempty"`
	IDContains             *string                           `json:"id_contains,omitempty"`
	IDNotContains          *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith           *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string                           `json:"id_not_ends_with,omitempty"`
	Type                   *int32                            `json:"type,omitempty"`
	TypeNot                *int32                            `json:"type_not,omitempty"`
	TypeIn                 []int32                           `json:"type_in,omitempty"`
	TypeNotIn              []int32                           `json:"type_not_in,omitempty"`
	TypeLt                 *int32                            `json:"type_lt,omitempty"`
	TypeLte                *int32                            `json:"type_lte,omitempty"`
	TypeGt                 *int32                            `json:"type_gt,omitempty"`
	TypeGte                *int32                            `json:"type_gte,omitempty"`
	Role                   *int32                            `json:"role,omitempty"`
	RoleNot                *int32                            `json:"role_not,omitempty"`
	RoleIn                 []int32                           `json:"role_in,omitempty"`
	RoleNotIn              []int32                           `json:"role_not_in,omitempty"`
	RoleLt                 *int32                            `json:"role_lt,omitempty"`
	RoleLte                *int32                            `json:"role_lte,omitempty"`
	RoleGt                 *int32                            `json:"role_gt,omitempty"`
	RoleGte                *int32                            `json:"role_gte,omitempty"`
	DealId                 *int32                            `json:"dealId,omitempty"`
	DealIdNot              *int32                            `json:"dealId_not,omitempty"`
	DealIdIn               []int32                           `json:"dealId_in,omitempty"`
	DealIdNotIn            []int32                           `json:"dealId_not_in,omitempty"`
	DealIdLt               *int32                            `json:"dealId_lt,omitempty"`
	DealIdLte              *int32                            `json:"dealId_lte,omitempty"`
	DealIdGt               *int32                            `json:"dealId_gt,omitempty"`
	DealIdGte              *int32                            `json:"dealId_gte,omitempty"`
	UniqueKey              *string                           `json:"uniqueKey,omitempty"`
	UniqueKeyNot           *string                           `json:"uniqueKey_not,omitempty"`
	UniqueKeyIn            []string                          `json:"uniqueKey_in,omitempty"`
	UniqueKeyNotIn         []string                          `json:"uniqueKey_not_in,omitempty"`
	UniqueKeyLt            *string                           `json:"uniqueKey_lt,omitempty"`
	UniqueKeyLte           *string                           `json:"uniqueKey_lte,omitempty"`
	UniqueKeyGt            *string                           `json:"uniqueKey_gt,omitempty"`
	UniqueKeyGte           *string                           `json:"uniqueKey_gte,omitempty"`
	UniqueKeyContains      *string                           `json:"uniqueKey_contains,omitempty"`
	UniqueKeyNotContains   *string                           `json:"uniqueKey_not_contains,omitempty"`
	UniqueKeyStartsWith    *string                           `json:"uniqueKey_starts_with,omitempty"`
	UniqueKeyNotStartsWith *string                           `json:"uniqueKey_not_starts_with,omitempty"`
	UniqueKeyEndsWith      *string                           `json:"uniqueKey_ends_with,omitempty"`
	UniqueKeyNotEndsWith   *string                           `json:"uniqueKey_not_ends_with,omitempty"`
	UniqueId               *int32                            `json:"uniqueId,omitempty"`
	UniqueIdNot            *int32                            `json:"uniqueId_not,omitempty"`
	UniqueIdIn             []int32                           `json:"uniqueId_in,omitempty"`
	UniqueIdNotIn          []int32                           `json:"uniqueId_not_in,omitempty"`
	UniqueIdLt             *int32                            `json:"uniqueId_lt,omitempty"`
	UniqueIdLte            *int32                            `json:"uniqueId_lte,omitempty"`
	UniqueIdGt             *int32                            `json:"uniqueId_gt,omitempty"`
	UniqueIdGte            *int32                            `json:"uniqueId_gte,omitempty"`
	Coin                   *CoinWhereInput                   `json:"coin,omitempty"`
	User                   *UserWhereInput                   `json:"user,omitempty"`
	MotherHistory          *MotherHistoryWhereInput          `json:"motherHistory,omitempty"`
	OrderHistory           *OrderHistoryWhereInput           `json:"orderHistory,omitempty"`
	DealPrice              *float64                          `json:"dealPrice,omitempty"`
	DealPriceNot           *float64                          `json:"dealPrice_not,omitempty"`
	DealPriceIn            []float64                         `json:"dealPrice_in,omitempty"`
	DealPriceNotIn         []float64                         `json:"dealPrice_not_in,omitempty"`
	DealPriceLt            *float64                          `json:"dealPrice_lt,omitempty"`
	DealPriceLte           *float64                          `json:"dealPrice_lte,omitempty"`
	DealPriceGt            *float64                          `json:"dealPrice_gt,omitempty"`
	DealPriceGte           *float64                          `json:"dealPrice_gte,omitempty"`
	DealQty                *float64                          `json:"dealQty,omitempty"`
	DealQtyNot             *float64                          `json:"dealQty_not,omitempty"`
	DealQtyIn              []float64                         `json:"dealQty_in,omitempty"`
	DealQtyNotIn           []float64                         `json:"dealQty_not_in,omitempty"`
	DealQtyLt              *float64                          `json:"dealQty_lt,omitempty"`
	DealQtyLte             *float64                          `json:"dealQty_lte,omitempty"`
	DealQtyGt              *float64                          `json:"dealQty_gt,omitempty"`
	DealQtyGte             *float64                          `json:"dealQty_gte,omitempty"`
	Fee                    *float64                          `json:"fee,omitempty"`
	FeeNot                 *float64                          `json:"fee_not,omitempty"`
	FeeIn                  []float64                         `json:"fee_in,omitempty"`
	FeeNotIn               []float64                         `json:"fee_not_in,omitempty"`
	FeeLt                  *float64                          `json:"fee_lt,omitempty"`
	FeeLte                 *float64                          `json:"fee_lte,omitempty"`
	FeeGt                  *float64                          `json:"fee_gt,omitempty"`
	FeeGte                 *float64                          `json:"fee_gte,omitempty"`
	DealOrderId            *int32                            `json:"dealOrderId,omitempty"`
	DealOrderIdNot         *int32                            `json:"dealOrderId_not,omitempty"`
	DealOrderIdIn          []int32                           `json:"dealOrderId_in,omitempty"`
	DealOrderIdNotIn       []int32                           `json:"dealOrderId_not_in,omitempty"`
	DealOrderIdLt          *int32                            `json:"dealOrderId_lt,omitempty"`
	DealOrderIdLte         *int32                            `json:"dealOrderId_lte,omitempty"`
	DealOrderIdGt          *int32                            `json:"dealOrderId_gt,omitempty"`
	DealOrderIdGte         *int32                            `json:"dealOrderId_gte,omitempty"`
	Time                   *float64                          `json:"time,omitempty"`
	TimeNot                *float64                          `json:"time_not,omitempty"`
	TimeIn                 []float64                         `json:"time_in,omitempty"`
	TimeNotIn              []float64                         `json:"time_not_in,omitempty"`
	TimeLt                 *float64                          `json:"time_lt,omitempty"`
	TimeLte                *float64                          `json:"time_lte,omitempty"`
	TimeGt                 *float64                          `json:"time_gt,omitempty"`
	TimeGte                *float64                          `json:"time_gte,omitempty"`
	CreatedAt              *string                           `json:"createdAt,omitempty"`
	CreatedAtNot           *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                           `json:"updatedAt_gte,omitempty"`
	And                    []OrderUserDealsHistoryWhereInput `json:"AND,omitempty"`
	Or                     []OrderUserDealsHistoryWhereInput `json:"OR,omitempty"`
	Not                    []OrderUserDealsHistoryWhereInput `json:"NOT,omitempty"`
}

type CashHistoryWhereInput struct {
	ID                       *string                            `json:"id,omitempty"`
	IDNot                    *string                            `json:"id_not,omitempty"`
	IDIn                     []string                           `json:"id_in,omitempty"`
	IDNotIn                  []string                           `json:"id_not_in,omitempty"`
	IDLt                     *string                            `json:"id_lt,omitempty"`
	IDLte                    *string                            `json:"id_lte,omitempty"`
	IDGt                     *string                            `json:"id_gt,omitempty"`
	IDGte                    *string                            `json:"id_gte,omitempty"`
	IDContains               *string                            `json:"id_contains,omitempty"`
	IDNotContains            *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                            `json:"id_not_ends_with,omitempty"`
	Type                     *int32                             `json:"type,omitempty"`
	TypeNot                  *int32                             `json:"type_not,omitempty"`
	TypeIn                   []int32                            `json:"type_in,omitempty"`
	TypeNotIn                []int32                            `json:"type_not_in,omitempty"`
	TypeLt                   *int32                             `json:"type_lt,omitempty"`
	TypeLte                  *int32                             `json:"type_lte,omitempty"`
	TypeGt                   *int32                             `json:"type_gt,omitempty"`
	TypeGte                  *int32                             `json:"type_gte,omitempty"`
	Property                 *int32                             `json:"property,omitempty"`
	PropertyNot              *int32                             `json:"property_not,omitempty"`
	PropertyIn               []int32                            `json:"property_in,omitempty"`
	PropertyNotIn            []int32                            `json:"property_not_in,omitempty"`
	PropertyLt               *int32                             `json:"property_lt,omitempty"`
	PropertyLte              *int32                             `json:"property_lte,omitempty"`
	PropertyGt               *int32                             `json:"property_gt,omitempty"`
	PropertyGte              *int32                             `json:"property_gte,omitempty"`
	OrderNum                 *int32                             `json:"orderNum,omitempty"`
	OrderNumNot              *int32                             `json:"orderNum_not,omitempty"`
	OrderNumIn               []int32                            `json:"orderNum_in,omitempty"`
	OrderNumNotIn            []int32                            `json:"orderNum_not_in,omitempty"`
	OrderNumLt               *int32                             `json:"orderNum_lt,omitempty"`
	OrderNumLte              *int32                             `json:"orderNum_lte,omitempty"`
	OrderNumGt               *int32                             `json:"orderNum_gt,omitempty"`
	OrderNumGte              *int32                             `json:"orderNum_gte,omitempty"`
	Description              *string                            `json:"description,omitempty"`
	DescriptionNot           *string                            `json:"description_not,omitempty"`
	DescriptionIn            []string                           `json:"description_in,omitempty"`
	DescriptionNotIn         []string                           `json:"description_not_in,omitempty"`
	DescriptionLt            *string                            `json:"description_lt,omitempty"`
	DescriptionLte           *string                            `json:"description_lte,omitempty"`
	DescriptionGt            *string                            `json:"description_gt,omitempty"`
	DescriptionGte           *string                            `json:"description_gte,omitempty"`
	DescriptionContains      *string                            `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                            `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                            `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                            `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                            `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                            `json:"description_not_ends_with,omitempty"`
	User                     *UserWhereInput                    `json:"user,omitempty"`
	MotherHistory            *MotherHistoryWhereInput           `json:"motherHistory,omitempty"`
	Qeh                      *QuestExpenditureHistoryWhereInput `json:"qeh,omitempty"`
	AergoAccountHistory      *AergoAccountHistoryWhereInput     `json:"aergoAccountHistory,omitempty"`
	Price                    *int32                             `json:"price,omitempty"`
	PriceNot                 *int32                             `json:"price_not,omitempty"`
	PriceIn                  []int32                            `json:"price_in,omitempty"`
	PriceNotIn               []int32                            `json:"price_not_in,omitempty"`
	PriceLt                  *int32                             `json:"price_lt,omitempty"`
	PriceLte                 *int32                             `json:"price_lte,omitempty"`
	PriceGt                  *int32                             `json:"price_gt,omitempty"`
	PriceGte                 *int32                             `json:"price_gte,omitempty"`
	OPrice                   *float64                           `json:"oPrice,omitempty"`
	OPriceNot                *float64                           `json:"oPrice_not,omitempty"`
	OPriceIn                 []float64                          `json:"oPrice_in,omitempty"`
	OPriceNotIn              []float64                          `json:"oPrice_not_in,omitempty"`
	OPriceLt                 *float64                           `json:"oPrice_lt,omitempty"`
	OPriceLte                *float64                           `json:"oPrice_lte,omitempty"`
	OPriceGt                 *float64                           `json:"oPrice_gt,omitempty"`
	OPriceGte                *float64                           `json:"oPrice_gte,omitempty"`
	OPriceBack               *float64                           `json:"oPriceBack,omitempty"`
	OPriceBackNot            *float64                           `json:"oPriceBack_not,omitempty"`
	OPriceBackIn             []float64                          `json:"oPriceBack_in,omitempty"`
	OPriceBackNotIn          []float64                          `json:"oPriceBack_not_in,omitempty"`
	OPriceBackLt             *float64                           `json:"oPriceBack_lt,omitempty"`
	OPriceBackLte            *float64                           `json:"oPriceBack_lte,omitempty"`
	OPriceBackGt             *float64                           `json:"oPriceBack_gt,omitempty"`
	OPriceBackGte            *float64                           `json:"oPriceBack_gte,omitempty"`
	Qty                      *float64                           `json:"qty,omitempty"`
	QtyNot                   *float64                           `json:"qty_not,omitempty"`
	QtyIn                    []float64                          `json:"qty_in,omitempty"`
	QtyNotIn                 []float64                          `json:"qty_not_in,omitempty"`
	QtyLt                    *float64                           `json:"qty_lt,omitempty"`
	QtyLte                   *float64                           `json:"qty_lte,omitempty"`
	QtyGt                    *float64                           `json:"qty_gt,omitempty"`
	QtyGte                   *float64                           `json:"qty_gte,omitempty"`
	Memo                     *string                            `json:"memo,omitempty"`
	MemoNot                  *string                            `json:"memo_not,omitempty"`
	MemoIn                   []string                           `json:"memo_in,omitempty"`
	MemoNotIn                []string                           `json:"memo_not_in,omitempty"`
	MemoLt                   *string                            `json:"memo_lt,omitempty"`
	MemoLte                  *string                            `json:"memo_lte,omitempty"`
	MemoGt                   *string                            `json:"memo_gt,omitempty"`
	MemoGte                  *string                            `json:"memo_gte,omitempty"`
	MemoContains             *string                            `json:"memo_contains,omitempty"`
	MemoNotContains          *string                            `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                            `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                            `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                            `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                            `json:"memo_not_ends_with,omitempty"`
	CreatedAt                *string                            `json:"createdAt,omitempty"`
	CreatedAtNot             *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                            `json:"updatedAt_gte,omitempty"`
	And                      []CashHistoryWhereInput            `json:"AND,omitempty"`
	Or                       []CashHistoryWhereInput            `json:"OR,omitempty"`
	Not                      []CashHistoryWhereInput            `json:"NOT,omitempty"`
}

type QuestExpenditureHistoryWhereInput struct {
	ID                       *string                             `json:"id,omitempty"`
	IDNot                    *string                             `json:"id_not,omitempty"`
	IDIn                     []string                            `json:"id_in,omitempty"`
	IDNotIn                  []string                            `json:"id_not_in,omitempty"`
	IDLt                     *string                             `json:"id_lt,omitempty"`
	IDLte                    *string                             `json:"id_lte,omitempty"`
	IDGt                     *string                             `json:"id_gt,omitempty"`
	IDGte                    *string                             `json:"id_gte,omitempty"`
	IDContains               *string                             `json:"id_contains,omitempty"`
	IDNotContains            *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                             `json:"id_not_ends_with,omitempty"`
	Type                     *int32                              `json:"type,omitempty"`
	TypeNot                  *int32                              `json:"type_not,omitempty"`
	TypeIn                   []int32                             `json:"type_in,omitempty"`
	TypeNotIn                []int32                             `json:"type_not_in,omitempty"`
	TypeLt                   *int32                              `json:"type_lt,omitempty"`
	TypeLte                  *int32                              `json:"type_lte,omitempty"`
	TypeGt                   *int32                              `json:"type_gt,omitempty"`
	TypeGte                  *int32                              `json:"type_gte,omitempty"`
	PayType                  *int32                              `json:"payType,omitempty"`
	PayTypeNot               *int32                              `json:"payType_not,omitempty"`
	PayTypeIn                []int32                             `json:"payType_in,omitempty"`
	PayTypeNotIn             []int32                             `json:"payType_not_in,omitempty"`
	PayTypeLt                *int32                              `json:"payType_lt,omitempty"`
	PayTypeLte               *int32                              `json:"payType_lte,omitempty"`
	PayTypeGt                *int32                              `json:"payType_gt,omitempty"`
	PayTypeGte               *int32                              `json:"payType_gte,omitempty"`
	OrderNum                 *int32                              `json:"orderNum,omitempty"`
	OrderNumNot              *int32                              `json:"orderNum_not,omitempty"`
	OrderNumIn               []int32                             `json:"orderNum_in,omitempty"`
	OrderNumNotIn            []int32                             `json:"orderNum_not_in,omitempty"`
	OrderNumLt               *int32                              `json:"orderNum_lt,omitempty"`
	OrderNumLte              *int32                              `json:"orderNum_lte,omitempty"`
	OrderNumGt               *int32                              `json:"orderNum_gt,omitempty"`
	OrderNumGte              *int32                              `json:"orderNum_gte,omitempty"`
	Description              *string                             `json:"description,omitempty"`
	DescriptionNot           *string                             `json:"description_not,omitempty"`
	DescriptionIn            []string                            `json:"description_in,omitempty"`
	DescriptionNotIn         []string                            `json:"description_not_in,omitempty"`
	DescriptionLt            *string                             `json:"description_lt,omitempty"`
	DescriptionLte           *string                             `json:"description_lte,omitempty"`
	DescriptionGt            *string                             `json:"description_gt,omitempty"`
	DescriptionGte           *string                             `json:"description_gte,omitempty"`
	DescriptionContains      *string                             `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                             `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                             `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                             `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                             `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                             `json:"description_not_ends_with,omitempty"`
	User                     *UserWhereInput                     `json:"user,omitempty"`
	Post                     *PostWhereInput                     `json:"post,omitempty"`
	MotherHistory            *MotherHistoryWhereInput            `json:"motherHistory,omitempty"`
	CashHistory              *CashHistoryWhereInput              `json:"cashHistory,omitempty"`
	Price                    *int32                              `json:"price,omitempty"`
	PriceNot                 *int32                              `json:"price_not,omitempty"`
	PriceIn                  []int32                             `json:"price_in,omitempty"`
	PriceNotIn               []int32                             `json:"price_not_in,omitempty"`
	PriceLt                  *int32                              `json:"price_lt,omitempty"`
	PriceLte                 *int32                              `json:"price_lte,omitempty"`
	PriceGt                  *int32                              `json:"price_gt,omitempty"`
	PriceGte                 *int32                              `json:"price_gte,omitempty"`
	Qty                      *float64                            `json:"qty,omitempty"`
	QtyNot                   *float64                            `json:"qty_not,omitempty"`
	QtyIn                    []float64                           `json:"qty_in,omitempty"`
	QtyNotIn                 []float64                           `json:"qty_not_in,omitempty"`
	QtyLt                    *float64                            `json:"qty_lt,omitempty"`
	QtyLte                   *float64                            `json:"qty_lte,omitempty"`
	QtyGt                    *float64                            `json:"qty_gt,omitempty"`
	QtyGte                   *float64                            `json:"qty_gte,omitempty"`
	OPrice                   *int32                              `json:"oPrice,omitempty"`
	OPriceNot                *int32                              `json:"oPrice_not,omitempty"`
	OPriceIn                 []int32                             `json:"oPrice_in,omitempty"`
	OPriceNotIn              []int32                             `json:"oPrice_not_in,omitempty"`
	OPriceLt                 *int32                              `json:"oPrice_lt,omitempty"`
	OPriceLte                *int32                              `json:"oPrice_lte,omitempty"`
	OPriceGt                 *int32                              `json:"oPrice_gt,omitempty"`
	OPriceGte                *int32                              `json:"oPrice_gte,omitempty"`
	CurrentPrice             *float64                            `json:"currentPrice,omitempty"`
	CurrentPriceNot          *float64                            `json:"currentPrice_not,omitempty"`
	CurrentPriceIn           []float64                           `json:"currentPrice_in,omitempty"`
	CurrentPriceNotIn        []float64                           `json:"currentPrice_not_in,omitempty"`
	CurrentPriceLt           *float64                            `json:"currentPrice_lt,omitempty"`
	CurrentPriceLte          *float64                            `json:"currentPrice_lte,omitempty"`
	CurrentPriceGt           *float64                            `json:"currentPrice_gt,omitempty"`
	CurrentPriceGte          *float64                            `json:"currentPrice_gte,omitempty"`
	Memo                     *string                             `json:"memo,omitempty"`
	MemoNot                  *string                             `json:"memo_not,omitempty"`
	MemoIn                   []string                            `json:"memo_in,omitempty"`
	MemoNotIn                []string                            `json:"memo_not_in,omitempty"`
	MemoLt                   *string                             `json:"memo_lt,omitempty"`
	MemoLte                  *string                             `json:"memo_lte,omitempty"`
	MemoGt                   *string                             `json:"memo_gt,omitempty"`
	MemoGte                  *string                             `json:"memo_gte,omitempty"`
	MemoContains             *string                             `json:"memo_contains,omitempty"`
	MemoNotContains          *string                             `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                             `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                             `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                             `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                             `json:"memo_not_ends_with,omitempty"`
	CreatedAt                *string                             `json:"createdAt,omitempty"`
	CreatedAtNot             *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                             `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                             `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                             `json:"updatedAt_gte,omitempty"`
	And                      []QuestExpenditureHistoryWhereInput `json:"AND,omitempty"`
	Or                       []QuestExpenditureHistoryWhereInput `json:"OR,omitempty"`
	Not                      []QuestExpenditureHistoryWhereInput `json:"NOT,omitempty"`
}

type AergoAccountHistoryWhereInput struct {
	ID                       *string                         `json:"id,omitempty"`
	IDNot                    *string                         `json:"id_not,omitempty"`
	IDIn                     []string                        `json:"id_in,omitempty"`
	IDNotIn                  []string                        `json:"id_not_in,omitempty"`
	IDLt                     *string                         `json:"id_lt,omitempty"`
	IDLte                    *string                         `json:"id_lte,omitempty"`
	IDGt                     *string                         `json:"id_gt,omitempty"`
	IDGte                    *string                         `json:"id_gte,omitempty"`
	IDContains               *string                         `json:"id_contains,omitempty"`
	IDNotContains            *string                         `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                         `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                         `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                         `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                         `json:"id_not_ends_with,omitempty"`
	Type                     *int32                          `json:"type,omitempty"`
	TypeNot                  *int32                          `json:"type_not,omitempty"`
	TypeIn                   []int32                         `json:"type_in,omitempty"`
	TypeNotIn                []int32                         `json:"type_not_in,omitempty"`
	TypeLt                   *int32                          `json:"type_lt,omitempty"`
	TypeLte                  *int32                          `json:"type_lte,omitempty"`
	TypeGt                   *int32                          `json:"type_gt,omitempty"`
	TypeGte                  *int32                          `json:"type_gte,omitempty"`
	MotherHistory            *MotherHistoryWhereInput        `json:"motherHistory,omitempty"`
	AergoAccount             *AergoAccountWhereInput         `json:"aergoAccount,omitempty"`
	CashHistory              *CashHistoryWhereInput          `json:"cashHistory,omitempty"`
	AergoAmount              *string                         `json:"aergoAmount,omitempty"`
	AergoAmountNot           *string                         `json:"aergoAmount_not,omitempty"`
	AergoAmountIn            []string                        `json:"aergoAmount_in,omitempty"`
	AergoAmountNotIn         []string                        `json:"aergoAmount_not_in,omitempty"`
	AergoAmountLt            *string                         `json:"aergoAmount_lt,omitempty"`
	AergoAmountLte           *string                         `json:"aergoAmount_lte,omitempty"`
	AergoAmountGt            *string                         `json:"aergoAmount_gt,omitempty"`
	AergoAmountGte           *string                         `json:"aergoAmount_gte,omitempty"`
	AergoAmountContains      *string                         `json:"aergoAmount_contains,omitempty"`
	AergoAmountNotContains   *string                         `json:"aergoAmount_not_contains,omitempty"`
	AergoAmountStartsWith    *string                         `json:"aergoAmount_starts_with,omitempty"`
	AergoAmountNotStartsWith *string                         `json:"aergoAmount_not_starts_with,omitempty"`
	AergoAmountEndsWith      *string                         `json:"aergoAmount_ends_with,omitempty"`
	AergoAmountNotEndsWith   *string                         `json:"aergoAmount_not_ends_with,omitempty"`
	AmountFee                *float64                        `json:"amount_fee,omitempty"`
	AmountFeeNot             *float64                        `json:"amount_fee_not,omitempty"`
	AmountFeeIn              []float64                       `json:"amount_fee_in,omitempty"`
	AmountFeeNotIn           []float64                       `json:"amount_fee_not_in,omitempty"`
	AmountFeeLt              *float64                        `json:"amount_fee_lt,omitempty"`
	AmountFeeLte             *float64                        `json:"amount_fee_lte,omitempty"`
	AmountFeeGt              *float64                        `json:"amount_fee_gt,omitempty"`
	AmountFeeGte             *float64                        `json:"amount_fee_gte,omitempty"`
	Amount                   *float64                        `json:"amount,omitempty"`
	AmountNot                *float64                        `json:"amount_not,omitempty"`
	AmountIn                 []float64                       `json:"amount_in,omitempty"`
	AmountNotIn              []float64                       `json:"amount_not_in,omitempty"`
	AmountLt                 *float64                        `json:"amount_lt,omitempty"`
	AmountLte                *float64                        `json:"amount_lte,omitempty"`
	AmountGt                 *float64                        `json:"amount_gt,omitempty"`
	AmountGte                *float64                        `json:"amount_gte,omitempty"`
	MarketPrice              *string                         `json:"marketPrice,omitempty"`
	MarketPriceNot           *string                         `json:"marketPrice_not,omitempty"`
	MarketPriceIn            []string                        `json:"marketPrice_in,omitempty"`
	MarketPriceNotIn         []string                        `json:"marketPrice_not_in,omitempty"`
	MarketPriceLt            *string                         `json:"marketPrice_lt,omitempty"`
	MarketPriceLte           *string                         `json:"marketPrice_lte,omitempty"`
	MarketPriceGt            *string                         `json:"marketPrice_gt,omitempty"`
	MarketPriceGte           *string                         `json:"marketPrice_gte,omitempty"`
	MarketPriceContains      *string                         `json:"marketPrice_contains,omitempty"`
	MarketPriceNotContains   *string                         `json:"marketPrice_not_contains,omitempty"`
	MarketPriceStartsWith    *string                         `json:"marketPrice_starts_with,omitempty"`
	MarketPriceNotStartsWith *string                         `json:"marketPrice_not_starts_with,omitempty"`
	MarketPriceEndsWith      *string                         `json:"marketPrice_ends_with,omitempty"`
	MarketPriceNotEndsWith   *string                         `json:"marketPrice_not_ends_with,omitempty"`
	TxHash                   *string                         `json:"txHash,omitempty"`
	TxHashNot                *string                         `json:"txHash_not,omitempty"`
	TxHashIn                 []string                        `json:"txHash_in,omitempty"`
	TxHashNotIn              []string                        `json:"txHash_not_in,omitempty"`
	TxHashLt                 *string                         `json:"txHash_lt,omitempty"`
	TxHashLte                *string                         `json:"txHash_lte,omitempty"`
	TxHashGt                 *string                         `json:"txHash_gt,omitempty"`
	TxHashGte                *string                         `json:"txHash_gte,omitempty"`
	TxHashContains           *string                         `json:"txHash_contains,omitempty"`
	TxHashNotContains        *string                         `json:"txHash_not_contains,omitempty"`
	TxHashStartsWith         *string                         `json:"txHash_starts_with,omitempty"`
	TxHashNotStartsWith      *string                         `json:"txHash_not_starts_with,omitempty"`
	TxHashEndsWith           *string                         `json:"txHash_ends_with,omitempty"`
	TxHashNotEndsWith        *string                         `json:"txHash_not_ends_with,omitempty"`
	Memo                     *string                         `json:"memo,omitempty"`
	MemoNot                  *string                         `json:"memo_not,omitempty"`
	MemoIn                   []string                        `json:"memo_in,omitempty"`
	MemoNotIn                []string                        `json:"memo_not_in,omitempty"`
	MemoLt                   *string                         `json:"memo_lt,omitempty"`
	MemoLte                  *string                         `json:"memo_lte,omitempty"`
	MemoGt                   *string                         `json:"memo_gt,omitempty"`
	MemoGte                  *string                         `json:"memo_gte,omitempty"`
	MemoContains             *string                         `json:"memo_contains,omitempty"`
	MemoNotContains          *string                         `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                         `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                         `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                         `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                         `json:"memo_not_ends_with,omitempty"`
	Description              *string                         `json:"description,omitempty"`
	DescriptionNot           *string                         `json:"description_not,omitempty"`
	DescriptionIn            []string                        `json:"description_in,omitempty"`
	DescriptionNotIn         []string                        `json:"description_not_in,omitempty"`
	DescriptionLt            *string                         `json:"description_lt,omitempty"`
	DescriptionLte           *string                         `json:"description_lte,omitempty"`
	DescriptionGt            *string                         `json:"description_gt,omitempty"`
	DescriptionGte           *string                         `json:"description_gte,omitempty"`
	DescriptionContains      *string                         `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                         `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                         `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                         `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                         `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                         `json:"description_not_ends_with,omitempty"`
	BlockNo                  *int32                          `json:"blockNo,omitempty"`
	BlockNoNot               *int32                          `json:"blockNo_not,omitempty"`
	BlockNoIn                []int32                         `json:"blockNo_in,omitempty"`
	BlockNoNotIn             []int32                         `json:"blockNo_not_in,omitempty"`
	BlockNoLt                *int32                          `json:"blockNo_lt,omitempty"`
	BlockNoLte               *int32                          `json:"blockNo_lte,omitempty"`
	BlockNoGt                *int32                          `json:"blockNo_gt,omitempty"`
	BlockNoGte               *int32                          `json:"blockNo_gte,omitempty"`
	Status                   *int32                          `json:"status,omitempty"`
	StatusNot                *int32                          `json:"status_not,omitempty"`
	StatusIn                 []int32                         `json:"status_in,omitempty"`
	StatusNotIn              []int32                         `json:"status_not_in,omitempty"`
	StatusLt                 *int32                          `json:"status_lt,omitempty"`
	StatusLte                *int32                          `json:"status_lte,omitempty"`
	StatusGt                 *int32                          `json:"status_gt,omitempty"`
	StatusGte                *int32                          `json:"status_gte,omitempty"`
	CreatedAt                *string                         `json:"createdAt,omitempty"`
	CreatedAtNot             *string                         `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                         `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                         `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                         `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                         `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                         `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                         `json:"updatedAt_gte,omitempty"`
	And                      []AergoAccountHistoryWhereInput `json:"AND,omitempty"`
	Or                       []AergoAccountHistoryWhereInput `json:"OR,omitempty"`
	Not                      []AergoAccountHistoryWhereInput `json:"NOT,omitempty"`
}

type AergoAccountWhereInput struct {
	ID                           *string                        `json:"id,omitempty"`
	IDNot                        *string                        `json:"id_not,omitempty"`
	IDIn                         []string                       `json:"id_in,omitempty"`
	IDNotIn                      []string                       `json:"id_not_in,omitempty"`
	IDLt                         *string                        `json:"id_lt,omitempty"`
	IDLte                        *string                        `json:"id_lte,omitempty"`
	IDGt                         *string                        `json:"id_gt,omitempty"`
	IDGte                        *string                        `json:"id_gte,omitempty"`
	IDContains                   *string                        `json:"id_contains,omitempty"`
	IDNotContains                *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                        `json:"id_not_ends_with,omitempty"`
	ContractAddress              *string                        `json:"contractAddress,omitempty"`
	ContractAddressNot           *string                        `json:"contractAddress_not,omitempty"`
	ContractAddressIn            []string                       `json:"contractAddress_in,omitempty"`
	ContractAddressNotIn         []string                       `json:"contractAddress_not_in,omitempty"`
	ContractAddressLt            *string                        `json:"contractAddress_lt,omitempty"`
	ContractAddressLte           *string                        `json:"contractAddress_lte,omitempty"`
	ContractAddressGt            *string                        `json:"contractAddress_gt,omitempty"`
	ContractAddressGte           *string                        `json:"contractAddress_gte,omitempty"`
	ContractAddressContains      *string                        `json:"contractAddress_contains,omitempty"`
	ContractAddressNotContains   *string                        `json:"contractAddress_not_contains,omitempty"`
	ContractAddressStartsWith    *string                        `json:"contractAddress_starts_with,omitempty"`
	ContractAddressNotStartsWith *string                        `json:"contractAddress_not_starts_with,omitempty"`
	ContractAddressEndsWith      *string                        `json:"contractAddress_ends_with,omitempty"`
	ContractAddressNotEndsWith   *string                        `json:"contractAddress_not_ends_with,omitempty"`
	Amount                       *float64                       `json:"amount,omitempty"`
	AmountNot                    *float64                       `json:"amount_not,omitempty"`
	AmountIn                     []float64                      `json:"amount_in,omitempty"`
	AmountNotIn                  []float64                      `json:"amount_not_in,omitempty"`
	AmountLt                     *float64                       `json:"amount_lt,omitempty"`
	AmountLte                    *float64                       `json:"amount_lte,omitempty"`
	AmountGt                     *float64                       `json:"amount_gt,omitempty"`
	AmountGte                    *float64                       `json:"amount_gte,omitempty"`
	Owner                        *UserWhereInput                `json:"owner,omitempty"`
	LatestBlock                  *int32                         `json:"latestBlock,omitempty"`
	LatestBlockNot               *int32                         `json:"latestBlock_not,omitempty"`
	LatestBlockIn                []int32                        `json:"latestBlock_in,omitempty"`
	LatestBlockNotIn             []int32                        `json:"latestBlock_not_in,omitempty"`
	LatestBlockLt                *int32                         `json:"latestBlock_lt,omitempty"`
	LatestBlockLte               *int32                         `json:"latestBlock_lte,omitempty"`
	LatestBlockGt                *int32                         `json:"latestBlock_gt,omitempty"`
	LatestBlockGte               *int32                         `json:"latestBlock_gte,omitempty"`
	HistoriesEvery               *AergoAccountHistoryWhereInput `json:"histories_every,omitempty"`
	HistoriesSome                *AergoAccountHistoryWhereInput `json:"histories_some,omitempty"`
	HistoriesNone                *AergoAccountHistoryWhereInput `json:"histories_none,omitempty"`
	CreatedAt                    *string                        `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                        `json:"updatedAt_gte,omitempty"`
	And                          []AergoAccountWhereInput       `json:"AND,omitempty"`
	Or                           []AergoAccountWhereInput       `json:"OR,omitempty"`
	Not                          []AergoAccountWhereInput       `json:"NOT,omitempty"`
}

type AirDropHistoryWhereInput struct {
	ID                       *string                    `json:"id,omitempty"`
	IDNot                    *string                    `json:"id_not,omitempty"`
	IDIn                     []string                   `json:"id_in,omitempty"`
	IDNotIn                  []string                   `json:"id_not_in,omitempty"`
	IDLt                     *string                    `json:"id_lt,omitempty"`
	IDLte                    *string                    `json:"id_lte,omitempty"`
	IDGt                     *string                    `json:"id_gt,omitempty"`
	IDGte                    *string                    `json:"id_gte,omitempty"`
	IDContains               *string                    `json:"id_contains,omitempty"`
	IDNotContains            *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                    `json:"id_not_ends_with,omitempty"`
	Type                     *int32                     `json:"type,omitempty"`
	TypeNot                  *int32                     `json:"type_not,omitempty"`
	TypeIn                   []int32                    `json:"type_in,omitempty"`
	TypeNotIn                []int32                    `json:"type_not_in,omitempty"`
	TypeLt                   *int32                     `json:"type_lt,omitempty"`
	TypeLte                  *int32                     `json:"type_lte,omitempty"`
	TypeGt                   *int32                     `json:"type_gt,omitempty"`
	TypeGte                  *int32                     `json:"type_gte,omitempty"`
	Description              *string                    `json:"description,omitempty"`
	DescriptionNot           *string                    `json:"description_not,omitempty"`
	DescriptionIn            []string                   `json:"description_in,omitempty"`
	DescriptionNotIn         []string                   `json:"description_not_in,omitempty"`
	DescriptionLt            *string                    `json:"description_lt,omitempty"`
	DescriptionLte           *string                    `json:"description_lte,omitempty"`
	DescriptionGt            *string                    `json:"description_gt,omitempty"`
	DescriptionGte           *string                    `json:"description_gte,omitempty"`
	DescriptionContains      *string                    `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                    `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                    `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                    `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                    `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                    `json:"description_not_ends_with,omitempty"`
	User                     *UserWhereInput            `json:"user,omitempty"`
	MotherHistory            *MotherHistoryWhereInput   `json:"motherHistory,omitempty"`
	AirDrop                  *AirDropWhereInput         `json:"airDrop,omitempty"`
	AirDropMember            *AirDropMemberWhereInput   `json:"airDropMember,omitempty"`
	Qty                      *float64                   `json:"qty,omitempty"`
	QtyNot                   *float64                   `json:"qty_not,omitempty"`
	QtyIn                    []float64                  `json:"qty_in,omitempty"`
	QtyNotIn                 []float64                  `json:"qty_not_in,omitempty"`
	QtyLt                    *float64                   `json:"qty_lt,omitempty"`
	QtyLte                   *float64                   `json:"qty_lte,omitempty"`
	QtyGt                    *float64                   `json:"qty_gt,omitempty"`
	QtyGte                   *float64                   `json:"qty_gte,omitempty"`
	CurrentPrice             *float64                   `json:"currentPrice,omitempty"`
	CurrentPriceNot          *float64                   `json:"currentPrice_not,omitempty"`
	CurrentPriceIn           []float64                  `json:"currentPrice_in,omitempty"`
	CurrentPriceNotIn        []float64                  `json:"currentPrice_not_in,omitempty"`
	CurrentPriceLt           *float64                   `json:"currentPrice_lt,omitempty"`
	CurrentPriceLte          *float64                   `json:"currentPrice_lte,omitempty"`
	CurrentPriceGt           *float64                   `json:"currentPrice_gt,omitempty"`
	CurrentPriceGte          *float64                   `json:"currentPrice_gte,omitempty"`
	Memo                     *string                    `json:"memo,omitempty"`
	MemoNot                  *string                    `json:"memo_not,omitempty"`
	MemoIn                   []string                   `json:"memo_in,omitempty"`
	MemoNotIn                []string                   `json:"memo_not_in,omitempty"`
	MemoLt                   *string                    `json:"memo_lt,omitempty"`
	MemoLte                  *string                    `json:"memo_lte,omitempty"`
	MemoGt                   *string                    `json:"memo_gt,omitempty"`
	MemoGte                  *string                    `json:"memo_gte,omitempty"`
	MemoContains             *string                    `json:"memo_contains,omitempty"`
	MemoNotContains          *string                    `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                    `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                    `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                    `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                    `json:"memo_not_ends_with,omitempty"`
	CreatedAt                *string                    `json:"createdAt,omitempty"`
	CreatedAtNot             *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                    `json:"updatedAt_gte,omitempty"`
	And                      []AirDropHistoryWhereInput `json:"AND,omitempty"`
	Or                       []AirDropHistoryWhereInput `json:"OR,omitempty"`
	Not                      []AirDropHistoryWhereInput `json:"NOT,omitempty"`
}

type AirDropWhereInput struct {
	ID                             *string                   `json:"id,omitempty"`
	IDNot                          *string                   `json:"id_not,omitempty"`
	IDIn                           []string                  `json:"id_in,omitempty"`
	IDNotIn                        []string                  `json:"id_not_in,omitempty"`
	IDLt                           *string                   `json:"id_lt,omitempty"`
	IDLte                          *string                   `json:"id_lte,omitempty"`
	IDGt                           *string                   `json:"id_gt,omitempty"`
	IDGte                          *string                   `json:"id_gte,omitempty"`
	IDContains                     *string                   `json:"id_contains,omitempty"`
	IDNotContains                  *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                   `json:"id_not_ends_with,omitempty"`
	Status                         *int32                    `json:"status,omitempty"`
	StatusNot                      *int32                    `json:"status_not,omitempty"`
	StatusIn                       []int32                   `json:"status_in,omitempty"`
	StatusNotIn                    []int32                   `json:"status_not_in,omitempty"`
	StatusLt                       *int32                    `json:"status_lt,omitempty"`
	StatusLte                      *int32                    `json:"status_lte,omitempty"`
	StatusGt                       *int32                    `json:"status_gt,omitempty"`
	StatusGte                      *int32                    `json:"status_gte,omitempty"`
	Post                           *PostWhereInput           `json:"post,omitempty"`
	DeployTxhash                   *string                   `json:"deployTxhash,omitempty"`
	DeployTxhashNot                *string                   `json:"deployTxhash_not,omitempty"`
	DeployTxhashIn                 []string                  `json:"deployTxhash_in,omitempty"`
	DeployTxhashNotIn              []string                  `json:"deployTxhash_not_in,omitempty"`
	DeployTxhashLt                 *string                   `json:"deployTxhash_lt,omitempty"`
	DeployTxhashLte                *string                   `json:"deployTxhash_lte,omitempty"`
	DeployTxhashGt                 *string                   `json:"deployTxhash_gt,omitempty"`
	DeployTxhashGte                *string                   `json:"deployTxhash_gte,omitempty"`
	DeployTxhashContains           *string                   `json:"deployTxhash_contains,omitempty"`
	DeployTxhashNotContains        *string                   `json:"deployTxhash_not_contains,omitempty"`
	DeployTxhashStartsWith         *string                   `json:"deployTxhash_starts_with,omitempty"`
	DeployTxhashNotStartsWith      *string                   `json:"deployTxhash_not_starts_with,omitempty"`
	DeployTxhashEndsWith           *string                   `json:"deployTxhash_ends_with,omitempty"`
	DeployTxhashNotEndsWith        *string                   `json:"deployTxhash_not_ends_with,omitempty"`
	ContractAddress                *string                   `json:"contractAddress,omitempty"`
	ContractAddressNot             *string                   `json:"contractAddress_not,omitempty"`
	ContractAddressIn              []string                  `json:"contractAddress_in,omitempty"`
	ContractAddressNotIn           []string                  `json:"contractAddress_not_in,omitempty"`
	ContractAddressLt              *string                   `json:"contractAddress_lt,omitempty"`
	ContractAddressLte             *string                   `json:"contractAddress_lte,omitempty"`
	ContractAddressGt              *string                   `json:"contractAddress_gt,omitempty"`
	ContractAddressGte             *string                   `json:"contractAddress_gte,omitempty"`
	ContractAddressContains        *string                   `json:"contractAddress_contains,omitempty"`
	ContractAddressNotContains     *string                   `json:"contractAddress_not_contains,omitempty"`
	ContractAddressStartsWith      *string                   `json:"contractAddress_starts_with,omitempty"`
	ContractAddressNotStartsWith   *string                   `json:"contractAddress_not_starts_with,omitempty"`
	ContractAddressEndsWith        *string                   `json:"contractAddress_ends_with,omitempty"`
	ContractAddressNotEndsWith     *string                   `json:"contractAddress_not_ends_with,omitempty"`
	RandomArrayString              *string                   `json:"randomArrayString,omitempty"`
	RandomArrayStringNot           *string                   `json:"randomArrayString_not,omitempty"`
	RandomArrayStringIn            []string                  `json:"randomArrayString_in,omitempty"`
	RandomArrayStringNotIn         []string                  `json:"randomArrayString_not_in,omitempty"`
	RandomArrayStringLt            *string                   `json:"randomArrayString_lt,omitempty"`
	RandomArrayStringLte           *string                   `json:"randomArrayString_lte,omitempty"`
	RandomArrayStringGt            *string                   `json:"randomArrayString_gt,omitempty"`
	RandomArrayStringGte           *string                   `json:"randomArrayString_gte,omitempty"`
	RandomArrayStringContains      *string                   `json:"randomArrayString_contains,omitempty"`
	RandomArrayStringNotContains   *string                   `json:"randomArrayString_not_contains,omitempty"`
	RandomArrayStringStartsWith    *string                   `json:"randomArrayString_starts_with,omitempty"`
	RandomArrayStringNotStartsWith *string                   `json:"randomArrayString_not_starts_with,omitempty"`
	RandomArrayStringEndsWith      *string                   `json:"randomArrayString_ends_with,omitempty"`
	RandomArrayStringNotEndsWith   *string                   `json:"randomArrayString_not_ends_with,omitempty"`
	Amount                         *float64                  `json:"amount,omitempty"`
	AmountNot                      *float64                  `json:"amount_not,omitempty"`
	AmountIn                       []float64                 `json:"amount_in,omitempty"`
	AmountNotIn                    []float64                 `json:"amount_not_in,omitempty"`
	AmountLt                       *float64                  `json:"amount_lt,omitempty"`
	AmountLte                      *float64                  `json:"amount_lte,omitempty"`
	AmountGt                       *float64                  `json:"amount_gt,omitempty"`
	AmountGte                      *float64                  `json:"amount_gte,omitempty"`
	Left                           *float64                  `json:"left,omitempty"`
	LeftNot                        *float64                  `json:"left_not,omitempty"`
	LeftIn                         []float64                 `json:"left_in,omitempty"`
	LeftNotIn                      []float64                 `json:"left_not_in,omitempty"`
	LeftLt                         *float64                  `json:"left_lt,omitempty"`
	LeftLte                        *float64                  `json:"left_lte,omitempty"`
	LeftGt                         *float64                  `json:"left_gt,omitempty"`
	LeftGte                        *float64                  `json:"left_gte,omitempty"`
	MembersEvery                   *AirDropMemberWhereInput  `json:"members_every,omitempty"`
	MembersSome                    *AirDropMemberWhereInput  `json:"members_some,omitempty"`
	MembersNone                    *AirDropMemberWhereInput  `json:"members_none,omitempty"`
	ToDate                         *string                   `json:"toDate,omitempty"`
	ToDateNot                      *string                   `json:"toDate_not,omitempty"`
	ToDateIn                       []string                  `json:"toDate_in,omitempty"`
	ToDateNotIn                    []string                  `json:"toDate_not_in,omitempty"`
	ToDateLt                       *string                   `json:"toDate_lt,omitempty"`
	ToDateLte                      *string                   `json:"toDate_lte,omitempty"`
	ToDateGt                       *string                   `json:"toDate_gt,omitempty"`
	ToDateGte                      *string                   `json:"toDate_gte,omitempty"`
	AirDropHistoriesEvery          *AirDropHistoryWhereInput `json:"airDropHistories_every,omitempty"`
	AirDropHistoriesSome           *AirDropHistoryWhereInput `json:"airDropHistories_some,omitempty"`
	AirDropHistoriesNone           *AirDropHistoryWhereInput `json:"airDropHistories_none,omitempty"`
	CreatedAt                      *string                   `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                   `json:"updatedAt_gte,omitempty"`
	IsDel                          *bool                     `json:"isDel,omitempty"`
	IsDelNot                       *bool                     `json:"isDel_not,omitempty"`
	And                            []AirDropWhereInput       `json:"AND,omitempty"`
	Or                             []AirDropWhereInput       `json:"OR,omitempty"`
	Not                            []AirDropWhereInput       `json:"NOT,omitempty"`
}

type AirDropMemberWhereInput struct {
	ID              *string                   `json:"id,omitempty"`
	IDNot           *string                   `json:"id_not,omitempty"`
	IDIn            []string                  `json:"id_in,omitempty"`
	IDNotIn         []string                  `json:"id_not_in,omitempty"`
	IDLt            *string                   `json:"id_lt,omitempty"`
	IDLte           *string                   `json:"id_lte,omitempty"`
	IDGt            *string                   `json:"id_gt,omitempty"`
	IDGte           *string                   `json:"id_gte,omitempty"`
	IDContains      *string                   `json:"id_contains,omitempty"`
	IDNotContains   *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                   `json:"id_not_ends_with,omitempty"`
	AirDrop         *AirDropWhereInput        `json:"airDrop,omitempty"`
	User            *UserWhereInput           `json:"user,omitempty"`
	DropNum         *int32                    `json:"dropNum,omitempty"`
	DropNumNot      *int32                    `json:"dropNum_not,omitempty"`
	DropNumIn       []int32                   `json:"dropNum_in,omitempty"`
	DropNumNotIn    []int32                   `json:"dropNum_not_in,omitempty"`
	DropNumLt       *int32                    `json:"dropNum_lt,omitempty"`
	DropNumLte      *int32                    `json:"dropNum_lte,omitempty"`
	DropNumGt       *int32                    `json:"dropNum_gt,omitempty"`
	DropNumGte      *int32                    `json:"dropNum_gte,omitempty"`
	Qty             *float64                  `json:"qty,omitempty"`
	QtyNot          *float64                  `json:"qty_not,omitempty"`
	QtyIn           []float64                 `json:"qty_in,omitempty"`
	QtyNotIn        []float64                 `json:"qty_not_in,omitempty"`
	QtyLt           *float64                  `json:"qty_lt,omitempty"`
	QtyLte          *float64                  `json:"qty_lte,omitempty"`
	QtyGt           *float64                  `json:"qty_gt,omitempty"`
	QtyGte          *float64                  `json:"qty_gte,omitempty"`
	AirDropHistory  *AirDropHistoryWhereInput `json:"airDropHistory,omitempty"`
	CreatedAt       *string                   `json:"createdAt,omitempty"`
	CreatedAtNot    *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                   `json:"updatedAt_gte,omitempty"`
	IsDel           *bool                     `json:"isDel,omitempty"`
	IsDelNot        *bool                     `json:"isDel_not,omitempty"`
	And             []AirDropMemberWhereInput `json:"AND,omitempty"`
	Or              []AirDropMemberWhereInput `json:"OR,omitempty"`
	Not             []AirDropMemberWhereInput `json:"NOT,omitempty"`
}

type PostRewardHistoryWhereInput struct {
	ID                       *string                       `json:"id,omitempty"`
	IDNot                    *string                       `json:"id_not,omitempty"`
	IDIn                     []string                      `json:"id_in,omitempty"`
	IDNotIn                  []string                      `json:"id_not_in,omitempty"`
	IDLt                     *string                       `json:"id_lt,omitempty"`
	IDLte                    *string                       `json:"id_lte,omitempty"`
	IDGt                     *string                       `json:"id_gt,omitempty"`
	IDGte                    *string                       `json:"id_gte,omitempty"`
	IDContains               *string                       `json:"id_contains,omitempty"`
	IDNotContains            *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                       `json:"id_not_ends_with,omitempty"`
	Type                     *int32                        `json:"type,omitempty"`
	TypeNot                  *int32                        `json:"type_not,omitempty"`
	TypeIn                   []int32                       `json:"type_in,omitempty"`
	TypeNotIn                []int32                       `json:"type_not_in,omitempty"`
	TypeLt                   *int32                        `json:"type_lt,omitempty"`
	TypeLte                  *int32                        `json:"type_lte,omitempty"`
	TypeGt                   *int32                        `json:"type_gt,omitempty"`
	TypeGte                  *int32                        `json:"type_gte,omitempty"`
	Description              *string                       `json:"description,omitempty"`
	DescriptionNot           *string                       `json:"description_not,omitempty"`
	DescriptionIn            []string                      `json:"description_in,omitempty"`
	DescriptionNotIn         []string                      `json:"description_not_in,omitempty"`
	DescriptionLt            *string                       `json:"description_lt,omitempty"`
	DescriptionLte           *string                       `json:"description_lte,omitempty"`
	DescriptionGt            *string                       `json:"description_gt,omitempty"`
	DescriptionGte           *string                       `json:"description_gte,omitempty"`
	DescriptionContains      *string                       `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                       `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                       `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                       `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                       `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                       `json:"description_not_ends_with,omitempty"`
	User                     *UserWhereInput               `json:"user,omitempty"`
	Post                     *PostWhereInput               `json:"post,omitempty"`
	MotherHistory            *MotherHistoryWhereInput      `json:"motherHistory,omitempty"`
	Comment                  *CommentWhereInput            `json:"comment,omitempty"`
	Qty                      *float64                      `json:"qty,omitempty"`
	QtyNot                   *float64                      `json:"qty_not,omitempty"`
	QtyIn                    []float64                     `json:"qty_in,omitempty"`
	QtyNotIn                 []float64                     `json:"qty_not_in,omitempty"`
	QtyLt                    *float64                      `json:"qty_lt,omitempty"`
	QtyLte                   *float64                      `json:"qty_lte,omitempty"`
	QtyGt                    *float64                      `json:"qty_gt,omitempty"`
	QtyGte                   *float64                      `json:"qty_gte,omitempty"`
	CurrentPrice             *float64                      `json:"currentPrice,omitempty"`
	CurrentPriceNot          *float64                      `json:"currentPrice_not,omitempty"`
	CurrentPriceIn           []float64                     `json:"currentPrice_in,omitempty"`
	CurrentPriceNotIn        []float64                     `json:"currentPrice_not_in,omitempty"`
	CurrentPriceLt           *float64                      `json:"currentPrice_lt,omitempty"`
	CurrentPriceLte          *float64                      `json:"currentPrice_lte,omitempty"`
	CurrentPriceGt           *float64                      `json:"currentPrice_gt,omitempty"`
	CurrentPriceGte          *float64                      `json:"currentPrice_gte,omitempty"`
	Memo                     *string                       `json:"memo,omitempty"`
	MemoNot                  *string                       `json:"memo_not,omitempty"`
	MemoIn                   []string                      `json:"memo_in,omitempty"`
	MemoNotIn                []string                      `json:"memo_not_in,omitempty"`
	MemoLt                   *string                       `json:"memo_lt,omitempty"`
	MemoLte                  *string                       `json:"memo_lte,omitempty"`
	MemoGt                   *string                       `json:"memo_gt,omitempty"`
	MemoGte                  *string                       `json:"memo_gte,omitempty"`
	MemoContains             *string                       `json:"memo_contains,omitempty"`
	MemoNotContains          *string                       `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                       `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                       `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                       `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                       `json:"memo_not_ends_with,omitempty"`
	CreatedAt                *string                       `json:"createdAt,omitempty"`
	CreatedAtNot             *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                       `json:"updatedAt_gte,omitempty"`
	And                      []PostRewardHistoryWhereInput `json:"AND,omitempty"`
	Or                       []PostRewardHistoryWhereInput `json:"OR,omitempty"`
	Not                      []PostRewardHistoryWhereInput `json:"NOT,omitempty"`
}

type CommentWhereInput struct {
	ID                   *string                      `json:"id,omitempty"`
	IDNot                *string                      `json:"id_not,omitempty"`
	IDIn                 []string                     `json:"id_in,omitempty"`
	IDNotIn              []string                     `json:"id_not_in,omitempty"`
	IDLt                 *string                      `json:"id_lt,omitempty"`
	IDLte                *string                      `json:"id_lte,omitempty"`
	IDGt                 *string                      `json:"id_gt,omitempty"`
	IDGte                *string                      `json:"id_gte,omitempty"`
	IDContains           *string                      `json:"id_contains,omitempty"`
	IDNotContains        *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                      `json:"id_not_ends_with,omitempty"`
	Type                 *int32                       `json:"type,omitempty"`
	TypeNot              *int32                       `json:"type_not,omitempty"`
	TypeIn               []int32                      `json:"type_in,omitempty"`
	TypeNotIn            []int32                      `json:"type_not_in,omitempty"`
	TypeLt               *int32                       `json:"type_lt,omitempty"`
	TypeLte              *int32                       `json:"type_lte,omitempty"`
	TypeGt               *int32                       `json:"type_gt,omitempty"`
	TypeGte              *int32                       `json:"type_gte,omitempty"`
	Post                 *PostWhereInput              `json:"post,omitempty"`
	Content              *string                      `json:"content,omitempty"`
	ContentNot           *string                      `json:"content_not,omitempty"`
	ContentIn            []string                     `json:"content_in,omitempty"`
	ContentNotIn         []string                     `json:"content_not_in,omitempty"`
	ContentLt            *string                      `json:"content_lt,omitempty"`
	ContentLte           *string                      `json:"content_lte,omitempty"`
	ContentGt            *string                      `json:"content_gt,omitempty"`
	ContentGte           *string                      `json:"content_gte,omitempty"`
	ContentContains      *string                      `json:"content_contains,omitempty"`
	ContentNotContains   *string                      `json:"content_not_contains,omitempty"`
	ContentStartsWith    *string                      `json:"content_starts_with,omitempty"`
	ContentNotStartsWith *string                      `json:"content_not_starts_with,omitempty"`
	ContentEndsWith      *string                      `json:"content_ends_with,omitempty"`
	ContentNotEndsWith   *string                      `json:"content_not_ends_with,omitempty"`
	Image                *FileInfoWhereInput          `json:"image,omitempty"`
	Url                  *string                      `json:"url,omitempty"`
	UrlNot               *string                      `json:"url_not,omitempty"`
	UrlIn                []string                     `json:"url_in,omitempty"`
	UrlNotIn             []string                     `json:"url_not_in,omitempty"`
	UrlLt                *string                      `json:"url_lt,omitempty"`
	UrlLte               *string                      `json:"url_lte,omitempty"`
	UrlGt                *string                      `json:"url_gt,omitempty"`
	UrlGte               *string                      `json:"url_gte,omitempty"`
	UrlContains          *string                      `json:"url_contains,omitempty"`
	UrlNotContains       *string                      `json:"url_not_contains,omitempty"`
	UrlStartsWith        *string                      `json:"url_starts_with,omitempty"`
	UrlNotStartsWith     *string                      `json:"url_not_starts_with,omitempty"`
	UrlEndsWith          *string                      `json:"url_ends_with,omitempty"`
	UrlNotEndsWith       *string                      `json:"url_not_ends_with,omitempty"`
	ReplyEvery           *CommentReplyWhereInput      `json:"reply_every,omitempty"`
	ReplySome            *CommentReplyWhereInput      `json:"reply_some,omitempty"`
	ReplyNone            *CommentReplyWhereInput      `json:"reply_none,omitempty"`
	Owner                *UserWhereInput              `json:"owner,omitempty"`
	PostRewardHistory    *PostRewardHistoryWhereInput `json:"postRewardHistory,omitempty"`
	CreatedAt            *string                      `json:"createdAt,omitempty"`
	CreatedAtNot         *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                      `json:"updatedAt_gte,omitempty"`
	IsDel                *bool                        `json:"isDel,omitempty"`
	IsDelNot             *bool                        `json:"isDel_not,omitempty"`
	And                  []CommentWhereInput          `json:"AND,omitempty"`
	Or                   []CommentWhereInput          `json:"OR,omitempty"`
	Not                  []CommentWhereInput          `json:"NOT,omitempty"`
}

type CommentReplyWhereInput struct {
	ID                   *string                  `json:"id,omitempty"`
	IDNot                *string                  `json:"id_not,omitempty"`
	IDIn                 []string                 `json:"id_in,omitempty"`
	IDNotIn              []string                 `json:"id_not_in,omitempty"`
	IDLt                 *string                  `json:"id_lt,omitempty"`
	IDLte                *string                  `json:"id_lte,omitempty"`
	IDGt                 *string                  `json:"id_gt,omitempty"`
	IDGte                *string                  `json:"id_gte,omitempty"`
	IDContains           *string                  `json:"id_contains,omitempty"`
	IDNotContains        *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                  `json:"id_not_ends_with,omitempty"`
	Comment              *CommentWhereInput       `json:"comment,omitempty"`
	Content              *string                  `json:"content,omitempty"`
	ContentNot           *string                  `json:"content_not,omitempty"`
	ContentIn            []string                 `json:"content_in,omitempty"`
	ContentNotIn         []string                 `json:"content_not_in,omitempty"`
	ContentLt            *string                  `json:"content_lt,omitempty"`
	ContentLte           *string                  `json:"content_lte,omitempty"`
	ContentGt            *string                  `json:"content_gt,omitempty"`
	ContentGte           *string                  `json:"content_gte,omitempty"`
	ContentContains      *string                  `json:"content_contains,omitempty"`
	ContentNotContains   *string                  `json:"content_not_contains,omitempty"`
	ContentStartsWith    *string                  `json:"content_starts_with,omitempty"`
	ContentNotStartsWith *string                  `json:"content_not_starts_with,omitempty"`
	ContentEndsWith      *string                  `json:"content_ends_with,omitempty"`
	ContentNotEndsWith   *string                  `json:"content_not_ends_with,omitempty"`
	Owner                *UserWhereInput          `json:"owner,omitempty"`
	CreatedAt            *string                  `json:"createdAt,omitempty"`
	CreatedAtNot         *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                  `json:"updatedAt_gte,omitempty"`
	IsDel                *bool                    `json:"isDel,omitempty"`
	IsDelNot             *bool                    `json:"isDel_not,omitempty"`
	And                  []CommentReplyWhereInput `json:"AND,omitempty"`
	Or                   []CommentReplyWhereInput `json:"OR,omitempty"`
	Not                  []CommentReplyWhereInput `json:"NOT,omitempty"`
}

type OrderDealsHistoryWhereInput struct {
	ID              *string                       `json:"id,omitempty"`
	IDNot           *string                       `json:"id_not,omitempty"`
	IDIn            []string                      `json:"id_in,omitempty"`
	IDNotIn         []string                      `json:"id_not_in,omitempty"`
	IDLt            *string                       `json:"id_lt,omitempty"`
	IDLte           *string                       `json:"id_lte,omitempty"`
	IDGt            *string                       `json:"id_gt,omitempty"`
	IDGte           *string                       `json:"id_gte,omitempty"`
	IDContains      *string                       `json:"id_contains,omitempty"`
	IDNotContains   *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                       `json:"id_not_ends_with,omitempty"`
	Type            *int32                        `json:"type,omitempty"`
	TypeNot         *int32                        `json:"type_not,omitempty"`
	TypeIn          []int32                       `json:"type_in,omitempty"`
	TypeNotIn       []int32                       `json:"type_not_in,omitempty"`
	TypeLt          *int32                        `json:"type_lt,omitempty"`
	TypeLte         *int32                        `json:"type_lte,omitempty"`
	TypeGt          *int32                        `json:"type_gt,omitempty"`
	TypeGte         *int32                        `json:"type_gte,omitempty"`
	DealId          *int32                        `json:"dealId,omitempty"`
	DealIdNot       *int32                        `json:"dealId_not,omitempty"`
	DealIdIn        []int32                       `json:"dealId_in,omitempty"`
	DealIdNotIn     []int32                       `json:"dealId_not_in,omitempty"`
	DealIdLt        *int32                        `json:"dealId_lt,omitempty"`
	DealIdLte       *int32                        `json:"dealId_lte,omitempty"`
	DealIdGt        *int32                        `json:"dealId_gt,omitempty"`
	DealIdGte       *int32                        `json:"dealId_gte,omitempty"`
	Coin            *CoinWhereInput               `json:"coin,omitempty"`
	DealPrice       *float64                      `json:"dealPrice,omitempty"`
	DealPriceNot    *float64                      `json:"dealPrice_not,omitempty"`
	DealPriceIn     []float64                     `json:"dealPrice_in,omitempty"`
	DealPriceNotIn  []float64                     `json:"dealPrice_not_in,omitempty"`
	DealPriceLt     *float64                      `json:"dealPrice_lt,omitempty"`
	DealPriceLte    *float64                      `json:"dealPrice_lte,omitempty"`
	DealPriceGt     *float64                      `json:"dealPrice_gt,omitempty"`
	DealPriceGte    *float64                      `json:"dealPrice_gte,omitempty"`
	DealQty         *float64                      `json:"dealQty,omitempty"`
	DealQtyNot      *float64                      `json:"dealQty_not,omitempty"`
	DealQtyIn       []float64                     `json:"dealQty_in,omitempty"`
	DealQtyNotIn    []float64                     `json:"dealQty_not_in,omitempty"`
	DealQtyLt       *float64                      `json:"dealQty_lt,omitempty"`
	DealQtyLte      *float64                      `json:"dealQty_lte,omitempty"`
	DealQtyGt       *float64                      `json:"dealQty_gt,omitempty"`
	DealQtyGte      *float64                      `json:"dealQty_gte,omitempty"`
	Time            *float64                      `json:"time,omitempty"`
	TimeNot         *float64                      `json:"time_not,omitempty"`
	TimeIn          []float64                     `json:"time_in,omitempty"`
	TimeNotIn       []float64                     `json:"time_not_in,omitempty"`
	TimeLt          *float64                      `json:"time_lt,omitempty"`
	TimeLte         *float64                      `json:"time_lte,omitempty"`
	TimeGt          *float64                      `json:"time_gt,omitempty"`
	TimeGte         *float64                      `json:"time_gte,omitempty"`
	CreatedAt       *string                       `json:"createdAt,omitempty"`
	CreatedAtNot    *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                       `json:"updatedAt_gte,omitempty"`
	And             []OrderDealsHistoryWhereInput `json:"AND,omitempty"`
	Or              []OrderDealsHistoryWhereInput `json:"OR,omitempty"`
	Not             []OrderDealsHistoryWhereInput `json:"NOT,omitempty"`
}

type CoinPriceTableWhereInput struct {
	ID              *string                    `json:"id,omitempty"`
	IDNot           *string                    `json:"id_not,omitempty"`
	IDIn            []string                   `json:"id_in,omitempty"`
	IDNotIn         []string                   `json:"id_not_in,omitempty"`
	IDLt            *string                    `json:"id_lt,omitempty"`
	IDLte           *string                    `json:"id_lte,omitempty"`
	IDGt            *string                    `json:"id_gt,omitempty"`
	IDGte           *string                    `json:"id_gte,omitempty"`
	IDContains      *string                    `json:"id_contains,omitempty"`
	IDNotContains   *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                    `json:"id_not_ends_with,omitempty"`
	Type            *int32                     `json:"type,omitempty"`
	TypeNot         *int32                     `json:"type_not,omitempty"`
	TypeIn          []int32                    `json:"type_in,omitempty"`
	TypeNotIn       []int32                    `json:"type_not_in,omitempty"`
	TypeLt          *int32                     `json:"type_lt,omitempty"`
	TypeLte         *int32                     `json:"type_lte,omitempty"`
	TypeGt          *int32                     `json:"type_gt,omitempty"`
	TypeGte         *int32                     `json:"type_gte,omitempty"`
	Coin            *CoinWhereInput            `json:"coin,omitempty"`
	CreatedAt       *string                    `json:"createdAt,omitempty"`
	CreatedAtNot    *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                    `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                    `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                    `json:"updatedAt_gte,omitempty"`
	And             []CoinPriceTableWhereInput `json:"AND,omitempty"`
	Or              []CoinPriceTableWhereInput `json:"OR,omitempty"`
	Not             []CoinPriceTableWhereInput `json:"NOT,omitempty"`
}

type CoinKlineWhereInput struct {
	ID              *string               `json:"id,omitempty"`
	IDNot           *string               `json:"id_not,omitempty"`
	IDIn            []string              `json:"id_in,omitempty"`
	IDNotIn         []string              `json:"id_not_in,omitempty"`
	IDLt            *string               `json:"id_lt,omitempty"`
	IDLte           *string               `json:"id_lte,omitempty"`
	IDGt            *string               `json:"id_gt,omitempty"`
	IDGte           *string               `json:"id_gte,omitempty"`
	IDContains      *string               `json:"id_contains,omitempty"`
	IDNotContains   *string               `json:"id_not_contains,omitempty"`
	IDStartsWith    *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string               `json:"id_not_ends_with,omitempty"`
	Open            *float64              `json:"open,omitempty"`
	OpenNot         *float64              `json:"open_not,omitempty"`
	OpenIn          []float64             `json:"open_in,omitempty"`
	OpenNotIn       []float64             `json:"open_not_in,omitempty"`
	OpenLt          *float64              `json:"open_lt,omitempty"`
	OpenLte         *float64              `json:"open_lte,omitempty"`
	OpenGt          *float64              `json:"open_gt,omitempty"`
	OpenGte         *float64              `json:"open_gte,omitempty"`
	Close           *float64              `json:"close,omitempty"`
	CloseNot        *float64              `json:"close_not,omitempty"`
	CloseIn         []float64             `json:"close_in,omitempty"`
	CloseNotIn      []float64             `json:"close_not_in,omitempty"`
	CloseLt         *float64              `json:"close_lt,omitempty"`
	CloseLte        *float64              `json:"close_lte,omitempty"`
	CloseGt         *float64              `json:"close_gt,omitempty"`
	CloseGte        *float64              `json:"close_gte,omitempty"`
	High            *float64              `json:"high,omitempty"`
	HighNot         *float64              `json:"high_not,omitempty"`
	HighIn          []float64             `json:"high_in,omitempty"`
	HighNotIn       []float64             `json:"high_not_in,omitempty"`
	HighLt          *float64              `json:"high_lt,omitempty"`
	HighLte         *float64              `json:"high_lte,omitempty"`
	HighGt          *float64              `json:"high_gt,omitempty"`
	HighGte         *float64              `json:"high_gte,omitempty"`
	Low             *float64              `json:"low,omitempty"`
	LowNot          *float64              `json:"low_not,omitempty"`
	LowIn           []float64             `json:"low_in,omitempty"`
	LowNotIn        []float64             `json:"low_not_in,omitempty"`
	LowLt           *float64              `json:"low_lt,omitempty"`
	LowLte          *float64              `json:"low_lte,omitempty"`
	LowGt           *float64              `json:"low_gt,omitempty"`
	LowGte          *float64              `json:"low_gte,omitempty"`
	Volume          *float64              `json:"volume,omitempty"`
	VolumeNot       *float64              `json:"volume_not,omitempty"`
	VolumeIn        []float64             `json:"volume_in,omitempty"`
	VolumeNotIn     []float64             `json:"volume_not_in,omitempty"`
	VolumeLt        *float64              `json:"volume_lt,omitempty"`
	VolumeLte       *float64              `json:"volume_lte,omitempty"`
	VolumeGt        *float64              `json:"volume_gt,omitempty"`
	VolumeGte       *float64              `json:"volume_gte,omitempty"`
	Deal            *float64              `json:"deal,omitempty"`
	DealNot         *float64              `json:"deal_not,omitempty"`
	DealIn          []float64             `json:"deal_in,omitempty"`
	DealNotIn       []float64             `json:"deal_not_in,omitempty"`
	DealLt          *float64              `json:"deal_lt,omitempty"`
	DealLte         *float64              `json:"deal_lte,omitempty"`
	DealGt          *float64              `json:"deal_gt,omitempty"`
	DealGte         *float64              `json:"deal_gte,omitempty"`
	Coin            *CoinWhereInput       `json:"coin,omitempty"`
	CreatedAt       *string               `json:"createdAt,omitempty"`
	CreatedAtNot    *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string               `json:"updatedAt_gte,omitempty"`
	And             []CoinKlineWhereInput `json:"AND,omitempty"`
	Or              []CoinKlineWhereInput `json:"OR,omitempty"`
	Not             []CoinKlineWhereInput `json:"NOT,omitempty"`
}

type QuestMemberWhereInput struct {
	ID                *string                 `json:"id,omitempty"`
	IDNot             *string                 `json:"id_not,omitempty"`
	IDIn              []string                `json:"id_in,omitempty"`
	IDNotIn           []string                `json:"id_not_in,omitempty"`
	IDLt              *string                 `json:"id_lt,omitempty"`
	IDLte             *string                 `json:"id_lte,omitempty"`
	IDGt              *string                 `json:"id_gt,omitempty"`
	IDGte             *string                 `json:"id_gte,omitempty"`
	IDContains        *string                 `json:"id_contains,omitempty"`
	IDNotContains     *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                 `json:"id_not_ends_with,omitempty"`
	Post              *PostWhereInput         `json:"post,omitempty"`
	User              *UserWhereInput         `json:"user,omitempty"`
	Note              *string                 `json:"note,omitempty"`
	NoteNot           *string                 `json:"note_not,omitempty"`
	NoteIn            []string                `json:"note_in,omitempty"`
	NoteNotIn         []string                `json:"note_not_in,omitempty"`
	NoteLt            *string                 `json:"note_lt,omitempty"`
	NoteLte           *string                 `json:"note_lte,omitempty"`
	NoteGt            *string                 `json:"note_gt,omitempty"`
	NoteGte           *string                 `json:"note_gte,omitempty"`
	NoteContains      *string                 `json:"note_contains,omitempty"`
	NoteNotContains   *string                 `json:"note_not_contains,omitempty"`
	NoteStartsWith    *string                 `json:"note_starts_with,omitempty"`
	NoteNotStartsWith *string                 `json:"note_not_starts_with,omitempty"`
	NoteEndsWith      *string                 `json:"note_ends_with,omitempty"`
	NoteNotEndsWith   *string                 `json:"note_not_ends_with,omitempty"`
	CreatedAt         *string                 `json:"createdAt,omitempty"`
	CreatedAtNot      *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                 `json:"createdAt_gte,omitempty"`
	IsDel             *bool                   `json:"isDel,omitempty"`
	IsDelNot          *bool                   `json:"isDel_not,omitempty"`
	And               []QuestMemberWhereInput `json:"AND,omitempty"`
	Or                []QuestMemberWhereInput `json:"OR,omitempty"`
	Not               []QuestMemberWhereInput `json:"NOT,omitempty"`
}

type UpdatePostHistoryWhereInput struct {
	ID                          *string                       `json:"id,omitempty"`
	IDNot                       *string                       `json:"id_not,omitempty"`
	IDIn                        []string                      `json:"id_in,omitempty"`
	IDNotIn                     []string                      `json:"id_not_in,omitempty"`
	IDLt                        *string                       `json:"id_lt,omitempty"`
	IDLte                       *string                       `json:"id_lte,omitempty"`
	IDGt                        *string                       `json:"id_gt,omitempty"`
	IDGte                       *string                       `json:"id_gte,omitempty"`
	IDContains                  *string                       `json:"id_contains,omitempty"`
	IDNotContains               *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                       `json:"id_not_ends_with,omitempty"`
	Action                      *int32                        `json:"action,omitempty"`
	ActionNot                   *int32                        `json:"action_not,omitempty"`
	ActionIn                    []int32                       `json:"action_in,omitempty"`
	ActionNotIn                 []int32                       `json:"action_not_in,omitempty"`
	ActionLt                    *int32                        `json:"action_lt,omitempty"`
	ActionLte                   *int32                        `json:"action_lte,omitempty"`
	ActionGt                    *int32                        `json:"action_gt,omitempty"`
	ActionGte                   *int32                        `json:"action_gte,omitempty"`
	Post                        *PostWhereInput               `json:"post,omitempty"`
	BeforeContent               *string                       `json:"beforeContent,omitempty"`
	BeforeContentNot            *string                       `json:"beforeContent_not,omitempty"`
	BeforeContentIn             []string                      `json:"beforeContent_in,omitempty"`
	BeforeContentNotIn          []string                      `json:"beforeContent_not_in,omitempty"`
	BeforeContentLt             *string                       `json:"beforeContent_lt,omitempty"`
	BeforeContentLte            *string                       `json:"beforeContent_lte,omitempty"`
	BeforeContentGt             *string                       `json:"beforeContent_gt,omitempty"`
	BeforeContentGte            *string                       `json:"beforeContent_gte,omitempty"`
	BeforeContentContains       *string                       `json:"beforeContent_contains,omitempty"`
	BeforeContentNotContains    *string                       `json:"beforeContent_not_contains,omitempty"`
	BeforeContentStartsWith     *string                       `json:"beforeContent_starts_with,omitempty"`
	BeforeContentNotStartsWith  *string                       `json:"beforeContent_not_starts_with,omitempty"`
	BeforeContentEndsWith       *string                       `json:"beforeContent_ends_with,omitempty"`
	BeforeContentNotEndsWith    *string                       `json:"beforeContent_not_ends_with,omitempty"`
	BeforeImageUrl              *string                       `json:"beforeImageUrl,omitempty"`
	BeforeImageUrlNot           *string                       `json:"beforeImageUrl_not,omitempty"`
	BeforeImageUrlIn            []string                      `json:"beforeImageUrl_in,omitempty"`
	BeforeImageUrlNotIn         []string                      `json:"beforeImageUrl_not_in,omitempty"`
	BeforeImageUrlLt            *string                       `json:"beforeImageUrl_lt,omitempty"`
	BeforeImageUrlLte           *string                       `json:"beforeImageUrl_lte,omitempty"`
	BeforeImageUrlGt            *string                       `json:"beforeImageUrl_gt,omitempty"`
	BeforeImageUrlGte           *string                       `json:"beforeImageUrl_gte,omitempty"`
	BeforeImageUrlContains      *string                       `json:"beforeImageUrl_contains,omitempty"`
	BeforeImageUrlNotContains   *string                       `json:"beforeImageUrl_not_contains,omitempty"`
	BeforeImageUrlStartsWith    *string                       `json:"beforeImageUrl_starts_with,omitempty"`
	BeforeImageUrlNotStartsWith *string                       `json:"beforeImageUrl_not_starts_with,omitempty"`
	BeforeImageUrlEndsWith      *string                       `json:"beforeImageUrl_ends_with,omitempty"`
	BeforeImageUrlNotEndsWith   *string                       `json:"beforeImageUrl_not_ends_with,omitempty"`
	User                        *UserWhereInput               `json:"user,omitempty"`
	Admin                       *AdminUserWhereInput          `json:"admin,omitempty"`
	CreatedAt                   *string                       `json:"createdAt,omitempty"`
	CreatedAtNot                *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                       `json:"createdAt_gte,omitempty"`
	And                         []UpdatePostHistoryWhereInput `json:"AND,omitempty"`
	Or                          []UpdatePostHistoryWhereInput `json:"OR,omitempty"`
	Not                         []UpdatePostHistoryWhereInput `json:"NOT,omitempty"`
}

type AdminUserWhereInput struct {
	ID                    *string                 `json:"id,omitempty"`
	IDNot                 *string                 `json:"id_not,omitempty"`
	IDIn                  []string                `json:"id_in,omitempty"`
	IDNotIn               []string                `json:"id_not_in,omitempty"`
	IDLt                  *string                 `json:"id_lt,omitempty"`
	IDLte                 *string                 `json:"id_lte,omitempty"`
	IDGt                  *string                 `json:"id_gt,omitempty"`
	IDGte                 *string                 `json:"id_gte,omitempty"`
	IDContains            *string                 `json:"id_contains,omitempty"`
	IDNotContains         *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                 `json:"id_not_ends_with,omitempty"`
	Role                  *Role                   `json:"role,omitempty"`
	RoleNot               *Role                   `json:"role_not,omitempty"`
	RoleIn                []Role                  `json:"role_in,omitempty"`
	RoleNotIn             []Role                  `json:"role_not_in,omitempty"`
	Email                 *string                 `json:"email,omitempty"`
	EmailNot              *string                 `json:"email_not,omitempty"`
	EmailIn               []string                `json:"email_in,omitempty"`
	EmailNotIn            []string                `json:"email_not_in,omitempty"`
	EmailLt               *string                 `json:"email_lt,omitempty"`
	EmailLte              *string                 `json:"email_lte,omitempty"`
	EmailGt               *string                 `json:"email_gt,omitempty"`
	EmailGte              *string                 `json:"email_gte,omitempty"`
	EmailContains         *string                 `json:"email_contains,omitempty"`
	EmailNotContains      *string                 `json:"email_not_contains,omitempty"`
	EmailStartsWith       *string                 `json:"email_starts_with,omitempty"`
	EmailNotStartsWith    *string                 `json:"email_not_starts_with,omitempty"`
	EmailEndsWith         *string                 `json:"email_ends_with,omitempty"`
	EmailNotEndsWith      *string                 `json:"email_not_ends_with,omitempty"`
	Password              *string                 `json:"password,omitempty"`
	PasswordNot           *string                 `json:"password_not,omitempty"`
	PasswordIn            []string                `json:"password_in,omitempty"`
	PasswordNotIn         []string                `json:"password_not_in,omitempty"`
	PasswordLt            *string                 `json:"password_lt,omitempty"`
	PasswordLte           *string                 `json:"password_lte,omitempty"`
	PasswordGt            *string                 `json:"password_gt,omitempty"`
	PasswordGte           *string                 `json:"password_gte,omitempty"`
	PasswordContains      *string                 `json:"password_contains,omitempty"`
	PasswordNotContains   *string                 `json:"password_not_contains,omitempty"`
	PasswordStartsWith    *string                 `json:"password_starts_with,omitempty"`
	PasswordNotStartsWith *string                 `json:"password_not_starts_with,omitempty"`
	PasswordEndsWith      *string                 `json:"password_ends_with,omitempty"`
	PasswordNotEndsWith   *string                 `json:"password_not_ends_with,omitempty"`
	NickName              *string                 `json:"nickName,omitempty"`
	NickNameNot           *string                 `json:"nickName_not,omitempty"`
	NickNameIn            []string                `json:"nickName_in,omitempty"`
	NickNameNotIn         []string                `json:"nickName_not_in,omitempty"`
	NickNameLt            *string                 `json:"nickName_lt,omitempty"`
	NickNameLte           *string                 `json:"nickName_lte,omitempty"`
	NickNameGt            *string                 `json:"nickName_gt,omitempty"`
	NickNameGte           *string                 `json:"nickName_gte,omitempty"`
	NickNameContains      *string                 `json:"nickName_contains,omitempty"`
	NickNameNotContains   *string                 `json:"nickName_not_contains,omitempty"`
	NickNameStartsWith    *string                 `json:"nickName_starts_with,omitempty"`
	NickNameNotStartsWith *string                 `json:"nickName_not_starts_with,omitempty"`
	NickNameEndsWith      *string                 `json:"nickName_ends_with,omitempty"`
	NickNameNotEndsWith   *string                 `json:"nickName_not_ends_with,omitempty"`
	OtpKey                *string                 `json:"otpKey,omitempty"`
	OtpKeyNot             *string                 `json:"otpKey_not,omitempty"`
	OtpKeyIn              []string                `json:"otpKey_in,omitempty"`
	OtpKeyNotIn           []string                `json:"otpKey_not_in,omitempty"`
	OtpKeyLt              *string                 `json:"otpKey_lt,omitempty"`
	OtpKeyLte             *string                 `json:"otpKey_lte,omitempty"`
	OtpKeyGt              *string                 `json:"otpKey_gt,omitempty"`
	OtpKeyGte             *string                 `json:"otpKey_gte,omitempty"`
	OtpKeyContains        *string                 `json:"otpKey_contains,omitempty"`
	OtpKeyNotContains     *string                 `json:"otpKey_not_contains,omitempty"`
	OtpKeyStartsWith      *string                 `json:"otpKey_starts_with,omitempty"`
	OtpKeyNotStartsWith   *string                 `json:"otpKey_not_starts_with,omitempty"`
	OtpKeyEndsWith        *string                 `json:"otpKey_ends_with,omitempty"`
	OtpKeyNotEndsWith     *string                 `json:"otpKey_not_ends_with,omitempty"`
	Level                 *string                 `json:"level,omitempty"`
	LevelNot              *string                 `json:"level_not,omitempty"`
	LevelIn               []string                `json:"level_in,omitempty"`
	LevelNotIn            []string                `json:"level_not_in,omitempty"`
	LevelLt               *string                 `json:"level_lt,omitempty"`
	LevelLte              *string                 `json:"level_lte,omitempty"`
	LevelGt               *string                 `json:"level_gt,omitempty"`
	LevelGte              *string                 `json:"level_gte,omitempty"`
	LevelContains         *string                 `json:"level_contains,omitempty"`
	LevelNotContains      *string                 `json:"level_not_contains,omitempty"`
	LevelStartsWith       *string                 `json:"level_starts_with,omitempty"`
	LevelNotStartsWith    *string                 `json:"level_not_starts_with,omitempty"`
	LevelEndsWith         *string                 `json:"level_ends_with,omitempty"`
	LevelNotEndsWith      *string                 `json:"level_not_ends_with,omitempty"`
	MembersEvery          *UserWhereInput         `json:"members_every,omitempty"`
	MembersSome           *UserWhereInput         `json:"members_some,omitempty"`
	MembersNone           *UserWhereInput         `json:"members_none,omitempty"`
	CreateNotification    *NotificationWhereInput `json:"createNotification,omitempty"`
	UpdateNotification    *NotificationWhereInput `json:"updateNotification,omitempty"`
	CreatedAt             *string                 `json:"createdAt,omitempty"`
	CreatedAtNot          *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                 `json:"updatedAt_gte,omitempty"`
	And                   []AdminUserWhereInput   `json:"AND,omitempty"`
	Or                    []AdminUserWhereInput   `json:"OR,omitempty"`
	Not                   []AdminUserWhereInput   `json:"NOT,omitempty"`
}

type NotificationWhereInput struct {
	ID                     *string                  `json:"id,omitempty"`
	IDNot                  *string                  `json:"id_not,omitempty"`
	IDIn                   []string                 `json:"id_in,omitempty"`
	IDNotIn                []string                 `json:"id_not_in,omitempty"`
	IDLt                   *string                  `json:"id_lt,omitempty"`
	IDLte                  *string                  `json:"id_lte,omitempty"`
	IDGt                   *string                  `json:"id_gt,omitempty"`
	IDGte                  *string                  `json:"id_gte,omitempty"`
	IDContains             *string                  `json:"id_contains,omitempty"`
	IDNotContains          *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith           *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string                  `json:"id_not_ends_with,omitempty"`
	NotiType               *int32                   `json:"notiType,omitempty"`
	NotiTypeNot            *int32                   `json:"notiType_not,omitempty"`
	NotiTypeIn             []int32                  `json:"notiType_in,omitempty"`
	NotiTypeNotIn          []int32                  `json:"notiType_not_in,omitempty"`
	NotiTypeLt             *int32                   `json:"notiType_lt,omitempty"`
	NotiTypeLte            *int32                   `json:"notiType_lte,omitempty"`
	NotiTypeGt             *int32                   `json:"notiType_gt,omitempty"`
	NotiTypeGte            *int32                   `json:"notiType_gte,omitempty"`
	PushType               *int32                   `json:"pushType,omitempty"`
	PushTypeNot            *int32                   `json:"pushType_not,omitempty"`
	PushTypeIn             []int32                  `json:"pushType_in,omitempty"`
	PushTypeNotIn          []int32                  `json:"pushType_not_in,omitempty"`
	PushTypeLt             *int32                   `json:"pushType_lt,omitempty"`
	PushTypeLte            *int32                   `json:"pushType_lte,omitempty"`
	PushTypeGt             *int32                   `json:"pushType_gt,omitempty"`
	PushTypeGte            *int32                   `json:"pushType_gte,omitempty"`
	PushState              *int32                   `json:"pushState,omitempty"`
	PushStateNot           *int32                   `json:"pushState_not,omitempty"`
	PushStateIn            []int32                  `json:"pushState_in,omitempty"`
	PushStateNotIn         []int32                  `json:"pushState_not_in,omitempty"`
	PushStateLt            *int32                   `json:"pushState_lt,omitempty"`
	PushStateLte           *int32                   `json:"pushState_lte,omitempty"`
	PushStateGt            *int32                   `json:"pushState_gt,omitempty"`
	PushStateGte           *int32                   `json:"pushState_gte,omitempty"`
	UserEvery              *UserWhereInput          `json:"user_every,omitempty"`
	UserSome               *UserWhereInput          `json:"user_some,omitempty"`
	UserNone               *UserWhereInput          `json:"user_none,omitempty"`
	SendFailUserEvery      *UserWhereInput          `json:"sendFailUser_every,omitempty"`
	SendFailUserSome       *UserWhereInput          `json:"sendFailUser_some,omitempty"`
	SendFailUserNone       *UserWhereInput          `json:"sendFailUser_none,omitempty"`
	ByUser                 *UserWhereInput          `json:"byUser,omitempty"`
	Post                   *PostWhereInput          `json:"post,omitempty"`
	Coin                   *CoinWhereInput          `json:"coin,omitempty"`
	Topic                  *string                  `json:"topic,omitempty"`
	TopicNot               *string                  `json:"topic_not,omitempty"`
	TopicIn                []string                 `json:"topic_in,omitempty"`
	TopicNotIn             []string                 `json:"topic_not_in,omitempty"`
	TopicLt                *string                  `json:"topic_lt,omitempty"`
	TopicLte               *string                  `json:"topic_lte,omitempty"`
	TopicGt                *string                  `json:"topic_gt,omitempty"`
	TopicGte               *string                  `json:"topic_gte,omitempty"`
	TopicContains          *string                  `json:"topic_contains,omitempty"`
	TopicNotContains       *string                  `json:"topic_not_contains,omitempty"`
	TopicStartsWith        *string                  `json:"topic_starts_with,omitempty"`
	TopicNotStartsWith     *string                  `json:"topic_not_starts_with,omitempty"`
	TopicEndsWith          *string                  `json:"topic_ends_with,omitempty"`
	TopicNotEndsWith       *string                  `json:"topic_not_ends_with,omitempty"`
	LinkType               *string                  `json:"linkType,omitempty"`
	LinkTypeNot            *string                  `json:"linkType_not,omitempty"`
	LinkTypeIn             []string                 `json:"linkType_in,omitempty"`
	LinkTypeNotIn          []string                 `json:"linkType_not_in,omitempty"`
	LinkTypeLt             *string                  `json:"linkType_lt,omitempty"`
	LinkTypeLte            *string                  `json:"linkType_lte,omitempty"`
	LinkTypeGt             *string                  `json:"linkType_gt,omitempty"`
	LinkTypeGte            *string                  `json:"linkType_gte,omitempty"`
	LinkTypeContains       *string                  `json:"linkType_contains,omitempty"`
	LinkTypeNotContains    *string                  `json:"linkType_not_contains,omitempty"`
	LinkTypeStartsWith     *string                  `json:"linkType_starts_with,omitempty"`
	LinkTypeNotStartsWith  *string                  `json:"linkType_not_starts_with,omitempty"`
	LinkTypeEndsWith       *string                  `json:"linkType_ends_with,omitempty"`
	LinkTypeNotEndsWith    *string                  `json:"linkType_not_ends_with,omitempty"`
	LinkValue              *string                  `json:"linkValue,omitempty"`
	LinkValueNot           *string                  `json:"linkValue_not,omitempty"`
	LinkValueIn            []string                 `json:"linkValue_in,omitempty"`
	LinkValueNotIn         []string                 `json:"linkValue_not_in,omitempty"`
	LinkValueLt            *string                  `json:"linkValue_lt,omitempty"`
	LinkValueLte           *string                  `json:"linkValue_lte,omitempty"`
	LinkValueGt            *string                  `json:"linkValue_gt,omitempty"`
	LinkValueGte           *string                  `json:"linkValue_gte,omitempty"`
	LinkValueContains      *string                  `json:"linkValue_contains,omitempty"`
	LinkValueNotContains   *string                  `json:"linkValue_not_contains,omitempty"`
	LinkValueStartsWith    *string                  `json:"linkValue_starts_with,omitempty"`
	LinkValueNotStartsWith *string                  `json:"linkValue_not_starts_with,omitempty"`
	LinkValueEndsWith      *string                  `json:"linkValue_ends_with,omitempty"`
	LinkValueNotEndsWith   *string                  `json:"linkValue_not_ends_with,omitempty"`
	Message                *string                  `json:"message,omitempty"`
	MessageNot             *string                  `json:"message_not,omitempty"`
	MessageIn              []string                 `json:"message_in,omitempty"`
	MessageNotIn           []string                 `json:"message_not_in,omitempty"`
	MessageLt              *string                  `json:"message_lt,omitempty"`
	MessageLte             *string                  `json:"message_lte,omitempty"`
	MessageGt              *string                  `json:"message_gt,omitempty"`
	MessageGte             *string                  `json:"message_gte,omitempty"`
	MessageContains        *string                  `json:"message_contains,omitempty"`
	MessageNotContains     *string                  `json:"message_not_contains,omitempty"`
	MessageStartsWith      *string                  `json:"message_starts_with,omitempty"`
	MessageNotStartsWith   *string                  `json:"message_not_starts_with,omitempty"`
	MessageEndsWith        *string                  `json:"message_ends_with,omitempty"`
	MessageNotEndsWith     *string                  `json:"message_not_ends_with,omitempty"`
	Image                  *string                  `json:"image,omitempty"`
	ImageNot               *string                  `json:"image_not,omitempty"`
	ImageIn                []string                 `json:"image_in,omitempty"`
	ImageNotIn             []string                 `json:"image_not_in,omitempty"`
	ImageLt                *string                  `json:"image_lt,omitempty"`
	ImageLte               *string                  `json:"image_lte,omitempty"`
	ImageGt                *string                  `json:"image_gt,omitempty"`
	ImageGte               *string                  `json:"image_gte,omitempty"`
	ImageContains          *string                  `json:"image_contains,omitempty"`
	ImageNotContains       *string                  `json:"image_not_contains,omitempty"`
	ImageStartsWith        *string                  `json:"image_starts_with,omitempty"`
	ImageNotStartsWith     *string                  `json:"image_not_starts_with,omitempty"`
	ImageEndsWith          *string                  `json:"image_ends_with,omitempty"`
	ImageNotEndsWith       *string                  `json:"image_not_ends_with,omitempty"`
	PublishType            *int32                   `json:"publishType,omitempty"`
	PublishTypeNot         *int32                   `json:"publishType_not,omitempty"`
	PublishTypeIn          []int32                  `json:"publishType_in,omitempty"`
	PublishTypeNotIn       []int32                  `json:"publishType_not_in,omitempty"`
	PublishTypeLt          *int32                   `json:"publishType_lt,omitempty"`
	PublishTypeLte         *int32                   `json:"publishType_lte,omitempty"`
	PublishTypeGt          *int32                   `json:"publishType_gt,omitempty"`
	PublishTypeGte         *int32                   `json:"publishType_gte,omitempty"`
	PublishDate            *string                  `json:"publishDate,omitempty"`
	PublishDateNot         *string                  `json:"publishDate_not,omitempty"`
	PublishDateIn          []string                 `json:"publishDate_in,omitempty"`
	PublishDateNotIn       []string                 `json:"publishDate_not_in,omitempty"`
	PublishDateLt          *string                  `json:"publishDate_lt,omitempty"`
	PublishDateLte         *string                  `json:"publishDate_lte,omitempty"`
	PublishDateGt          *string                  `json:"publishDate_gt,omitempty"`
	PublishDateGte         *string                  `json:"publishDate_gte,omitempty"`
	CreateUser             *AdminUserWhereInput     `json:"createUser,omitempty"`
	UpdateUser             *AdminUserWhereInput     `json:"updateUser,omitempty"`
	CreatedAt              *string                  `json:"createdAt,omitempty"`
	CreatedAtNot           *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                  `json:"updatedAt_gte,omitempty"`
	IsDel                  *bool                    `json:"isDel,omitempty"`
	IsDelNot               *bool                    `json:"isDel_not,omitempty"`
	And                    []NotificationWhereInput `json:"AND,omitempty"`
	Or                     []NotificationWhereInput `json:"OR,omitempty"`
	Not                    []NotificationWhereInput `json:"NOT,omitempty"`
}

type VerificationWhereInput struct {
	ID                     *string                            `json:"id,omitempty"`
	IDNot                  *string                            `json:"id_not,omitempty"`
	IDIn                   []string                           `json:"id_in,omitempty"`
	IDNotIn                []string                           `json:"id_not_in,omitempty"`
	IDLt                   *string                            `json:"id_lt,omitempty"`
	IDLte                  *string                            `json:"id_lte,omitempty"`
	IDGt                   *string                            `json:"id_gt,omitempty"`
	IDGte                  *string                            `json:"id_gte,omitempty"`
	IDContains             *string                            `json:"id_contains,omitempty"`
	IDNotContains          *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith           *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string                            `json:"id_not_ends_with,omitempty"`
	Level                  *int32                             `json:"level,omitempty"`
	LevelNot               *int32                             `json:"level_not,omitempty"`
	LevelIn                []int32                            `json:"level_in,omitempty"`
	LevelNotIn             []int32                            `json:"level_not_in,omitempty"`
	LevelLt                *int32                             `json:"level_lt,omitempty"`
	LevelLte               *int32                             `json:"level_lte,omitempty"`
	LevelGt                *int32                             `json:"level_gt,omitempty"`
	LevelGte               *int32                             `json:"level_gte,omitempty"`
	HasEmail               *bool                              `json:"hasEmail,omitempty"`
	HasEmailNot            *bool                              `json:"hasEmail_not,omitempty"`
	HasPin                 *bool                              `json:"hasPin,omitempty"`
	HasPinNot              *bool                              `json:"hasPin_not,omitempty"`
	HasPhone               *bool                              `json:"hasPhone,omitempty"`
	HasPhoneNot            *bool                              `json:"hasPhone_not,omitempty"`
	HasBankAccount         *bool                              `json:"hasBankAccount,omitempty"`
	HasBankAccountNot      *bool                              `json:"hasBankAccount_not,omitempty"`
	HasInter               *bool                              `json:"hasInter,omitempty"`
	HasInterNot            *bool                              `json:"hasInter_not,omitempty"`
	PinNumber              *string                            `json:"pinNumber,omitempty"`
	PinNumberNot           *string                            `json:"pinNumber_not,omitempty"`
	PinNumberIn            []string                           `json:"pinNumber_in,omitempty"`
	PinNumberNotIn         []string                           `json:"pinNumber_not_in,omitempty"`
	PinNumberLt            *string                            `json:"pinNumber_lt,omitempty"`
	PinNumberLte           *string                            `json:"pinNumber_lte,omitempty"`
	PinNumberGt            *string                            `json:"pinNumber_gt,omitempty"`
	PinNumberGte           *string                            `json:"pinNumber_gte,omitempty"`
	PinNumberContains      *string                            `json:"pinNumber_contains,omitempty"`
	PinNumberNotContains   *string                            `json:"pinNumber_not_contains,omitempty"`
	PinNumberStartsWith    *string                            `json:"pinNumber_starts_with,omitempty"`
	PinNumberNotStartsWith *string                            `json:"pinNumber_not_starts_with,omitempty"`
	PinNumberEndsWith      *string                            `json:"pinNumber_ends_with,omitempty"`
	PinNumberNotEndsWith   *string                            `json:"pinNumber_not_ends_with,omitempty"`
	Phone                  *PhoneVerificationWhereInput       `json:"phone,omitempty"`
	BankAccount            *BankAccountVerificationWhereInput `json:"bankAccount,omitempty"`
	User                   *UserWhereInput                    `json:"user,omitempty"`
	CreatedAt              *string                            `json:"createdAt,omitempty"`
	CreatedAtNot           *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                            `json:"updatedAt_gte,omitempty"`
	And                    []VerificationWhereInput           `json:"AND,omitempty"`
	Or                     []VerificationWhereInput           `json:"OR,omitempty"`
	Not                    []VerificationWhereInput           `json:"NOT,omitempty"`
}

type PhoneVerificationWhereInput struct {
	ID                       *string                       `json:"id,omitempty"`
	IDNot                    *string                       `json:"id_not,omitempty"`
	IDIn                     []string                      `json:"id_in,omitempty"`
	IDNotIn                  []string                      `json:"id_not_in,omitempty"`
	IDLt                     *string                       `json:"id_lt,omitempty"`
	IDLte                    *string                       `json:"id_lte,omitempty"`
	IDGt                     *string                       `json:"id_gt,omitempty"`
	IDGte                    *string                       `json:"id_gte,omitempty"`
	IDContains               *string                       `json:"id_contains,omitempty"`
	IDNotContains            *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                       `json:"id_not_ends_with,omitempty"`
	Verification             *VerificationWhereInput       `json:"verification,omitempty"`
	Name                     *string                       `json:"name,omitempty"`
	NameNot                  *string                       `json:"name_not,omitempty"`
	NameIn                   []string                      `json:"name_in,omitempty"`
	NameNotIn                []string                      `json:"name_not_in,omitempty"`
	NameLt                   *string                       `json:"name_lt,omitempty"`
	NameLte                  *string                       `json:"name_lte,omitempty"`
	NameGt                   *string                       `json:"name_gt,omitempty"`
	NameGte                  *string                       `json:"name_gte,omitempty"`
	NameContains             *string                       `json:"name_contains,omitempty"`
	NameNotContains          *string                       `json:"name_not_contains,omitempty"`
	NameStartsWith           *string                       `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string                       `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string                       `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string                       `json:"name_not_ends_with,omitempty"`
	Birth                    *string                       `json:"birth,omitempty"`
	BirthNot                 *string                       `json:"birth_not,omitempty"`
	BirthIn                  []string                      `json:"birth_in,omitempty"`
	BirthNotIn               []string                      `json:"birth_not_in,omitempty"`
	BirthLt                  *string                       `json:"birth_lt,omitempty"`
	BirthLte                 *string                       `json:"birth_lte,omitempty"`
	BirthGt                  *string                       `json:"birth_gt,omitempty"`
	BirthGte                 *string                       `json:"birth_gte,omitempty"`
	BirthContains            *string                       `json:"birth_contains,omitempty"`
	BirthNotContains         *string                       `json:"birth_not_contains,omitempty"`
	BirthStartsWith          *string                       `json:"birth_starts_with,omitempty"`
	BirthNotStartsWith       *string                       `json:"birth_not_starts_with,omitempty"`
	BirthEndsWith            *string                       `json:"birth_ends_with,omitempty"`
	BirthNotEndsWith         *string                       `json:"birth_not_ends_with,omitempty"`
	Foreigner                *bool                         `json:"foreigner,omitempty"`
	ForeignerNot             *bool                         `json:"foreigner_not,omitempty"`
	Gender                   *string                       `json:"gender,omitempty"`
	GenderNot                *string                       `json:"gender_not,omitempty"`
	GenderIn                 []string                      `json:"gender_in,omitempty"`
	GenderNotIn              []string                      `json:"gender_not_in,omitempty"`
	GenderLt                 *string                       `json:"gender_lt,omitempty"`
	GenderLte                *string                       `json:"gender_lte,omitempty"`
	GenderGt                 *string                       `json:"gender_gt,omitempty"`
	GenderGte                *string                       `json:"gender_gte,omitempty"`
	GenderContains           *string                       `json:"gender_contains,omitempty"`
	GenderNotContains        *string                       `json:"gender_not_contains,omitempty"`
	GenderStartsWith         *string                       `json:"gender_starts_with,omitempty"`
	GenderNotStartsWith      *string                       `json:"gender_not_starts_with,omitempty"`
	GenderEndsWith           *string                       `json:"gender_ends_with,omitempty"`
	GenderNotEndsWith        *string                       `json:"gender_not_ends_with,omitempty"`
	PhoneNumber              *string                       `json:"phoneNumber,omitempty"`
	PhoneNumberNot           *string                       `json:"phoneNumber_not,omitempty"`
	PhoneNumberIn            []string                      `json:"phoneNumber_in,omitempty"`
	PhoneNumberNotIn         []string                      `json:"phoneNumber_not_in,omitempty"`
	PhoneNumberLt            *string                       `json:"phoneNumber_lt,omitempty"`
	PhoneNumberLte           *string                       `json:"phoneNumber_lte,omitempty"`
	PhoneNumberGt            *string                       `json:"phoneNumber_gt,omitempty"`
	PhoneNumberGte           *string                       `json:"phoneNumber_gte,omitempty"`
	PhoneNumberContains      *string                       `json:"phoneNumber_contains,omitempty"`
	PhoneNumberNotContains   *string                       `json:"phoneNumber_not_contains,omitempty"`
	PhoneNumberStartsWith    *string                       `json:"phoneNumber_starts_with,omitempty"`
	PhoneNumberNotStartsWith *string                       `json:"phoneNumber_not_starts_with,omitempty"`
	PhoneNumberEndsWith      *string                       `json:"phoneNumber_ends_with,omitempty"`
	PhoneNumberNotEndsWith   *string                       `json:"phoneNumber_not_ends_with,omitempty"`
	Ci                       *string                       `json:"CI,omitempty"`
	CiNot                    *string                       `json:"CI_not,omitempty"`
	CiIn                     []string                      `json:"CI_in,omitempty"`
	CiNotIn                  []string                      `json:"CI_not_in,omitempty"`
	CiLt                     *string                       `json:"CI_lt,omitempty"`
	CiLte                    *string                       `json:"CI_lte,omitempty"`
	CiGt                     *string                       `json:"CI_gt,omitempty"`
	CiGte                    *string                       `json:"CI_gte,omitempty"`
	CiContains               *string                       `json:"CI_contains,omitempty"`
	CiNotContains            *string                       `json:"CI_not_contains,omitempty"`
	CiStartsWith             *string                       `json:"CI_starts_with,omitempty"`
	CiNotStartsWith          *string                       `json:"CI_not_starts_with,omitempty"`
	CiEndsWith               *string                       `json:"CI_ends_with,omitempty"`
	CiNotEndsWith            *string                       `json:"CI_not_ends_with,omitempty"`
	Di                       *string                       `json:"DI,omitempty"`
	DiNot                    *string                       `json:"DI_not,omitempty"`
	DiIn                     []string                      `json:"DI_in,omitempty"`
	DiNotIn                  []string                      `json:"DI_not_in,omitempty"`
	DiLt                     *string                       `json:"DI_lt,omitempty"`
	DiLte                    *string                       `json:"DI_lte,omitempty"`
	DiGt                     *string                       `json:"DI_gt,omitempty"`
	DiGte                    *string                       `json:"DI_gte,omitempty"`
	DiContains               *string                       `json:"DI_contains,omitempty"`
	DiNotContains            *string                       `json:"DI_not_contains,omitempty"`
	DiStartsWith             *string                       `json:"DI_starts_with,omitempty"`
	DiNotStartsWith          *string                       `json:"DI_not_starts_with,omitempty"`
	DiEndsWith               *string                       `json:"DI_ends_with,omitempty"`
	DiNotEndsWith            *string                       `json:"DI_not_ends_with,omitempty"`
	ImpUid                   *string                       `json:"imp_uid,omitempty"`
	ImpUidNot                *string                       `json:"imp_uid_not,omitempty"`
	ImpUidIn                 []string                      `json:"imp_uid_in,omitempty"`
	ImpUidNotIn              []string                      `json:"imp_uid_not_in,omitempty"`
	ImpUidLt                 *string                       `json:"imp_uid_lt,omitempty"`
	ImpUidLte                *string                       `json:"imp_uid_lte,omitempty"`
	ImpUidGt                 *string                       `json:"imp_uid_gt,omitempty"`
	ImpUidGte                *string                       `json:"imp_uid_gte,omitempty"`
	ImpUidContains           *string                       `json:"imp_uid_contains,omitempty"`
	ImpUidNotContains        *string                       `json:"imp_uid_not_contains,omitempty"`
	ImpUidStartsWith         *string                       `json:"imp_uid_starts_with,omitempty"`
	ImpUidNotStartsWith      *string                       `json:"imp_uid_not_starts_with,omitempty"`
	ImpUidEndsWith           *string                       `json:"imp_uid_ends_with,omitempty"`
	ImpUidNotEndsWith        *string                       `json:"imp_uid_not_ends_with,omitempty"`
	MerchantUid              *string                       `json:"merchant_uid,omitempty"`
	MerchantUidNot           *string                       `json:"merchant_uid_not,omitempty"`
	MerchantUidIn            []string                      `json:"merchant_uid_in,omitempty"`
	MerchantUidNotIn         []string                      `json:"merchant_uid_not_in,omitempty"`
	MerchantUidLt            *string                       `json:"merchant_uid_lt,omitempty"`
	MerchantUidLte           *string                       `json:"merchant_uid_lte,omitempty"`
	MerchantUidGt            *string                       `json:"merchant_uid_gt,omitempty"`
	MerchantUidGte           *string                       `json:"merchant_uid_gte,omitempty"`
	MerchantUidContains      *string                       `json:"merchant_uid_contains,omitempty"`
	MerchantUidNotContains   *string                       `json:"merchant_uid_not_contains,omitempty"`
	MerchantUidStartsWith    *string                       `json:"merchant_uid_starts_with,omitempty"`
	MerchantUidNotStartsWith *string                       `json:"merchant_uid_not_starts_with,omitempty"`
	MerchantUidEndsWith      *string                       `json:"merchant_uid_ends_with,omitempty"`
	MerchantUidNotEndsWith   *string                       `json:"merchant_uid_not_ends_with,omitempty"`
	CreatedAt                *string                       `json:"createdAt,omitempty"`
	CreatedAtNot             *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                       `json:"updatedAt_gte,omitempty"`
	And                      []PhoneVerificationWhereInput `json:"AND,omitempty"`
	Or                       []PhoneVerificationWhereInput `json:"OR,omitempty"`
	Not                      []PhoneVerificationWhereInput `json:"NOT,omitempty"`
}

type BankAccountVerificationWhereInput struct {
	ID                         *string                                           `json:"id,omitempty"`
	IDNot                      *string                                           `json:"id_not,omitempty"`
	IDIn                       []string                                          `json:"id_in,omitempty"`
	IDNotIn                    []string                                          `json:"id_not_in,omitempty"`
	IDLt                       *string                                           `json:"id_lt,omitempty"`
	IDLte                      *string                                           `json:"id_lte,omitempty"`
	IDGt                       *string                                           `json:"id_gt,omitempty"`
	IDGte                      *string                                           `json:"id_gte,omitempty"`
	IDContains                 *string                                           `json:"id_contains,omitempty"`
	IDNotContains              *string                                           `json:"id_not_contains,omitempty"`
	IDStartsWith               *string                                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string                                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string                                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string                                           `json:"id_not_ends_with,omitempty"`
	Verification               *VerificationWhereInput                           `json:"verification,omitempty"`
	Bank                       *BankWhereInput                                   `json:"bank,omitempty"`
	HolderName                 *string                                           `json:"holderName,omitempty"`
	HolderNameNot              *string                                           `json:"holderName_not,omitempty"`
	HolderNameIn               []string                                          `json:"holderName_in,omitempty"`
	HolderNameNotIn            []string                                          `json:"holderName_not_in,omitempty"`
	HolderNameLt               *string                                           `json:"holderName_lt,omitempty"`
	HolderNameLte              *string                                           `json:"holderName_lte,omitempty"`
	HolderNameGt               *string                                           `json:"holderName_gt,omitempty"`
	HolderNameGte              *string                                           `json:"holderName_gte,omitempty"`
	HolderNameContains         *string                                           `json:"holderName_contains,omitempty"`
	HolderNameNotContains      *string                                           `json:"holderName_not_contains,omitempty"`
	HolderNameStartsWith       *string                                           `json:"holderName_starts_with,omitempty"`
	HolderNameNotStartsWith    *string                                           `json:"holderName_not_starts_with,omitempty"`
	HolderNameEndsWith         *string                                           `json:"holderName_ends_with,omitempty"`
	HolderNameNotEndsWith      *string                                           `json:"holderName_not_ends_with,omitempty"`
	AccountNumber              *string                                           `json:"accountNumber,omitempty"`
	AccountNumberNot           *string                                           `json:"accountNumber_not,omitempty"`
	AccountNumberIn            []string                                          `json:"accountNumber_in,omitempty"`
	AccountNumberNotIn         []string                                          `json:"accountNumber_not_in,omitempty"`
	AccountNumberLt            *string                                           `json:"accountNumber_lt,omitempty"`
	AccountNumberLte           *string                                           `json:"accountNumber_lte,omitempty"`
	AccountNumberGt            *string                                           `json:"accountNumber_gt,omitempty"`
	AccountNumberGte           *string                                           `json:"accountNumber_gte,omitempty"`
	AccountNumberContains      *string                                           `json:"accountNumber_contains,omitempty"`
	AccountNumberNotContains   *string                                           `json:"accountNumber_not_contains,omitempty"`
	AccountNumberStartsWith    *string                                           `json:"accountNumber_starts_with,omitempty"`
	AccountNumberNotStartsWith *string                                           `json:"accountNumber_not_starts_with,omitempty"`
	AccountNumberEndsWith      *string                                           `json:"accountNumber_ends_with,omitempty"`
	AccountNumberNotEndsWith   *string                                           `json:"accountNumber_not_ends_with,omitempty"`
	TransactionInfo            *BankAccountVerificationTransactionInfoWhereInput `json:"transactionInfo,omitempty"`
	VerifyAt                   *string                                           `json:"verifyAt,omitempty"`
	VerifyAtNot                *string                                           `json:"verifyAt_not,omitempty"`
	VerifyAtIn                 []string                                          `json:"verifyAt_in,omitempty"`
	VerifyAtNotIn              []string                                          `json:"verifyAt_not_in,omitempty"`
	VerifyAtLt                 *string                                           `json:"verifyAt_lt,omitempty"`
	VerifyAtLte                *string                                           `json:"verifyAt_lte,omitempty"`
	VerifyAtGt                 *string                                           `json:"verifyAt_gt,omitempty"`
	VerifyAtGte                *string                                           `json:"verifyAt_gte,omitempty"`
	CreatedAt                  *string                                           `json:"createdAt,omitempty"`
	CreatedAtNot               *string                                           `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string                                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string                                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                                           `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                                           `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string                                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string                                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                                           `json:"updatedAt_gte,omitempty"`
	And                        []BankAccountVerificationWhereInput               `json:"AND,omitempty"`
	Or                         []BankAccountVerificationWhereInput               `json:"OR,omitempty"`
	Not                        []BankAccountVerificationWhereInput               `json:"NOT,omitempty"`
}

type BankWhereInput struct {
	ID                *string          `json:"id,omitempty"`
	IDNot             *string          `json:"id_not,omitempty"`
	IDIn              []string         `json:"id_in,omitempty"`
	IDNotIn           []string         `json:"id_not_in,omitempty"`
	IDLt              *string          `json:"id_lt,omitempty"`
	IDLte             *string          `json:"id_lte,omitempty"`
	IDGt              *string          `json:"id_gt,omitempty"`
	IDGte             *string          `json:"id_gte,omitempty"`
	IDContains        *string          `json:"id_contains,omitempty"`
	IDNotContains     *string          `json:"id_not_contains,omitempty"`
	IDStartsWith      *string          `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string          `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string          `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string          `json:"id_not_ends_with,omitempty"`
	Code              *string          `json:"code,omitempty"`
	CodeNot           *string          `json:"code_not,omitempty"`
	CodeIn            []string         `json:"code_in,omitempty"`
	CodeNotIn         []string         `json:"code_not_in,omitempty"`
	CodeLt            *string          `json:"code_lt,omitempty"`
	CodeLte           *string          `json:"code_lte,omitempty"`
	CodeGt            *string          `json:"code_gt,omitempty"`
	CodeGte           *string          `json:"code_gte,omitempty"`
	CodeContains      *string          `json:"code_contains,omitempty"`
	CodeNotContains   *string          `json:"code_not_contains,omitempty"`
	CodeStartsWith    *string          `json:"code_starts_with,omitempty"`
	CodeNotStartsWith *string          `json:"code_not_starts_with,omitempty"`
	CodeEndsWith      *string          `json:"code_ends_with,omitempty"`
	CodeNotEndsWith   *string          `json:"code_not_ends_with,omitempty"`
	Name              *string          `json:"name,omitempty"`
	NameNot           *string          `json:"name_not,omitempty"`
	NameIn            []string         `json:"name_in,omitempty"`
	NameNotIn         []string         `json:"name_not_in,omitempty"`
	NameLt            *string          `json:"name_lt,omitempty"`
	NameLte           *string          `json:"name_lte,omitempty"`
	NameGt            *string          `json:"name_gt,omitempty"`
	NameGte           *string          `json:"name_gte,omitempty"`
	NameContains      *string          `json:"name_contains,omitempty"`
	NameNotContains   *string          `json:"name_not_contains,omitempty"`
	NameStartsWith    *string          `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string          `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string          `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string          `json:"name_not_ends_with,omitempty"`
	CreatedAt         *string          `json:"createdAt,omitempty"`
	CreatedAtNot      *string          `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string          `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string          `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string          `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string          `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string          `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string          `json:"updatedAt_gte,omitempty"`
	And               []BankWhereInput `json:"AND,omitempty"`
	Or                []BankWhereInput `json:"OR,omitempty"`
	Not               []BankWhereInput `json:"NOT,omitempty"`
}

type BankAccountVerificationTransactionInfoWhereInput struct {
	ID                         *string                                            `json:"id,omitempty"`
	IDNot                      *string                                            `json:"id_not,omitempty"`
	IDIn                       []string                                           `json:"id_in,omitempty"`
	IDNotIn                    []string                                           `json:"id_not_in,omitempty"`
	IDLt                       *string                                            `json:"id_lt,omitempty"`
	IDLte                      *string                                            `json:"id_lte,omitempty"`
	IDGt                       *string                                            `json:"id_gt,omitempty"`
	IDGte                      *string                                            `json:"id_gte,omitempty"`
	IDContains                 *string                                            `json:"id_contains,omitempty"`
	IDNotContains              *string                                            `json:"id_not_contains,omitempty"`
	IDStartsWith               *string                                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string                                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string                                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string                                            `json:"id_not_ends_with,omitempty"`
	TransactionDt              *string                                            `json:"transactionDt,omitempty"`
	TransactionDtNot           *string                                            `json:"transactionDt_not,omitempty"`
	TransactionDtIn            []string                                           `json:"transactionDt_in,omitempty"`
	TransactionDtNotIn         []string                                           `json:"transactionDt_not_in,omitempty"`
	TransactionDtLt            *string                                            `json:"transactionDt_lt,omitempty"`
	TransactionDtLte           *string                                            `json:"transactionDt_lte,omitempty"`
	TransactionDtGt            *string                                            `json:"transactionDt_gt,omitempty"`
	TransactionDtGte           *string                                            `json:"transactionDt_gte,omitempty"`
	TransactionDtContains      *string                                            `json:"transactionDt_contains,omitempty"`
	TransactionDtNotContains   *string                                            `json:"transactionDt_not_contains,omitempty"`
	TransactionDtStartsWith    *string                                            `json:"transactionDt_starts_with,omitempty"`
	TransactionDtNotStartsWith *string                                            `json:"transactionDt_not_starts_with,omitempty"`
	TransactionDtEndsWith      *string                                            `json:"transactionDt_ends_with,omitempty"`
	TransactionDtNotEndsWith   *string                                            `json:"transactionDt_not_ends_with,omitempty"`
	TransactionNo              *string                                            `json:"transactionNo,omitempty"`
	TransactionNoNot           *string                                            `json:"transactionNo_not,omitempty"`
	TransactionNoIn            []string                                           `json:"transactionNo_in,omitempty"`
	TransactionNoNotIn         []string                                           `json:"transactionNo_not_in,omitempty"`
	TransactionNoLt            *string                                            `json:"transactionNo_lt,omitempty"`
	TransactionNoLte           *string                                            `json:"transactionNo_lte,omitempty"`
	TransactionNoGt            *string                                            `json:"transactionNo_gt,omitempty"`
	TransactionNoGte           *string                                            `json:"transactionNo_gte,omitempty"`
	TransactionNoContains      *string                                            `json:"transactionNo_contains,omitempty"`
	TransactionNoNotContains   *string                                            `json:"transactionNo_not_contains,omitempty"`
	TransactionNoStartsWith    *string                                            `json:"transactionNo_starts_with,omitempty"`
	TransactionNoNotStartsWith *string                                            `json:"transactionNo_not_starts_with,omitempty"`
	TransactionNoEndsWith      *string                                            `json:"transactionNo_ends_with,omitempty"`
	TransactionNoNotEndsWith   *string                                            `json:"transactionNo_not_ends_with,omitempty"`
	ExpireAt                   *string                                            `json:"expireAt,omitempty"`
	ExpireAtNot                *string                                            `json:"expireAt_not,omitempty"`
	ExpireAtIn                 []string                                           `json:"expireAt_in,omitempty"`
	ExpireAtNotIn              []string                                           `json:"expireAt_not_in,omitempty"`
	ExpireAtLt                 *string                                            `json:"expireAt_lt,omitempty"`
	ExpireAtLte                *string                                            `json:"expireAt_lte,omitempty"`
	ExpireAtGt                 *string                                            `json:"expireAt_gt,omitempty"`
	ExpireAtGte                *string                                            `json:"expireAt_gte,omitempty"`
	CreatedAt                  *string                                            `json:"createdAt,omitempty"`
	CreatedAtNot               *string                                            `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string                                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string                                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                                            `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                                            `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string                                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string                                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                                            `json:"updatedAt_gte,omitempty"`
	And                        []BankAccountVerificationTransactionInfoWhereInput `json:"AND,omitempty"`
	Or                         []BankAccountVerificationTransactionInfoWhereInput `json:"OR,omitempty"`
	Not                        []BankAccountVerificationTransactionInfoWhereInput `json:"NOT,omitempty"`
}

type ReportWhereInput struct {
	ID              *string            `json:"id,omitempty"`
	IDNot           *string            `json:"id_not,omitempty"`
	IDIn            []string           `json:"id_in,omitempty"`
	IDNotIn         []string           `json:"id_not_in,omitempty"`
	IDLt            *string            `json:"id_lt,omitempty"`
	IDLte           *string            `json:"id_lte,omitempty"`
	IDGt            *string            `json:"id_gt,omitempty"`
	IDGte           *string            `json:"id_gte,omitempty"`
	IDContains      *string            `json:"id_contains,omitempty"`
	IDNotContains   *string            `json:"id_not_contains,omitempty"`
	IDStartsWith    *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string            `json:"id_not_ends_with,omitempty"`
	Type            *int32             `json:"type,omitempty"`
	TypeNot         *int32             `json:"type_not,omitempty"`
	TypeIn          []int32            `json:"type_in,omitempty"`
	TypeNotIn       []int32            `json:"type_not_in,omitempty"`
	TypeLt          *int32             `json:"type_lt,omitempty"`
	TypeLte         *int32             `json:"type_lte,omitempty"`
	TypeGt          *int32             `json:"type_gt,omitempty"`
	TypeGte         *int32             `json:"type_gte,omitempty"`
	ReportUser      *UserWhereInput    `json:"reportUser,omitempty"`
	ReportType      *int32             `json:"reportType,omitempty"`
	ReportTypeNot   *int32             `json:"reportType_not,omitempty"`
	ReportTypeIn    []int32            `json:"reportType_in,omitempty"`
	ReportTypeNotIn []int32            `json:"reportType_not_in,omitempty"`
	ReportTypeLt    *int32             `json:"reportType_lt,omitempty"`
	ReportTypeLte   *int32             `json:"reportType_lte,omitempty"`
	ReportTypeGt    *int32             `json:"reportType_gt,omitempty"`
	ReportTypeGte   *int32             `json:"reportType_gte,omitempty"`
	TargetPost      *PostWhereInput    `json:"targetPost,omitempty"`
	TargetUser      *UserWhereInput    `json:"targetUser,omitempty"`
	CreatedAt       *string            `json:"createdAt,omitempty"`
	CreatedAtNot    *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string            `json:"createdAt_gte,omitempty"`
	And             []ReportWhereInput `json:"AND,omitempty"`
	Or              []ReportWhereInput `json:"OR,omitempty"`
	Not             []ReportWhereInput `json:"NOT,omitempty"`
}

type RewardDropAttendingUserWhereInput struct {
	ID                *string                             `json:"id,omitempty"`
	IDNot             *string                             `json:"id_not,omitempty"`
	IDIn              []string                            `json:"id_in,omitempty"`
	IDNotIn           []string                            `json:"id_not_in,omitempty"`
	IDLt              *string                             `json:"id_lt,omitempty"`
	IDLte             *string                             `json:"id_lte,omitempty"`
	IDGt              *string                             `json:"id_gt,omitempty"`
	IDGte             *string                             `json:"id_gte,omitempty"`
	IDContains        *string                             `json:"id_contains,omitempty"`
	IDNotContains     *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                             `json:"id_not_ends_with,omitempty"`
	RewardDropEvent   *RewardDropEventWhereInput          `json:"rewardDropEvent,omitempty"`
	User              *UserWhereInput                     `json:"user,omitempty"`
	Memo              *string                             `json:"memo,omitempty"`
	MemoNot           *string                             `json:"memo_not,omitempty"`
	MemoIn            []string                            `json:"memo_in,omitempty"`
	MemoNotIn         []string                            `json:"memo_not_in,omitempty"`
	MemoLt            *string                             `json:"memo_lt,omitempty"`
	MemoLte           *string                             `json:"memo_lte,omitempty"`
	MemoGt            *string                             `json:"memo_gt,omitempty"`
	MemoGte           *string                             `json:"memo_gte,omitempty"`
	MemoContains      *string                             `json:"memo_contains,omitempty"`
	MemoNotContains   *string                             `json:"memo_not_contains,omitempty"`
	MemoStartsWith    *string                             `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith *string                             `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith      *string                             `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith   *string                             `json:"memo_not_ends_with,omitempty"`
	IsDel             *bool                               `json:"isDel,omitempty"`
	IsDelNot          *bool                               `json:"isDel_not,omitempty"`
	CreatedAt         *string                             `json:"createdAt,omitempty"`
	CreatedAtNot      *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                             `json:"createdAt_gte,omitempty"`
	And               []RewardDropAttendingUserWhereInput `json:"AND,omitempty"`
	Or                []RewardDropAttendingUserWhereInput `json:"OR,omitempty"`
	Not               []RewardDropAttendingUserWhereInput `json:"NOT,omitempty"`
}

type RewardDropEventWhereInput struct {
	ID                   *string                            `json:"id,omitempty"`
	IDNot                *string                            `json:"id_not,omitempty"`
	IDIn                 []string                           `json:"id_in,omitempty"`
	IDNotIn              []string                           `json:"id_not_in,omitempty"`
	IDLt                 *string                            `json:"id_lt,omitempty"`
	IDLte                *string                            `json:"id_lte,omitempty"`
	IDGt                 *string                            `json:"id_gt,omitempty"`
	IDGte                *string                            `json:"id_gte,omitempty"`
	IDContains           *string                            `json:"id_contains,omitempty"`
	IDNotContains        *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                            `json:"id_not_ends_with,omitempty"`
	EventId              *string                            `json:"eventID,omitempty"`
	EventIdNot           *string                            `json:"eventID_not,omitempty"`
	EventIdIn            []string                           `json:"eventID_in,omitempty"`
	EventIdNotIn         []string                           `json:"eventID_not_in,omitempty"`
	EventIdLt            *string                            `json:"eventID_lt,omitempty"`
	EventIdLte           *string                            `json:"eventID_lte,omitempty"`
	EventIdGt            *string                            `json:"eventID_gt,omitempty"`
	EventIdGte           *string                            `json:"eventID_gte,omitempty"`
	EventIdContains      *string                            `json:"eventID_contains,omitempty"`
	EventIdNotContains   *string                            `json:"eventID_not_contains,omitempty"`
	EventIdStartsWith    *string                            `json:"eventID_starts_with,omitempty"`
	EventIdNotStartsWith *string                            `json:"eventID_not_starts_with,omitempty"`
	EventIdEndsWith      *string                            `json:"eventID_ends_with,omitempty"`
	EventIdNotEndsWith   *string                            `json:"eventID_not_ends_with,omitempty"`
	Type                 *int32                             `json:"type,omitempty"`
	TypeNot              *int32                             `json:"type_not,omitempty"`
	TypeIn               []int32                            `json:"type_in,omitempty"`
	TypeNotIn            []int32                            `json:"type_not_in,omitempty"`
	TypeLt               *int32                             `json:"type_lt,omitempty"`
	TypeLte              *int32                             `json:"type_lte,omitempty"`
	TypeGt               *int32                             `json:"type_gt,omitempty"`
	TypeGte              *int32                             `json:"type_gte,omitempty"`
	Title                *string                            `json:"title,omitempty"`
	TitleNot             *string                            `json:"title_not,omitempty"`
	TitleIn              []string                           `json:"title_in,omitempty"`
	TitleNotIn           []string                           `json:"title_not_in,omitempty"`
	TitleLt              *string                            `json:"title_lt,omitempty"`
	TitleLte             *string                            `json:"title_lte,omitempty"`
	TitleGt              *string                            `json:"title_gt,omitempty"`
	TitleGte             *string                            `json:"title_gte,omitempty"`
	TitleContains        *string                            `json:"title_contains,omitempty"`
	TitleNotContains     *string                            `json:"title_not_contains,omitempty"`
	TitleStartsWith      *string                            `json:"title_starts_with,omitempty"`
	TitleNotStartsWith   *string                            `json:"title_not_starts_with,omitempty"`
	TitleEndsWith        *string                            `json:"title_ends_with,omitempty"`
	TitleNotEndsWith     *string                            `json:"title_not_ends_with,omitempty"`
	Cash                 *int32                             `json:"cash,omitempty"`
	CashNot              *int32                             `json:"cash_not,omitempty"`
	CashIn               []int32                            `json:"cash_in,omitempty"`
	CashNotIn            []int32                            `json:"cash_not_in,omitempty"`
	CashLt               *int32                             `json:"cash_lt,omitempty"`
	CashLte              *int32                             `json:"cash_lte,omitempty"`
	CashGt               *int32                             `json:"cash_gt,omitempty"`
	CashGte              *int32                             `json:"cash_gte,omitempty"`
	Coin                 *CoinWhereInput                    `json:"coin,omitempty"`
	Qty                  *int32                             `json:"qty,omitempty"`
	QtyNot               *int32                             `json:"qty_not,omitempty"`
	QtyIn                []int32                            `json:"qty_in,omitempty"`
	QtyNotIn             []int32                            `json:"qty_not_in,omitempty"`
	QtyLt                *int32                             `json:"qty_lt,omitempty"`
	QtyLte               *int32                             `json:"qty_lte,omitempty"`
	QtyGt                *int32                             `json:"qty_gt,omitempty"`
	QtyGte               *int32                             `json:"qty_gte,omitempty"`
	LimitUserCount       *int32                             `json:"limitUserCount,omitempty"`
	LimitUserCountNot    *int32                             `json:"limitUserCount_not,omitempty"`
	LimitUserCountIn     []int32                            `json:"limitUserCount_in,omitempty"`
	LimitUserCountNotIn  []int32                            `json:"limitUserCount_not_in,omitempty"`
	LimitUserCountLt     *int32                             `json:"limitUserCount_lt,omitempty"`
	LimitUserCountLte    *int32                             `json:"limitUserCount_lte,omitempty"`
	LimitUserCountGt     *int32                             `json:"limitUserCount_gt,omitempty"`
	LimitUserCountGte    *int32                             `json:"limitUserCount_gte,omitempty"`
	FromDate             *string                            `json:"fromDate,omitempty"`
	FromDateNot          *string                            `json:"fromDate_not,omitempty"`
	FromDateIn           []string                           `json:"fromDate_in,omitempty"`
	FromDateNotIn        []string                           `json:"fromDate_not_in,omitempty"`
	FromDateLt           *string                            `json:"fromDate_lt,omitempty"`
	FromDateLte          *string                            `json:"fromDate_lte,omitempty"`
	FromDateGt           *string                            `json:"fromDate_gt,omitempty"`
	FromDateGte          *string                            `json:"fromDate_gte,omitempty"`
	ToDate               *string                            `json:"toDate,omitempty"`
	ToDateNot            *string                            `json:"toDate_not,omitempty"`
	ToDateIn             []string                           `json:"toDate_in,omitempty"`
	ToDateNotIn          []string                           `json:"toDate_not_in,omitempty"`
	ToDateLt             *string                            `json:"toDate_lt,omitempty"`
	ToDateLte            *string                            `json:"toDate_lte,omitempty"`
	ToDateGt             *string                            `json:"toDate_gt,omitempty"`
	ToDateGte            *string                            `json:"toDate_gte,omitempty"`
	AttendingUsersEvery  *RewardDropAttendingUserWhereInput `json:"attendingUsers_every,omitempty"`
	AttendingUsersSome   *RewardDropAttendingUserWhereInput `json:"attendingUsers_some,omitempty"`
	AttendingUsersNone   *RewardDropAttendingUserWhereInput `json:"attendingUsers_none,omitempty"`
	IsDel                *bool                              `json:"isDel,omitempty"`
	IsDelNot             *bool                              `json:"isDel_not,omitempty"`
	CreatedAt            *string                            `json:"createdAt,omitempty"`
	CreatedAtNot         *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                            `json:"createdAt_gte,omitempty"`
	And                  []RewardDropEventWhereInput        `json:"AND,omitempty"`
	Or                   []RewardDropEventWhereInput        `json:"OR,omitempty"`
	Not                  []RewardDropEventWhereInput        `json:"NOT,omitempty"`
}

type FeeWhereInput struct {
	ID                     *string         `json:"id,omitempty"`
	IDNot                  *string         `json:"id_not,omitempty"`
	IDIn                   []string        `json:"id_in,omitempty"`
	IDNotIn                []string        `json:"id_not_in,omitempty"`
	IDLt                   *string         `json:"id_lt,omitempty"`
	IDLte                  *string         `json:"id_lte,omitempty"`
	IDGt                   *string         `json:"id_gt,omitempty"`
	IDGte                  *string         `json:"id_gte,omitempty"`
	IDContains             *string         `json:"id_contains,omitempty"`
	IDNotContains          *string         `json:"id_not_contains,omitempty"`
	IDStartsWith           *string         `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string         `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string         `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string         `json:"id_not_ends_with,omitempty"`
	Type                   *int32          `json:"type,omitempty"`
	TypeNot                *int32          `json:"type_not,omitempty"`
	TypeIn                 []int32         `json:"type_in,omitempty"`
	TypeNotIn              []int32         `json:"type_not_in,omitempty"`
	TypeLt                 *int32          `json:"type_lt,omitempty"`
	TypeLte                *int32          `json:"type_lte,omitempty"`
	TypeGt                 *int32          `json:"type_gt,omitempty"`
	TypeGte                *int32          `json:"type_gte,omitempty"`
	Key                    *int32          `json:"key,omitempty"`
	KeyNot                 *int32          `json:"key_not,omitempty"`
	KeyIn                  []int32         `json:"key_in,omitempty"`
	KeyNotIn               []int32         `json:"key_not_in,omitempty"`
	KeyLt                  *int32          `json:"key_lt,omitempty"`
	KeyLte                 *int32          `json:"key_lte,omitempty"`
	KeyGt                  *int32          `json:"key_gt,omitempty"`
	KeyGte                 *int32          `json:"key_gte,omitempty"`
	Memo                   *string         `json:"memo,omitempty"`
	MemoNot                *string         `json:"memo_not,omitempty"`
	MemoIn                 []string        `json:"memo_in,omitempty"`
	MemoNotIn              []string        `json:"memo_not_in,omitempty"`
	MemoLt                 *string         `json:"memo_lt,omitempty"`
	MemoLte                *string         `json:"memo_lte,omitempty"`
	MemoGt                 *string         `json:"memo_gt,omitempty"`
	MemoGte                *string         `json:"memo_gte,omitempty"`
	MemoContains           *string         `json:"memo_contains,omitempty"`
	MemoNotContains        *string         `json:"memo_not_contains,omitempty"`
	MemoStartsWith         *string         `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith      *string         `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith           *string         `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith        *string         `json:"memo_not_ends_with,omitempty"`
	Rank                   *int32          `json:"rank,omitempty"`
	RankNot                *int32          `json:"rank_not,omitempty"`
	RankIn                 []int32         `json:"rank_in,omitempty"`
	RankNotIn              []int32         `json:"rank_not_in,omitempty"`
	RankLt                 *int32          `json:"rank_lt,omitempty"`
	RankLte                *int32          `json:"rank_lte,omitempty"`
	RankGt                 *int32          `json:"rank_gt,omitempty"`
	RankGte                *int32          `json:"rank_gte,omitempty"`
	AskTakerFee            *float64        `json:"askTakerFee,omitempty"`
	AskTakerFeeNot         *float64        `json:"askTakerFee_not,omitempty"`
	AskTakerFeeIn          []float64       `json:"askTakerFee_in,omitempty"`
	AskTakerFeeNotIn       []float64       `json:"askTakerFee_not_in,omitempty"`
	AskTakerFeeLt          *float64        `json:"askTakerFee_lt,omitempty"`
	AskTakerFeeLte         *float64        `json:"askTakerFee_lte,omitempty"`
	AskTakerFeeGt          *float64        `json:"askTakerFee_gt,omitempty"`
	AskTakerFeeGte         *float64        `json:"askTakerFee_gte,omitempty"`
	AskMakerFee            *float64        `json:"askMakerFee,omitempty"`
	AskMakerFeeNot         *float64        `json:"askMakerFee_not,omitempty"`
	AskMakerFeeIn          []float64       `json:"askMakerFee_in,omitempty"`
	AskMakerFeeNotIn       []float64       `json:"askMakerFee_not_in,omitempty"`
	AskMakerFeeLt          *float64        `json:"askMakerFee_lt,omitempty"`
	AskMakerFeeLte         *float64        `json:"askMakerFee_lte,omitempty"`
	AskMakerFeeGt          *float64        `json:"askMakerFee_gt,omitempty"`
	AskMakerFeeGte         *float64        `json:"askMakerFee_gte,omitempty"`
	BidTakerFee            *float64        `json:"bidTakerFee,omitempty"`
	BidTakerFeeNot         *float64        `json:"bidTakerFee_not,omitempty"`
	BidTakerFeeIn          []float64       `json:"bidTakerFee_in,omitempty"`
	BidTakerFeeNotIn       []float64       `json:"bidTakerFee_not_in,omitempty"`
	BidTakerFeeLt          *float64        `json:"bidTakerFee_lt,omitempty"`
	BidTakerFeeLte         *float64        `json:"bidTakerFee_lte,omitempty"`
	BidTakerFeeGt          *float64        `json:"bidTakerFee_gt,omitempty"`
	BidTakerFeeGte         *float64        `json:"bidTakerFee_gte,omitempty"`
	BidMakerFee            *float64        `json:"bidMakerFee,omitempty"`
	BidMakerFeeNot         *float64        `json:"bidMakerFee_not,omitempty"`
	BidMakerFeeIn          []float64       `json:"bidMakerFee_in,omitempty"`
	BidMakerFeeNotIn       []float64       `json:"bidMakerFee_not_in,omitempty"`
	BidMakerFeeLt          *float64        `json:"bidMakerFee_lt,omitempty"`
	BidMakerFeeLte         *float64        `json:"bidMakerFee_lte,omitempty"`
	BidMakerFeeGt          *float64        `json:"bidMakerFee_gt,omitempty"`
	BidMakerFeeGte         *float64        `json:"bidMakerFee_gte,omitempty"`
	MyCoinAskTakerFee      *float64        `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskTakerFeeNot   *float64        `json:"myCoinAskTakerFee_not,omitempty"`
	MyCoinAskTakerFeeIn    []float64       `json:"myCoinAskTakerFee_in,omitempty"`
	MyCoinAskTakerFeeNotIn []float64       `json:"myCoinAskTakerFee_not_in,omitempty"`
	MyCoinAskTakerFeeLt    *float64        `json:"myCoinAskTakerFee_lt,omitempty"`
	MyCoinAskTakerFeeLte   *float64        `json:"myCoinAskTakerFee_lte,omitempty"`
	MyCoinAskTakerFeeGt    *float64        `json:"myCoinAskTakerFee_gt,omitempty"`
	MyCoinAskTakerFeeGte   *float64        `json:"myCoinAskTakerFee_gte,omitempty"`
	MyCoinAskMakerFee      *float64        `json:"myCoinAskMakerFee,omitempty"`
	MyCoinAskMakerFeeNot   *float64        `json:"myCoinAskMakerFee_not,omitempty"`
	MyCoinAskMakerFeeIn    []float64       `json:"myCoinAskMakerFee_in,omitempty"`
	MyCoinAskMakerFeeNotIn []float64       `json:"myCoinAskMakerFee_not_in,omitempty"`
	MyCoinAskMakerFeeLt    *float64        `json:"myCoinAskMakerFee_lt,omitempty"`
	MyCoinAskMakerFeeLte   *float64        `json:"myCoinAskMakerFee_lte,omitempty"`
	MyCoinAskMakerFeeGt    *float64        `json:"myCoinAskMakerFee_gt,omitempty"`
	MyCoinAskMakerFeeGte   *float64        `json:"myCoinAskMakerFee_gte,omitempty"`
	MyCoinBidTakerFee      *float64        `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidTakerFeeNot   *float64        `json:"myCoinBidTakerFee_not,omitempty"`
	MyCoinBidTakerFeeIn    []float64       `json:"myCoinBidTakerFee_in,omitempty"`
	MyCoinBidTakerFeeNotIn []float64       `json:"myCoinBidTakerFee_not_in,omitempty"`
	MyCoinBidTakerFeeLt    *float64        `json:"myCoinBidTakerFee_lt,omitempty"`
	MyCoinBidTakerFeeLte   *float64        `json:"myCoinBidTakerFee_lte,omitempty"`
	MyCoinBidTakerFeeGt    *float64        `json:"myCoinBidTakerFee_gt,omitempty"`
	MyCoinBidTakerFeeGte   *float64        `json:"myCoinBidTakerFee_gte,omitempty"`
	MyCoinBidMakerFee      *float64        `json:"myCoinBidMakerFee,omitempty"`
	MyCoinBidMakerFeeNot   *float64        `json:"myCoinBidMakerFee_not,omitempty"`
	MyCoinBidMakerFeeIn    []float64       `json:"myCoinBidMakerFee_in,omitempty"`
	MyCoinBidMakerFeeNotIn []float64       `json:"myCoinBidMakerFee_not_in,omitempty"`
	MyCoinBidMakerFeeLt    *float64        `json:"myCoinBidMakerFee_lt,omitempty"`
	MyCoinBidMakerFeeLte   *float64        `json:"myCoinBidMakerFee_lte,omitempty"`
	MyCoinBidMakerFeeGt    *float64        `json:"myCoinBidMakerFee_gt,omitempty"`
	MyCoinBidMakerFeeGte   *float64        `json:"myCoinBidMakerFee_gte,omitempty"`
	RankRelationEvery      *UserWhereInput `json:"rankRelation_every,omitempty"`
	RankRelationSome       *UserWhereInput `json:"rankRelation_some,omitempty"`
	RankRelationNone       *UserWhereInput `json:"rankRelation_none,omitempty"`
	EventRelationEvery     *UserWhereInput `json:"eventRelation_every,omitempty"`
	EventRelationSome      *UserWhereInput `json:"eventRelation_some,omitempty"`
	EventRelationNone      *UserWhereInput `json:"eventRelation_none,omitempty"`
	CreatedAt              *string         `json:"createdAt,omitempty"`
	CreatedAtNot           *string         `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string         `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string         `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string         `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string         `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string         `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string         `json:"updatedAt_gte,omitempty"`
	And                    []FeeWhereInput `json:"AND,omitempty"`
	Or                     []FeeWhereInput `json:"OR,omitempty"`
	Not                    []FeeWhereInput `json:"NOT,omitempty"`
}

type InviteCodeWhereInput struct {
	ID                *string                      `json:"id,omitempty"`
	IDNot             *string                      `json:"id_not,omitempty"`
	IDIn              []string                     `json:"id_in,omitempty"`
	IDNotIn           []string                     `json:"id_not_in,omitempty"`
	IDLt              *string                      `json:"id_lt,omitempty"`
	IDLte             *string                      `json:"id_lte,omitempty"`
	IDGt              *string                      `json:"id_gt,omitempty"`
	IDGte             *string                      `json:"id_gte,omitempty"`
	IDContains        *string                      `json:"id_contains,omitempty"`
	IDNotContains     *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                      `json:"id_not_ends_with,omitempty"`
	NumId             *int32                       `json:"numId,omitempty"`
	NumIdNot          *int32                       `json:"numId_not,omitempty"`
	NumIdIn           []int32                      `json:"numId_in,omitempty"`
	NumIdNotIn        []int32                      `json:"numId_not_in,omitempty"`
	NumIdLt           *int32                       `json:"numId_lt,omitempty"`
	NumIdLte          *int32                       `json:"numId_lte,omitempty"`
	NumIdGt           *int32                       `json:"numId_gt,omitempty"`
	NumIdGte          *int32                       `json:"numId_gte,omitempty"`
	Code              *string                      `json:"code,omitempty"`
	CodeNot           *string                      `json:"code_not,omitempty"`
	CodeIn            []string                     `json:"code_in,omitempty"`
	CodeNotIn         []string                     `json:"code_not_in,omitempty"`
	CodeLt            *string                      `json:"code_lt,omitempty"`
	CodeLte           *string                      `json:"code_lte,omitempty"`
	CodeGt            *string                      `json:"code_gt,omitempty"`
	CodeGte           *string                      `json:"code_gte,omitempty"`
	CodeContains      *string                      `json:"code_contains,omitempty"`
	CodeNotContains   *string                      `json:"code_not_contains,omitempty"`
	CodeStartsWith    *string                      `json:"code_starts_with,omitempty"`
	CodeNotStartsWith *string                      `json:"code_not_starts_with,omitempty"`
	CodeEndsWith      *string                      `json:"code_ends_with,omitempty"`
	CodeNotEndsWith   *string                      `json:"code_not_ends_with,omitempty"`
	Owner             *UserWhereInput              `json:"owner,omitempty"`
	InviteUsersEvery  *InviteUserHistoryWhereInput `json:"inviteUsers_every,omitempty"`
	InviteUsersSome   *InviteUserHistoryWhereInput `json:"inviteUsers_some,omitempty"`
	InviteUsersNone   *InviteUserHistoryWhereInput `json:"inviteUsers_none,omitempty"`
	CreatedAt         *string                      `json:"createdAt,omitempty"`
	CreatedAtNot      *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                      `json:"updatedAt_gte,omitempty"`
	And               []InviteCodeWhereInput       `json:"AND,omitempty"`
	Or                []InviteCodeWhereInput       `json:"OR,omitempty"`
	Not               []InviteCodeWhereInput       `json:"NOT,omitempty"`
}

type InviteUserHistoryWhereInput struct {
	ID              *string                       `json:"id,omitempty"`
	IDNot           *string                       `json:"id_not,omitempty"`
	IDIn            []string                      `json:"id_in,omitempty"`
	IDNotIn         []string                      `json:"id_not_in,omitempty"`
	IDLt            *string                       `json:"id_lt,omitempty"`
	IDLte           *string                       `json:"id_lte,omitempty"`
	IDGt            *string                       `json:"id_gt,omitempty"`
	IDGte           *string                       `json:"id_gte,omitempty"`
	IDContains      *string                       `json:"id_contains,omitempty"`
	IDNotContains   *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                       `json:"id_not_ends_with,omitempty"`
	InviteCode      *InviteCodeWhereInput         `json:"inviteCode,omitempty"`
	User            *UserWhereInput               `json:"user,omitempty"`
	CreatedAt       *string                       `json:"createdAt,omitempty"`
	CreatedAtNot    *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                       `json:"updatedAt_gte,omitempty"`
	And             []InviteUserHistoryWhereInput `json:"AND,omitempty"`
	Or              []InviteUserHistoryWhereInput `json:"OR,omitempty"`
	Not             []InviteUserHistoryWhereInput `json:"NOT,omitempty"`
}

type PageWhereInput struct {
	ID                       *string                      `json:"id,omitempty"`
	IDNot                    *string                      `json:"id_not,omitempty"`
	IDIn                     []string                     `json:"id_in,omitempty"`
	IDNotIn                  []string                     `json:"id_not_in,omitempty"`
	IDLt                     *string                      `json:"id_lt,omitempty"`
	IDLte                    *string                      `json:"id_lte,omitempty"`
	IDGt                     *string                      `json:"id_gt,omitempty"`
	IDGte                    *string                      `json:"id_gte,omitempty"`
	IDContains               *string                      `json:"id_contains,omitempty"`
	IDNotContains            *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                      `json:"id_not_ends_with,omitempty"`
	PageId                   *string                      `json:"pageId,omitempty"`
	PageIdNot                *string                      `json:"pageId_not,omitempty"`
	PageIdIn                 []string                     `json:"pageId_in,omitempty"`
	PageIdNotIn              []string                     `json:"pageId_not_in,omitempty"`
	PageIdLt                 *string                      `json:"pageId_lt,omitempty"`
	PageIdLte                *string                      `json:"pageId_lte,omitempty"`
	PageIdGt                 *string                      `json:"pageId_gt,omitempty"`
	PageIdGte                *string                      `json:"pageId_gte,omitempty"`
	PageIdContains           *string                      `json:"pageId_contains,omitempty"`
	PageIdNotContains        *string                      `json:"pageId_not_contains,omitempty"`
	PageIdStartsWith         *string                      `json:"pageId_starts_with,omitempty"`
	PageIdNotStartsWith      *string                      `json:"pageId_not_starts_with,omitempty"`
	PageIdEndsWith           *string                      `json:"pageId_ends_with,omitempty"`
	PageIdNotEndsWith        *string                      `json:"pageId_not_ends_with,omitempty"`
	NickName                 *string                      `json:"nickName,omitempty"`
	NickNameNot              *string                      `json:"nickName_not,omitempty"`
	NickNameIn               []string                     `json:"nickName_in,omitempty"`
	NickNameNotIn            []string                     `json:"nickName_not_in,omitempty"`
	NickNameLt               *string                      `json:"nickName_lt,omitempty"`
	NickNameLte              *string                      `json:"nickName_lte,omitempty"`
	NickNameGt               *string                      `json:"nickName_gt,omitempty"`
	NickNameGte              *string                      `json:"nickName_gte,omitempty"`
	NickNameContains         *string                      `json:"nickName_contains,omitempty"`
	NickNameNotContains      *string                      `json:"nickName_not_contains,omitempty"`
	NickNameStartsWith       *string                      `json:"nickName_starts_with,omitempty"`
	NickNameNotStartsWith    *string                      `json:"nickName_not_starts_with,omitempty"`
	NickNameEndsWith         *string                      `json:"nickName_ends_with,omitempty"`
	NickNameNotEndsWith      *string                      `json:"nickName_not_ends_with,omitempty"`
	AvatarUrl                *string                      `json:"avatarUrl,omitempty"`
	AvatarUrlNot             *string                      `json:"avatarUrl_not,omitempty"`
	AvatarUrlIn              []string                     `json:"avatarUrl_in,omitempty"`
	AvatarUrlNotIn           []string                     `json:"avatarUrl_not_in,omitempty"`
	AvatarUrlLt              *string                      `json:"avatarUrl_lt,omitempty"`
	AvatarUrlLte             *string                      `json:"avatarUrl_lte,omitempty"`
	AvatarUrlGt              *string                      `json:"avatarUrl_gt,omitempty"`
	AvatarUrlGte             *string                      `json:"avatarUrl_gte,omitempty"`
	AvatarUrlContains        *string                      `json:"avatarUrl_contains,omitempty"`
	AvatarUrlNotContains     *string                      `json:"avatarUrl_not_contains,omitempty"`
	AvatarUrlStartsWith      *string                      `json:"avatarUrl_starts_with,omitempty"`
	AvatarUrlNotStartsWith   *string                      `json:"avatarUrl_not_starts_with,omitempty"`
	AvatarUrlEndsWith        *string                      `json:"avatarUrl_ends_with,omitempty"`
	AvatarUrlNotEndsWith     *string                      `json:"avatarUrl_not_ends_with,omitempty"`
	CoverUrl                 *string                      `json:"coverUrl,omitempty"`
	CoverUrlNot              *string                      `json:"coverUrl_not,omitempty"`
	CoverUrlIn               []string                     `json:"coverUrl_in,omitempty"`
	CoverUrlNotIn            []string                     `json:"coverUrl_not_in,omitempty"`
	CoverUrlLt               *string                      `json:"coverUrl_lt,omitempty"`
	CoverUrlLte              *string                      `json:"coverUrl_lte,omitempty"`
	CoverUrlGt               *string                      `json:"coverUrl_gt,omitempty"`
	CoverUrlGte              *string                      `json:"coverUrl_gte,omitempty"`
	CoverUrlContains         *string                      `json:"coverUrl_contains,omitempty"`
	CoverUrlNotContains      *string                      `json:"coverUrl_not_contains,omitempty"`
	CoverUrlStartsWith       *string                      `json:"coverUrl_starts_with,omitempty"`
	CoverUrlNotStartsWith    *string                      `json:"coverUrl_not_starts_with,omitempty"`
	CoverUrlEndsWith         *string                      `json:"coverUrl_ends_with,omitempty"`
	CoverUrlNotEndsWith      *string                      `json:"coverUrl_not_ends_with,omitempty"`
	Description              *string                      `json:"description,omitempty"`
	DescriptionNot           *string                      `json:"description_not,omitempty"`
	DescriptionIn            []string                     `json:"description_in,omitempty"`
	DescriptionNotIn         []string                     `json:"description_not_in,omitempty"`
	DescriptionLt            *string                      `json:"description_lt,omitempty"`
	DescriptionLte           *string                      `json:"description_lte,omitempty"`
	DescriptionGt            *string                      `json:"description_gt,omitempty"`
	DescriptionGte           *string                      `json:"description_gte,omitempty"`
	DescriptionContains      *string                      `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                      `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                      `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                      `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                      `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                      `json:"description_not_ends_with,omitempty"`
	BadgesEvery              *PageBadgeWhereInput         `json:"badges_every,omitempty"`
	BadgesSome               *PageBadgeWhereInput         `json:"badges_some,omitempty"`
	BadgesNone               *PageBadgeWhereInput         `json:"badges_none,omitempty"`
	Youtube                  *YoutubeWhereInput           `json:"youtube,omitempty"`
	Twitch                   *TwitchWhereInput            `json:"twitch,omitempty"`
	Instagram                *InstagramWhereInput         `json:"instagram,omitempty"`
	AfreecaTv                *AfreecaTvWhereInput         `json:"afreecaTV,omitempty"`
	FansEvery                *PageFanWhereInput           `json:"fans_every,omitempty"`
	FansSome                 *PageFanWhereInput           `json:"fans_some,omitempty"`
	FansNone                 *PageFanWhereInput           `json:"fans_none,omitempty"`
	Owner                    *UserWhereInput              `json:"owner,omitempty"`
	CommentsEvery            *PageCommentWhereInput       `json:"comments_every,omitempty"`
	CommentsSome             *PageCommentWhereInput       `json:"comments_some,omitempty"`
	CommentsNone             *PageCommentWhereInput       `json:"comments_none,omitempty"`
	RequestPageItemsEvery    *RequestPageItemWhereInput   `json:"requestPageItems_every,omitempty"`
	RequestPageItemsSome     *RequestPageItemWhereInput   `json:"requestPageItems_some,omitempty"`
	RequestPageItemsNone     *RequestPageItemWhereInput   `json:"requestPageItems_none,omitempty"`
	ReviewsEvery             *ReviewContentPageWhereInput `json:"reviews_every,omitempty"`
	ReviewsSome              *ReviewContentPageWhereInput `json:"reviews_some,omitempty"`
	ReviewsNone              *ReviewContentPageWhereInput `json:"reviews_none,omitempty"`
	RelatedReviewsEvery      *ReviewContentWhereInput     `json:"relatedReviews_every,omitempty"`
	RelatedReviewsSome       *ReviewContentWhereInput     `json:"relatedReviews_some,omitempty"`
	RelatedReviewsNone       *ReviewContentWhereInput     `json:"relatedReviews_none,omitempty"`
	CreatedAt                *string                      `json:"createdAt,omitempty"`
	CreatedAtNot             *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                      `json:"updatedAt_gte,omitempty"`
	And                      []PageWhereInput             `json:"AND,omitempty"`
	Or                       []PageWhereInput             `json:"OR,omitempty"`
	Not                      []PageWhereInput             `json:"NOT,omitempty"`
}

type PageBadgeWhereInput struct {
	ID              *string               `json:"id,omitempty"`
	IDNot           *string               `json:"id_not,omitempty"`
	IDIn            []string              `json:"id_in,omitempty"`
	IDNotIn         []string              `json:"id_not_in,omitempty"`
	IDLt            *string               `json:"id_lt,omitempty"`
	IDLte           *string               `json:"id_lte,omitempty"`
	IDGt            *string               `json:"id_gt,omitempty"`
	IDGte           *string               `json:"id_gte,omitempty"`
	IDContains      *string               `json:"id_contains,omitempty"`
	IDNotContains   *string               `json:"id_not_contains,omitempty"`
	IDStartsWith    *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string               `json:"id_not_ends_with,omitempty"`
	Badge           *BadgeWhereInput      `json:"badge,omitempty"`
	Vote            *int32                `json:"vote,omitempty"`
	VoteNot         *int32                `json:"vote_not,omitempty"`
	VoteIn          []int32               `json:"vote_in,omitempty"`
	VoteNotIn       []int32               `json:"vote_not_in,omitempty"`
	VoteLt          *int32                `json:"vote_lt,omitempty"`
	VoteLte         *int32                `json:"vote_lte,omitempty"`
	VoteGt          *int32                `json:"vote_gt,omitempty"`
	VoteGte         *int32                `json:"vote_gte,omitempty"`
	VoterEvery      *BadgeVoterWhereInput `json:"voter_every,omitempty"`
	VoterSome       *BadgeVoterWhereInput `json:"voter_some,omitempty"`
	VoterNone       *BadgeVoterWhereInput `json:"voter_none,omitempty"`
	Page            *PageWhereInput       `json:"page,omitempty"`
	CreatedAt       *string               `json:"createdAt,omitempty"`
	CreatedAtNot    *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string               `json:"updatedAt_gte,omitempty"`
	And             []PageBadgeWhereInput `json:"AND,omitempty"`
	Or              []PageBadgeWhereInput `json:"OR,omitempty"`
	Not             []PageBadgeWhereInput `json:"NOT,omitempty"`
}

type BadgeWhereInput struct {
	ID                       *string              `json:"id,omitempty"`
	IDNot                    *string              `json:"id_not,omitempty"`
	IDIn                     []string             `json:"id_in,omitempty"`
	IDNotIn                  []string             `json:"id_not_in,omitempty"`
	IDLt                     *string              `json:"id_lt,omitempty"`
	IDLte                    *string              `json:"id_lte,omitempty"`
	IDGt                     *string              `json:"id_gt,omitempty"`
	IDGte                    *string              `json:"id_gte,omitempty"`
	IDContains               *string              `json:"id_contains,omitempty"`
	IDNotContains            *string              `json:"id_not_contains,omitempty"`
	IDStartsWith             *string              `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string              `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string              `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string              `json:"id_not_ends_with,omitempty"`
	Name                     *string              `json:"name,omitempty"`
	NameNot                  *string              `json:"name_not,omitempty"`
	NameIn                   []string             `json:"name_in,omitempty"`
	NameNotIn                []string             `json:"name_not_in,omitempty"`
	NameLt                   *string              `json:"name_lt,omitempty"`
	NameLte                  *string              `json:"name_lte,omitempty"`
	NameGt                   *string              `json:"name_gt,omitempty"`
	NameGte                  *string              `json:"name_gte,omitempty"`
	NameContains             *string              `json:"name_contains,omitempty"`
	NameNotContains          *string              `json:"name_not_contains,omitempty"`
	NameStartsWith           *string              `json:"name_starts_with,omitempty"`
	NameNotStartsWith        *string              `json:"name_not_starts_with,omitempty"`
	NameEndsWith             *string              `json:"name_ends_with,omitempty"`
	NameNotEndsWith          *string              `json:"name_not_ends_with,omitempty"`
	ImageUrl                 *string              `json:"imageUrl,omitempty"`
	ImageUrlNot              *string              `json:"imageUrl_not,omitempty"`
	ImageUrlIn               []string             `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn            []string             `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt               *string              `json:"imageUrl_lt,omitempty"`
	ImageUrlLte              *string              `json:"imageUrl_lte,omitempty"`
	ImageUrlGt               *string              `json:"imageUrl_gt,omitempty"`
	ImageUrlGte              *string              `json:"imageUrl_gte,omitempty"`
	ImageUrlContains         *string              `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains      *string              `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith       *string              `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith    *string              `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith         *string              `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith      *string              `json:"imageUrl_not_ends_with,omitempty"`
	Description              *string              `json:"description,omitempty"`
	DescriptionNot           *string              `json:"description_not,omitempty"`
	DescriptionIn            []string             `json:"description_in,omitempty"`
	DescriptionNotIn         []string             `json:"description_not_in,omitempty"`
	DescriptionLt            *string              `json:"description_lt,omitempty"`
	DescriptionLte           *string              `json:"description_lte,omitempty"`
	DescriptionGt            *string              `json:"description_gt,omitempty"`
	DescriptionGte           *string              `json:"description_gte,omitempty"`
	DescriptionContains      *string              `json:"description_contains,omitempty"`
	DescriptionNotContains   *string              `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string              `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string              `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string              `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string              `json:"description_not_ends_with,omitempty"`
	OrderIndex               *int32               `json:"orderIndex,omitempty"`
	OrderIndexNot            *int32               `json:"orderIndex_not,omitempty"`
	OrderIndexIn             []int32              `json:"orderIndex_in,omitempty"`
	OrderIndexNotIn          []int32              `json:"orderIndex_not_in,omitempty"`
	OrderIndexLt             *int32               `json:"orderIndex_lt,omitempty"`
	OrderIndexLte            *int32               `json:"orderIndex_lte,omitempty"`
	OrderIndexGt             *int32               `json:"orderIndex_gt,omitempty"`
	OrderIndexGte            *int32               `json:"orderIndex_gte,omitempty"`
	PagesEvery               *PageBadgeWhereInput `json:"pages_every,omitempty"`
	PagesSome                *PageBadgeWhereInput `json:"pages_some,omitempty"`
	PagesNone                *PageBadgeWhereInput `json:"pages_none,omitempty"`
	CreatedAt                *string              `json:"createdAt,omitempty"`
	CreatedAtNot             *string              `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string              `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string              `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string              `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string              `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string              `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string              `json:"updatedAt_gte,omitempty"`
	And                      []BadgeWhereInput    `json:"AND,omitempty"`
	Or                       []BadgeWhereInput    `json:"OR,omitempty"`
	Not                      []BadgeWhereInput    `json:"NOT,omitempty"`
}

type BadgeVoterWhereInput struct {
	ID              *string                  `json:"id,omitempty"`
	IDNot           *string                  `json:"id_not,omitempty"`
	IDIn            []string                 `json:"id_in,omitempty"`
	IDNotIn         []string                 `json:"id_not_in,omitempty"`
	IDLt            *string                  `json:"id_lt,omitempty"`
	IDLte           *string                  `json:"id_lte,omitempty"`
	IDGt            *string                  `json:"id_gt,omitempty"`
	IDGte           *string                  `json:"id_gte,omitempty"`
	IDContains      *string                  `json:"id_contains,omitempty"`
	IDNotContains   *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                  `json:"id_not_ends_with,omitempty"`
	PageBadge       *PageBadgeWhereInput     `json:"pageBadge,omitempty"`
	ReviewContent   *ReviewContentWhereInput `json:"reviewContent,omitempty"`
	User            *UserWhereInput          `json:"user,omitempty"`
	Ip              *string                  `json:"ip,omitempty"`
	IpNot           *string                  `json:"ip_not,omitempty"`
	IpIn            []string                 `json:"ip_in,omitempty"`
	IpNotIn         []string                 `json:"ip_not_in,omitempty"`
	IpLt            *string                  `json:"ip_lt,omitempty"`
	IpLte           *string                  `json:"ip_lte,omitempty"`
	IpGt            *string                  `json:"ip_gt,omitempty"`
	IpGte           *string                  `json:"ip_gte,omitempty"`
	IpContains      *string                  `json:"ip_contains,omitempty"`
	IpNotContains   *string                  `json:"ip_not_contains,omitempty"`
	IpStartsWith    *string                  `json:"ip_starts_with,omitempty"`
	IpNotStartsWith *string                  `json:"ip_not_starts_with,omitempty"`
	IpEndsWith      *string                  `json:"ip_ends_with,omitempty"`
	IpNotEndsWith   *string                  `json:"ip_not_ends_with,omitempty"`
	CreatedAt       *string                  `json:"createdAt,omitempty"`
	CreatedAtNot    *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                  `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                  `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                  `json:"updatedAt_gte,omitempty"`
	And             []BadgeVoterWhereInput   `json:"AND,omitempty"`
	Or              []BadgeVoterWhereInput   `json:"OR,omitempty"`
	Not             []BadgeVoterWhereInput   `json:"NOT,omitempty"`
}

type ReviewContentWhereInput struct {
	ID                           *string                          `json:"id,omitempty"`
	IDNot                        *string                          `json:"id_not,omitempty"`
	IDIn                         []string                         `json:"id_in,omitempty"`
	IDNotIn                      []string                         `json:"id_not_in,omitempty"`
	IDLt                         *string                          `json:"id_lt,omitempty"`
	IDLte                        *string                          `json:"id_lte,omitempty"`
	IDGt                         *string                          `json:"id_gt,omitempty"`
	IDGte                        *string                          `json:"id_gte,omitempty"`
	IDContains                   *string                          `json:"id_contains,omitempty"`
	IDNotContains                *string                          `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                          `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                          `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                          `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                          `json:"id_not_ends_with,omitempty"`
	ReviewContentPage            *ReviewContentPageWhereInput     `json:"reviewContentPage,omitempty"`
	PreviewImageUrl              *string                          `json:"previewImageUrl,omitempty"`
	PreviewImageUrlNot           *string                          `json:"previewImageUrl_not,omitempty"`
	PreviewImageUrlIn            []string                         `json:"previewImageUrl_in,omitempty"`
	PreviewImageUrlNotIn         []string                         `json:"previewImageUrl_not_in,omitempty"`
	PreviewImageUrlLt            *string                          `json:"previewImageUrl_lt,omitempty"`
	PreviewImageUrlLte           *string                          `json:"previewImageUrl_lte,omitempty"`
	PreviewImageUrlGt            *string                          `json:"previewImageUrl_gt,omitempty"`
	PreviewImageUrlGte           *string                          `json:"previewImageUrl_gte,omitempty"`
	PreviewImageUrlContains      *string                          `json:"previewImageUrl_contains,omitempty"`
	PreviewImageUrlNotContains   *string                          `json:"previewImageUrl_not_contains,omitempty"`
	PreviewImageUrlStartsWith    *string                          `json:"previewImageUrl_starts_with,omitempty"`
	PreviewImageUrlNotStartsWith *string                          `json:"previewImageUrl_not_starts_with,omitempty"`
	PreviewImageUrlEndsWith      *string                          `json:"previewImageUrl_ends_with,omitempty"`
	PreviewImageUrlNotEndsWith   *string                          `json:"previewImageUrl_not_ends_with,omitempty"`
	Title                        *string                          `json:"title,omitempty"`
	TitleNot                     *string                          `json:"title_not,omitempty"`
	TitleIn                      []string                         `json:"title_in,omitempty"`
	TitleNotIn                   []string                         `json:"title_not_in,omitempty"`
	TitleLt                      *string                          `json:"title_lt,omitempty"`
	TitleLte                     *string                          `json:"title_lte,omitempty"`
	TitleGt                      *string                          `json:"title_gt,omitempty"`
	TitleGte                     *string                          `json:"title_gte,omitempty"`
	TitleContains                *string                          `json:"title_contains,omitempty"`
	TitleNotContains             *string                          `json:"title_not_contains,omitempty"`
	TitleStartsWith              *string                          `json:"title_starts_with,omitempty"`
	TitleNotStartsWith           *string                          `json:"title_not_starts_with,omitempty"`
	TitleEndsWith                *string                          `json:"title_ends_with,omitempty"`
	TitleNotEndsWith             *string                          `json:"title_not_ends_with,omitempty"`
	Type                         *string                          `json:"type,omitempty"`
	TypeNot                      *string                          `json:"type_not,omitempty"`
	TypeIn                       []string                         `json:"type_in,omitempty"`
	TypeNotIn                    []string                         `json:"type_not_in,omitempty"`
	TypeLt                       *string                          `json:"type_lt,omitempty"`
	TypeLte                      *string                          `json:"type_lte,omitempty"`
	TypeGt                       *string                          `json:"type_gt,omitempty"`
	TypeGte                      *string                          `json:"type_gte,omitempty"`
	TypeContains                 *string                          `json:"type_contains,omitempty"`
	TypeNotContains              *string                          `json:"type_not_contains,omitempty"`
	TypeStartsWith               *string                          `json:"type_starts_with,omitempty"`
	TypeNotStartsWith            *string                          `json:"type_not_starts_with,omitempty"`
	TypeEndsWith                 *string                          `json:"type_ends_with,omitempty"`
	TypeNotEndsWith              *string                          `json:"type_not_ends_with,omitempty"`
	Url                          *string                          `json:"url,omitempty"`
	UrlNot                       *string                          `json:"url_not,omitempty"`
	UrlIn                        []string                         `json:"url_in,omitempty"`
	UrlNotIn                     []string                         `json:"url_not_in,omitempty"`
	UrlLt                        *string                          `json:"url_lt,omitempty"`
	UrlLte                       *string                          `json:"url_lte,omitempty"`
	UrlGt                        *string                          `json:"url_gt,omitempty"`
	UrlGte                       *string                          `json:"url_gte,omitempty"`
	UrlContains                  *string                          `json:"url_contains,omitempty"`
	UrlNotContains               *string                          `json:"url_not_contains,omitempty"`
	UrlStartsWith                *string                          `json:"url_starts_with,omitempty"`
	UrlNotStartsWith             *string                          `json:"url_not_starts_with,omitempty"`
	UrlEndsWith                  *string                          `json:"url_ends_with,omitempty"`
	UrlNotEndsWith               *string                          `json:"url_not_ends_with,omitempty"`
	Review                       *string                          `json:"review,omitempty"`
	ReviewNot                    *string                          `json:"review_not,omitempty"`
	ReviewIn                     []string                         `json:"review_in,omitempty"`
	ReviewNotIn                  []string                         `json:"review_not_in,omitempty"`
	ReviewLt                     *string                          `json:"review_lt,omitempty"`
	ReviewLte                    *string                          `json:"review_lte,omitempty"`
	ReviewGt                     *string                          `json:"review_gt,omitempty"`
	ReviewGte                    *string                          `json:"review_gte,omitempty"`
	ReviewContains               *string                          `json:"review_contains,omitempty"`
	ReviewNotContains            *string                          `json:"review_not_contains,omitempty"`
	ReviewStartsWith             *string                          `json:"review_starts_with,omitempty"`
	ReviewNotStartsWith          *string                          `json:"review_not_starts_with,omitempty"`
	ReviewEndsWith               *string                          `json:"review_ends_with,omitempty"`
	ReviewNotEndsWith            *string                          `json:"review_not_ends_with,omitempty"`
	VideoId                      *string                          `json:"videoId,omitempty"`
	VideoIdNot                   *string                          `json:"videoId_not,omitempty"`
	VideoIdIn                    []string                         `json:"videoId_in,omitempty"`
	VideoIdNotIn                 []string                         `json:"videoId_not_in,omitempty"`
	VideoIdLt                    *string                          `json:"videoId_lt,omitempty"`
	VideoIdLte                   *string                          `json:"videoId_lte,omitempty"`
	VideoIdGt                    *string                          `json:"videoId_gt,omitempty"`
	VideoIdGte                   *string                          `json:"videoId_gte,omitempty"`
	VideoIdContains              *string                          `json:"videoId_contains,omitempty"`
	VideoIdNotContains           *string                          `json:"videoId_not_contains,omitempty"`
	VideoIdStartsWith            *string                          `json:"videoId_starts_with,omitempty"`
	VideoIdNotStartsWith         *string                          `json:"videoId_not_starts_with,omitempty"`
	VideoIdEndsWith              *string                          `json:"videoId_ends_with,omitempty"`
	VideoIdNotEndsWith           *string                          `json:"videoId_not_ends_with,omitempty"`
	ContentId                    *string                          `json:"contentId,omitempty"`
	ContentIdNot                 *string                          `json:"contentId_not,omitempty"`
	ContentIdIn                  []string                         `json:"contentId_in,omitempty"`
	ContentIdNotIn               []string                         `json:"contentId_not_in,omitempty"`
	ContentIdLt                  *string                          `json:"contentId_lt,omitempty"`
	ContentIdLte                 *string                          `json:"contentId_lte,omitempty"`
	ContentIdGt                  *string                          `json:"contentId_gt,omitempty"`
	ContentIdGte                 *string                          `json:"contentId_gte,omitempty"`
	ContentIdContains            *string                          `json:"contentId_contains,omitempty"`
	ContentIdNotContains         *string                          `json:"contentId_not_contains,omitempty"`
	ContentIdStartsWith          *string                          `json:"contentId_starts_with,omitempty"`
	ContentIdNotStartsWith       *string                          `json:"contentId_not_starts_with,omitempty"`
	ContentIdEndsWith            *string                          `json:"contentId_ends_with,omitempty"`
	ContentIdNotEndsWith         *string                          `json:"contentId_not_ends_with,omitempty"`
	ViewersEvery                 *ReviewContentViewerWhereInput   `json:"viewers_every,omitempty"`
	ViewersSome                  *ReviewContentViewerWhereInput   `json:"viewers_some,omitempty"`
	ViewersNone                  *ReviewContentViewerWhereInput   `json:"viewers_none,omitempty"`
	ReviewersEvery               *ReviewContentReviewerWhereInput `json:"reviewers_every,omitempty"`
	ReviewersSome                *ReviewContentReviewerWhereInput `json:"reviewers_some,omitempty"`
	ReviewersNone                *ReviewContentReviewerWhereInput `json:"reviewers_none,omitempty"`
	RelatedPage                  *PageWhereInput                  `json:"relatedPage,omitempty"`
	Owner                        *UserWhereInput                  `json:"owner,omitempty"`
	CreatedAt                    *string                          `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                          `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                          `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                          `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                          `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                          `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                          `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                          `json:"updatedAt_gte,omitempty"`
	And                          []ReviewContentWhereInput        `json:"AND,omitempty"`
	Or                           []ReviewContentWhereInput        `json:"OR,omitempty"`
	Not                          []ReviewContentWhereInput        `json:"NOT,omitempty"`
}

type ReviewContentPageWhereInput struct {
	ID                    *string                              `json:"id,omitempty"`
	IDNot                 *string                              `json:"id_not,omitempty"`
	IDIn                  []string                             `json:"id_in,omitempty"`
	IDNotIn               []string                             `json:"id_not_in,omitempty"`
	IDLt                  *string                              `json:"id_lt,omitempty"`
	IDLte                 *string                              `json:"id_lte,omitempty"`
	IDGt                  *string                              `json:"id_gt,omitempty"`
	IDGte                 *string                              `json:"id_gte,omitempty"`
	IDContains            *string                              `json:"id_contains,omitempty"`
	IDNotContains         *string                              `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                              `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                              `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                              `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                              `json:"id_not_ends_with,omitempty"`
	Page                  *PageWhereInput                      `json:"page,omitempty"`
	CategoriesEvery       *ReviewContentCategoryWhereInput     `json:"categories_every,omitempty"`
	CategoriesSome        *ReviewContentCategoryWhereInput     `json:"categories_some,omitempty"`
	CategoriesNone        *ReviewContentCategoryWhereInput     `json:"categories_none,omitempty"`
	Title                 *string                              `json:"title,omitempty"`
	TitleNot              *string                              `json:"title_not,omitempty"`
	TitleIn               []string                             `json:"title_in,omitempty"`
	TitleNotIn            []string                             `json:"title_not_in,omitempty"`
	TitleLt               *string                              `json:"title_lt,omitempty"`
	TitleLte              *string                              `json:"title_lte,omitempty"`
	TitleGt               *string                              `json:"title_gt,omitempty"`
	TitleGte              *string                              `json:"title_gte,omitempty"`
	TitleContains         *string                              `json:"title_contains,omitempty"`
	TitleNotContains      *string                              `json:"title_not_contains,omitempty"`
	TitleStartsWith       *string                              `json:"title_starts_with,omitempty"`
	TitleNotStartsWith    *string                              `json:"title_not_starts_with,omitempty"`
	TitleEndsWith         *string                              `json:"title_ends_with,omitempty"`
	TitleNotEndsWith      *string                              `json:"title_not_ends_with,omitempty"`
	SubTitle              *string                              `json:"subTitle,omitempty"`
	SubTitleNot           *string                              `json:"subTitle_not,omitempty"`
	SubTitleIn            []string                             `json:"subTitle_in,omitempty"`
	SubTitleNotIn         []string                             `json:"subTitle_not_in,omitempty"`
	SubTitleLt            *string                              `json:"subTitle_lt,omitempty"`
	SubTitleLte           *string                              `json:"subTitle_lte,omitempty"`
	SubTitleGt            *string                              `json:"subTitle_gt,omitempty"`
	SubTitleGte           *string                              `json:"subTitle_gte,omitempty"`
	SubTitleContains      *string                              `json:"subTitle_contains,omitempty"`
	SubTitleNotContains   *string                              `json:"subTitle_not_contains,omitempty"`
	SubTitleStartsWith    *string                              `json:"subTitle_starts_with,omitempty"`
	SubTitleNotStartsWith *string                              `json:"subTitle_not_starts_with,omitempty"`
	SubTitleEndsWith      *string                              `json:"subTitle_ends_with,omitempty"`
	SubTitleNotEndsWith   *string                              `json:"subTitle_not_ends_with,omitempty"`
	Message               *string                              `json:"message,omitempty"`
	MessageNot            *string                              `json:"message_not,omitempty"`
	MessageIn             []string                             `json:"message_in,omitempty"`
	MessageNotIn          []string                             `json:"message_not_in,omitempty"`
	MessageLt             *string                              `json:"message_lt,omitempty"`
	MessageLte            *string                              `json:"message_lte,omitempty"`
	MessageGt             *string                              `json:"message_gt,omitempty"`
	MessageGte            *string                              `json:"message_gte,omitempty"`
	MessageContains       *string                              `json:"message_contains,omitempty"`
	MessageNotContains    *string                              `json:"message_not_contains,omitempty"`
	MessageStartsWith     *string                              `json:"message_starts_with,omitempty"`
	MessageNotStartsWith  *string                              `json:"message_not_starts_with,omitempty"`
	MessageEndsWith       *string                              `json:"message_ends_with,omitempty"`
	MessageNotEndsWith    *string                              `json:"message_not_ends_with,omitempty"`
	ViewersEvery          *ReviewContentPageViewerWhereInput   `json:"viewers_every,omitempty"`
	ViewersSome           *ReviewContentPageViewerWhereInput   `json:"viewers_some,omitempty"`
	ViewersNone           *ReviewContentPageViewerWhereInput   `json:"viewers_none,omitempty"`
	ReviewsEvery          *ReviewContentWhereInput             `json:"reviews_every,omitempty"`
	ReviewsSome           *ReviewContentWhereInput             `json:"reviews_some,omitempty"`
	ReviewsNone           *ReviewContentWhereInput             `json:"reviews_none,omitempty"`
	CommentsEvery         *PageCommentWhereInput               `json:"comments_every,omitempty"`
	CommentsSome          *PageCommentWhereInput               `json:"comments_some,omitempty"`
	CommentsNone          *PageCommentWhereInput               `json:"comments_none,omitempty"`
	Owner                 *UserWhereInput                      `json:"owner,omitempty"`
	FeedBacksEvery        *ReviewContentPageFeedBackWhereInput `json:"feedBacks_every,omitempty"`
	FeedBacksSome         *ReviewContentPageFeedBackWhereInput `json:"feedBacks_some,omitempty"`
	FeedBacksNone         *ReviewContentPageFeedBackWhereInput `json:"feedBacks_none,omitempty"`
	ReleasedAt            *string                              `json:"releasedAt,omitempty"`
	ReleasedAtNot         *string                              `json:"releasedAt_not,omitempty"`
	ReleasedAtIn          []string                             `json:"releasedAt_in,omitempty"`
	ReleasedAtNotIn       []string                             `json:"releasedAt_not_in,omitempty"`
	ReleasedAtLt          *string                              `json:"releasedAt_lt,omitempty"`
	ReleasedAtLte         *string                              `json:"releasedAt_lte,omitempty"`
	ReleasedAtGt          *string                              `json:"releasedAt_gt,omitempty"`
	ReleasedAtGte         *string                              `json:"releasedAt_gte,omitempty"`
	IsDrafts              *bool                                `json:"isDrafts,omitempty"`
	IsDraftsNot           *bool                                `json:"isDrafts_not,omitempty"`
	IsDel                 *bool                                `json:"isDel,omitempty"`
	IsDelNot              *bool                                `json:"isDel_not,omitempty"`
	CreatedAt             *string                              `json:"createdAt,omitempty"`
	CreatedAtNot          *string                              `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                              `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                              `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                              `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                              `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                              `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                              `json:"updatedAt_gte,omitempty"`
	And                   []ReviewContentPageWhereInput        `json:"AND,omitempty"`
	Or                    []ReviewContentPageWhereInput        `json:"OR,omitempty"`
	Not                   []ReviewContentPageWhereInput        `json:"NOT,omitempty"`
}

type ReviewContentCategoryWhereInput struct {
	ID                    *string                           `json:"id,omitempty"`
	IDNot                 *string                           `json:"id_not,omitempty"`
	IDIn                  []string                          `json:"id_in,omitempty"`
	IDNotIn               []string                          `json:"id_not_in,omitempty"`
	IDLt                  *string                           `json:"id_lt,omitempty"`
	IDLte                 *string                           `json:"id_lte,omitempty"`
	IDGt                  *string                           `json:"id_gt,omitempty"`
	IDGte                 *string                           `json:"id_gte,omitempty"`
	IDContains            *string                           `json:"id_contains,omitempty"`
	IDNotContains         *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                           `json:"id_not_ends_with,omitempty"`
	Name                  *string                           `json:"name,omitempty"`
	NameNot               *string                           `json:"name_not,omitempty"`
	NameIn                []string                          `json:"name_in,omitempty"`
	NameNotIn             []string                          `json:"name_not_in,omitempty"`
	NameLt                *string                           `json:"name_lt,omitempty"`
	NameLte               *string                           `json:"name_lte,omitempty"`
	NameGt                *string                           `json:"name_gt,omitempty"`
	NameGte               *string                           `json:"name_gte,omitempty"`
	NameContains          *string                           `json:"name_contains,omitempty"`
	NameNotContains       *string                           `json:"name_not_contains,omitempty"`
	NameStartsWith        *string                           `json:"name_starts_with,omitempty"`
	NameNotStartsWith     *string                           `json:"name_not_starts_with,omitempty"`
	NameEndsWith          *string                           `json:"name_ends_with,omitempty"`
	NameNotEndsWith       *string                           `json:"name_not_ends_with,omitempty"`
	ImageUrl              *string                           `json:"imageUrl,omitempty"`
	ImageUrlNot           *string                           `json:"imageUrl_not,omitempty"`
	ImageUrlIn            []string                          `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn         []string                          `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt            *string                           `json:"imageUrl_lt,omitempty"`
	ImageUrlLte           *string                           `json:"imageUrl_lte,omitempty"`
	ImageUrlGt            *string                           `json:"imageUrl_gt,omitempty"`
	ImageUrlGte           *string                           `json:"imageUrl_gte,omitempty"`
	ImageUrlContains      *string                           `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains   *string                           `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith    *string                           `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith *string                           `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith      *string                           `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith   *string                           `json:"imageUrl_not_ends_with,omitempty"`
	CreatedAt             *string                           `json:"createdAt,omitempty"`
	CreatedAtNot          *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                           `json:"updatedAt_gte,omitempty"`
	And                   []ReviewContentCategoryWhereInput `json:"AND,omitempty"`
	Or                    []ReviewContentCategoryWhereInput `json:"OR,omitempty"`
	Not                   []ReviewContentCategoryWhereInput `json:"NOT,omitempty"`
}

type ReviewContentPageViewerWhereInput struct {
	ID                *string                             `json:"id,omitempty"`
	IDNot             *string                             `json:"id_not,omitempty"`
	IDIn              []string                            `json:"id_in,omitempty"`
	IDNotIn           []string                            `json:"id_not_in,omitempty"`
	IDLt              *string                             `json:"id_lt,omitempty"`
	IDLte             *string                             `json:"id_lte,omitempty"`
	IDGt              *string                             `json:"id_gt,omitempty"`
	IDGte             *string                             `json:"id_gte,omitempty"`
	IDContains        *string                             `json:"id_contains,omitempty"`
	IDNotContains     *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                             `json:"id_not_ends_with,omitempty"`
	ReviewContentPage *ReviewContentPageWhereInput        `json:"reviewContentPage,omitempty"`
	User              *UserWhereInput                     `json:"user,omitempty"`
	Ip                *string                             `json:"ip,omitempty"`
	IpNot             *string                             `json:"ip_not,omitempty"`
	IpIn              []string                            `json:"ip_in,omitempty"`
	IpNotIn           []string                            `json:"ip_not_in,omitempty"`
	IpLt              *string                             `json:"ip_lt,omitempty"`
	IpLte             *string                             `json:"ip_lte,omitempty"`
	IpGt              *string                             `json:"ip_gt,omitempty"`
	IpGte             *string                             `json:"ip_gte,omitempty"`
	IpContains        *string                             `json:"ip_contains,omitempty"`
	IpNotContains     *string                             `json:"ip_not_contains,omitempty"`
	IpStartsWith      *string                             `json:"ip_starts_with,omitempty"`
	IpNotStartsWith   *string                             `json:"ip_not_starts_with,omitempty"`
	IpEndsWith        *string                             `json:"ip_ends_with,omitempty"`
	IpNotEndsWith     *string                             `json:"ip_not_ends_with,omitempty"`
	CreatedAt         *string                             `json:"createdAt,omitempty"`
	CreatedAtNot      *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                             `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                             `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                             `json:"updatedAt_gte,omitempty"`
	And               []ReviewContentPageViewerWhereInput `json:"AND,omitempty"`
	Or                []ReviewContentPageViewerWhereInput `json:"OR,omitempty"`
	Not               []ReviewContentPageViewerWhereInput `json:"NOT,omitempty"`
}

type PageCommentWhereInput struct {
	ID                             *string                      `json:"id,omitempty"`
	IDNot                          *string                      `json:"id_not,omitempty"`
	IDIn                           []string                     `json:"id_in,omitempty"`
	IDNotIn                        []string                     `json:"id_not_in,omitempty"`
	IDLt                           *string                      `json:"id_lt,omitempty"`
	IDLte                          *string                      `json:"id_lte,omitempty"`
	IDGt                           *string                      `json:"id_gt,omitempty"`
	IDGte                          *string                      `json:"id_gte,omitempty"`
	IDContains                     *string                      `json:"id_contains,omitempty"`
	IDNotContains                  *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                      `json:"id_not_ends_with,omitempty"`
	Page                           *PageWhereInput              `json:"page,omitempty"`
	Content                        *string                      `json:"content,omitempty"`
	ContentNot                     *string                      `json:"content_not,omitempty"`
	ContentIn                      []string                     `json:"content_in,omitempty"`
	ContentNotIn                   []string                     `json:"content_not_in,omitempty"`
	ContentLt                      *string                      `json:"content_lt,omitempty"`
	ContentLte                     *string                      `json:"content_lte,omitempty"`
	ContentGt                      *string                      `json:"content_gt,omitempty"`
	ContentGte                     *string                      `json:"content_gte,omitempty"`
	ContentContains                *string                      `json:"content_contains,omitempty"`
	ContentNotContains             *string                      `json:"content_not_contains,omitempty"`
	ContentStartsWith              *string                      `json:"content_starts_with,omitempty"`
	ContentNotStartsWith           *string                      `json:"content_not_starts_with,omitempty"`
	ContentEndsWith                *string                      `json:"content_ends_with,omitempty"`
	ContentNotEndsWith             *string                      `json:"content_not_ends_with,omitempty"`
	CommentsEvery                  *PageCommentReplyWhereInput  `json:"comments_every,omitempty"`
	CommentsSome                   *PageCommentReplyWhereInput  `json:"comments_some,omitempty"`
	CommentsNone                   *PageCommentReplyWhereInput  `json:"comments_none,omitempty"`
	IpAddress                      *string                      `json:"ipAddress,omitempty"`
	IpAddressNot                   *string                      `json:"ipAddress_not,omitempty"`
	IpAddressIn                    []string                     `json:"ipAddress_in,omitempty"`
	IpAddressNotIn                 []string                     `json:"ipAddress_not_in,omitempty"`
	IpAddressLt                    *string                      `json:"ipAddress_lt,omitempty"`
	IpAddressLte                   *string                      `json:"ipAddress_lte,omitempty"`
	IpAddressGt                    *string                      `json:"ipAddress_gt,omitempty"`
	IpAddressGte                   *string                      `json:"ipAddress_gte,omitempty"`
	IpAddressContains              *string                      `json:"ipAddress_contains,omitempty"`
	IpAddressNotContains           *string                      `json:"ipAddress_not_contains,omitempty"`
	IpAddressStartsWith            *string                      `json:"ipAddress_starts_with,omitempty"`
	IpAddressNotStartsWith         *string                      `json:"ipAddress_not_starts_with,omitempty"`
	IpAddressEndsWith              *string                      `json:"ipAddress_ends_with,omitempty"`
	IpAddressNotEndsWith           *string                      `json:"ipAddress_not_ends_with,omitempty"`
	ImageUrl                       *string                      `json:"imageUrl,omitempty"`
	ImageUrlNot                    *string                      `json:"imageUrl_not,omitempty"`
	ImageUrlIn                     []string                     `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn                  []string                     `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt                     *string                      `json:"imageUrl_lt,omitempty"`
	ImageUrlLte                    *string                      `json:"imageUrl_lte,omitempty"`
	ImageUrlGt                     *string                      `json:"imageUrl_gt,omitempty"`
	ImageUrlGte                    *string                      `json:"imageUrl_gte,omitempty"`
	ImageUrlContains               *string                      `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains            *string                      `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith             *string                      `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith          *string                      `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith               *string                      `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith            *string                      `json:"imageUrl_not_ends_with,omitempty"`
	ThumbnailImageUrl              *string                      `json:"thumbnailImageUrl,omitempty"`
	ThumbnailImageUrlNot           *string                      `json:"thumbnailImageUrl_not,omitempty"`
	ThumbnailImageUrlIn            []string                     `json:"thumbnailImageUrl_in,omitempty"`
	ThumbnailImageUrlNotIn         []string                     `json:"thumbnailImageUrl_not_in,omitempty"`
	ThumbnailImageUrlLt            *string                      `json:"thumbnailImageUrl_lt,omitempty"`
	ThumbnailImageUrlLte           *string                      `json:"thumbnailImageUrl_lte,omitempty"`
	ThumbnailImageUrlGt            *string                      `json:"thumbnailImageUrl_gt,omitempty"`
	ThumbnailImageUrlGte           *string                      `json:"thumbnailImageUrl_gte,omitempty"`
	ThumbnailImageUrlContains      *string                      `json:"thumbnailImageUrl_contains,omitempty"`
	ThumbnailImageUrlNotContains   *string                      `json:"thumbnailImageUrl_not_contains,omitempty"`
	ThumbnailImageUrlStartsWith    *string                      `json:"thumbnailImageUrl_starts_with,omitempty"`
	ThumbnailImageUrlNotStartsWith *string                      `json:"thumbnailImageUrl_not_starts_with,omitempty"`
	ThumbnailImageUrlEndsWith      *string                      `json:"thumbnailImageUrl_ends_with,omitempty"`
	ThumbnailImageUrlNotEndsWith   *string                      `json:"thumbnailImageUrl_not_ends_with,omitempty"`
	Owner                          *UserWhereInput              `json:"owner,omitempty"`
	RelatedReviewContentPage       *ReviewContentPageWhereInput `json:"relatedReviewContentPage,omitempty"`
	CreatedAt                      *string                      `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                      `json:"updatedAt_gte,omitempty"`
	IsDel                          *bool                        `json:"isDel,omitempty"`
	IsDelNot                       *bool                        `json:"isDel_not,omitempty"`
	And                            []PageCommentWhereInput      `json:"AND,omitempty"`
	Or                             []PageCommentWhereInput      `json:"OR,omitempty"`
	Not                            []PageCommentWhereInput      `json:"NOT,omitempty"`
}

type PageCommentReplyWhereInput struct {
	ID                             *string                      `json:"id,omitempty"`
	IDNot                          *string                      `json:"id_not,omitempty"`
	IDIn                           []string                     `json:"id_in,omitempty"`
	IDNotIn                        []string                     `json:"id_not_in,omitempty"`
	IDLt                           *string                      `json:"id_lt,omitempty"`
	IDLte                          *string                      `json:"id_lte,omitempty"`
	IDGt                           *string                      `json:"id_gt,omitempty"`
	IDGte                          *string                      `json:"id_gte,omitempty"`
	IDContains                     *string                      `json:"id_contains,omitempty"`
	IDNotContains                  *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                      `json:"id_not_ends_with,omitempty"`
	PageComment                    *PageCommentWhereInput       `json:"pageComment,omitempty"`
	Content                        *string                      `json:"content,omitempty"`
	ContentNot                     *string                      `json:"content_not,omitempty"`
	ContentIn                      []string                     `json:"content_in,omitempty"`
	ContentNotIn                   []string                     `json:"content_not_in,omitempty"`
	ContentLt                      *string                      `json:"content_lt,omitempty"`
	ContentLte                     *string                      `json:"content_lte,omitempty"`
	ContentGt                      *string                      `json:"content_gt,omitempty"`
	ContentGte                     *string                      `json:"content_gte,omitempty"`
	ContentContains                *string                      `json:"content_contains,omitempty"`
	ContentNotContains             *string                      `json:"content_not_contains,omitempty"`
	ContentStartsWith              *string                      `json:"content_starts_with,omitempty"`
	ContentNotStartsWith           *string                      `json:"content_not_starts_with,omitempty"`
	ContentEndsWith                *string                      `json:"content_ends_with,omitempty"`
	ContentNotEndsWith             *string                      `json:"content_not_ends_with,omitempty"`
	IpAddress                      *string                      `json:"ipAddress,omitempty"`
	IpAddressNot                   *string                      `json:"ipAddress_not,omitempty"`
	IpAddressIn                    []string                     `json:"ipAddress_in,omitempty"`
	IpAddressNotIn                 []string                     `json:"ipAddress_not_in,omitempty"`
	IpAddressLt                    *string                      `json:"ipAddress_lt,omitempty"`
	IpAddressLte                   *string                      `json:"ipAddress_lte,omitempty"`
	IpAddressGt                    *string                      `json:"ipAddress_gt,omitempty"`
	IpAddressGte                   *string                      `json:"ipAddress_gte,omitempty"`
	IpAddressContains              *string                      `json:"ipAddress_contains,omitempty"`
	IpAddressNotContains           *string                      `json:"ipAddress_not_contains,omitempty"`
	IpAddressStartsWith            *string                      `json:"ipAddress_starts_with,omitempty"`
	IpAddressNotStartsWith         *string                      `json:"ipAddress_not_starts_with,omitempty"`
	IpAddressEndsWith              *string                      `json:"ipAddress_ends_with,omitempty"`
	IpAddressNotEndsWith           *string                      `json:"ipAddress_not_ends_with,omitempty"`
	ImageUrl                       *string                      `json:"imageUrl,omitempty"`
	ImageUrlNot                    *string                      `json:"imageUrl_not,omitempty"`
	ImageUrlIn                     []string                     `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn                  []string                     `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt                     *string                      `json:"imageUrl_lt,omitempty"`
	ImageUrlLte                    *string                      `json:"imageUrl_lte,omitempty"`
	ImageUrlGt                     *string                      `json:"imageUrl_gt,omitempty"`
	ImageUrlGte                    *string                      `json:"imageUrl_gte,omitempty"`
	ImageUrlContains               *string                      `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains            *string                      `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith             *string                      `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith          *string                      `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith               *string                      `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith            *string                      `json:"imageUrl_not_ends_with,omitempty"`
	ThumbnailImageUrl              *string                      `json:"thumbnailImageUrl,omitempty"`
	ThumbnailImageUrlNot           *string                      `json:"thumbnailImageUrl_not,omitempty"`
	ThumbnailImageUrlIn            []string                     `json:"thumbnailImageUrl_in,omitempty"`
	ThumbnailImageUrlNotIn         []string                     `json:"thumbnailImageUrl_not_in,omitempty"`
	ThumbnailImageUrlLt            *string                      `json:"thumbnailImageUrl_lt,omitempty"`
	ThumbnailImageUrlLte           *string                      `json:"thumbnailImageUrl_lte,omitempty"`
	ThumbnailImageUrlGt            *string                      `json:"thumbnailImageUrl_gt,omitempty"`
	ThumbnailImageUrlGte           *string                      `json:"thumbnailImageUrl_gte,omitempty"`
	ThumbnailImageUrlContains      *string                      `json:"thumbnailImageUrl_contains,omitempty"`
	ThumbnailImageUrlNotContains   *string                      `json:"thumbnailImageUrl_not_contains,omitempty"`
	ThumbnailImageUrlStartsWith    *string                      `json:"thumbnailImageUrl_starts_with,omitempty"`
	ThumbnailImageUrlNotStartsWith *string                      `json:"thumbnailImageUrl_not_starts_with,omitempty"`
	ThumbnailImageUrlEndsWith      *string                      `json:"thumbnailImageUrl_ends_with,omitempty"`
	ThumbnailImageUrlNotEndsWith   *string                      `json:"thumbnailImageUrl_not_ends_with,omitempty"`
	Owner                          *UserWhereInput              `json:"owner,omitempty"`
	CreatedAt                      *string                      `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                      `json:"updatedAt_gte,omitempty"`
	IsDel                          *bool                        `json:"isDel,omitempty"`
	IsDelNot                       *bool                        `json:"isDel_not,omitempty"`
	And                            []PageCommentReplyWhereInput `json:"AND,omitempty"`
	Or                             []PageCommentReplyWhereInput `json:"OR,omitempty"`
	Not                            []PageCommentReplyWhereInput `json:"NOT,omitempty"`
}

type ReviewContentPageFeedBackWhereInput struct {
	ID                     *string                               `json:"id,omitempty"`
	IDNot                  *string                               `json:"id_not,omitempty"`
	IDIn                   []string                              `json:"id_in,omitempty"`
	IDNotIn                []string                              `json:"id_not_in,omitempty"`
	IDLt                   *string                               `json:"id_lt,omitempty"`
	IDLte                  *string                               `json:"id_lte,omitempty"`
	IDGt                   *string                               `json:"id_gt,omitempty"`
	IDGte                  *string                               `json:"id_gte,omitempty"`
	IDContains             *string                               `json:"id_contains,omitempty"`
	IDNotContains          *string                               `json:"id_not_contains,omitempty"`
	IDStartsWith           *string                               `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string                               `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string                               `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string                               `json:"id_not_ends_with,omitempty"`
	IsLike                 *bool                                 `json:"isLike,omitempty"`
	IsLikeNot              *bool                                 `json:"isLike_not,omitempty"`
	ReviewContentPage      *ReviewContentPageWhereInput          `json:"reviewContentPage,omitempty"`
	Message                *string                               `json:"message,omitempty"`
	MessageNot             *string                               `json:"message_not,omitempty"`
	MessageIn              []string                              `json:"message_in,omitempty"`
	MessageNotIn           []string                              `json:"message_not_in,omitempty"`
	MessageLt              *string                               `json:"message_lt,omitempty"`
	MessageLte             *string                               `json:"message_lte,omitempty"`
	MessageGt              *string                               `json:"message_gt,omitempty"`
	MessageGte             *string                               `json:"message_gte,omitempty"`
	MessageContains        *string                               `json:"message_contains,omitempty"`
	MessageNotContains     *string                               `json:"message_not_contains,omitempty"`
	MessageStartsWith      *string                               `json:"message_starts_with,omitempty"`
	MessageNotStartsWith   *string                               `json:"message_not_starts_with,omitempty"`
	MessageEndsWith        *string                               `json:"message_ends_with,omitempty"`
	MessageNotEndsWith     *string                               `json:"message_not_ends_with,omitempty"`
	Owner                  *UserWhereInput                       `json:"owner,omitempty"`
	IpAddress              *string                               `json:"ipAddress,omitempty"`
	IpAddressNot           *string                               `json:"ipAddress_not,omitempty"`
	IpAddressIn            []string                              `json:"ipAddress_in,omitempty"`
	IpAddressNotIn         []string                              `json:"ipAddress_not_in,omitempty"`
	IpAddressLt            *string                               `json:"ipAddress_lt,omitempty"`
	IpAddressLte           *string                               `json:"ipAddress_lte,omitempty"`
	IpAddressGt            *string                               `json:"ipAddress_gt,omitempty"`
	IpAddressGte           *string                               `json:"ipAddress_gte,omitempty"`
	IpAddressContains      *string                               `json:"ipAddress_contains,omitempty"`
	IpAddressNotContains   *string                               `json:"ipAddress_not_contains,omitempty"`
	IpAddressStartsWith    *string                               `json:"ipAddress_starts_with,omitempty"`
	IpAddressNotStartsWith *string                               `json:"ipAddress_not_starts_with,omitempty"`
	IpAddressEndsWith      *string                               `json:"ipAddress_ends_with,omitempty"`
	IpAddressNotEndsWith   *string                               `json:"ipAddress_not_ends_with,omitempty"`
	CreatedAt              *string                               `json:"createdAt,omitempty"`
	CreatedAtNot           *string                               `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string                              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string                              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                               `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                               `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                               `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                               `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                               `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string                              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string                              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                               `json:"updatedAt_gte,omitempty"`
	And                    []ReviewContentPageFeedBackWhereInput `json:"AND,omitempty"`
	Or                     []ReviewContentPageFeedBackWhereInput `json:"OR,omitempty"`
	Not                    []ReviewContentPageFeedBackWhereInput `json:"NOT,omitempty"`
}

type ReviewContentViewerWhereInput struct {
	ID              *string                         `json:"id,omitempty"`
	IDNot           *string                         `json:"id_not,omitempty"`
	IDIn            []string                        `json:"id_in,omitempty"`
	IDNotIn         []string                        `json:"id_not_in,omitempty"`
	IDLt            *string                         `json:"id_lt,omitempty"`
	IDLte           *string                         `json:"id_lte,omitempty"`
	IDGt            *string                         `json:"id_gt,omitempty"`
	IDGte           *string                         `json:"id_gte,omitempty"`
	IDContains      *string                         `json:"id_contains,omitempty"`
	IDNotContains   *string                         `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                         `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                         `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                         `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                         `json:"id_not_ends_with,omitempty"`
	ReviewContent   *ReviewContentWhereInput        `json:"reviewContent,omitempty"`
	User            *UserWhereInput                 `json:"user,omitempty"`
	Ip              *string                         `json:"ip,omitempty"`
	IpNot           *string                         `json:"ip_not,omitempty"`
	IpIn            []string                        `json:"ip_in,omitempty"`
	IpNotIn         []string                        `json:"ip_not_in,omitempty"`
	IpLt            *string                         `json:"ip_lt,omitempty"`
	IpLte           *string                         `json:"ip_lte,omitempty"`
	IpGt            *string                         `json:"ip_gt,omitempty"`
	IpGte           *string                         `json:"ip_gte,omitempty"`
	IpContains      *string                         `json:"ip_contains,omitempty"`
	IpNotContains   *string                         `json:"ip_not_contains,omitempty"`
	IpStartsWith    *string                         `json:"ip_starts_with,omitempty"`
	IpNotStartsWith *string                         `json:"ip_not_starts_with,omitempty"`
	IpEndsWith      *string                         `json:"ip_ends_with,omitempty"`
	IpNotEndsWith   *string                         `json:"ip_not_ends_with,omitempty"`
	CreatedAt       *string                         `json:"createdAt,omitempty"`
	CreatedAtNot    *string                         `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                         `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                         `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                         `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                         `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                         `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                         `json:"updatedAt_gte,omitempty"`
	And             []ReviewContentViewerWhereInput `json:"AND,omitempty"`
	Or              []ReviewContentViewerWhereInput `json:"OR,omitempty"`
	Not             []ReviewContentViewerWhereInput `json:"NOT,omitempty"`
}

type ReviewContentReviewerWhereInput struct {
	ID                  *string                           `json:"id,omitempty"`
	IDNot               *string                           `json:"id_not,omitempty"`
	IDIn                []string                          `json:"id_in,omitempty"`
	IDNotIn             []string                          `json:"id_not_in,omitempty"`
	IDLt                *string                           `json:"id_lt,omitempty"`
	IDLte               *string                           `json:"id_lte,omitempty"`
	IDGt                *string                           `json:"id_gt,omitempty"`
	IDGte               *string                           `json:"id_gte,omitempty"`
	IDContains          *string                           `json:"id_contains,omitempty"`
	IDNotContains       *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith        *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string                           `json:"id_not_ends_with,omitempty"`
	ReviewContent       *ReviewContentWhereInput          `json:"reviewContent,omitempty"`
	Review              *string                           `json:"review,omitempty"`
	ReviewNot           *string                           `json:"review_not,omitempty"`
	ReviewIn            []string                          `json:"review_in,omitempty"`
	ReviewNotIn         []string                          `json:"review_not_in,omitempty"`
	ReviewLt            *string                           `json:"review_lt,omitempty"`
	ReviewLte           *string                           `json:"review_lte,omitempty"`
	ReviewGt            *string                           `json:"review_gt,omitempty"`
	ReviewGte           *string                           `json:"review_gte,omitempty"`
	ReviewContains      *string                           `json:"review_contains,omitempty"`
	ReviewNotContains   *string                           `json:"review_not_contains,omitempty"`
	ReviewStartsWith    *string                           `json:"review_starts_with,omitempty"`
	ReviewNotStartsWith *string                           `json:"review_not_starts_with,omitempty"`
	ReviewEndsWith      *string                           `json:"review_ends_with,omitempty"`
	ReviewNotEndsWith   *string                           `json:"review_not_ends_with,omitempty"`
	Owner               *UserWhereInput                   `json:"owner,omitempty"`
	CreatedAt           *string                           `json:"createdAt,omitempty"`
	CreatedAtNot        *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                           `json:"updatedAt_gte,omitempty"`
	And                 []ReviewContentReviewerWhereInput `json:"AND,omitempty"`
	Or                  []ReviewContentReviewerWhereInput `json:"OR,omitempty"`
	Not                 []ReviewContentReviewerWhereInput `json:"NOT,omitempty"`
}

type YoutubeWhereInput struct {
	ID                           *string                           `json:"id,omitempty"`
	IDNot                        *string                           `json:"id_not,omitempty"`
	IDIn                         []string                          `json:"id_in,omitempty"`
	IDNotIn                      []string                          `json:"id_not_in,omitempty"`
	IDLt                         *string                           `json:"id_lt,omitempty"`
	IDLte                        *string                           `json:"id_lte,omitempty"`
	IDGt                         *string                           `json:"id_gt,omitempty"`
	IDGte                        *string                           `json:"id_gte,omitempty"`
	IDContains                   *string                           `json:"id_contains,omitempty"`
	IDNotContains                *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                           `json:"id_not_ends_with,omitempty"`
	ChannelId                    *string                           `json:"channelId,omitempty"`
	ChannelIdNot                 *string                           `json:"channelId_not,omitempty"`
	ChannelIdIn                  []string                          `json:"channelId_in,omitempty"`
	ChannelIdNotIn               []string                          `json:"channelId_not_in,omitempty"`
	ChannelIdLt                  *string                           `json:"channelId_lt,omitempty"`
	ChannelIdLte                 *string                           `json:"channelId_lte,omitempty"`
	ChannelIdGt                  *string                           `json:"channelId_gt,omitempty"`
	ChannelIdGte                 *string                           `json:"channelId_gte,omitempty"`
	ChannelIdContains            *string                           `json:"channelId_contains,omitempty"`
	ChannelIdNotContains         *string                           `json:"channelId_not_contains,omitempty"`
	ChannelIdStartsWith          *string                           `json:"channelId_starts_with,omitempty"`
	ChannelIdNotStartsWith       *string                           `json:"channelId_not_starts_with,omitempty"`
	ChannelIdEndsWith            *string                           `json:"channelId_ends_with,omitempty"`
	ChannelIdNotEndsWith         *string                           `json:"channelId_not_ends_with,omitempty"`
	ChannelType                  *string                           `json:"channelType,omitempty"`
	ChannelTypeNot               *string                           `json:"channelType_not,omitempty"`
	ChannelTypeIn                []string                          `json:"channelType_in,omitempty"`
	ChannelTypeNotIn             []string                          `json:"channelType_not_in,omitempty"`
	ChannelTypeLt                *string                           `json:"channelType_lt,omitempty"`
	ChannelTypeLte               *string                           `json:"channelType_lte,omitempty"`
	ChannelTypeGt                *string                           `json:"channelType_gt,omitempty"`
	ChannelTypeGte               *string                           `json:"channelType_gte,omitempty"`
	ChannelTypeContains          *string                           `json:"channelType_contains,omitempty"`
	ChannelTypeNotContains       *string                           `json:"channelType_not_contains,omitempty"`
	ChannelTypeStartsWith        *string                           `json:"channelType_starts_with,omitempty"`
	ChannelTypeNotStartsWith     *string                           `json:"channelType_not_starts_with,omitempty"`
	ChannelTypeEndsWith          *string                           `json:"channelType_ends_with,omitempty"`
	ChannelTypeNotEndsWith       *string                           `json:"channelType_not_ends_with,omitempty"`
	ChannelName                  *string                           `json:"channelName,omitempty"`
	ChannelNameNot               *string                           `json:"channelName_not,omitempty"`
	ChannelNameIn                []string                          `json:"channelName_in,omitempty"`
	ChannelNameNotIn             []string                          `json:"channelName_not_in,omitempty"`
	ChannelNameLt                *string                           `json:"channelName_lt,omitempty"`
	ChannelNameLte               *string                           `json:"channelName_lte,omitempty"`
	ChannelNameGt                *string                           `json:"channelName_gt,omitempty"`
	ChannelNameGte               *string                           `json:"channelName_gte,omitempty"`
	ChannelNameContains          *string                           `json:"channelName_contains,omitempty"`
	ChannelNameNotContains       *string                           `json:"channelName_not_contains,omitempty"`
	ChannelNameStartsWith        *string                           `json:"channelName_starts_with,omitempty"`
	ChannelNameNotStartsWith     *string                           `json:"channelName_not_starts_with,omitempty"`
	ChannelNameEndsWith          *string                           `json:"channelName_ends_with,omitempty"`
	ChannelNameNotEndsWith       *string                           `json:"channelName_not_ends_with,omitempty"`
	UserName                     *string                           `json:"userName,omitempty"`
	UserNameNot                  *string                           `json:"userName_not,omitempty"`
	UserNameIn                   []string                          `json:"userName_in,omitempty"`
	UserNameNotIn                []string                          `json:"userName_not_in,omitempty"`
	UserNameLt                   *string                           `json:"userName_lt,omitempty"`
	UserNameLte                  *string                           `json:"userName_lte,omitempty"`
	UserNameGt                   *string                           `json:"userName_gt,omitempty"`
	UserNameGte                  *string                           `json:"userName_gte,omitempty"`
	UserNameContains             *string                           `json:"userName_contains,omitempty"`
	UserNameNotContains          *string                           `json:"userName_not_contains,omitempty"`
	UserNameStartsWith           *string                           `json:"userName_starts_with,omitempty"`
	UserNameNotStartsWith        *string                           `json:"userName_not_starts_with,omitempty"`
	UserNameEndsWith             *string                           `json:"userName_ends_with,omitempty"`
	UserNameNotEndsWith          *string                           `json:"userName_not_ends_with,omitempty"`
	VideoCount                   *string                           `json:"videoCount,omitempty"`
	VideoCountNot                *string                           `json:"videoCount_not,omitempty"`
	VideoCountIn                 []string                          `json:"videoCount_in,omitempty"`
	VideoCountNotIn              []string                          `json:"videoCount_not_in,omitempty"`
	VideoCountLt                 *string                           `json:"videoCount_lt,omitempty"`
	VideoCountLte                *string                           `json:"videoCount_lte,omitempty"`
	VideoCountGt                 *string                           `json:"videoCount_gt,omitempty"`
	VideoCountGte                *string                           `json:"videoCount_gte,omitempty"`
	VideoCountContains           *string                           `json:"videoCount_contains,omitempty"`
	VideoCountNotContains        *string                           `json:"videoCount_not_contains,omitempty"`
	VideoCountStartsWith         *string                           `json:"videoCount_starts_with,omitempty"`
	VideoCountNotStartsWith      *string                           `json:"videoCount_not_starts_with,omitempty"`
	VideoCountEndsWith           *string                           `json:"videoCount_ends_with,omitempty"`
	VideoCountNotEndsWith        *string                           `json:"videoCount_not_ends_with,omitempty"`
	SubscriberCount              *string                           `json:"subscriberCount,omitempty"`
	SubscriberCountNot           *string                           `json:"subscriberCount_not,omitempty"`
	SubscriberCountIn            []string                          `json:"subscriberCount_in,omitempty"`
	SubscriberCountNotIn         []string                          `json:"subscriberCount_not_in,omitempty"`
	SubscriberCountLt            *string                           `json:"subscriberCount_lt,omitempty"`
	SubscriberCountLte           *string                           `json:"subscriberCount_lte,omitempty"`
	SubscriberCountGt            *string                           `json:"subscriberCount_gt,omitempty"`
	SubscriberCountGte           *string                           `json:"subscriberCount_gte,omitempty"`
	SubscriberCountContains      *string                           `json:"subscriberCount_contains,omitempty"`
	SubscriberCountNotContains   *string                           `json:"subscriberCount_not_contains,omitempty"`
	SubscriberCountStartsWith    *string                           `json:"subscriberCount_starts_with,omitempty"`
	SubscriberCountNotStartsWith *string                           `json:"subscriberCount_not_starts_with,omitempty"`
	SubscriberCountEndsWith      *string                           `json:"subscriberCount_ends_with,omitempty"`
	SubscriberCountNotEndsWith   *string                           `json:"subscriberCount_not_ends_with,omitempty"`
	VideoViewCount               *string                           `json:"videoViewCount,omitempty"`
	VideoViewCountNot            *string                           `json:"videoViewCount_not,omitempty"`
	VideoViewCountIn             []string                          `json:"videoViewCount_in,omitempty"`
	VideoViewCountNotIn          []string                          `json:"videoViewCount_not_in,omitempty"`
	VideoViewCountLt             *string                           `json:"videoViewCount_lt,omitempty"`
	VideoViewCountLte            *string                           `json:"videoViewCount_lte,omitempty"`
	VideoViewCountGt             *string                           `json:"videoViewCount_gt,omitempty"`
	VideoViewCountGte            *string                           `json:"videoViewCount_gte,omitempty"`
	VideoViewCountContains       *string                           `json:"videoViewCount_contains,omitempty"`
	VideoViewCountNotContains    *string                           `json:"videoViewCount_not_contains,omitempty"`
	VideoViewCountStartsWith     *string                           `json:"videoViewCount_starts_with,omitempty"`
	VideoViewCountNotStartsWith  *string                           `json:"videoViewCount_not_starts_with,omitempty"`
	VideoViewCountEndsWith       *string                           `json:"videoViewCount_ends_with,omitempty"`
	VideoViewCountNotEndsWith    *string                           `json:"videoViewCount_not_ends_with,omitempty"`
	ThumbnailUrl                 *string                           `json:"thumbnailUrl,omitempty"`
	ThumbnailUrlNot              *string                           `json:"thumbnailUrl_not,omitempty"`
	ThumbnailUrlIn               []string                          `json:"thumbnailUrl_in,omitempty"`
	ThumbnailUrlNotIn            []string                          `json:"thumbnailUrl_not_in,omitempty"`
	ThumbnailUrlLt               *string                           `json:"thumbnailUrl_lt,omitempty"`
	ThumbnailUrlLte              *string                           `json:"thumbnailUrl_lte,omitempty"`
	ThumbnailUrlGt               *string                           `json:"thumbnailUrl_gt,omitempty"`
	ThumbnailUrlGte              *string                           `json:"thumbnailUrl_gte,omitempty"`
	ThumbnailUrlContains         *string                           `json:"thumbnailUrl_contains,omitempty"`
	ThumbnailUrlNotContains      *string                           `json:"thumbnailUrl_not_contains,omitempty"`
	ThumbnailUrlStartsWith       *string                           `json:"thumbnailUrl_starts_with,omitempty"`
	ThumbnailUrlNotStartsWith    *string                           `json:"thumbnailUrl_not_starts_with,omitempty"`
	ThumbnailUrlEndsWith         *string                           `json:"thumbnailUrl_ends_with,omitempty"`
	ThumbnailUrlNotEndsWith      *string                           `json:"thumbnailUrl_not_ends_with,omitempty"`
	BannerUrl                    *string                           `json:"bannerUrl,omitempty"`
	BannerUrlNot                 *string                           `json:"bannerUrl_not,omitempty"`
	BannerUrlIn                  []string                          `json:"bannerUrl_in,omitempty"`
	BannerUrlNotIn               []string                          `json:"bannerUrl_not_in,omitempty"`
	BannerUrlLt                  *string                           `json:"bannerUrl_lt,omitempty"`
	BannerUrlLte                 *string                           `json:"bannerUrl_lte,omitempty"`
	BannerUrlGt                  *string                           `json:"bannerUrl_gt,omitempty"`
	BannerUrlGte                 *string                           `json:"bannerUrl_gte,omitempty"`
	BannerUrlContains            *string                           `json:"bannerUrl_contains,omitempty"`
	BannerUrlNotContains         *string                           `json:"bannerUrl_not_contains,omitempty"`
	BannerUrlStartsWith          *string                           `json:"bannerUrl_starts_with,omitempty"`
	BannerUrlNotStartsWith       *string                           `json:"bannerUrl_not_starts_with,omitempty"`
	BannerUrlEndsWith            *string                           `json:"bannerUrl_ends_with,omitempty"`
	BannerUrlNotEndsWith         *string                           `json:"bannerUrl_not_ends_with,omitempty"`
	Description                  *string                           `json:"description,omitempty"`
	DescriptionNot               *string                           `json:"description_not,omitempty"`
	DescriptionIn                []string                          `json:"description_in,omitempty"`
	DescriptionNotIn             []string                          `json:"description_not_in,omitempty"`
	DescriptionLt                *string                           `json:"description_lt,omitempty"`
	DescriptionLte               *string                           `json:"description_lte,omitempty"`
	DescriptionGt                *string                           `json:"description_gt,omitempty"`
	DescriptionGte               *string                           `json:"description_gte,omitempty"`
	DescriptionContains          *string                           `json:"description_contains,omitempty"`
	DescriptionNotContains       *string                           `json:"description_not_contains,omitempty"`
	DescriptionStartsWith        *string                           `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith     *string                           `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith          *string                           `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith       *string                           `json:"description_not_ends_with,omitempty"`
	PublishedAt                  *string                           `json:"publishedAt,omitempty"`
	PublishedAtNot               *string                           `json:"publishedAt_not,omitempty"`
	PublishedAtIn                []string                          `json:"publishedAt_in,omitempty"`
	PublishedAtNotIn             []string                          `json:"publishedAt_not_in,omitempty"`
	PublishedAtLt                *string                           `json:"publishedAt_lt,omitempty"`
	PublishedAtLte               *string                           `json:"publishedAt_lte,omitempty"`
	PublishedAtGt                *string                           `json:"publishedAt_gt,omitempty"`
	PublishedAtGte               *string                           `json:"publishedAt_gte,omitempty"`
	Country                      *string                           `json:"country,omitempty"`
	CountryNot                   *string                           `json:"country_not,omitempty"`
	CountryIn                    []string                          `json:"country_in,omitempty"`
	CountryNotIn                 []string                          `json:"country_not_in,omitempty"`
	CountryLt                    *string                           `json:"country_lt,omitempty"`
	CountryLte                   *string                           `json:"country_lte,omitempty"`
	CountryGt                    *string                           `json:"country_gt,omitempty"`
	CountryGte                   *string                           `json:"country_gte,omitempty"`
	CountryContains              *string                           `json:"country_contains,omitempty"`
	CountryNotContains           *string                           `json:"country_not_contains,omitempty"`
	CountryStartsWith            *string                           `json:"country_starts_with,omitempty"`
	CountryNotStartsWith         *string                           `json:"country_not_starts_with,omitempty"`
	CountryEndsWith              *string                           `json:"country_ends_with,omitempty"`
	CountryNotEndsWith           *string                           `json:"country_not_ends_with,omitempty"`
	PageUrl                      *string                           `json:"pageUrl,omitempty"`
	PageUrlNot                   *string                           `json:"pageUrl_not,omitempty"`
	PageUrlIn                    []string                          `json:"pageUrl_in,omitempty"`
	PageUrlNotIn                 []string                          `json:"pageUrl_not_in,omitempty"`
	PageUrlLt                    *string                           `json:"pageUrl_lt,omitempty"`
	PageUrlLte                   *string                           `json:"pageUrl_lte,omitempty"`
	PageUrlGt                    *string                           `json:"pageUrl_gt,omitempty"`
	PageUrlGte                   *string                           `json:"pageUrl_gte,omitempty"`
	PageUrlContains              *string                           `json:"pageUrl_contains,omitempty"`
	PageUrlNotContains           *string                           `json:"pageUrl_not_contains,omitempty"`
	PageUrlStartsWith            *string                           `json:"pageUrl_starts_with,omitempty"`
	PageUrlNotStartsWith         *string                           `json:"pageUrl_not_starts_with,omitempty"`
	PageUrlEndsWith              *string                           `json:"pageUrl_ends_with,omitempty"`
	PageUrlNotEndsWith           *string                           `json:"pageUrl_not_ends_with,omitempty"`
	Page                         *PageWhereInput                   `json:"page,omitempty"`
	StatisticsEvery              *YoutubeDailyStatisticsWhereInput `json:"statistics_every,omitempty"`
	StatisticsSome               *YoutubeDailyStatisticsWhereInput `json:"statistics_some,omitempty"`
	StatisticsNone               *YoutubeDailyStatisticsWhereInput `json:"statistics_none,omitempty"`
	CreatedAt                    *string                           `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                           `json:"updatedAt_gte,omitempty"`
	And                          []YoutubeWhereInput               `json:"AND,omitempty"`
	Or                           []YoutubeWhereInput               `json:"OR,omitempty"`
	Not                          []YoutubeWhereInput               `json:"NOT,omitempty"`
}

type YoutubeDailyStatisticsWhereInput struct {
	ID                           *string                            `json:"id,omitempty"`
	IDNot                        *string                            `json:"id_not,omitempty"`
	IDIn                         []string                           `json:"id_in,omitempty"`
	IDNotIn                      []string                           `json:"id_not_in,omitempty"`
	IDLt                         *string                            `json:"id_lt,omitempty"`
	IDLte                        *string                            `json:"id_lte,omitempty"`
	IDGt                         *string                            `json:"id_gt,omitempty"`
	IDGte                        *string                            `json:"id_gte,omitempty"`
	IDContains                   *string                            `json:"id_contains,omitempty"`
	IDNotContains                *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                            `json:"id_not_ends_with,omitempty"`
	Date                         *string                            `json:"date,omitempty"`
	DateNot                      *string                            `json:"date_not,omitempty"`
	DateIn                       []string                           `json:"date_in,omitempty"`
	DateNotIn                    []string                           `json:"date_not_in,omitempty"`
	DateLt                       *string                            `json:"date_lt,omitempty"`
	DateLte                      *string                            `json:"date_lte,omitempty"`
	DateGt                       *string                            `json:"date_gt,omitempty"`
	DateGte                      *string                            `json:"date_gte,omitempty"`
	DateContains                 *string                            `json:"date_contains,omitempty"`
	DateNotContains              *string                            `json:"date_not_contains,omitempty"`
	DateStartsWith               *string                            `json:"date_starts_with,omitempty"`
	DateNotStartsWith            *string                            `json:"date_not_starts_with,omitempty"`
	DateEndsWith                 *string                            `json:"date_ends_with,omitempty"`
	DateNotEndsWith              *string                            `json:"date_not_ends_with,omitempty"`
	VideoCount                   *string                            `json:"videoCount,omitempty"`
	VideoCountNot                *string                            `json:"videoCount_not,omitempty"`
	VideoCountIn                 []string                           `json:"videoCount_in,omitempty"`
	VideoCountNotIn              []string                           `json:"videoCount_not_in,omitempty"`
	VideoCountLt                 *string                            `json:"videoCount_lt,omitempty"`
	VideoCountLte                *string                            `json:"videoCount_lte,omitempty"`
	VideoCountGt                 *string                            `json:"videoCount_gt,omitempty"`
	VideoCountGte                *string                            `json:"videoCount_gte,omitempty"`
	VideoCountContains           *string                            `json:"videoCount_contains,omitempty"`
	VideoCountNotContains        *string                            `json:"videoCount_not_contains,omitempty"`
	VideoCountStartsWith         *string                            `json:"videoCount_starts_with,omitempty"`
	VideoCountNotStartsWith      *string                            `json:"videoCount_not_starts_with,omitempty"`
	VideoCountEndsWith           *string                            `json:"videoCount_ends_with,omitempty"`
	VideoCountNotEndsWith        *string                            `json:"videoCount_not_ends_with,omitempty"`
	SubscriberCount              *string                            `json:"subscriberCount,omitempty"`
	SubscriberCountNot           *string                            `json:"subscriberCount_not,omitempty"`
	SubscriberCountIn            []string                           `json:"subscriberCount_in,omitempty"`
	SubscriberCountNotIn         []string                           `json:"subscriberCount_not_in,omitempty"`
	SubscriberCountLt            *string                            `json:"subscriberCount_lt,omitempty"`
	SubscriberCountLte           *string                            `json:"subscriberCount_lte,omitempty"`
	SubscriberCountGt            *string                            `json:"subscriberCount_gt,omitempty"`
	SubscriberCountGte           *string                            `json:"subscriberCount_gte,omitempty"`
	SubscriberCountContains      *string                            `json:"subscriberCount_contains,omitempty"`
	SubscriberCountNotContains   *string                            `json:"subscriberCount_not_contains,omitempty"`
	SubscriberCountStartsWith    *string                            `json:"subscriberCount_starts_with,omitempty"`
	SubscriberCountNotStartsWith *string                            `json:"subscriberCount_not_starts_with,omitempty"`
	SubscriberCountEndsWith      *string                            `json:"subscriberCount_ends_with,omitempty"`
	SubscriberCountNotEndsWith   *string                            `json:"subscriberCount_not_ends_with,omitempty"`
	VideoViewCount               *string                            `json:"videoViewCount,omitempty"`
	VideoViewCountNot            *string                            `json:"videoViewCount_not,omitempty"`
	VideoViewCountIn             []string                           `json:"videoViewCount_in,omitempty"`
	VideoViewCountNotIn          []string                           `json:"videoViewCount_not_in,omitempty"`
	VideoViewCountLt             *string                            `json:"videoViewCount_lt,omitempty"`
	VideoViewCountLte            *string                            `json:"videoViewCount_lte,omitempty"`
	VideoViewCountGt             *string                            `json:"videoViewCount_gt,omitempty"`
	VideoViewCountGte            *string                            `json:"videoViewCount_gte,omitempty"`
	VideoViewCountContains       *string                            `json:"videoViewCount_contains,omitempty"`
	VideoViewCountNotContains    *string                            `json:"videoViewCount_not_contains,omitempty"`
	VideoViewCountStartsWith     *string                            `json:"videoViewCount_starts_with,omitempty"`
	VideoViewCountNotStartsWith  *string                            `json:"videoViewCount_not_starts_with,omitempty"`
	VideoViewCountEndsWith       *string                            `json:"videoViewCount_ends_with,omitempty"`
	VideoViewCountNotEndsWith    *string                            `json:"videoViewCount_not_ends_with,omitempty"`
	Youtube                      *YoutubeWhereInput                 `json:"youtube,omitempty"`
	CreatedAt                    *string                            `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                            `json:"updatedAt_gte,omitempty"`
	And                          []YoutubeDailyStatisticsWhereInput `json:"AND,omitempty"`
	Or                           []YoutubeDailyStatisticsWhereInput `json:"OR,omitempty"`
	Not                          []YoutubeDailyStatisticsWhereInput `json:"NOT,omitempty"`
}

type TwitchWhereInput struct {
	ID                            *string                          `json:"id,omitempty"`
	IDNot                         *string                          `json:"id_not,omitempty"`
	IDIn                          []string                         `json:"id_in,omitempty"`
	IDNotIn                       []string                         `json:"id_not_in,omitempty"`
	IDLt                          *string                          `json:"id_lt,omitempty"`
	IDLte                         *string                          `json:"id_lte,omitempty"`
	IDGt                          *string                          `json:"id_gt,omitempty"`
	IDGte                         *string                          `json:"id_gte,omitempty"`
	IDContains                    *string                          `json:"id_contains,omitempty"`
	IDNotContains                 *string                          `json:"id_not_contains,omitempty"`
	IDStartsWith                  *string                          `json:"id_starts_with,omitempty"`
	IDNotStartsWith               *string                          `json:"id_not_starts_with,omitempty"`
	IDEndsWith                    *string                          `json:"id_ends_with,omitempty"`
	IDNotEndsWith                 *string                          `json:"id_not_ends_with,omitempty"`
	UserId                        *string                          `json:"userId,omitempty"`
	UserIdNot                     *string                          `json:"userId_not,omitempty"`
	UserIdIn                      []string                         `json:"userId_in,omitempty"`
	UserIdNotIn                   []string                         `json:"userId_not_in,omitempty"`
	UserIdLt                      *string                          `json:"userId_lt,omitempty"`
	UserIdLte                     *string                          `json:"userId_lte,omitempty"`
	UserIdGt                      *string                          `json:"userId_gt,omitempty"`
	UserIdGte                     *string                          `json:"userId_gte,omitempty"`
	UserIdContains                *string                          `json:"userId_contains,omitempty"`
	UserIdNotContains             *string                          `json:"userId_not_contains,omitempty"`
	UserIdStartsWith              *string                          `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith           *string                          `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith                *string                          `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith             *string                          `json:"userId_not_ends_with,omitempty"`
	UserNo                        *string                          `json:"userNo,omitempty"`
	UserNoNot                     *string                          `json:"userNo_not,omitempty"`
	UserNoIn                      []string                         `json:"userNo_in,omitempty"`
	UserNoNotIn                   []string                         `json:"userNo_not_in,omitempty"`
	UserNoLt                      *string                          `json:"userNo_lt,omitempty"`
	UserNoLte                     *string                          `json:"userNo_lte,omitempty"`
	UserNoGt                      *string                          `json:"userNo_gt,omitempty"`
	UserNoGte                     *string                          `json:"userNo_gte,omitempty"`
	UserNoContains                *string                          `json:"userNo_contains,omitempty"`
	UserNoNotContains             *string                          `json:"userNo_not_contains,omitempty"`
	UserNoStartsWith              *string                          `json:"userNo_starts_with,omitempty"`
	UserNoNotStartsWith           *string                          `json:"userNo_not_starts_with,omitempty"`
	UserNoEndsWith                *string                          `json:"userNo_ends_with,omitempty"`
	UserNoNotEndsWith             *string                          `json:"userNo_not_ends_with,omitempty"`
	UserName                      *string                          `json:"userName,omitempty"`
	UserNameNot                   *string                          `json:"userName_not,omitempty"`
	UserNameIn                    []string                         `json:"userName_in,omitempty"`
	UserNameNotIn                 []string                         `json:"userName_not_in,omitempty"`
	UserNameLt                    *string                          `json:"userName_lt,omitempty"`
	UserNameLte                   *string                          `json:"userName_lte,omitempty"`
	UserNameGt                    *string                          `json:"userName_gt,omitempty"`
	UserNameGte                   *string                          `json:"userName_gte,omitempty"`
	UserNameContains              *string                          `json:"userName_contains,omitempty"`
	UserNameNotContains           *string                          `json:"userName_not_contains,omitempty"`
	UserNameStartsWith            *string                          `json:"userName_starts_with,omitempty"`
	UserNameNotStartsWith         *string                          `json:"userName_not_starts_with,omitempty"`
	UserNameEndsWith              *string                          `json:"userName_ends_with,omitempty"`
	UserNameNotEndsWith           *string                          `json:"userName_not_ends_with,omitempty"`
	FollowerCount                 *string                          `json:"followerCount,omitempty"`
	FollowerCountNot              *string                          `json:"followerCount_not,omitempty"`
	FollowerCountIn               []string                         `json:"followerCount_in,omitempty"`
	FollowerCountNotIn            []string                         `json:"followerCount_not_in,omitempty"`
	FollowerCountLt               *string                          `json:"followerCount_lt,omitempty"`
	FollowerCountLte              *string                          `json:"followerCount_lte,omitempty"`
	FollowerCountGt               *string                          `json:"followerCount_gt,omitempty"`
	FollowerCountGte              *string                          `json:"followerCount_gte,omitempty"`
	FollowerCountContains         *string                          `json:"followerCount_contains,omitempty"`
	FollowerCountNotContains      *string                          `json:"followerCount_not_contains,omitempty"`
	FollowerCountStartsWith       *string                          `json:"followerCount_starts_with,omitempty"`
	FollowerCountNotStartsWith    *string                          `json:"followerCount_not_starts_with,omitempty"`
	FollowerCountEndsWith         *string                          `json:"followerCount_ends_with,omitempty"`
	FollowerCountNotEndsWith      *string                          `json:"followerCount_not_ends_with,omitempty"`
	FollowingCount                *string                          `json:"followingCount,omitempty"`
	FollowingCountNot             *string                          `json:"followingCount_not,omitempty"`
	FollowingCountIn              []string                         `json:"followingCount_in,omitempty"`
	FollowingCountNotIn           []string                         `json:"followingCount_not_in,omitempty"`
	FollowingCountLt              *string                          `json:"followingCount_lt,omitempty"`
	FollowingCountLte             *string                          `json:"followingCount_lte,omitempty"`
	FollowingCountGt              *string                          `json:"followingCount_gt,omitempty"`
	FollowingCountGte             *string                          `json:"followingCount_gte,omitempty"`
	FollowingCountContains        *string                          `json:"followingCount_contains,omitempty"`
	FollowingCountNotContains     *string                          `json:"followingCount_not_contains,omitempty"`
	FollowingCountStartsWith      *string                          `json:"followingCount_starts_with,omitempty"`
	FollowingCountNotStartsWith   *string                          `json:"followingCount_not_starts_with,omitempty"`
	FollowingCountEndsWith        *string                          `json:"followingCount_ends_with,omitempty"`
	FollowingCountNotEndsWith     *string                          `json:"followingCount_not_ends_with,omitempty"`
	ChannelType                   *string                          `json:"channelType,omitempty"`
	ChannelTypeNot                *string                          `json:"channelType_not,omitempty"`
	ChannelTypeIn                 []string                         `json:"channelType_in,omitempty"`
	ChannelTypeNotIn              []string                         `json:"channelType_not_in,omitempty"`
	ChannelTypeLt                 *string                          `json:"channelType_lt,omitempty"`
	ChannelTypeLte                *string                          `json:"channelType_lte,omitempty"`
	ChannelTypeGt                 *string                          `json:"channelType_gt,omitempty"`
	ChannelTypeGte                *string                          `json:"channelType_gte,omitempty"`
	ChannelTypeContains           *string                          `json:"channelType_contains,omitempty"`
	ChannelTypeNotContains        *string                          `json:"channelType_not_contains,omitempty"`
	ChannelTypeStartsWith         *string                          `json:"channelType_starts_with,omitempty"`
	ChannelTypeNotStartsWith      *string                          `json:"channelType_not_starts_with,omitempty"`
	ChannelTypeEndsWith           *string                          `json:"channelType_ends_with,omitempty"`
	ChannelTypeNotEndsWith        *string                          `json:"channelType_not_ends_with,omitempty"`
	ChannelViewCount              *string                          `json:"channelViewCount,omitempty"`
	ChannelViewCountNot           *string                          `json:"channelViewCount_not,omitempty"`
	ChannelViewCountIn            []string                         `json:"channelViewCount_in,omitempty"`
	ChannelViewCountNotIn         []string                         `json:"channelViewCount_not_in,omitempty"`
	ChannelViewCountLt            *string                          `json:"channelViewCount_lt,omitempty"`
	ChannelViewCountLte           *string                          `json:"channelViewCount_lte,omitempty"`
	ChannelViewCountGt            *string                          `json:"channelViewCount_gt,omitempty"`
	ChannelViewCountGte           *string                          `json:"channelViewCount_gte,omitempty"`
	ChannelViewCountContains      *string                          `json:"channelViewCount_contains,omitempty"`
	ChannelViewCountNotContains   *string                          `json:"channelViewCount_not_contains,omitempty"`
	ChannelViewCountStartsWith    *string                          `json:"channelViewCount_starts_with,omitempty"`
	ChannelViewCountNotStartsWith *string                          `json:"channelViewCount_not_starts_with,omitempty"`
	ChannelViewCountEndsWith      *string                          `json:"channelViewCount_ends_with,omitempty"`
	ChannelViewCountNotEndsWith   *string                          `json:"channelViewCount_not_ends_with,omitempty"`
	AvatarUrl                     *string                          `json:"avatarUrl,omitempty"`
	AvatarUrlNot                  *string                          `json:"avatarUrl_not,omitempty"`
	AvatarUrlIn                   []string                         `json:"avatarUrl_in,omitempty"`
	AvatarUrlNotIn                []string                         `json:"avatarUrl_not_in,omitempty"`
	AvatarUrlLt                   *string                          `json:"avatarUrl_lt,omitempty"`
	AvatarUrlLte                  *string                          `json:"avatarUrl_lte,omitempty"`
	AvatarUrlGt                   *string                          `json:"avatarUrl_gt,omitempty"`
	AvatarUrlGte                  *string                          `json:"avatarUrl_gte,omitempty"`
	AvatarUrlContains             *string                          `json:"avatarUrl_contains,omitempty"`
	AvatarUrlNotContains          *string                          `json:"avatarUrl_not_contains,omitempty"`
	AvatarUrlStartsWith           *string                          `json:"avatarUrl_starts_with,omitempty"`
	AvatarUrlNotStartsWith        *string                          `json:"avatarUrl_not_starts_with,omitempty"`
	AvatarUrlEndsWith             *string                          `json:"avatarUrl_ends_with,omitempty"`
	AvatarUrlNotEndsWith          *string                          `json:"avatarUrl_not_ends_with,omitempty"`
	CoverUrl                      *string                          `json:"coverUrl,omitempty"`
	CoverUrlNot                   *string                          `json:"coverUrl_not,omitempty"`
	CoverUrlIn                    []string                         `json:"coverUrl_in,omitempty"`
	CoverUrlNotIn                 []string                         `json:"coverUrl_not_in,omitempty"`
	CoverUrlLt                    *string                          `json:"coverUrl_lt,omitempty"`
	CoverUrlLte                   *string                          `json:"coverUrl_lte,omitempty"`
	CoverUrlGt                    *string                          `json:"coverUrl_gt,omitempty"`
	CoverUrlGte                   *string                          `json:"coverUrl_gte,omitempty"`
	CoverUrlContains              *string                          `json:"coverUrl_contains,omitempty"`
	CoverUrlNotContains           *string                          `json:"coverUrl_not_contains,omitempty"`
	CoverUrlStartsWith            *string                          `json:"coverUrl_starts_with,omitempty"`
	CoverUrlNotStartsWith         *string                          `json:"coverUrl_not_starts_with,omitempty"`
	CoverUrlEndsWith              *string                          `json:"coverUrl_ends_with,omitempty"`
	CoverUrlNotEndsWith           *string                          `json:"coverUrl_not_ends_with,omitempty"`
	Description                   *string                          `json:"description,omitempty"`
	DescriptionNot                *string                          `json:"description_not,omitempty"`
	DescriptionIn                 []string                         `json:"description_in,omitempty"`
	DescriptionNotIn              []string                         `json:"description_not_in,omitempty"`
	DescriptionLt                 *string                          `json:"description_lt,omitempty"`
	DescriptionLte                *string                          `json:"description_lte,omitempty"`
	DescriptionGt                 *string                          `json:"description_gt,omitempty"`
	DescriptionGte                *string                          `json:"description_gte,omitempty"`
	DescriptionContains           *string                          `json:"description_contains,omitempty"`
	DescriptionNotContains        *string                          `json:"description_not_contains,omitempty"`
	DescriptionStartsWith         *string                          `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith      *string                          `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith           *string                          `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith        *string                          `json:"description_not_ends_with,omitempty"`
	PageUrl                       *string                          `json:"pageUrl,omitempty"`
	PageUrlNot                    *string                          `json:"pageUrl_not,omitempty"`
	PageUrlIn                     []string                         `json:"pageUrl_in,omitempty"`
	PageUrlNotIn                  []string                         `json:"pageUrl_not_in,omitempty"`
	PageUrlLt                     *string                          `json:"pageUrl_lt,omitempty"`
	PageUrlLte                    *string                          `json:"pageUrl_lte,omitempty"`
	PageUrlGt                     *string                          `json:"pageUrl_gt,omitempty"`
	PageUrlGte                    *string                          `json:"pageUrl_gte,omitempty"`
	PageUrlContains               *string                          `json:"pageUrl_contains,omitempty"`
	PageUrlNotContains            *string                          `json:"pageUrl_not_contains,omitempty"`
	PageUrlStartsWith             *string                          `json:"pageUrl_starts_with,omitempty"`
	PageUrlNotStartsWith          *string                          `json:"pageUrl_not_starts_with,omitempty"`
	PageUrlEndsWith               *string                          `json:"pageUrl_ends_with,omitempty"`
	PageUrlNotEndsWith            *string                          `json:"pageUrl_not_ends_with,omitempty"`
	Page                          *PageWhereInput                  `json:"page,omitempty"`
	StatisticsEvery               *TwitchDailyStatisticsWhereInput `json:"statistics_every,omitempty"`
	StatisticsSome                *TwitchDailyStatisticsWhereInput `json:"statistics_some,omitempty"`
	StatisticsNone                *TwitchDailyStatisticsWhereInput `json:"statistics_none,omitempty"`
	CreatedAt                     *string                          `json:"createdAt,omitempty"`
	CreatedAtNot                  *string                          `json:"createdAt_not,omitempty"`
	CreatedAtIn                   []string                         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                []string                         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                   *string                          `json:"createdAt_lt,omitempty"`
	CreatedAtLte                  *string                          `json:"createdAt_lte,omitempty"`
	CreatedAtGt                   *string                          `json:"createdAt_gt,omitempty"`
	CreatedAtGte                  *string                          `json:"createdAt_gte,omitempty"`
	UpdatedAt                     *string                          `json:"updatedAt,omitempty"`
	UpdatedAtNot                  *string                          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                   []string                         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                []string                         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                   *string                          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                  *string                          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                   *string                          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                  *string                          `json:"updatedAt_gte,omitempty"`
	And                           []TwitchWhereInput               `json:"AND,omitempty"`
	Or                            []TwitchWhereInput               `json:"OR,omitempty"`
	Not                           []TwitchWhereInput               `json:"NOT,omitempty"`
}

type TwitchDailyStatisticsWhereInput struct {
	ID                            *string                           `json:"id,omitempty"`
	IDNot                         *string                           `json:"id_not,omitempty"`
	IDIn                          []string                          `json:"id_in,omitempty"`
	IDNotIn                       []string                          `json:"id_not_in,omitempty"`
	IDLt                          *string                           `json:"id_lt,omitempty"`
	IDLte                         *string                           `json:"id_lte,omitempty"`
	IDGt                          *string                           `json:"id_gt,omitempty"`
	IDGte                         *string                           `json:"id_gte,omitempty"`
	IDContains                    *string                           `json:"id_contains,omitempty"`
	IDNotContains                 *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith                  *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith               *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith                    *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith                 *string                           `json:"id_not_ends_with,omitempty"`
	Date                          *string                           `json:"date,omitempty"`
	DateNot                       *string                           `json:"date_not,omitempty"`
	DateIn                        []string                          `json:"date_in,omitempty"`
	DateNotIn                     []string                          `json:"date_not_in,omitempty"`
	DateLt                        *string                           `json:"date_lt,omitempty"`
	DateLte                       *string                           `json:"date_lte,omitempty"`
	DateGt                        *string                           `json:"date_gt,omitempty"`
	DateGte                       *string                           `json:"date_gte,omitempty"`
	DateContains                  *string                           `json:"date_contains,omitempty"`
	DateNotContains               *string                           `json:"date_not_contains,omitempty"`
	DateStartsWith                *string                           `json:"date_starts_with,omitempty"`
	DateNotStartsWith             *string                           `json:"date_not_starts_with,omitempty"`
	DateEndsWith                  *string                           `json:"date_ends_with,omitempty"`
	DateNotEndsWith               *string                           `json:"date_not_ends_with,omitempty"`
	FollowerCount                 *string                           `json:"followerCount,omitempty"`
	FollowerCountNot              *string                           `json:"followerCount_not,omitempty"`
	FollowerCountIn               []string                          `json:"followerCount_in,omitempty"`
	FollowerCountNotIn            []string                          `json:"followerCount_not_in,omitempty"`
	FollowerCountLt               *string                           `json:"followerCount_lt,omitempty"`
	FollowerCountLte              *string                           `json:"followerCount_lte,omitempty"`
	FollowerCountGt               *string                           `json:"followerCount_gt,omitempty"`
	FollowerCountGte              *string                           `json:"followerCount_gte,omitempty"`
	FollowerCountContains         *string                           `json:"followerCount_contains,omitempty"`
	FollowerCountNotContains      *string                           `json:"followerCount_not_contains,omitempty"`
	FollowerCountStartsWith       *string                           `json:"followerCount_starts_with,omitempty"`
	FollowerCountNotStartsWith    *string                           `json:"followerCount_not_starts_with,omitempty"`
	FollowerCountEndsWith         *string                           `json:"followerCount_ends_with,omitempty"`
	FollowerCountNotEndsWith      *string                           `json:"followerCount_not_ends_with,omitempty"`
	FollowingCount                *string                           `json:"followingCount,omitempty"`
	FollowingCountNot             *string                           `json:"followingCount_not,omitempty"`
	FollowingCountIn              []string                          `json:"followingCount_in,omitempty"`
	FollowingCountNotIn           []string                          `json:"followingCount_not_in,omitempty"`
	FollowingCountLt              *string                           `json:"followingCount_lt,omitempty"`
	FollowingCountLte             *string                           `json:"followingCount_lte,omitempty"`
	FollowingCountGt              *string                           `json:"followingCount_gt,omitempty"`
	FollowingCountGte             *string                           `json:"followingCount_gte,omitempty"`
	FollowingCountContains        *string                           `json:"followingCount_contains,omitempty"`
	FollowingCountNotContains     *string                           `json:"followingCount_not_contains,omitempty"`
	FollowingCountStartsWith      *string                           `json:"followingCount_starts_with,omitempty"`
	FollowingCountNotStartsWith   *string                           `json:"followingCount_not_starts_with,omitempty"`
	FollowingCountEndsWith        *string                           `json:"followingCount_ends_with,omitempty"`
	FollowingCountNotEndsWith     *string                           `json:"followingCount_not_ends_with,omitempty"`
	ChannelViewCount              *string                           `json:"channelViewCount,omitempty"`
	ChannelViewCountNot           *string                           `json:"channelViewCount_not,omitempty"`
	ChannelViewCountIn            []string                          `json:"channelViewCount_in,omitempty"`
	ChannelViewCountNotIn         []string                          `json:"channelViewCount_not_in,omitempty"`
	ChannelViewCountLt            *string                           `json:"channelViewCount_lt,omitempty"`
	ChannelViewCountLte           *string                           `json:"channelViewCount_lte,omitempty"`
	ChannelViewCountGt            *string                           `json:"channelViewCount_gt,omitempty"`
	ChannelViewCountGte           *string                           `json:"channelViewCount_gte,omitempty"`
	ChannelViewCountContains      *string                           `json:"channelViewCount_contains,omitempty"`
	ChannelViewCountNotContains   *string                           `json:"channelViewCount_not_contains,omitempty"`
	ChannelViewCountStartsWith    *string                           `json:"channelViewCount_starts_with,omitempty"`
	ChannelViewCountNotStartsWith *string                           `json:"channelViewCount_not_starts_with,omitempty"`
	ChannelViewCountEndsWith      *string                           `json:"channelViewCount_ends_with,omitempty"`
	ChannelViewCountNotEndsWith   *string                           `json:"channelViewCount_not_ends_with,omitempty"`
	Twitch                        *TwitchWhereInput                 `json:"twitch,omitempty"`
	CreatedAt                     *string                           `json:"createdAt,omitempty"`
	CreatedAtNot                  *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn                   []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                   *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte                  *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt                   *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte                  *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt                     *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot                  *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                   []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                   *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                  *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                   *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                  *string                           `json:"updatedAt_gte,omitempty"`
	And                           []TwitchDailyStatisticsWhereInput `json:"AND,omitempty"`
	Or                            []TwitchDailyStatisticsWhereInput `json:"OR,omitempty"`
	Not                           []TwitchDailyStatisticsWhereInput `json:"NOT,omitempty"`
}

type InstagramWhereInput struct {
	ID                          *string                             `json:"id,omitempty"`
	IDNot                       *string                             `json:"id_not,omitempty"`
	IDIn                        []string                            `json:"id_in,omitempty"`
	IDNotIn                     []string                            `json:"id_not_in,omitempty"`
	IDLt                        *string                             `json:"id_lt,omitempty"`
	IDLte                       *string                             `json:"id_lte,omitempty"`
	IDGt                        *string                             `json:"id_gt,omitempty"`
	IDGte                       *string                             `json:"id_gte,omitempty"`
	IDContains                  *string                             `json:"id_contains,omitempty"`
	IDNotContains               *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                             `json:"id_not_ends_with,omitempty"`
	UserId                      *string                             `json:"userId,omitempty"`
	UserIdNot                   *string                             `json:"userId_not,omitempty"`
	UserIdIn                    []string                            `json:"userId_in,omitempty"`
	UserIdNotIn                 []string                            `json:"userId_not_in,omitempty"`
	UserIdLt                    *string                             `json:"userId_lt,omitempty"`
	UserIdLte                   *string                             `json:"userId_lte,omitempty"`
	UserIdGt                    *string                             `json:"userId_gt,omitempty"`
	UserIdGte                   *string                             `json:"userId_gte,omitempty"`
	UserIdContains              *string                             `json:"userId_contains,omitempty"`
	UserIdNotContains           *string                             `json:"userId_not_contains,omitempty"`
	UserIdStartsWith            *string                             `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith         *string                             `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith              *string                             `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith           *string                             `json:"userId_not_ends_with,omitempty"`
	UserNo                      *string                             `json:"userNo,omitempty"`
	UserNoNot                   *string                             `json:"userNo_not,omitempty"`
	UserNoIn                    []string                            `json:"userNo_in,omitempty"`
	UserNoNotIn                 []string                            `json:"userNo_not_in,omitempty"`
	UserNoLt                    *string                             `json:"userNo_lt,omitempty"`
	UserNoLte                   *string                             `json:"userNo_lte,omitempty"`
	UserNoGt                    *string                             `json:"userNo_gt,omitempty"`
	UserNoGte                   *string                             `json:"userNo_gte,omitempty"`
	UserNoContains              *string                             `json:"userNo_contains,omitempty"`
	UserNoNotContains           *string                             `json:"userNo_not_contains,omitempty"`
	UserNoStartsWith            *string                             `json:"userNo_starts_with,omitempty"`
	UserNoNotStartsWith         *string                             `json:"userNo_not_starts_with,omitempty"`
	UserNoEndsWith              *string                             `json:"userNo_ends_with,omitempty"`
	UserNoNotEndsWith           *string                             `json:"userNo_not_ends_with,omitempty"`
	UserName                    *string                             `json:"userName,omitempty"`
	UserNameNot                 *string                             `json:"userName_not,omitempty"`
	UserNameIn                  []string                            `json:"userName_in,omitempty"`
	UserNameNotIn               []string                            `json:"userName_not_in,omitempty"`
	UserNameLt                  *string                             `json:"userName_lt,omitempty"`
	UserNameLte                 *string                             `json:"userName_lte,omitempty"`
	UserNameGt                  *string                             `json:"userName_gt,omitempty"`
	UserNameGte                 *string                             `json:"userName_gte,omitempty"`
	UserNameContains            *string                             `json:"userName_contains,omitempty"`
	UserNameNotContains         *string                             `json:"userName_not_contains,omitempty"`
	UserNameStartsWith          *string                             `json:"userName_starts_with,omitempty"`
	UserNameNotStartsWith       *string                             `json:"userName_not_starts_with,omitempty"`
	UserNameEndsWith            *string                             `json:"userName_ends_with,omitempty"`
	UserNameNotEndsWith         *string                             `json:"userName_not_ends_with,omitempty"`
	PostCount                   *string                             `json:"postCount,omitempty"`
	PostCountNot                *string                             `json:"postCount_not,omitempty"`
	PostCountIn                 []string                            `json:"postCount_in,omitempty"`
	PostCountNotIn              []string                            `json:"postCount_not_in,omitempty"`
	PostCountLt                 *string                             `json:"postCount_lt,omitempty"`
	PostCountLte                *string                             `json:"postCount_lte,omitempty"`
	PostCountGt                 *string                             `json:"postCount_gt,omitempty"`
	PostCountGte                *string                             `json:"postCount_gte,omitempty"`
	PostCountContains           *string                             `json:"postCount_contains,omitempty"`
	PostCountNotContains        *string                             `json:"postCount_not_contains,omitempty"`
	PostCountStartsWith         *string                             `json:"postCount_starts_with,omitempty"`
	PostCountNotStartsWith      *string                             `json:"postCount_not_starts_with,omitempty"`
	PostCountEndsWith           *string                             `json:"postCount_ends_with,omitempty"`
	PostCountNotEndsWith        *string                             `json:"postCount_not_ends_with,omitempty"`
	FollowerCount               *string                             `json:"followerCount,omitempty"`
	FollowerCountNot            *string                             `json:"followerCount_not,omitempty"`
	FollowerCountIn             []string                            `json:"followerCount_in,omitempty"`
	FollowerCountNotIn          []string                            `json:"followerCount_not_in,omitempty"`
	FollowerCountLt             *string                             `json:"followerCount_lt,omitempty"`
	FollowerCountLte            *string                             `json:"followerCount_lte,omitempty"`
	FollowerCountGt             *string                             `json:"followerCount_gt,omitempty"`
	FollowerCountGte            *string                             `json:"followerCount_gte,omitempty"`
	FollowerCountContains       *string                             `json:"followerCount_contains,omitempty"`
	FollowerCountNotContains    *string                             `json:"followerCount_not_contains,omitempty"`
	FollowerCountStartsWith     *string                             `json:"followerCount_starts_with,omitempty"`
	FollowerCountNotStartsWith  *string                             `json:"followerCount_not_starts_with,omitempty"`
	FollowerCountEndsWith       *string                             `json:"followerCount_ends_with,omitempty"`
	FollowerCountNotEndsWith    *string                             `json:"followerCount_not_ends_with,omitempty"`
	FollowingCount              *string                             `json:"followingCount,omitempty"`
	FollowingCountNot           *string                             `json:"followingCount_not,omitempty"`
	FollowingCountIn            []string                            `json:"followingCount_in,omitempty"`
	FollowingCountNotIn         []string                            `json:"followingCount_not_in,omitempty"`
	FollowingCountLt            *string                             `json:"followingCount_lt,omitempty"`
	FollowingCountLte           *string                             `json:"followingCount_lte,omitempty"`
	FollowingCountGt            *string                             `json:"followingCount_gt,omitempty"`
	FollowingCountGte           *string                             `json:"followingCount_gte,omitempty"`
	FollowingCountContains      *string                             `json:"followingCount_contains,omitempty"`
	FollowingCountNotContains   *string                             `json:"followingCount_not_contains,omitempty"`
	FollowingCountStartsWith    *string                             `json:"followingCount_starts_with,omitempty"`
	FollowingCountNotStartsWith *string                             `json:"followingCount_not_starts_with,omitempty"`
	FollowingCountEndsWith      *string                             `json:"followingCount_ends_with,omitempty"`
	FollowingCountNotEndsWith   *string                             `json:"followingCount_not_ends_with,omitempty"`
	AvatarUrl                   *string                             `json:"avatarUrl,omitempty"`
	AvatarUrlNot                *string                             `json:"avatarUrl_not,omitempty"`
	AvatarUrlIn                 []string                            `json:"avatarUrl_in,omitempty"`
	AvatarUrlNotIn              []string                            `json:"avatarUrl_not_in,omitempty"`
	AvatarUrlLt                 *string                             `json:"avatarUrl_lt,omitempty"`
	AvatarUrlLte                *string                             `json:"avatarUrl_lte,omitempty"`
	AvatarUrlGt                 *string                             `json:"avatarUrl_gt,omitempty"`
	AvatarUrlGte                *string                             `json:"avatarUrl_gte,omitempty"`
	AvatarUrlContains           *string                             `json:"avatarUrl_contains,omitempty"`
	AvatarUrlNotContains        *string                             `json:"avatarUrl_not_contains,omitempty"`
	AvatarUrlStartsWith         *string                             `json:"avatarUrl_starts_with,omitempty"`
	AvatarUrlNotStartsWith      *string                             `json:"avatarUrl_not_starts_with,omitempty"`
	AvatarUrlEndsWith           *string                             `json:"avatarUrl_ends_with,omitempty"`
	AvatarUrlNotEndsWith        *string                             `json:"avatarUrl_not_ends_with,omitempty"`
	Description                 *string                             `json:"description,omitempty"`
	DescriptionNot              *string                             `json:"description_not,omitempty"`
	DescriptionIn               []string                            `json:"description_in,omitempty"`
	DescriptionNotIn            []string                            `json:"description_not_in,omitempty"`
	DescriptionLt               *string                             `json:"description_lt,omitempty"`
	DescriptionLte              *string                             `json:"description_lte,omitempty"`
	DescriptionGt               *string                             `json:"description_gt,omitempty"`
	DescriptionGte              *string                             `json:"description_gte,omitempty"`
	DescriptionContains         *string                             `json:"description_contains,omitempty"`
	DescriptionNotContains      *string                             `json:"description_not_contains,omitempty"`
	DescriptionStartsWith       *string                             `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith    *string                             `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith         *string                             `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith      *string                             `json:"description_not_ends_with,omitempty"`
	PageUrl                     *string                             `json:"pageUrl,omitempty"`
	PageUrlNot                  *string                             `json:"pageUrl_not,omitempty"`
	PageUrlIn                   []string                            `json:"pageUrl_in,omitempty"`
	PageUrlNotIn                []string                            `json:"pageUrl_not_in,omitempty"`
	PageUrlLt                   *string                             `json:"pageUrl_lt,omitempty"`
	PageUrlLte                  *string                             `json:"pageUrl_lte,omitempty"`
	PageUrlGt                   *string                             `json:"pageUrl_gt,omitempty"`
	PageUrlGte                  *string                             `json:"pageUrl_gte,omitempty"`
	PageUrlContains             *string                             `json:"pageUrl_contains,omitempty"`
	PageUrlNotContains          *string                             `json:"pageUrl_not_contains,omitempty"`
	PageUrlStartsWith           *string                             `json:"pageUrl_starts_with,omitempty"`
	PageUrlNotStartsWith        *string                             `json:"pageUrl_not_starts_with,omitempty"`
	PageUrlEndsWith             *string                             `json:"pageUrl_ends_with,omitempty"`
	PageUrlNotEndsWith          *string                             `json:"pageUrl_not_ends_with,omitempty"`
	Page                        *PageWhereInput                     `json:"page,omitempty"`
	StatisticsEvery             *InstagramDailyStatisticsWhereInput `json:"statistics_every,omitempty"`
	StatisticsSome              *InstagramDailyStatisticsWhereInput `json:"statistics_some,omitempty"`
	StatisticsNone              *InstagramDailyStatisticsWhereInput `json:"statistics_none,omitempty"`
	CreatedAt                   *string                             `json:"createdAt,omitempty"`
	CreatedAtNot                *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                             `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                             `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string                            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string                            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                             `json:"updatedAt_gte,omitempty"`
	And                         []InstagramWhereInput               `json:"AND,omitempty"`
	Or                          []InstagramWhereInput               `json:"OR,omitempty"`
	Not                         []InstagramWhereInput               `json:"NOT,omitempty"`
}

type InstagramDailyStatisticsWhereInput struct {
	ID                          *string                              `json:"id,omitempty"`
	IDNot                       *string                              `json:"id_not,omitempty"`
	IDIn                        []string                             `json:"id_in,omitempty"`
	IDNotIn                     []string                             `json:"id_not_in,omitempty"`
	IDLt                        *string                              `json:"id_lt,omitempty"`
	IDLte                       *string                              `json:"id_lte,omitempty"`
	IDGt                        *string                              `json:"id_gt,omitempty"`
	IDGte                       *string                              `json:"id_gte,omitempty"`
	IDContains                  *string                              `json:"id_contains,omitempty"`
	IDNotContains               *string                              `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                              `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                              `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                              `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                              `json:"id_not_ends_with,omitempty"`
	Date                        *string                              `json:"date,omitempty"`
	DateNot                     *string                              `json:"date_not,omitempty"`
	DateIn                      []string                             `json:"date_in,omitempty"`
	DateNotIn                   []string                             `json:"date_not_in,omitempty"`
	DateLt                      *string                              `json:"date_lt,omitempty"`
	DateLte                     *string                              `json:"date_lte,omitempty"`
	DateGt                      *string                              `json:"date_gt,omitempty"`
	DateGte                     *string                              `json:"date_gte,omitempty"`
	DateContains                *string                              `json:"date_contains,omitempty"`
	DateNotContains             *string                              `json:"date_not_contains,omitempty"`
	DateStartsWith              *string                              `json:"date_starts_with,omitempty"`
	DateNotStartsWith           *string                              `json:"date_not_starts_with,omitempty"`
	DateEndsWith                *string                              `json:"date_ends_with,omitempty"`
	DateNotEndsWith             *string                              `json:"date_not_ends_with,omitempty"`
	PostCount                   *string                              `json:"postCount,omitempty"`
	PostCountNot                *string                              `json:"postCount_not,omitempty"`
	PostCountIn                 []string                             `json:"postCount_in,omitempty"`
	PostCountNotIn              []string                             `json:"postCount_not_in,omitempty"`
	PostCountLt                 *string                              `json:"postCount_lt,omitempty"`
	PostCountLte                *string                              `json:"postCount_lte,omitempty"`
	PostCountGt                 *string                              `json:"postCount_gt,omitempty"`
	PostCountGte                *string                              `json:"postCount_gte,omitempty"`
	PostCountContains           *string                              `json:"postCount_contains,omitempty"`
	PostCountNotContains        *string                              `json:"postCount_not_contains,omitempty"`
	PostCountStartsWith         *string                              `json:"postCount_starts_with,omitempty"`
	PostCountNotStartsWith      *string                              `json:"postCount_not_starts_with,omitempty"`
	PostCountEndsWith           *string                              `json:"postCount_ends_with,omitempty"`
	PostCountNotEndsWith        *string                              `json:"postCount_not_ends_with,omitempty"`
	FollowerCount               *string                              `json:"followerCount,omitempty"`
	FollowerCountNot            *string                              `json:"followerCount_not,omitempty"`
	FollowerCountIn             []string                             `json:"followerCount_in,omitempty"`
	FollowerCountNotIn          []string                             `json:"followerCount_not_in,omitempty"`
	FollowerCountLt             *string                              `json:"followerCount_lt,omitempty"`
	FollowerCountLte            *string                              `json:"followerCount_lte,omitempty"`
	FollowerCountGt             *string                              `json:"followerCount_gt,omitempty"`
	FollowerCountGte            *string                              `json:"followerCount_gte,omitempty"`
	FollowerCountContains       *string                              `json:"followerCount_contains,omitempty"`
	FollowerCountNotContains    *string                              `json:"followerCount_not_contains,omitempty"`
	FollowerCountStartsWith     *string                              `json:"followerCount_starts_with,omitempty"`
	FollowerCountNotStartsWith  *string                              `json:"followerCount_not_starts_with,omitempty"`
	FollowerCountEndsWith       *string                              `json:"followerCount_ends_with,omitempty"`
	FollowerCountNotEndsWith    *string                              `json:"followerCount_not_ends_with,omitempty"`
	FollowingCount              *string                              `json:"followingCount,omitempty"`
	FollowingCountNot           *string                              `json:"followingCount_not,omitempty"`
	FollowingCountIn            []string                             `json:"followingCount_in,omitempty"`
	FollowingCountNotIn         []string                             `json:"followingCount_not_in,omitempty"`
	FollowingCountLt            *string                              `json:"followingCount_lt,omitempty"`
	FollowingCountLte           *string                              `json:"followingCount_lte,omitempty"`
	FollowingCountGt            *string                              `json:"followingCount_gt,omitempty"`
	FollowingCountGte           *string                              `json:"followingCount_gte,omitempty"`
	FollowingCountContains      *string                              `json:"followingCount_contains,omitempty"`
	FollowingCountNotContains   *string                              `json:"followingCount_not_contains,omitempty"`
	FollowingCountStartsWith    *string                              `json:"followingCount_starts_with,omitempty"`
	FollowingCountNotStartsWith *string                              `json:"followingCount_not_starts_with,omitempty"`
	FollowingCountEndsWith      *string                              `json:"followingCount_ends_with,omitempty"`
	FollowingCountNotEndsWith   *string                              `json:"followingCount_not_ends_with,omitempty"`
	Instagram                   *InstagramWhereInput                 `json:"instagram,omitempty"`
	CreatedAt                   *string                              `json:"createdAt,omitempty"`
	CreatedAtNot                *string                              `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                              `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                              `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                              `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                              `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                              `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string                             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string                             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                              `json:"updatedAt_gte,omitempty"`
	And                         []InstagramDailyStatisticsWhereInput `json:"AND,omitempty"`
	Or                          []InstagramDailyStatisticsWhereInput `json:"OR,omitempty"`
	Not                         []InstagramDailyStatisticsWhereInput `json:"NOT,omitempty"`
}

type AfreecaTvWhereInput struct {
	ID                         *string                             `json:"id,omitempty"`
	IDNot                      *string                             `json:"id_not,omitempty"`
	IDIn                       []string                            `json:"id_in,omitempty"`
	IDNotIn                    []string                            `json:"id_not_in,omitempty"`
	IDLt                       *string                             `json:"id_lt,omitempty"`
	IDLte                      *string                             `json:"id_lte,omitempty"`
	IDGt                       *string                             `json:"id_gt,omitempty"`
	IDGte                      *string                             `json:"id_gte,omitempty"`
	IDContains                 *string                             `json:"id_contains,omitempty"`
	IDNotContains              *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith               *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string                             `json:"id_not_ends_with,omitempty"`
	StationNo                  *string                             `json:"stationNo,omitempty"`
	StationNoNot               *string                             `json:"stationNo_not,omitempty"`
	StationNoIn                []string                            `json:"stationNo_in,omitempty"`
	StationNoNotIn             []string                            `json:"stationNo_not_in,omitempty"`
	StationNoLt                *string                             `json:"stationNo_lt,omitempty"`
	StationNoLte               *string                             `json:"stationNo_lte,omitempty"`
	StationNoGt                *string                             `json:"stationNo_gt,omitempty"`
	StationNoGte               *string                             `json:"stationNo_gte,omitempty"`
	StationNoContains          *string                             `json:"stationNo_contains,omitempty"`
	StationNoNotContains       *string                             `json:"stationNo_not_contains,omitempty"`
	StationNoStartsWith        *string                             `json:"stationNo_starts_with,omitempty"`
	StationNoNotStartsWith     *string                             `json:"stationNo_not_starts_with,omitempty"`
	StationNoEndsWith          *string                             `json:"stationNo_ends_with,omitempty"`
	StationNoNotEndsWith       *string                             `json:"stationNo_not_ends_with,omitempty"`
	StationName                *string                             `json:"stationName,omitempty"`
	StationNameNot             *string                             `json:"stationName_not,omitempty"`
	StationNameIn              []string                            `json:"stationName_in,omitempty"`
	StationNameNotIn           []string                            `json:"stationName_not_in,omitempty"`
	StationNameLt              *string                             `json:"stationName_lt,omitempty"`
	StationNameLte             *string                             `json:"stationName_lte,omitempty"`
	StationNameGt              *string                             `json:"stationName_gt,omitempty"`
	StationNameGte             *string                             `json:"stationName_gte,omitempty"`
	StationNameContains        *string                             `json:"stationName_contains,omitempty"`
	StationNameNotContains     *string                             `json:"stationName_not_contains,omitempty"`
	StationNameStartsWith      *string                             `json:"stationName_starts_with,omitempty"`
	StationNameNotStartsWith   *string                             `json:"stationName_not_starts_with,omitempty"`
	StationNameEndsWith        *string                             `json:"stationName_ends_with,omitempty"`
	StationNameNotEndsWith     *string                             `json:"stationName_not_ends_with,omitempty"`
	StationTitle               *string                             `json:"stationTitle,omitempty"`
	StationTitleNot            *string                             `json:"stationTitle_not,omitempty"`
	StationTitleIn             []string                            `json:"stationTitle_in,omitempty"`
	StationTitleNotIn          []string                            `json:"stationTitle_not_in,omitempty"`
	StationTitleLt             *string                             `json:"stationTitle_lt,omitempty"`
	StationTitleLte            *string                             `json:"stationTitle_lte,omitempty"`
	StationTitleGt             *string                             `json:"stationTitle_gt,omitempty"`
	StationTitleGte            *string                             `json:"stationTitle_gte,omitempty"`
	StationTitleContains       *string                             `json:"stationTitle_contains,omitempty"`
	StationTitleNotContains    *string                             `json:"stationTitle_not_contains,omitempty"`
	StationTitleStartsWith     *string                             `json:"stationTitle_starts_with,omitempty"`
	StationTitleNotStartsWith  *string                             `json:"stationTitle_not_starts_with,omitempty"`
	StationTitleEndsWith       *string                             `json:"stationTitle_ends_with,omitempty"`
	StationTitleNotEndsWith    *string                             `json:"stationTitle_not_ends_with,omitempty"`
	UserId                     *string                             `json:"userId,omitempty"`
	UserIdNot                  *string                             `json:"userId_not,omitempty"`
	UserIdIn                   []string                            `json:"userId_in,omitempty"`
	UserIdNotIn                []string                            `json:"userId_not_in,omitempty"`
	UserIdLt                   *string                             `json:"userId_lt,omitempty"`
	UserIdLte                  *string                             `json:"userId_lte,omitempty"`
	UserIdGt                   *string                             `json:"userId_gt,omitempty"`
	UserIdGte                  *string                             `json:"userId_gte,omitempty"`
	UserIdContains             *string                             `json:"userId_contains,omitempty"`
	UserIdNotContains          *string                             `json:"userId_not_contains,omitempty"`
	UserIdStartsWith           *string                             `json:"userId_starts_with,omitempty"`
	UserIdNotStartsWith        *string                             `json:"userId_not_starts_with,omitempty"`
	UserIdEndsWith             *string                             `json:"userId_ends_with,omitempty"`
	UserIdNotEndsWith          *string                             `json:"userId_not_ends_with,omitempty"`
	UserName                   *string                             `json:"userName,omitempty"`
	UserNameNot                *string                             `json:"userName_not,omitempty"`
	UserNameIn                 []string                            `json:"userName_in,omitempty"`
	UserNameNotIn              []string                            `json:"userName_not_in,omitempty"`
	UserNameLt                 *string                             `json:"userName_lt,omitempty"`
	UserNameLte                *string                             `json:"userName_lte,omitempty"`
	UserNameGt                 *string                             `json:"userName_gt,omitempty"`
	UserNameGte                *string                             `json:"userName_gte,omitempty"`
	UserNameContains           *string                             `json:"userName_contains,omitempty"`
	UserNameNotContains        *string                             `json:"userName_not_contains,omitempty"`
	UserNameStartsWith         *string                             `json:"userName_starts_with,omitempty"`
	UserNameNotStartsWith      *string                             `json:"userName_not_starts_with,omitempty"`
	UserNameEndsWith           *string                             `json:"userName_ends_with,omitempty"`
	UserNameNotEndsWith        *string                             `json:"userName_not_ends_with,omitempty"`
	AvatarUrl                  *string                             `json:"avatarUrl,omitempty"`
	AvatarUrlNot               *string                             `json:"avatarUrl_not,omitempty"`
	AvatarUrlIn                []string                            `json:"avatarUrl_in,omitempty"`
	AvatarUrlNotIn             []string                            `json:"avatarUrl_not_in,omitempty"`
	AvatarUrlLt                *string                             `json:"avatarUrl_lt,omitempty"`
	AvatarUrlLte               *string                             `json:"avatarUrl_lte,omitempty"`
	AvatarUrlGt                *string                             `json:"avatarUrl_gt,omitempty"`
	AvatarUrlGte               *string                             `json:"avatarUrl_gte,omitempty"`
	AvatarUrlContains          *string                             `json:"avatarUrl_contains,omitempty"`
	AvatarUrlNotContains       *string                             `json:"avatarUrl_not_contains,omitempty"`
	AvatarUrlStartsWith        *string                             `json:"avatarUrl_starts_with,omitempty"`
	AvatarUrlNotStartsWith     *string                             `json:"avatarUrl_not_starts_with,omitempty"`
	AvatarUrlEndsWith          *string                             `json:"avatarUrl_ends_with,omitempty"`
	AvatarUrlNotEndsWith       *string                             `json:"avatarUrl_not_ends_with,omitempty"`
	Description                *string                             `json:"description,omitempty"`
	DescriptionNot             *string                             `json:"description_not,omitempty"`
	DescriptionIn              []string                            `json:"description_in,omitempty"`
	DescriptionNotIn           []string                            `json:"description_not_in,omitempty"`
	DescriptionLt              *string                             `json:"description_lt,omitempty"`
	DescriptionLte             *string                             `json:"description_lte,omitempty"`
	DescriptionGt              *string                             `json:"description_gt,omitempty"`
	DescriptionGte             *string                             `json:"description_gte,omitempty"`
	DescriptionContains        *string                             `json:"description_contains,omitempty"`
	DescriptionNotContains     *string                             `json:"description_not_contains,omitempty"`
	DescriptionStartsWith      *string                             `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith   *string                             `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith        *string                             `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith     *string                             `json:"description_not_ends_with,omitempty"`
	PageUrl                    *string                             `json:"pageUrl,omitempty"`
	PageUrlNot                 *string                             `json:"pageUrl_not,omitempty"`
	PageUrlIn                  []string                            `json:"pageUrl_in,omitempty"`
	PageUrlNotIn               []string                            `json:"pageUrl_not_in,omitempty"`
	PageUrlLt                  *string                             `json:"pageUrl_lt,omitempty"`
	PageUrlLte                 *string                             `json:"pageUrl_lte,omitempty"`
	PageUrlGt                  *string                             `json:"pageUrl_gt,omitempty"`
	PageUrlGte                 *string                             `json:"pageUrl_gte,omitempty"`
	PageUrlContains            *string                             `json:"pageUrl_contains,omitempty"`
	PageUrlNotContains         *string                             `json:"pageUrl_not_contains,omitempty"`
	PageUrlStartsWith          *string                             `json:"pageUrl_starts_with,omitempty"`
	PageUrlNotStartsWith       *string                             `json:"pageUrl_not_starts_with,omitempty"`
	PageUrlEndsWith            *string                             `json:"pageUrl_ends_with,omitempty"`
	PageUrlNotEndsWith         *string                             `json:"pageUrl_not_ends_with,omitempty"`
	Page                       *PageWhereInput                     `json:"page,omitempty"`
	StatisticsEvery            *AfreecaTvDailyStatisticsWhereInput `json:"statistics_every,omitempty"`
	StatisticsSome             *AfreecaTvDailyStatisticsWhereInput `json:"statistics_some,omitempty"`
	StatisticsNone             *AfreecaTvDailyStatisticsWhereInput `json:"statistics_none,omitempty"`
	FollowerCount              *string                             `json:"followerCount,omitempty"`
	FollowerCountNot           *string                             `json:"followerCount_not,omitempty"`
	FollowerCountIn            []string                            `json:"followerCount_in,omitempty"`
	FollowerCountNotIn         []string                            `json:"followerCount_not_in,omitempty"`
	FollowerCountLt            *string                             `json:"followerCount_lt,omitempty"`
	FollowerCountLte           *string                             `json:"followerCount_lte,omitempty"`
	FollowerCountGt            *string                             `json:"followerCount_gt,omitempty"`
	FollowerCountGte           *string                             `json:"followerCount_gte,omitempty"`
	FollowerCountContains      *string                             `json:"followerCount_contains,omitempty"`
	FollowerCountNotContains   *string                             `json:"followerCount_not_contains,omitempty"`
	FollowerCountStartsWith    *string                             `json:"followerCount_starts_with,omitempty"`
	FollowerCountNotStartsWith *string                             `json:"followerCount_not_starts_with,omitempty"`
	FollowerCountEndsWith      *string                             `json:"followerCount_ends_with,omitempty"`
	FollowerCountNotEndsWith   *string                             `json:"followerCount_not_ends_with,omitempty"`
	ViewCount                  *string                             `json:"viewCount,omitempty"`
	ViewCountNot               *string                             `json:"viewCount_not,omitempty"`
	ViewCountIn                []string                            `json:"viewCount_in,omitempty"`
	ViewCountNotIn             []string                            `json:"viewCount_not_in,omitempty"`
	ViewCountLt                *string                             `json:"viewCount_lt,omitempty"`
	ViewCountLte               *string                             `json:"viewCount_lte,omitempty"`
	ViewCountGt                *string                             `json:"viewCount_gt,omitempty"`
	ViewCountGte               *string                             `json:"viewCount_gte,omitempty"`
	ViewCountContains          *string                             `json:"viewCount_contains,omitempty"`
	ViewCountNotContains       *string                             `json:"viewCount_not_contains,omitempty"`
	ViewCountStartsWith        *string                             `json:"viewCount_starts_with,omitempty"`
	ViewCountNotStartsWith     *string                             `json:"viewCount_not_starts_with,omitempty"`
	ViewCountEndsWith          *string                             `json:"viewCount_ends_with,omitempty"`
	ViewCountNotEndsWith       *string                             `json:"viewCount_not_ends_with,omitempty"`
	VisitCount                 *string                             `json:"visitCount,omitempty"`
	VisitCountNot              *string                             `json:"visitCount_not,omitempty"`
	VisitCountIn               []string                            `json:"visitCount_in,omitempty"`
	VisitCountNotIn            []string                            `json:"visitCount_not_in,omitempty"`
	VisitCountLt               *string                             `json:"visitCount_lt,omitempty"`
	VisitCountLte              *string                             `json:"visitCount_lte,omitempty"`
	VisitCountGt               *string                             `json:"visitCount_gt,omitempty"`
	VisitCountGte              *string                             `json:"visitCount_gte,omitempty"`
	VisitCountContains         *string                             `json:"visitCount_contains,omitempty"`
	VisitCountNotContains      *string                             `json:"visitCount_not_contains,omitempty"`
	VisitCountStartsWith       *string                             `json:"visitCount_starts_with,omitempty"`
	VisitCountNotStartsWith    *string                             `json:"visitCount_not_starts_with,omitempty"`
	VisitCountEndsWith         *string                             `json:"visitCount_ends_with,omitempty"`
	VisitCountNotEndsWith      *string                             `json:"visitCount_not_ends_with,omitempty"`
	FanCount                   *string                             `json:"fanCount,omitempty"`
	FanCountNot                *string                             `json:"fanCount_not,omitempty"`
	FanCountIn                 []string                            `json:"fanCount_in,omitempty"`
	FanCountNotIn              []string                            `json:"fanCount_not_in,omitempty"`
	FanCountLt                 *string                             `json:"fanCount_lt,omitempty"`
	FanCountLte                *string                             `json:"fanCount_lte,omitempty"`
	FanCountGt                 *string                             `json:"fanCount_gt,omitempty"`
	FanCountGte                *string                             `json:"fanCount_gte,omitempty"`
	FanCountContains           *string                             `json:"fanCount_contains,omitempty"`
	FanCountNotContains        *string                             `json:"fanCount_not_contains,omitempty"`
	FanCountStartsWith         *string                             `json:"fanCount_starts_with,omitempty"`
	FanCountNotStartsWith      *string                             `json:"fanCount_not_starts_with,omitempty"`
	FanCountEndsWith           *string                             `json:"fanCount_ends_with,omitempty"`
	FanCountNotEndsWith        *string                             `json:"fanCount_not_ends_with,omitempty"`
	CreatedAt                  *string                             `json:"createdAt,omitempty"`
	CreatedAtNot               *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                             `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                             `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string                            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string                            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                             `json:"updatedAt_gte,omitempty"`
	And                        []AfreecaTvWhereInput               `json:"AND,omitempty"`
	Or                         []AfreecaTvWhereInput               `json:"OR,omitempty"`
	Not                        []AfreecaTvWhereInput               `json:"NOT,omitempty"`
}

type AfreecaTvDailyStatisticsWhereInput struct {
	ID                         *string                              `json:"id,omitempty"`
	IDNot                      *string                              `json:"id_not,omitempty"`
	IDIn                       []string                             `json:"id_in,omitempty"`
	IDNotIn                    []string                             `json:"id_not_in,omitempty"`
	IDLt                       *string                              `json:"id_lt,omitempty"`
	IDLte                      *string                              `json:"id_lte,omitempty"`
	IDGt                       *string                              `json:"id_gt,omitempty"`
	IDGte                      *string                              `json:"id_gte,omitempty"`
	IDContains                 *string                              `json:"id_contains,omitempty"`
	IDNotContains              *string                              `json:"id_not_contains,omitempty"`
	IDStartsWith               *string                              `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string                              `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string                              `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string                              `json:"id_not_ends_with,omitempty"`
	Date                       *string                              `json:"date,omitempty"`
	DateNot                    *string                              `json:"date_not,omitempty"`
	DateIn                     []string                             `json:"date_in,omitempty"`
	DateNotIn                  []string                             `json:"date_not_in,omitempty"`
	DateLt                     *string                              `json:"date_lt,omitempty"`
	DateLte                    *string                              `json:"date_lte,omitempty"`
	DateGt                     *string                              `json:"date_gt,omitempty"`
	DateGte                    *string                              `json:"date_gte,omitempty"`
	DateContains               *string                              `json:"date_contains,omitempty"`
	DateNotContains            *string                              `json:"date_not_contains,omitempty"`
	DateStartsWith             *string                              `json:"date_starts_with,omitempty"`
	DateNotStartsWith          *string                              `json:"date_not_starts_with,omitempty"`
	DateEndsWith               *string                              `json:"date_ends_with,omitempty"`
	DateNotEndsWith            *string                              `json:"date_not_ends_with,omitempty"`
	FollowerCount              *string                              `json:"followerCount,omitempty"`
	FollowerCountNot           *string                              `json:"followerCount_not,omitempty"`
	FollowerCountIn            []string                             `json:"followerCount_in,omitempty"`
	FollowerCountNotIn         []string                             `json:"followerCount_not_in,omitempty"`
	FollowerCountLt            *string                              `json:"followerCount_lt,omitempty"`
	FollowerCountLte           *string                              `json:"followerCount_lte,omitempty"`
	FollowerCountGt            *string                              `json:"followerCount_gt,omitempty"`
	FollowerCountGte           *string                              `json:"followerCount_gte,omitempty"`
	FollowerCountContains      *string                              `json:"followerCount_contains,omitempty"`
	FollowerCountNotContains   *string                              `json:"followerCount_not_contains,omitempty"`
	FollowerCountStartsWith    *string                              `json:"followerCount_starts_with,omitempty"`
	FollowerCountNotStartsWith *string                              `json:"followerCount_not_starts_with,omitempty"`
	FollowerCountEndsWith      *string                              `json:"followerCount_ends_with,omitempty"`
	FollowerCountNotEndsWith   *string                              `json:"followerCount_not_ends_with,omitempty"`
	ViewCount                  *string                              `json:"viewCount,omitempty"`
	ViewCountNot               *string                              `json:"viewCount_not,omitempty"`
	ViewCountIn                []string                             `json:"viewCount_in,omitempty"`
	ViewCountNotIn             []string                             `json:"viewCount_not_in,omitempty"`
	ViewCountLt                *string                              `json:"viewCount_lt,omitempty"`
	ViewCountLte               *string                              `json:"viewCount_lte,omitempty"`
	ViewCountGt                *string                              `json:"viewCount_gt,omitempty"`
	ViewCountGte               *string                              `json:"viewCount_gte,omitempty"`
	ViewCountContains          *string                              `json:"viewCount_contains,omitempty"`
	ViewCountNotContains       *string                              `json:"viewCount_not_contains,omitempty"`
	ViewCountStartsWith        *string                              `json:"viewCount_starts_with,omitempty"`
	ViewCountNotStartsWith     *string                              `json:"viewCount_not_starts_with,omitempty"`
	ViewCountEndsWith          *string                              `json:"viewCount_ends_with,omitempty"`
	ViewCountNotEndsWith       *string                              `json:"viewCount_not_ends_with,omitempty"`
	VisitCount                 *string                              `json:"visitCount,omitempty"`
	VisitCountNot              *string                              `json:"visitCount_not,omitempty"`
	VisitCountIn               []string                             `json:"visitCount_in,omitempty"`
	VisitCountNotIn            []string                             `json:"visitCount_not_in,omitempty"`
	VisitCountLt               *string                              `json:"visitCount_lt,omitempty"`
	VisitCountLte              *string                              `json:"visitCount_lte,omitempty"`
	VisitCountGt               *string                              `json:"visitCount_gt,omitempty"`
	VisitCountGte              *string                              `json:"visitCount_gte,omitempty"`
	VisitCountContains         *string                              `json:"visitCount_contains,omitempty"`
	VisitCountNotContains      *string                              `json:"visitCount_not_contains,omitempty"`
	VisitCountStartsWith       *string                              `json:"visitCount_starts_with,omitempty"`
	VisitCountNotStartsWith    *string                              `json:"visitCount_not_starts_with,omitempty"`
	VisitCountEndsWith         *string                              `json:"visitCount_ends_with,omitempty"`
	VisitCountNotEndsWith      *string                              `json:"visitCount_not_ends_with,omitempty"`
	FanCount                   *string                              `json:"fanCount,omitempty"`
	FanCountNot                *string                              `json:"fanCount_not,omitempty"`
	FanCountIn                 []string                             `json:"fanCount_in,omitempty"`
	FanCountNotIn              []string                             `json:"fanCount_not_in,omitempty"`
	FanCountLt                 *string                              `json:"fanCount_lt,omitempty"`
	FanCountLte                *string                              `json:"fanCount_lte,omitempty"`
	FanCountGt                 *string                              `json:"fanCount_gt,omitempty"`
	FanCountGte                *string                              `json:"fanCount_gte,omitempty"`
	FanCountContains           *string                              `json:"fanCount_contains,omitempty"`
	FanCountNotContains        *string                              `json:"fanCount_not_contains,omitempty"`
	FanCountStartsWith         *string                              `json:"fanCount_starts_with,omitempty"`
	FanCountNotStartsWith      *string                              `json:"fanCount_not_starts_with,omitempty"`
	FanCountEndsWith           *string                              `json:"fanCount_ends_with,omitempty"`
	FanCountNotEndsWith        *string                              `json:"fanCount_not_ends_with,omitempty"`
	AfreecaTv                  *AfreecaTvWhereInput                 `json:"afreecaTV,omitempty"`
	CreatedAt                  *string                              `json:"createdAt,omitempty"`
	CreatedAtNot               *string                              `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string                             `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string                             `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                              `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                              `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                              `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                              `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                              `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                              `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string                             `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string                             `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                              `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                              `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                              `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                              `json:"updatedAt_gte,omitempty"`
	And                        []AfreecaTvDailyStatisticsWhereInput `json:"AND,omitempty"`
	Or                         []AfreecaTvDailyStatisticsWhereInput `json:"OR,omitempty"`
	Not                        []AfreecaTvDailyStatisticsWhereInput `json:"NOT,omitempty"`
}

type PageFanWhereInput struct {
	ID              *string             `json:"id,omitempty"`
	IDNot           *string             `json:"id_not,omitempty"`
	IDIn            []string            `json:"id_in,omitempty"`
	IDNotIn         []string            `json:"id_not_in,omitempty"`
	IDLt            *string             `json:"id_lt,omitempty"`
	IDLte           *string             `json:"id_lte,omitempty"`
	IDGt            *string             `json:"id_gt,omitempty"`
	IDGte           *string             `json:"id_gte,omitempty"`
	IDContains      *string             `json:"id_contains,omitempty"`
	IDNotContains   *string             `json:"id_not_contains,omitempty"`
	IDStartsWith    *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string             `json:"id_not_ends_with,omitempty"`
	User            *UserWhereInput     `json:"user,omitempty"`
	CreatedAt       *string             `json:"createdAt,omitempty"`
	CreatedAtNot    *string             `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string             `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string             `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string             `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string             `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string             `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string             `json:"updatedAt_gte,omitempty"`
	And             []PageFanWhereInput `json:"AND,omitempty"`
	Or              []PageFanWhereInput `json:"OR,omitempty"`
	Not             []PageFanWhereInput `json:"NOT,omitempty"`
}

type RequestPageItemWhereInput struct {
	ID                     *string                     `json:"id,omitempty"`
	IDNot                  *string                     `json:"id_not,omitempty"`
	IDIn                   []string                    `json:"id_in,omitempty"`
	IDNotIn                []string                    `json:"id_not_in,omitempty"`
	IDLt                   *string                     `json:"id_lt,omitempty"`
	IDLte                  *string                     `json:"id_lte,omitempty"`
	IDGt                   *string                     `json:"id_gt,omitempty"`
	IDGte                  *string                     `json:"id_gte,omitempty"`
	IDContains             *string                     `json:"id_contains,omitempty"`
	IDNotContains          *string                     `json:"id_not_contains,omitempty"`
	IDStartsWith           *string                     `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string                     `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string                     `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string                     `json:"id_not_ends_with,omitempty"`
	Type                   *int32                      `json:"type,omitempty"`
	TypeNot                *int32                      `json:"type_not,omitempty"`
	TypeIn                 []int32                     `json:"type_in,omitempty"`
	TypeNotIn              []int32                     `json:"type_not_in,omitempty"`
	TypeLt                 *int32                      `json:"type_lt,omitempty"`
	TypeLte                *int32                      `json:"type_lte,omitempty"`
	TypeGt                 *int32                      `json:"type_gt,omitempty"`
	TypeGte                *int32                      `json:"type_gte,omitempty"`
	Page                   *PageWhereInput             `json:"page,omitempty"`
	Note                   *string                     `json:"note,omitempty"`
	NoteNot                *string                     `json:"note_not,omitempty"`
	NoteIn                 []string                    `json:"note_in,omitempty"`
	NoteNotIn              []string                    `json:"note_not_in,omitempty"`
	NoteLt                 *string                     `json:"note_lt,omitempty"`
	NoteLte                *string                     `json:"note_lte,omitempty"`
	NoteGt                 *string                     `json:"note_gt,omitempty"`
	NoteGte                *string                     `json:"note_gte,omitempty"`
	NoteContains           *string                     `json:"note_contains,omitempty"`
	NoteNotContains        *string                     `json:"note_not_contains,omitempty"`
	NoteStartsWith         *string                     `json:"note_starts_with,omitempty"`
	NoteNotStartsWith      *string                     `json:"note_not_starts_with,omitempty"`
	NoteEndsWith           *string                     `json:"note_ends_with,omitempty"`
	NoteNotEndsWith        *string                     `json:"note_not_ends_with,omitempty"`
	IpAddress              *string                     `json:"ipAddress,omitempty"`
	IpAddressNot           *string                     `json:"ipAddress_not,omitempty"`
	IpAddressIn            []string                    `json:"ipAddress_in,omitempty"`
	IpAddressNotIn         []string                    `json:"ipAddress_not_in,omitempty"`
	IpAddressLt            *string                     `json:"ipAddress_lt,omitempty"`
	IpAddressLte           *string                     `json:"ipAddress_lte,omitempty"`
	IpAddressGt            *string                     `json:"ipAddress_gt,omitempty"`
	IpAddressGte           *string                     `json:"ipAddress_gte,omitempty"`
	IpAddressContains      *string                     `json:"ipAddress_contains,omitempty"`
	IpAddressNotContains   *string                     `json:"ipAddress_not_contains,omitempty"`
	IpAddressStartsWith    *string                     `json:"ipAddress_starts_with,omitempty"`
	IpAddressNotStartsWith *string                     `json:"ipAddress_not_starts_with,omitempty"`
	IpAddressEndsWith      *string                     `json:"ipAddress_ends_with,omitempty"`
	IpAddressNotEndsWith   *string                     `json:"ipAddress_not_ends_with,omitempty"`
	Owner                  *UserWhereInput             `json:"owner,omitempty"`
	CreatedAt              *string                     `json:"createdAt,omitempty"`
	CreatedAtNot           *string                     `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string                    `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string                    `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                     `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                     `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                     `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                     `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                     `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                     `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string                    `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string                    `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                     `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                     `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                     `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                     `json:"updatedAt_gte,omitempty"`
	And                    []RequestPageItemWhereInput `json:"AND,omitempty"`
	Or                     []RequestPageItemWhereInput `json:"OR,omitempty"`
	Not                    []RequestPageItemWhereInput `json:"NOT,omitempty"`
}

type AergoAccountWhereUniqueInput struct {
	ID              *string `json:"id,omitempty"`
	ContractAddress *string `json:"contractAddress,omitempty"`
}

type AergoAccountHistoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AfreecaTvWhereUniqueInput struct {
	ID        *string `json:"id,omitempty"`
	StationNo *string `json:"stationNo,omitempty"`
	UserId    *string `json:"userId,omitempty"`
}

type AfreecaTvDailyStatisticsWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AirDropWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AirDropHistoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AirDropMemberWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AppVersionWhereUniqueInput struct {
	ID      *string `json:"id,omitempty"`
	Version *string `json:"version,omitempty"`
}

type DeviceWhereInput struct {
	ID                *string                `json:"id,omitempty"`
	IDNot             *string                `json:"id_not,omitempty"`
	IDIn              []string               `json:"id_in,omitempty"`
	IDNotIn           []string               `json:"id_not_in,omitempty"`
	IDLt              *string                `json:"id_lt,omitempty"`
	IDLte             *string                `json:"id_lte,omitempty"`
	IDGt              *string                `json:"id_gt,omitempty"`
	IDGte             *string                `json:"id_gte,omitempty"`
	IDContains        *string                `json:"id_contains,omitempty"`
	IDNotContains     *string                `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                `json:"id_not_ends_with,omitempty"`
	MaintenanceEvery  *MaintenanceWhereInput `json:"maintenance_every,omitempty"`
	MaintenanceSome   *MaintenanceWhereInput `json:"maintenance_some,omitempty"`
	MaintenanceNone   *MaintenanceWhereInput `json:"maintenance_none,omitempty"`
	AppVersionEvery   *AppVersionWhereInput  `json:"appVersion_every,omitempty"`
	AppVersionSome    *AppVersionWhereInput  `json:"appVersion_some,omitempty"`
	AppVersionNone    *AppVersionWhereInput  `json:"appVersion_none,omitempty"`
	Code              *int32                 `json:"code,omitempty"`
	CodeNot           *int32                 `json:"code_not,omitempty"`
	CodeIn            []int32                `json:"code_in,omitempty"`
	CodeNotIn         []int32                `json:"code_not_in,omitempty"`
	CodeLt            *int32                 `json:"code_lt,omitempty"`
	CodeLte           *int32                 `json:"code_lte,omitempty"`
	CodeGt            *int32                 `json:"code_gt,omitempty"`
	CodeGte           *int32                 `json:"code_gte,omitempty"`
	Name              *string                `json:"name,omitempty"`
	NameNot           *string                `json:"name_not,omitempty"`
	NameIn            []string               `json:"name_in,omitempty"`
	NameNotIn         []string               `json:"name_not_in,omitempty"`
	NameLt            *string                `json:"name_lt,omitempty"`
	NameLte           *string                `json:"name_lte,omitempty"`
	NameGt            *string                `json:"name_gt,omitempty"`
	NameGte           *string                `json:"name_gte,omitempty"`
	NameContains      *string                `json:"name_contains,omitempty"`
	NameNotContains   *string                `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                `json:"name_not_ends_with,omitempty"`
	And               []DeviceWhereInput     `json:"AND,omitempty"`
	Or                []DeviceWhereInput     `json:"OR,omitempty"`
	Not               []DeviceWhereInput     `json:"NOT,omitempty"`
}

type MaintenanceWhereInput struct {
	ID                   *string                 `json:"id,omitempty"`
	IDNot                *string                 `json:"id_not,omitempty"`
	IDIn                 []string                `json:"id_in,omitempty"`
	IDNotIn              []string                `json:"id_not_in,omitempty"`
	IDLt                 *string                 `json:"id_lt,omitempty"`
	IDLte                *string                 `json:"id_lte,omitempty"`
	IDGt                 *string                 `json:"id_gt,omitempty"`
	IDGte                *string                 `json:"id_gte,omitempty"`
	IDContains           *string                 `json:"id_contains,omitempty"`
	IDNotContains        *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                 `json:"id_not_ends_with,omitempty"`
	Type                 *int32                  `json:"type,omitempty"`
	TypeNot              *int32                  `json:"type_not,omitempty"`
	TypeIn               []int32                 `json:"type_in,omitempty"`
	TypeNotIn            []int32                 `json:"type_not_in,omitempty"`
	TypeLt               *int32                  `json:"type_lt,omitempty"`
	TypeLte              *int32                  `json:"type_lte,omitempty"`
	TypeGt               *int32                  `json:"type_gt,omitempty"`
	TypeGte              *int32                  `json:"type_gte,omitempty"`
	AffectedDevicesEvery *DeviceWhereInput       `json:"affectedDevices_every,omitempty"`
	AffectedDevicesSome  *DeviceWhereInput       `json:"affectedDevices_some,omitempty"`
	AffectedDevicesNone  *DeviceWhereInput       `json:"affectedDevices_none,omitempty"`
	Note                 *string                 `json:"note,omitempty"`
	NoteNot              *string                 `json:"note_not,omitempty"`
	NoteIn               []string                `json:"note_in,omitempty"`
	NoteNotIn            []string                `json:"note_not_in,omitempty"`
	NoteLt               *string                 `json:"note_lt,omitempty"`
	NoteLte              *string                 `json:"note_lte,omitempty"`
	NoteGt               *string                 `json:"note_gt,omitempty"`
	NoteGte              *string                 `json:"note_gte,omitempty"`
	NoteContains         *string                 `json:"note_contains,omitempty"`
	NoteNotContains      *string                 `json:"note_not_contains,omitempty"`
	NoteStartsWith       *string                 `json:"note_starts_with,omitempty"`
	NoteNotStartsWith    *string                 `json:"note_not_starts_with,omitempty"`
	NoteEndsWith         *string                 `json:"note_ends_with,omitempty"`
	NoteNotEndsWith      *string                 `json:"note_not_ends_with,omitempty"`
	FromDate             *string                 `json:"fromDate,omitempty"`
	FromDateNot          *string                 `json:"fromDate_not,omitempty"`
	FromDateIn           []string                `json:"fromDate_in,omitempty"`
	FromDateNotIn        []string                `json:"fromDate_not_in,omitempty"`
	FromDateLt           *string                 `json:"fromDate_lt,omitempty"`
	FromDateLte          *string                 `json:"fromDate_lte,omitempty"`
	FromDateGt           *string                 `json:"fromDate_gt,omitempty"`
	FromDateGte          *string                 `json:"fromDate_gte,omitempty"`
	ToDate               *string                 `json:"toDate,omitempty"`
	ToDateNot            *string                 `json:"toDate_not,omitempty"`
	ToDateIn             []string                `json:"toDate_in,omitempty"`
	ToDateNotIn          []string                `json:"toDate_not_in,omitempty"`
	ToDateLt             *string                 `json:"toDate_lt,omitempty"`
	ToDateLte            *string                 `json:"toDate_lte,omitempty"`
	ToDateGt             *string                 `json:"toDate_gt,omitempty"`
	ToDateGte            *string                 `json:"toDate_gte,omitempty"`
	CreateUser           *AdminUserWhereInput    `json:"createUser,omitempty"`
	UpdateUser           *AdminUserWhereInput    `json:"updateUser,omitempty"`
	CreatedAt            *string                 `json:"createdAt,omitempty"`
	CreatedAtNot         *string                 `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                 `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                 `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                 `json:"updatedAt_gte,omitempty"`
	IsDel                *bool                   `json:"isDel,omitempty"`
	IsDelNot             *bool                   `json:"isDel_not,omitempty"`
	And                  []MaintenanceWhereInput `json:"AND,omitempty"`
	Or                   []MaintenanceWhereInput `json:"OR,omitempty"`
	Not                  []MaintenanceWhereInput `json:"NOT,omitempty"`
}

type AppVersionWhereInput struct {
	ID                   *string                `json:"id,omitempty"`
	IDNot                *string                `json:"id_not,omitempty"`
	IDIn                 []string               `json:"id_in,omitempty"`
	IDNotIn              []string               `json:"id_not_in,omitempty"`
	IDLt                 *string                `json:"id_lt,omitempty"`
	IDLte                *string                `json:"id_lte,omitempty"`
	IDGt                 *string                `json:"id_gt,omitempty"`
	IDGte                *string                `json:"id_gte,omitempty"`
	IDContains           *string                `json:"id_contains,omitempty"`
	IDNotContains        *string                `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                `json:"id_not_ends_with,omitempty"`
	Version              *string                `json:"version,omitempty"`
	VersionNot           *string                `json:"version_not,omitempty"`
	VersionIn            []string               `json:"version_in,omitempty"`
	VersionNotIn         []string               `json:"version_not_in,omitempty"`
	VersionLt            *string                `json:"version_lt,omitempty"`
	VersionLte           *string                `json:"version_lte,omitempty"`
	VersionGt            *string                `json:"version_gt,omitempty"`
	VersionGte           *string                `json:"version_gte,omitempty"`
	VersionContains      *string                `json:"version_contains,omitempty"`
	VersionNotContains   *string                `json:"version_not_contains,omitempty"`
	VersionStartsWith    *string                `json:"version_starts_with,omitempty"`
	VersionNotStartsWith *string                `json:"version_not_starts_with,omitempty"`
	VersionEndsWith      *string                `json:"version_ends_with,omitempty"`
	VersionNotEndsWith   *string                `json:"version_not_ends_with,omitempty"`
	Type                 *int32                 `json:"type,omitempty"`
	TypeNot              *int32                 `json:"type_not,omitempty"`
	TypeIn               []int32                `json:"type_in,omitempty"`
	TypeNotIn            []int32                `json:"type_not_in,omitempty"`
	TypeLt               *int32                 `json:"type_lt,omitempty"`
	TypeLte              *int32                 `json:"type_lte,omitempty"`
	TypeGt               *int32                 `json:"type_gt,omitempty"`
	TypeGte              *int32                 `json:"type_gte,omitempty"`
	AffectedDevicesEvery *DeviceWhereInput      `json:"affectedDevices_every,omitempty"`
	AffectedDevicesSome  *DeviceWhereInput      `json:"affectedDevices_some,omitempty"`
	AffectedDevicesNone  *DeviceWhereInput      `json:"affectedDevices_none,omitempty"`
	Note                 *string                `json:"note,omitempty"`
	NoteNot              *string                `json:"note_not,omitempty"`
	NoteIn               []string               `json:"note_in,omitempty"`
	NoteNotIn            []string               `json:"note_not_in,omitempty"`
	NoteLt               *string                `json:"note_lt,omitempty"`
	NoteLte              *string                `json:"note_lte,omitempty"`
	NoteGt               *string                `json:"note_gt,omitempty"`
	NoteGte              *string                `json:"note_gte,omitempty"`
	NoteContains         *string                `json:"note_contains,omitempty"`
	NoteNotContains      *string                `json:"note_not_contains,omitempty"`
	NoteStartsWith       *string                `json:"note_starts_with,omitempty"`
	NoteNotStartsWith    *string                `json:"note_not_starts_with,omitempty"`
	NoteEndsWith         *string                `json:"note_ends_with,omitempty"`
	NoteNotEndsWith      *string                `json:"note_not_ends_with,omitempty"`
	CreateUser           *AdminUserWhereInput   `json:"createUser,omitempty"`
	UpdateUser           *AdminUserWhereInput   `json:"updateUser,omitempty"`
	ReleasedAt           *string                `json:"releasedAt,omitempty"`
	ReleasedAtNot        *string                `json:"releasedAt_not,omitempty"`
	ReleasedAtIn         []string               `json:"releasedAt_in,omitempty"`
	ReleasedAtNotIn      []string               `json:"releasedAt_not_in,omitempty"`
	ReleasedAtLt         *string                `json:"releasedAt_lt,omitempty"`
	ReleasedAtLte        *string                `json:"releasedAt_lte,omitempty"`
	ReleasedAtGt         *string                `json:"releasedAt_gt,omitempty"`
	ReleasedAtGte        *string                `json:"releasedAt_gte,omitempty"`
	CreatedAt            *string                `json:"createdAt,omitempty"`
	CreatedAtNot         *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                `json:"updatedAt_gte,omitempty"`
	IsDel                *bool                  `json:"isDel,omitempty"`
	IsDelNot             *bool                  `json:"isDel_not,omitempty"`
	And                  []AppVersionWhereInput `json:"AND,omitempty"`
	Or                   []AppVersionWhereInput `json:"OR,omitempty"`
	Not                  []AppVersionWhereInput `json:"NOT,omitempty"`
}

type BadgeWhereUniqueInput struct {
	ID         *string `json:"id,omitempty"`
	Name       *string `json:"name,omitempty"`
	OrderIndex *int32  `json:"orderIndex,omitempty"`
}

type BadgeVoterWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BankWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Code *string `json:"code,omitempty"`
	Name *string `json:"name,omitempty"`
}

type BankAccountVerificationWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BankAccountVerificationTransactionInfoWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BoardWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type BoardWhereInput struct {
	ID                   *string           `json:"id,omitempty"`
	IDNot                *string           `json:"id_not,omitempty"`
	IDIn                 []string          `json:"id_in,omitempty"`
	IDNotIn              []string          `json:"id_not_in,omitempty"`
	IDLt                 *string           `json:"id_lt,omitempty"`
	IDLte                *string           `json:"id_lte,omitempty"`
	IDGt                 *string           `json:"id_gt,omitempty"`
	IDGte                *string           `json:"id_gte,omitempty"`
	IDContains           *string           `json:"id_contains,omitempty"`
	IDNotContains        *string           `json:"id_not_contains,omitempty"`
	IDStartsWith         *string           `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string           `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string           `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string           `json:"id_not_ends_with,omitempty"`
	Type                 *int32            `json:"type,omitempty"`
	TypeNot              *int32            `json:"type_not,omitempty"`
	TypeIn               []int32           `json:"type_in,omitempty"`
	TypeNotIn            []int32           `json:"type_not_in,omitempty"`
	TypeLt               *int32            `json:"type_lt,omitempty"`
	TypeLte              *int32            `json:"type_lte,omitempty"`
	TypeGt               *int32            `json:"type_gt,omitempty"`
	TypeGte              *int32            `json:"type_gte,omitempty"`
	Title                *string           `json:"title,omitempty"`
	TitleNot             *string           `json:"title_not,omitempty"`
	TitleIn              []string          `json:"title_in,omitempty"`
	TitleNotIn           []string          `json:"title_not_in,omitempty"`
	TitleLt              *string           `json:"title_lt,omitempty"`
	TitleLte             *string           `json:"title_lte,omitempty"`
	TitleGt              *string           `json:"title_gt,omitempty"`
	TitleGte             *string           `json:"title_gte,omitempty"`
	TitleContains        *string           `json:"title_contains,omitempty"`
	TitleNotContains     *string           `json:"title_not_contains,omitempty"`
	TitleStartsWith      *string           `json:"title_starts_with,omitempty"`
	TitleNotStartsWith   *string           `json:"title_not_starts_with,omitempty"`
	TitleEndsWith        *string           `json:"title_ends_with,omitempty"`
	TitleNotEndsWith     *string           `json:"title_not_ends_with,omitempty"`
	Content              *string           `json:"content,omitempty"`
	ContentNot           *string           `json:"content_not,omitempty"`
	ContentIn            []string          `json:"content_in,omitempty"`
	ContentNotIn         []string          `json:"content_not_in,omitempty"`
	ContentLt            *string           `json:"content_lt,omitempty"`
	ContentLte           *string           `json:"content_lte,omitempty"`
	ContentGt            *string           `json:"content_gt,omitempty"`
	ContentGte           *string           `json:"content_gte,omitempty"`
	ContentContains      *string           `json:"content_contains,omitempty"`
	ContentNotContains   *string           `json:"content_not_contains,omitempty"`
	ContentStartsWith    *string           `json:"content_starts_with,omitempty"`
	ContentNotStartsWith *string           `json:"content_not_starts_with,omitempty"`
	ContentEndsWith      *string           `json:"content_ends_with,omitempty"`
	ContentNotEndsWith   *string           `json:"content_not_ends_with,omitempty"`
	CreatedAt            *string           `json:"createdAt,omitempty"`
	CreatedAtNot         *string           `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string           `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string           `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string           `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string           `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string           `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string           `json:"updatedAt_gte,omitempty"`
	IsDel                *bool             `json:"isDel,omitempty"`
	IsDelNot             *bool             `json:"isDel_not,omitempty"`
	And                  []BoardWhereInput `json:"AND,omitempty"`
	Or                   []BoardWhereInput `json:"OR,omitempty"`
	Not                  []BoardWhereInput `json:"NOT,omitempty"`
}

type CashHistoryWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	OrderNum *int32  `json:"orderNum,omitempty"`
}

type CategoryWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type CoinWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type CoinKlineWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CoinPriceTableWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CommentWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type CommentReplyWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type DeviceWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Code *int32  `json:"code,omitempty"`
	Name *string `json:"name,omitempty"`
}

type FeeWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Key  *int32  `json:"key,omitempty"`
	Rank *int32  `json:"rank,omitempty"`
}

type FileWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type FileInfoWhereUniqueInput struct {
	ID         *string `json:"id,omitempty"`
	TempFileId *string `json:"tempFileId,omitempty"`
}

type InstagramWhereUniqueInput struct {
	ID     *string `json:"id,omitempty"`
	UserNo *string `json:"userNo,omitempty"`
}

type InstagramDailyStatisticsWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type InviteCodeWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	NumId *int32  `json:"numId,omitempty"`
	Code  *string `json:"code,omitempty"`
}

type InviteUserHistoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type MaintenanceWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type MotherHistoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type NotificationWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type OfferWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type OfferorWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type OrderDealsHistoryWhereUniqueInput struct {
	ID     *string `json:"id,omitempty"`
	DealId *int32  `json:"dealId,omitempty"`
}

type OrderHistoryWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	OrderNum *int32  `json:"orderNum,omitempty"`
}

type OrderUserDealsHistoryWhereUniqueInput struct {
	ID        *string `json:"id,omitempty"`
	UniqueKey *string `json:"uniqueKey,omitempty"`
}

type PageWhereUniqueInput struct {
	ID     *string `json:"id,omitempty"`
	PageId *string `json:"pageId,omitempty"`
}

type PageBadgeWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PageCommentWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PageCommentReplyWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PageFanWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PaymentHistoryWhereUniqueInput struct {
	ID      *string `json:"id,omitempty"`
	OrderNo *string `json:"order_no,omitempty"`
}

type PaymentHistoryWhereInput struct {
	ID                           *string                    `json:"id,omitempty"`
	IDNot                        *string                    `json:"id_not,omitempty"`
	IDIn                         []string                   `json:"id_in,omitempty"`
	IDNotIn                      []string                   `json:"id_not_in,omitempty"`
	IDLt                         *string                    `json:"id_lt,omitempty"`
	IDLte                        *string                    `json:"id_lte,omitempty"`
	IDGt                         *string                    `json:"id_gt,omitempty"`
	IDGte                        *string                    `json:"id_gte,omitempty"`
	IDContains                   *string                    `json:"id_contains,omitempty"`
	IDNotContains                *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                    `json:"id_not_ends_with,omitempty"`
	Code                         *string                    `json:"code,omitempty"`
	CodeNot                      *string                    `json:"code_not,omitempty"`
	CodeIn                       []string                   `json:"code_in,omitempty"`
	CodeNotIn                    []string                   `json:"code_not_in,omitempty"`
	CodeLt                       *string                    `json:"code_lt,omitempty"`
	CodeLte                      *string                    `json:"code_lte,omitempty"`
	CodeGt                       *string                    `json:"code_gt,omitempty"`
	CodeGte                      *string                    `json:"code_gte,omitempty"`
	CodeContains                 *string                    `json:"code_contains,omitempty"`
	CodeNotContains              *string                    `json:"code_not_contains,omitempty"`
	CodeStartsWith               *string                    `json:"code_starts_with,omitempty"`
	CodeNotStartsWith            *string                    `json:"code_not_starts_with,omitempty"`
	CodeEndsWith                 *string                    `json:"code_ends_with,omitempty"`
	CodeNotEndsWith              *string                    `json:"code_not_ends_with,omitempty"`
	Message                      *string                    `json:"message,omitempty"`
	MessageNot                   *string                    `json:"message_not,omitempty"`
	MessageIn                    []string                   `json:"message_in,omitempty"`
	MessageNotIn                 []string                   `json:"message_not_in,omitempty"`
	MessageLt                    *string                    `json:"message_lt,omitempty"`
	MessageLte                   *string                    `json:"message_lte,omitempty"`
	MessageGt                    *string                    `json:"message_gt,omitempty"`
	MessageGte                   *string                    `json:"message_gte,omitempty"`
	MessageContains              *string                    `json:"message_contains,omitempty"`
	MessageNotContains           *string                    `json:"message_not_contains,omitempty"`
	MessageStartsWith            *string                    `json:"message_starts_with,omitempty"`
	MessageNotStartsWith         *string                    `json:"message_not_starts_with,omitempty"`
	MessageEndsWith              *string                    `json:"message_ends_with,omitempty"`
	MessageNotEndsWith           *string                    `json:"message_not_ends_with,omitempty"`
	User                         *UserWhereInput            `json:"user,omitempty"`
	OrderNo                      *string                    `json:"order_no,omitempty"`
	OrderNoNot                   *string                    `json:"order_no_not,omitempty"`
	OrderNoIn                    []string                   `json:"order_no_in,omitempty"`
	OrderNoNotIn                 []string                   `json:"order_no_not_in,omitempty"`
	OrderNoLt                    *string                    `json:"order_no_lt,omitempty"`
	OrderNoLte                   *string                    `json:"order_no_lte,omitempty"`
	OrderNoGt                    *string                    `json:"order_no_gt,omitempty"`
	OrderNoGte                   *string                    `json:"order_no_gte,omitempty"`
	OrderNoContains              *string                    `json:"order_no_contains,omitempty"`
	OrderNoNotContains           *string                    `json:"order_no_not_contains,omitempty"`
	OrderNoStartsWith            *string                    `json:"order_no_starts_with,omitempty"`
	OrderNoNotStartsWith         *string                    `json:"order_no_not_starts_with,omitempty"`
	OrderNoEndsWith              *string                    `json:"order_no_ends_with,omitempty"`
	OrderNoNotEndsWith           *string                    `json:"order_no_not_ends_with,omitempty"`
	ServiceName                  *string                    `json:"service_name,omitempty"`
	ServiceNameNot               *string                    `json:"service_name_not,omitempty"`
	ServiceNameIn                []string                   `json:"service_name_in,omitempty"`
	ServiceNameNotIn             []string                   `json:"service_name_not_in,omitempty"`
	ServiceNameLt                *string                    `json:"service_name_lt,omitempty"`
	ServiceNameLte               *string                    `json:"service_name_lte,omitempty"`
	ServiceNameGt                *string                    `json:"service_name_gt,omitempty"`
	ServiceNameGte               *string                    `json:"service_name_gte,omitempty"`
	ServiceNameContains          *string                    `json:"service_name_contains,omitempty"`
	ServiceNameNotContains       *string                    `json:"service_name_not_contains,omitempty"`
	ServiceNameStartsWith        *string                    `json:"service_name_starts_with,omitempty"`
	ServiceNameNotStartsWith     *string                    `json:"service_name_not_starts_with,omitempty"`
	ServiceNameEndsWith          *string                    `json:"service_name_ends_with,omitempty"`
	ServiceNameNotEndsWith       *string                    `json:"service_name_not_ends_with,omitempty"`
	ProductName                  *string                    `json:"product_name,omitempty"`
	ProductNameNot               *string                    `json:"product_name_not,omitempty"`
	ProductNameIn                []string                   `json:"product_name_in,omitempty"`
	ProductNameNotIn             []string                   `json:"product_name_not_in,omitempty"`
	ProductNameLt                *string                    `json:"product_name_lt,omitempty"`
	ProductNameLte               *string                    `json:"product_name_lte,omitempty"`
	ProductNameGt                *string                    `json:"product_name_gt,omitempty"`
	ProductNameGte               *string                    `json:"product_name_gte,omitempty"`
	ProductNameContains          *string                    `json:"product_name_contains,omitempty"`
	ProductNameNotContains       *string                    `json:"product_name_not_contains,omitempty"`
	ProductNameStartsWith        *string                    `json:"product_name_starts_with,omitempty"`
	ProductNameNotStartsWith     *string                    `json:"product_name_not_starts_with,omitempty"`
	ProductNameEndsWith          *string                    `json:"product_name_ends_with,omitempty"`
	ProductNameNotEndsWith       *string                    `json:"product_name_not_ends_with,omitempty"`
	CustomParameter              *string                    `json:"custom_parameter,omitempty"`
	CustomParameterNot           *string                    `json:"custom_parameter_not,omitempty"`
	CustomParameterIn            []string                   `json:"custom_parameter_in,omitempty"`
	CustomParameterNotIn         []string                   `json:"custom_parameter_not_in,omitempty"`
	CustomParameterLt            *string                    `json:"custom_parameter_lt,omitempty"`
	CustomParameterLte           *string                    `json:"custom_parameter_lte,omitempty"`
	CustomParameterGt            *string                    `json:"custom_parameter_gt,omitempty"`
	CustomParameterGte           *string                    `json:"custom_parameter_gte,omitempty"`
	CustomParameterContains      *string                    `json:"custom_parameter_contains,omitempty"`
	CustomParameterNotContains   *string                    `json:"custom_parameter_not_contains,omitempty"`
	CustomParameterStartsWith    *string                    `json:"custom_parameter_starts_with,omitempty"`
	CustomParameterNotStartsWith *string                    `json:"custom_parameter_not_starts_with,omitempty"`
	CustomParameterEndsWith      *string                    `json:"custom_parameter_ends_with,omitempty"`
	CustomParameterNotEndsWith   *string                    `json:"custom_parameter_not_ends_with,omitempty"`
	Tid                          *string                    `json:"tid,omitempty"`
	TidNot                       *string                    `json:"tid_not,omitempty"`
	TidIn                        []string                   `json:"tid_in,omitempty"`
	TidNotIn                     []string                   `json:"tid_not_in,omitempty"`
	TidLt                        *string                    `json:"tid_lt,omitempty"`
	TidLte                       *string                    `json:"tid_lte,omitempty"`
	TidGt                        *string                    `json:"tid_gt,omitempty"`
	TidGte                       *string                    `json:"tid_gte,omitempty"`
	TidContains                  *string                    `json:"tid_contains,omitempty"`
	TidNotContains               *string                    `json:"tid_not_contains,omitempty"`
	TidStartsWith                *string                    `json:"tid_starts_with,omitempty"`
	TidNotStartsWith             *string                    `json:"tid_not_starts_with,omitempty"`
	TidEndsWith                  *string                    `json:"tid_ends_with,omitempty"`
	TidNotEndsWith               *string                    `json:"tid_not_ends_with,omitempty"`
	Cid                          *string                    `json:"cid,omitempty"`
	CidNot                       *string                    `json:"cid_not,omitempty"`
	CidIn                        []string                   `json:"cid_in,omitempty"`
	CidNotIn                     []string                   `json:"cid_not_in,omitempty"`
	CidLt                        *string                    `json:"cid_lt,omitempty"`
	CidLte                       *string                    `json:"cid_lte,omitempty"`
	CidGt                        *string                    `json:"cid_gt,omitempty"`
	CidGte                       *string                    `json:"cid_gte,omitempty"`
	CidContains                  *string                    `json:"cid_contains,omitempty"`
	CidNotContains               *string                    `json:"cid_not_contains,omitempty"`
	CidStartsWith                *string                    `json:"cid_starts_with,omitempty"`
	CidNotStartsWith             *string                    `json:"cid_not_starts_with,omitempty"`
	CidEndsWith                  *string                    `json:"cid_ends_with,omitempty"`
	CidNotEndsWith               *string                    `json:"cid_not_ends_with,omitempty"`
	Amount                       *int32                     `json:"amount,omitempty"`
	AmountNot                    *int32                     `json:"amount_not,omitempty"`
	AmountIn                     []int32                    `json:"amount_in,omitempty"`
	AmountNotIn                  []int32                    `json:"amount_not_in,omitempty"`
	AmountLt                     *int32                     `json:"amount_lt,omitempty"`
	AmountLte                    *int32                     `json:"amount_lte,omitempty"`
	AmountGt                     *int32                     `json:"amount_gt,omitempty"`
	AmountGte                    *int32                     `json:"amount_gte,omitempty"`
	AmountFee                    *int32                     `json:"amount_fee,omitempty"`
	AmountFeeNot                 *int32                     `json:"amount_fee_not,omitempty"`
	AmountFeeIn                  []int32                    `json:"amount_fee_in,omitempty"`
	AmountFeeNotIn               []int32                    `json:"amount_fee_not_in,omitempty"`
	AmountFeeLt                  *int32                     `json:"amount_fee_lt,omitempty"`
	AmountFeeLte                 *int32                     `json:"amount_fee_lte,omitempty"`
	AmountFeeGt                  *int32                     `json:"amount_fee_gt,omitempty"`
	AmountFeeGte                 *int32                     `json:"amount_fee_gte,omitempty"`
	AmountWithoutFee             *int32                     `json:"amount_without_fee,omitempty"`
	AmountWithoutFeeNot          *int32                     `json:"amount_without_fee_not,omitempty"`
	AmountWithoutFeeIn           []int32                    `json:"amount_without_fee_in,omitempty"`
	AmountWithoutFeeNotIn        []int32                    `json:"amount_without_fee_not_in,omitempty"`
	AmountWithoutFeeLt           *int32                     `json:"amount_without_fee_lt,omitempty"`
	AmountWithoutFeeLte          *int32                     `json:"amount_without_fee_lte,omitempty"`
	AmountWithoutFeeGt           *int32                     `json:"amount_without_fee_gt,omitempty"`
	AmountWithoutFeeGte          *int32                     `json:"amount_without_fee_gte,omitempty"`
	Pgcode                       *string                    `json:"pgcode,omitempty"`
	PgcodeNot                    *string                    `json:"pgcode_not,omitempty"`
	PgcodeIn                     []string                   `json:"pgcode_in,omitempty"`
	PgcodeNotIn                  []string                   `json:"pgcode_not_in,omitempty"`
	PgcodeLt                     *string                    `json:"pgcode_lt,omitempty"`
	PgcodeLte                    *string                    `json:"pgcode_lte,omitempty"`
	PgcodeGt                     *string                    `json:"pgcode_gt,omitempty"`
	PgcodeGte                    *string                    `json:"pgcode_gte,omitempty"`
	PgcodeContains               *string                    `json:"pgcode_contains,omitempty"`
	PgcodeNotContains            *string                    `json:"pgcode_not_contains,omitempty"`
	PgcodeStartsWith             *string                    `json:"pgcode_starts_with,omitempty"`
	PgcodeNotStartsWith          *string                    `json:"pgcode_not_starts_with,omitempty"`
	PgcodeEndsWith               *string                    `json:"pgcode_ends_with,omitempty"`
	PgcodeNotEndsWith            *string                    `json:"pgcode_not_ends_with,omitempty"`
	PayInfo                      *string                    `json:"pay_info,omitempty"`
	PayInfoNot                   *string                    `json:"pay_info_not,omitempty"`
	PayInfoIn                    []string                   `json:"pay_info_in,omitempty"`
	PayInfoNotIn                 []string                   `json:"pay_info_not_in,omitempty"`
	PayInfoLt                    *string                    `json:"pay_info_lt,omitempty"`
	PayInfoLte                   *string                    `json:"pay_info_lte,omitempty"`
	PayInfoGt                    *string                    `json:"pay_info_gt,omitempty"`
	PayInfoGte                   *string                    `json:"pay_info_gte,omitempty"`
	PayInfoContains              *string                    `json:"pay_info_contains,omitempty"`
	PayInfoNotContains           *string                    `json:"pay_info_not_contains,omitempty"`
	PayInfoStartsWith            *string                    `json:"pay_info_starts_with,omitempty"`
	PayInfoNotStartsWith         *string                    `json:"pay_info_not_starts_with,omitempty"`
	PayInfoEndsWith              *string                    `json:"pay_info_ends_with,omitempty"`
	PayInfoNotEndsWith           *string                    `json:"pay_info_not_ends_with,omitempty"`
	DomesticFlag                 *string                    `json:"domestic_flag,omitempty"`
	DomesticFlagNot              *string                    `json:"domestic_flag_not,omitempty"`
	DomesticFlagIn               []string                   `json:"domestic_flag_in,omitempty"`
	DomesticFlagNotIn            []string                   `json:"domestic_flag_not_in,omitempty"`
	DomesticFlagLt               *string                    `json:"domestic_flag_lt,omitempty"`
	DomesticFlagLte              *string                    `json:"domestic_flag_lte,omitempty"`
	DomesticFlagGt               *string                    `json:"domestic_flag_gt,omitempty"`
	DomesticFlagGte              *string                    `json:"domestic_flag_gte,omitempty"`
	DomesticFlagContains         *string                    `json:"domestic_flag_contains,omitempty"`
	DomesticFlagNotContains      *string                    `json:"domestic_flag_not_contains,omitempty"`
	DomesticFlagStartsWith       *string                    `json:"domestic_flag_starts_with,omitempty"`
	DomesticFlagNotStartsWith    *string                    `json:"domestic_flag_not_starts_with,omitempty"`
	DomesticFlagEndsWith         *string                    `json:"domestic_flag_ends_with,omitempty"`
	DomesticFlagNotEndsWith      *string                    `json:"domestic_flag_not_ends_with,omitempty"`
	TransactionDate              *string                    `json:"transaction_date,omitempty"`
	TransactionDateNot           *string                    `json:"transaction_date_not,omitempty"`
	TransactionDateIn            []string                   `json:"transaction_date_in,omitempty"`
	TransactionDateNotIn         []string                   `json:"transaction_date_not_in,omitempty"`
	TransactionDateLt            *string                    `json:"transaction_date_lt,omitempty"`
	TransactionDateLte           *string                    `json:"transaction_date_lte,omitempty"`
	TransactionDateGt            *string                    `json:"transaction_date_gt,omitempty"`
	TransactionDateGte           *string                    `json:"transaction_date_gte,omitempty"`
	TransactionDateContains      *string                    `json:"transaction_date_contains,omitempty"`
	TransactionDateNotContains   *string                    `json:"transaction_date_not_contains,omitempty"`
	TransactionDateStartsWith    *string                    `json:"transaction_date_starts_with,omitempty"`
	TransactionDateNotStartsWith *string                    `json:"transaction_date_not_starts_with,omitempty"`
	TransactionDateEndsWith      *string                    `json:"transaction_date_ends_with,omitempty"`
	TransactionDateNotEndsWith   *string                    `json:"transaction_date_not_ends_with,omitempty"`
	InstallMonth                 *string                    `json:"install_month,omitempty"`
	InstallMonthNot              *string                    `json:"install_month_not,omitempty"`
	InstallMonthIn               []string                   `json:"install_month_in,omitempty"`
	InstallMonthNotIn            []string                   `json:"install_month_not_in,omitempty"`
	InstallMonthLt               *string                    `json:"install_month_lt,omitempty"`
	InstallMonthLte              *string                    `json:"install_month_lte,omitempty"`
	InstallMonthGt               *string                    `json:"install_month_gt,omitempty"`
	InstallMonthGte              *string                    `json:"install_month_gte,omitempty"`
	InstallMonthContains         *string                    `json:"install_month_contains,omitempty"`
	InstallMonthNotContains      *string                    `json:"install_month_not_contains,omitempty"`
	InstallMonthStartsWith       *string                    `json:"install_month_starts_with,omitempty"`
	InstallMonthNotStartsWith    *string                    `json:"install_month_not_starts_with,omitempty"`
	InstallMonthEndsWith         *string                    `json:"install_month_ends_with,omitempty"`
	InstallMonthNotEndsWith      *string                    `json:"install_month_not_ends_with,omitempty"`
	CardInfo                     *string                    `json:"card_info,omitempty"`
	CardInfoNot                  *string                    `json:"card_info_not,omitempty"`
	CardInfoIn                   []string                   `json:"card_info_in,omitempty"`
	CardInfoNotIn                []string                   `json:"card_info_not_in,omitempty"`
	CardInfoLt                   *string                    `json:"card_info_lt,omitempty"`
	CardInfoLte                  *string                    `json:"card_info_lte,omitempty"`
	CardInfoGt                   *string                    `json:"card_info_gt,omitempty"`
	CardInfoGte                  *string                    `json:"card_info_gte,omitempty"`
	CardInfoContains             *string                    `json:"card_info_contains,omitempty"`
	CardInfoNotContains          *string                    `json:"card_info_not_contains,omitempty"`
	CardInfoStartsWith           *string                    `json:"card_info_starts_with,omitempty"`
	CardInfoNotStartsWith        *string                    `json:"card_info_not_starts_with,omitempty"`
	CardInfoEndsWith             *string                    `json:"card_info_ends_with,omitempty"`
	CardInfoNotEndsWith          *string                    `json:"card_info_not_ends_with,omitempty"`
	Payhash                      *string                    `json:"payhash,omitempty"`
	PayhashNot                   *string                    `json:"payhash_not,omitempty"`
	PayhashIn                    []string                   `json:"payhash_in,omitempty"`
	PayhashNotIn                 []string                   `json:"payhash_not_in,omitempty"`
	PayhashLt                    *string                    `json:"payhash_lt,omitempty"`
	PayhashLte                   *string                    `json:"payhash_lte,omitempty"`
	PayhashGt                    *string                    `json:"payhash_gt,omitempty"`
	PayhashGte                   *string                    `json:"payhash_gte,omitempty"`
	PayhashContains              *string                    `json:"payhash_contains,omitempty"`
	PayhashNotContains           *string                    `json:"payhash_not_contains,omitempty"`
	PayhashStartsWith            *string                    `json:"payhash_starts_with,omitempty"`
	PayhashNotStartsWith         *string                    `json:"payhash_not_starts_with,omitempty"`
	PayhashEndsWith              *string                    `json:"payhash_ends_with,omitempty"`
	PayhashNotEndsWith           *string                    `json:"payhash_not_ends_with,omitempty"`
	AccountNo                    *string                    `json:"account_no,omitempty"`
	AccountNoNot                 *string                    `json:"account_no_not,omitempty"`
	AccountNoIn                  []string                   `json:"account_no_in,omitempty"`
	AccountNoNotIn               []string                   `json:"account_no_not_in,omitempty"`
	AccountNoLt                  *string                    `json:"account_no_lt,omitempty"`
	AccountNoLte                 *string                    `json:"account_no_lte,omitempty"`
	AccountNoGt                  *string                    `json:"account_no_gt,omitempty"`
	AccountNoGte                 *string                    `json:"account_no_gte,omitempty"`
	AccountNoContains            *string                    `json:"account_no_contains,omitempty"`
	AccountNoNotContains         *string                    `json:"account_no_not_contains,omitempty"`
	AccountNoStartsWith          *string                    `json:"account_no_starts_with,omitempty"`
	AccountNoNotStartsWith       *string                    `json:"account_no_not_starts_with,omitempty"`
	AccountNoEndsWith            *string                    `json:"account_no_ends_with,omitempty"`
	AccountNoNotEndsWith         *string                    `json:"account_no_not_ends_with,omitempty"`
	AccountName                  *string                    `json:"account_name,omitempty"`
	AccountNameNot               *string                    `json:"account_name_not,omitempty"`
	AccountNameIn                []string                   `json:"account_name_in,omitempty"`
	AccountNameNotIn             []string                   `json:"account_name_not_in,omitempty"`
	AccountNameLt                *string                    `json:"account_name_lt,omitempty"`
	AccountNameLte               *string                    `json:"account_name_lte,omitempty"`
	AccountNameGt                *string                    `json:"account_name_gt,omitempty"`
	AccountNameGte               *string                    `json:"account_name_gte,omitempty"`
	AccountNameContains          *string                    `json:"account_name_contains,omitempty"`
	AccountNameNotContains       *string                    `json:"account_name_not_contains,omitempty"`
	AccountNameStartsWith        *string                    `json:"account_name_starts_with,omitempty"`
	AccountNameNotStartsWith     *string                    `json:"account_name_not_starts_with,omitempty"`
	AccountNameEndsWith          *string                    `json:"account_name_ends_with,omitempty"`
	AccountNameNotEndsWith       *string                    `json:"account_name_not_ends_with,omitempty"`
	BankCode                     *string                    `json:"bank_code,omitempty"`
	BankCodeNot                  *string                    `json:"bank_code_not,omitempty"`
	BankCodeIn                   []string                   `json:"bank_code_in,omitempty"`
	BankCodeNotIn                []string                   `json:"bank_code_not_in,omitempty"`
	BankCodeLt                   *string                    `json:"bank_code_lt,omitempty"`
	BankCodeLte                  *string                    `json:"bank_code_lte,omitempty"`
	BankCodeGt                   *string                    `json:"bank_code_gt,omitempty"`
	BankCodeGte                  *string                    `json:"bank_code_gte,omitempty"`
	BankCodeContains             *string                    `json:"bank_code_contains,omitempty"`
	BankCodeNotContains          *string                    `json:"bank_code_not_contains,omitempty"`
	BankCodeStartsWith           *string                    `json:"bank_code_starts_with,omitempty"`
	BankCodeNotStartsWith        *string                    `json:"bank_code_not_starts_with,omitempty"`
	BankCodeEndsWith             *string                    `json:"bank_code_ends_with,omitempty"`
	BankCodeNotEndsWith          *string                    `json:"bank_code_not_ends_with,omitempty"`
	BankName                     *string                    `json:"bank_name,omitempty"`
	BankNameNot                  *string                    `json:"bank_name_not,omitempty"`
	BankNameIn                   []string                   `json:"bank_name_in,omitempty"`
	BankNameNotIn                []string                   `json:"bank_name_not_in,omitempty"`
	BankNameLt                   *string                    `json:"bank_name_lt,omitempty"`
	BankNameLte                  *string                    `json:"bank_name_lte,omitempty"`
	BankNameGt                   *string                    `json:"bank_name_gt,omitempty"`
	BankNameGte                  *string                    `json:"bank_name_gte,omitempty"`
	BankNameContains             *string                    `json:"bank_name_contains,omitempty"`
	BankNameNotContains          *string                    `json:"bank_name_not_contains,omitempty"`
	BankNameStartsWith           *string                    `json:"bank_name_starts_with,omitempty"`
	BankNameNotStartsWith        *string                    `json:"bank_name_not_starts_with,omitempty"`
	BankNameEndsWith             *string                    `json:"bank_name_ends_with,omitempty"`
	BankNameNotEndsWith          *string                    `json:"bank_name_not_ends_with,omitempty"`
	ExpireDate                   *string                    `json:"expire_date,omitempty"`
	ExpireDateNot                *string                    `json:"expire_date_not,omitempty"`
	ExpireDateIn                 []string                   `json:"expire_date_in,omitempty"`
	ExpireDateNotIn              []string                   `json:"expire_date_not_in,omitempty"`
	ExpireDateLt                 *string                    `json:"expire_date_lt,omitempty"`
	ExpireDateLte                *string                    `json:"expire_date_lte,omitempty"`
	ExpireDateGt                 *string                    `json:"expire_date_gt,omitempty"`
	ExpireDateGte                *string                    `json:"expire_date_gte,omitempty"`
	ExpireDateContains           *string                    `json:"expire_date_contains,omitempty"`
	ExpireDateNotContains        *string                    `json:"expire_date_not_contains,omitempty"`
	ExpireDateStartsWith         *string                    `json:"expire_date_starts_with,omitempty"`
	ExpireDateNotStartsWith      *string                    `json:"expire_date_not_starts_with,omitempty"`
	ExpireDateEndsWith           *string                    `json:"expire_date_ends_with,omitempty"`
	ExpireDateNotEndsWith        *string                    `json:"expire_date_not_ends_with,omitempty"`
	ExpireTime                   *string                    `json:"expire_time,omitempty"`
	ExpireTimeNot                *string                    `json:"expire_time_not,omitempty"`
	ExpireTimeIn                 []string                   `json:"expire_time_in,omitempty"`
	ExpireTimeNotIn              []string                   `json:"expire_time_not_in,omitempty"`
	ExpireTimeLt                 *string                    `json:"expire_time_lt,omitempty"`
	ExpireTimeLte                *string                    `json:"expire_time_lte,omitempty"`
	ExpireTimeGt                 *string                    `json:"expire_time_gt,omitempty"`
	ExpireTimeGte                *string                    `json:"expire_time_gte,omitempty"`
	ExpireTimeContains           *string                    `json:"expire_time_contains,omitempty"`
	ExpireTimeNotContains        *string                    `json:"expire_time_not_contains,omitempty"`
	ExpireTimeStartsWith         *string                    `json:"expire_time_starts_with,omitempty"`
	ExpireTimeNotStartsWith      *string                    `json:"expire_time_not_starts_with,omitempty"`
	ExpireTimeEndsWith           *string                    `json:"expire_time_ends_with,omitempty"`
	ExpireTimeNotEndsWith        *string                    `json:"expire_time_not_ends_with,omitempty"`
	IssueTid                     *string                    `json:"issue_tid,omitempty"`
	IssueTidNot                  *string                    `json:"issue_tid_not,omitempty"`
	IssueTidIn                   []string                   `json:"issue_tid_in,omitempty"`
	IssueTidNotIn                []string                   `json:"issue_tid_not_in,omitempty"`
	IssueTidLt                   *string                    `json:"issue_tid_lt,omitempty"`
	IssueTidLte                  *string                    `json:"issue_tid_lte,omitempty"`
	IssueTidGt                   *string                    `json:"issue_tid_gt,omitempty"`
	IssueTidGte                  *string                    `json:"issue_tid_gte,omitempty"`
	IssueTidContains             *string                    `json:"issue_tid_contains,omitempty"`
	IssueTidNotContains          *string                    `json:"issue_tid_not_contains,omitempty"`
	IssueTidStartsWith           *string                    `json:"issue_tid_starts_with,omitempty"`
	IssueTidNotStartsWith        *string                    `json:"issue_tid_not_starts_with,omitempty"`
	IssueTidEndsWith             *string                    `json:"issue_tid_ends_with,omitempty"`
	IssueTidNotEndsWith          *string                    `json:"issue_tid_not_ends_with,omitempty"`
	CreatedAt                    *string                    `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                    `json:"createdAt_gte,omitempty"`
	And                          []PaymentHistoryWhereInput `json:"AND,omitempty"`
	Or                           []PaymentHistoryWhereInput `json:"OR,omitempty"`
	Not                          []PaymentHistoryWhereInput `json:"NOT,omitempty"`
}

type PhoneVerificationWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
	Ci *string `json:"CI,omitempty"`
}

type PostWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type PostRewardHistoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type QuestExpenditureHistoryWhereUniqueInput struct {
	ID       *string `json:"id,omitempty"`
	OrderNum *int32  `json:"orderNum,omitempty"`
}

type QuestMemberWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ReportWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type RequestPageItemWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ReviewContentWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ReviewContentCategoryWhereUniqueInput struct {
	ID   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

type ReviewContentPageWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ReviewContentPageFeedBackWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ReviewContentPageViewerWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ReviewContentReviewerWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ReviewContentViewerWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type RewardDropAttendingUserWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type RewardDropEventWhereUniqueInput struct {
	ID      *string `json:"id,omitempty"`
	EventId *string `json:"eventID,omitempty"`
}

type TwitchWhereUniqueInput struct {
	ID     *string `json:"id,omitempty"`
	UserNo *string `json:"userNo,omitempty"`
}

type TwitchDailyStatisticsWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UpdatePostHistoryWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserWhereUniqueInput struct {
	ID             *string `json:"id,omitempty"`
	FirebaseUid    *string `json:"firebaseUID,omitempty"`
	NickName       *string `json:"nickName,omitempty"`
	Email          *string `json:"email,omitempty"`
	RevokeTokenKey *string `json:"revokeTokenKey,omitempty"`
	NumId          *int32  `json:"numId,omitempty"`
}

type VerificationWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type WalletWhereUniqueInput struct {
	ID            *string `json:"id,omitempty"`
	NumIdCoinName *string `json:"numIdCoinName,omitempty"`
}

type YoutubeWhereUniqueInput struct {
	ID        *string `json:"id,omitempty"`
	ChannelId *string `json:"channelId,omitempty"`
}

type YoutubeDailyStatisticsWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type AdminUserCreateInput struct {
	Role               Role                                         `json:"role"`
	Email              string                                       `json:"email"`
	Password           *string                                      `json:"password,omitempty"`
	NickName           string                                       `json:"nickName"`
	OtpKey             *string                                      `json:"otpKey,omitempty"`
	Level              *string                                      `json:"level,omitempty"`
	Members            *UserCreateManyWithoutAdminUserInput         `json:"members,omitempty"`
	CreateNotification *NotificationCreateOneWithoutCreateUserInput `json:"createNotification,omitempty"`
	UpdateNotification *NotificationCreateOneWithoutUpdateUserInput `json:"updateNotification,omitempty"`
}

type UserCreateManyWithoutAdminUserInput struct {
	Create  []UserCreateWithoutAdminUserInput `json:"create,omitempty"`
	Connect []UserWhereUniqueInput            `json:"connect,omitempty"`
}

type UserCreateWithoutAdminUserInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type CategoryCreateManyWithoutFeedUsersInput struct {
	Create  []CategoryCreateWithoutFeedUsersInput `json:"create,omitempty"`
	Connect []CategoryWhereUniqueInput            `json:"connect,omitempty"`
}

type CategoryCreateWithoutFeedUsersInput struct {
	Name       string                                `json:"name"`
	Posts      *PostCreateManyWithoutCategoriesInput `json:"posts,omitempty"`
	Coins      *CoinCreateManyWithoutCategoriesInput `json:"coins,omitempty"`
	OrderIndex *float64                              `json:"order_index,omitempty"`
}

type PostCreateManyWithoutCategoriesInput struct {
	Create  []PostCreateWithoutCategoriesInput `json:"create,omitempty"`
	Connect []PostWhereUniqueInput             `json:"connect,omitempty"`
}

type PostCreateWithoutCategoriesInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type UserCreateOneWithoutRequestPostsInput struct {
	Create  *UserCreateWithoutRequestPostsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput               `json:"connect,omitempty"`
}

type UserCreateWithoutRequestPostsInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type CoinCreateOneWithoutOwnerInput struct {
	Create  *CoinCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput        `json:"connect,omitempty"`
}

type CoinCreateWithoutOwnerInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type CategoryCreateManyWithoutCoinsInput struct {
	Create  []CategoryCreateWithoutCoinsInput `json:"create,omitempty"`
	Connect []CategoryWhereUniqueInput        `json:"connect,omitempty"`
}

type CategoryCreateWithoutCoinsInput struct {
	Name       string                                    `json:"name"`
	Posts      *PostCreateManyWithoutCategoriesInput     `json:"posts,omitempty"`
	FeedUsers  *UserCreateManyWithoutFeedCategoriesInput `json:"feedUsers,omitempty"`
	OrderIndex *float64                                  `json:"order_index,omitempty"`
}

type UserCreateManyWithoutFeedCategoriesInput struct {
	Create  []UserCreateWithoutFeedCategoriesInput `json:"create,omitempty"`
	Connect []UserWhereUniqueInput                 `json:"connect,omitempty"`
}

type UserCreateWithoutFeedCategoriesInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type VerificationCreateOneWithoutUserInput struct {
	Create  *VerificationCreateWithoutUserInput `json:"create,omitempty"`
	Connect *VerificationWhereUniqueInput       `json:"connect,omitempty"`
}

type VerificationCreateWithoutUserInput struct {
	Level          *int32                                                    `json:"level,omitempty"`
	HasEmail       *bool                                                     `json:"hasEmail,omitempty"`
	HasPin         *bool                                                     `json:"hasPin,omitempty"`
	HasPhone       *bool                                                     `json:"hasPhone,omitempty"`
	HasBankAccount *bool                                                     `json:"hasBankAccount,omitempty"`
	HasInter       *bool                                                     `json:"hasInter,omitempty"`
	PinNumber      *string                                                   `json:"pinNumber,omitempty"`
	Phone          *PhoneVerificationCreateOneWithoutVerificationInput       `json:"phone,omitempty"`
	BankAccount    *BankAccountVerificationCreateOneWithoutVerificationInput `json:"bankAccount,omitempty"`
}

type PhoneVerificationCreateOneWithoutVerificationInput struct {
	Create  *PhoneVerificationCreateWithoutVerificationInput `json:"create,omitempty"`
	Connect *PhoneVerificationWhereUniqueInput               `json:"connect,omitempty"`
}

type PhoneVerificationCreateWithoutVerificationInput struct {
	Name        string  `json:"name"`
	Birth       string  `json:"birth"`
	Foreigner   *bool   `json:"foreigner,omitempty"`
	Gender      string  `json:"gender"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	Ci          string  `json:"CI"`
	Di          string  `json:"DI"`
	ImpUid      *string `json:"imp_uid,omitempty"`
	MerchantUid *string `json:"merchant_uid,omitempty"`
}

type BankAccountVerificationCreateOneWithoutVerificationInput struct {
	Create  *BankAccountVerificationCreateWithoutVerificationInput `json:"create,omitempty"`
	Connect *BankAccountVerificationWhereUniqueInput               `json:"connect,omitempty"`
}

type BankAccountVerificationCreateWithoutVerificationInput struct {
	Bank            BankCreateOneInput                                   `json:"bank"`
	HolderName      string                                               `json:"holderName"`
	AccountNumber   string                                               `json:"accountNumber"`
	TransactionInfo BankAccountVerificationTransactionInfoCreateOneInput `json:"transactionInfo"`
	VerifyAt        *string                                              `json:"verifyAt,omitempty"`
}

type BankCreateOneInput struct {
	Create  *BankCreateInput      `json:"create,omitempty"`
	Connect *BankWhereUniqueInput `json:"connect,omitempty"`
}

type BankCreateInput struct {
	Code string `json:"code"`
	Name string `json:"name"`
}

type BankAccountVerificationTransactionInfoCreateOneInput struct {
	Create  *BankAccountVerificationTransactionInfoCreateInput      `json:"create,omitempty"`
	Connect *BankAccountVerificationTransactionInfoWhereUniqueInput `json:"connect,omitempty"`
}

type BankAccountVerificationTransactionInfoCreateInput struct {
	TransactionDt string `json:"transactionDt"`
	TransactionNo string `json:"transactionNo"`
	ExpireAt      string `json:"expireAt"`
}

type WalletCreateManyWithoutOwnerInput struct {
	Create  []WalletCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []WalletWhereUniqueInput        `json:"connect,omitempty"`
}

type WalletCreateWithoutOwnerInput struct {
	Coin                       CoinCreateOneWithoutWalletsInput `json:"coin"`
	NumIdCoinName              *string                          `json:"numIdCoinName,omitempty"`
	CumulativePurchaseQuantity *float64                         `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseValue    *float64                         `json:"cumulativePurchaseValue,omitempty"`
}

type CoinCreateOneWithoutWalletsInput struct {
	Create  *CoinCreateWithoutWalletsInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput          `json:"connect,omitempty"`
}

type CoinCreateWithoutWalletsInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type FileCreateOneWithoutCoinInput struct {
	Create  *FileCreateWithoutCoinInput `json:"create,omitempty"`
	Connect *FileWhereUniqueInput       `json:"connect,omitempty"`
}

type FileCreateWithoutCoinInput struct {
	Post         *PostCreateOneWithoutImageInput `json:"post,omitempty"`
	LocationPath *string                         `json:"locationPath,omitempty"`
	Name         *string                         `json:"name,omitempty"`
	ContentType  *string                         `json:"contentType,omitempty"`
	Url          string                          `json:"url"`
	Owner        *UserCreateOneWithoutFilesInput `json:"owner,omitempty"`
	IsDel        *bool                           `json:"isDel,omitempty"`
}

type PostCreateOneWithoutImageInput struct {
	Create  *PostCreateWithoutImageInput `json:"create,omitempty"`
	Connect *PostWhereUniqueInput        `json:"connect,omitempty"`
}

type PostCreateWithoutImageInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type CategoryCreateManyWithoutPostsInput struct {
	Create  []CategoryCreateWithoutPostsInput `json:"create,omitempty"`
	Connect []CategoryWhereUniqueInput        `json:"connect,omitempty"`
}

type CategoryCreateWithoutPostsInput struct {
	Name       string                                    `json:"name"`
	FeedUsers  *UserCreateManyWithoutFeedCategoriesInput `json:"feedUsers,omitempty"`
	Coins      *CoinCreateManyWithoutCategoriesInput     `json:"coins,omitempty"`
	OrderIndex *float64                                  `json:"order_index,omitempty"`
}

type CoinCreateManyWithoutCategoriesInput struct {
	Create  []CoinCreateWithoutCategoriesInput `json:"create,omitempty"`
	Connect []CoinWhereUniqueInput             `json:"connect,omitempty"`
}

type CoinCreateWithoutCategoriesInput struct {
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type FileInfoCreateOneWithoutCoinInput struct {
	Create  *FileInfoCreateWithoutCoinInput `json:"create,omitempty"`
	Connect *FileInfoWhereUniqueInput       `json:"connect,omitempty"`
}

type FileInfoCreateWithoutCoinInput struct {
	Post         *PostCreateOneWithoutFileListInput `json:"post,omitempty"`
	TempFileId   *string                            `json:"tempFileId,omitempty"`
	LocationPath *string                            `json:"locationPath,omitempty"`
	Name         *string                            `json:"name,omitempty"`
	ContentType  *string                            `json:"contentType,omitempty"`
	Url          string                             `json:"url"`
	Owner        *UserCreateOneWithoutFileListInput `json:"owner,omitempty"`
	IsVideo      *bool                              `json:"isVideo,omitempty"`
	IsDel        *bool                              `json:"isDel,omitempty"`
}

type PostCreateOneWithoutFileListInput struct {
	Create  *PostCreateWithoutFileListInput `json:"create,omitempty"`
	Connect *PostWhereUniqueInput           `json:"connect,omitempty"`
}

type PostCreateWithoutFileListInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type UserCreateOneWithoutPostsInput struct {
	Create  *UserCreateWithoutPostsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput        `json:"connect,omitempty"`
}

type UserCreateWithoutPostsInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PostCreateManyWithoutToUserInput struct {
	Create  []PostCreateWithoutToUserInput `json:"create,omitempty"`
	Connect []PostWhereUniqueInput         `json:"connect,omitempty"`
}

type PostCreateWithoutToUserInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type CoinCreateOneWithoutPostsInput struct {
	Create  *CoinCreateWithoutPostsInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput        `json:"connect,omitempty"`
}

type CoinCreateWithoutPostsInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type WalletCreateManyWithoutCoinInput struct {
	Create  []WalletCreateWithoutCoinInput `json:"create,omitempty"`
	Connect []WalletWhereUniqueInput       `json:"connect,omitempty"`
}

type WalletCreateWithoutCoinInput struct {
	Owner                      UserCreateOneWithoutWalletsInput `json:"owner"`
	NumIdCoinName              *string                          `json:"numIdCoinName,omitempty"`
	CumulativePurchaseQuantity *float64                         `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseValue    *float64                         `json:"cumulativePurchaseValue,omitempty"`
}

type UserCreateOneWithoutWalletsInput struct {
	Create  *UserCreateWithoutWalletsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput          `json:"connect,omitempty"`
}

type UserCreateWithoutWalletsInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PostCreateManyWithoutOwnerInput struct {
	Create  []PostCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []PostWhereUniqueInput        `json:"connect,omitempty"`
}

type PostCreateWithoutOwnerInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type AirDropCreateOneWithoutPostInput struct {
	Create  *AirDropCreateWithoutPostInput `json:"create,omitempty"`
	Connect *AirDropWhereUniqueInput       `json:"connect,omitempty"`
}

type AirDropCreateWithoutPostInput struct {
	Status            *int32                                       `json:"status,omitempty"`
	DeployTxhash      *string                                      `json:"deployTxhash,omitempty"`
	ContractAddress   *string                                      `json:"contractAddress,omitempty"`
	RandomArrayString *string                                      `json:"randomArrayString,omitempty"`
	Amount            float64                                      `json:"amount"`
	Left              float64                                      `json:"left"`
	Members           *AirDropMemberCreateManyWithoutAirDropInput  `json:"members,omitempty"`
	ToDate            *string                                      `json:"toDate,omitempty"`
	AirDropHistories  *AirDropHistoryCreateManyWithoutAirDropInput `json:"airDropHistories,omitempty"`
	IsDel             *bool                                        `json:"isDel,omitempty"`
}

type AirDropMemberCreateManyWithoutAirDropInput struct {
	Create  []AirDropMemberCreateWithoutAirDropInput `json:"create,omitempty"`
	Connect []AirDropMemberWhereUniqueInput          `json:"connect,omitempty"`
}

type AirDropMemberCreateWithoutAirDropInput struct {
	User           UserCreateOneWithoutAirDropMembersInput           `json:"user"`
	DropNum        int32                                             `json:"dropNum"`
	Qty            float64                                           `json:"qty"`
	AirDropHistory *AirDropHistoryCreateOneWithoutAirDropMemberInput `json:"airDropHistory,omitempty"`
	IsDel          *bool                                             `json:"isDel,omitempty"`
}

type UserCreateOneWithoutAirDropMembersInput struct {
	Create  *UserCreateWithoutAirDropMembersInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                 `json:"connect,omitempty"`
}

type UserCreateWithoutAirDropMembersInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type CommentCreateManyWithoutOwnerInput struct {
	Create  []CommentCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []CommentWhereUniqueInput        `json:"connect,omitempty"`
}

type CommentCreateWithoutOwnerInput struct {
	Type              *int32                                         `json:"type,omitempty"`
	Post              PostCreateOneWithoutCommentsInput              `json:"post"`
	Content           string                                         `json:"content"`
	Image             *FileInfoCreateOneInput                        `json:"image,omitempty"`
	Url               *string                                        `json:"url,omitempty"`
	Reply             *CommentReplyCreateManyWithoutCommentInput     `json:"reply,omitempty"`
	PostRewardHistory *PostRewardHistoryCreateOneWithoutCommentInput `json:"postRewardHistory,omitempty"`
	IsDel             *bool                                          `json:"isDel,omitempty"`
}

type PostCreateOneWithoutCommentsInput struct {
	Create  *PostCreateWithoutCommentsInput `json:"create,omitempty"`
	Connect *PostWhereUniqueInput           `json:"connect,omitempty"`
}

type PostCreateWithoutCommentsInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type FileCreateOneWithoutPostInput struct {
	Create  *FileCreateWithoutPostInput `json:"create,omitempty"`
	Connect *FileWhereUniqueInput       `json:"connect,omitempty"`
}

type FileCreateWithoutPostInput struct {
	Coin         *CoinCreateOneWithoutImageInput `json:"coin,omitempty"`
	LocationPath *string                         `json:"locationPath,omitempty"`
	Name         *string                         `json:"name,omitempty"`
	ContentType  *string                         `json:"contentType,omitempty"`
	Url          string                          `json:"url"`
	Owner        *UserCreateOneWithoutFilesInput `json:"owner,omitempty"`
	IsDel        *bool                           `json:"isDel,omitempty"`
}

type CoinCreateOneWithoutImageInput struct {
	Create  *CoinCreateWithoutImageInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput        `json:"connect,omitempty"`
}

type CoinCreateWithoutImageInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type UserCreateOneWithoutCoinInput struct {
	Create  *UserCreateWithoutCoinInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput       `json:"connect,omitempty"`
}

type UserCreateWithoutCoinInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type FileCreateManyWithoutOwnerInput struct {
	Create  []FileCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []FileWhereUniqueInput        `json:"connect,omitempty"`
}

type FileCreateWithoutOwnerInput struct {
	Coin         *CoinCreateOneWithoutImageInput `json:"coin,omitempty"`
	Post         *PostCreateOneWithoutImageInput `json:"post,omitempty"`
	LocationPath *string                         `json:"locationPath,omitempty"`
	Name         *string                         `json:"name,omitempty"`
	ContentType  *string                         `json:"contentType,omitempty"`
	Url          string                          `json:"url"`
	IsDel        *bool                           `json:"isDel,omitempty"`
}

type FileInfoCreateManyWithoutOwnerInput struct {
	Create  []FileInfoCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect []FileInfoWhereUniqueInput        `json:"connect,omitempty"`
}

type FileInfoCreateWithoutOwnerInput struct {
	Coin         *CoinCreateOneWithoutPictureInput  `json:"coin,omitempty"`
	Post         *PostCreateOneWithoutFileListInput `json:"post,omitempty"`
	TempFileId   *string                            `json:"tempFileId,omitempty"`
	LocationPath *string                            `json:"locationPath,omitempty"`
	Name         *string                            `json:"name,omitempty"`
	ContentType  *string                            `json:"contentType,omitempty"`
	Url          string                             `json:"url"`
	IsVideo      *bool                              `json:"isVideo,omitempty"`
	IsDel        *bool                              `json:"isDel,omitempty"`
}

type CoinCreateOneWithoutPictureInput struct {
	Create  *CoinCreateWithoutPictureInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput          `json:"connect,omitempty"`
}

type CoinCreateWithoutPictureInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type PostCreateManyWithoutCoinInput struct {
	Create  []PostCreateWithoutCoinInput `json:"create,omitempty"`
	Connect []PostWhereUniqueInput       `json:"connect,omitempty"`
}

type PostCreateWithoutCoinInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type FileInfoCreateManyWithoutPostInput struct {
	Create  []FileInfoCreateWithoutPostInput `json:"create,omitempty"`
	Connect []FileInfoWhereUniqueInput       `json:"connect,omitempty"`
}

type FileInfoCreateWithoutPostInput struct {
	Coin         *CoinCreateOneWithoutPictureInput  `json:"coin,omitempty"`
	TempFileId   *string                            `json:"tempFileId,omitempty"`
	LocationPath *string                            `json:"locationPath,omitempty"`
	Name         *string                            `json:"name,omitempty"`
	ContentType  *string                            `json:"contentType,omitempty"`
	Url          string                             `json:"url"`
	Owner        *UserCreateOneWithoutFileListInput `json:"owner,omitempty"`
	IsVideo      *bool                              `json:"isVideo,omitempty"`
	IsDel        *bool                              `json:"isDel,omitempty"`
}

type UserCreateOneWithoutFileListInput struct {
	Create  *UserCreateWithoutFileListInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput           `json:"connect,omitempty"`
}

type UserCreateWithoutFileListInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PostCreateManyWithoutLikesInput struct {
	Create  []PostCreateWithoutLikesInput `json:"create,omitempty"`
	Connect []PostWhereUniqueInput        `json:"connect,omitempty"`
}

type PostCreateWithoutLikesInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type QuestMemberCreateManyWithoutPostInput struct {
	Create  []QuestMemberCreateWithoutPostInput `json:"create,omitempty"`
	Connect []QuestMemberWhereUniqueInput       `json:"connect,omitempty"`
}

type QuestMemberCreateWithoutPostInput struct {
	User  UserCreateOneWithoutJoinedQuestsInput `json:"user"`
	Note  *string                               `json:"note,omitempty"`
	IsDel *bool                                 `json:"isDel,omitempty"`
}

type UserCreateOneWithoutJoinedQuestsInput struct {
	Create  *UserCreateWithoutJoinedQuestsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput               `json:"connect,omitempty"`
}

type UserCreateWithoutJoinedQuestsInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PostCreateManyWithoutViewsInput struct {
	Create  []PostCreateWithoutViewsInput `json:"create,omitempty"`
	Connect []PostWhereUniqueInput        `json:"connect,omitempty"`
}

type PostCreateWithoutViewsInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type MotherHistoryCreateManyWithoutPostInput struct {
	Create  []MotherHistoryCreateWithoutPostInput `json:"create,omitempty"`
	Connect []MotherHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type MotherHistoryCreateWithoutPostInput struct {
	Type                    int32                                                      `json:"type"`
	RoleTime                string                                                     `json:"roleTime"`
	Coin                    *CoinCreateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserCreateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryCreateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryCreateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryCreateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryCreateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryCreateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type CoinCreateOneWithoutMotherHistoriesInput struct {
	Create  *CoinCreateWithoutMotherHistoriesInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput                  `json:"connect,omitempty"`
}

type CoinCreateWithoutMotherHistoriesInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type OfferCreateOneWithoutCoinInput struct {
	Create  *OfferCreateWithoutCoinInput `json:"create,omitempty"`
	Connect *OfferWhereUniqueInput       `json:"connect,omitempty"`
}

type OfferCreateWithoutCoinInput struct {
	Qty      int32                               `json:"qty"`
	Offeror  *OfferorCreateManyWithoutOfferInput `json:"offeror,omitempty"`
	FromDate string                              `json:"fromDate"`
	ToDate   string                              `json:"toDate"`
}

type OfferorCreateManyWithoutOfferInput struct {
	Create  []OfferorCreateWithoutOfferInput `json:"create,omitempty"`
	Connect []OfferorWhereUniqueInput        `json:"connect,omitempty"`
}

type OfferorCreateWithoutOfferInput struct {
	Price int32                              `json:"price"`
	User  UserCreateOneWithoutJoinOfferInput `json:"user"`
}

type UserCreateOneWithoutJoinOfferInput struct {
	Create  *UserCreateWithoutJoinOfferInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput            `json:"connect,omitempty"`
}

type UserCreateWithoutJoinOfferInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type ReportCreateManyWithoutReportUserInput struct {
	Create  []ReportCreateWithoutReportUserInput `json:"create,omitempty"`
	Connect []ReportWhereUniqueInput             `json:"connect,omitempty"`
}

type ReportCreateWithoutReportUserInput struct {
	Type       int32                                  `json:"type"`
	ReportType int32                                  `json:"reportType"`
	TargetPost *PostCreateOneInput                    `json:"targetPost,omitempty"`
	TargetUser *UserCreateOneWithoutTargetReportInput `json:"targetUser,omitempty"`
}

type PostCreateOneInput struct {
	Create  *PostCreateInput      `json:"create,omitempty"`
	Connect *PostWhereUniqueInput `json:"connect,omitempty"`
}

type PostCreateInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type QuestExpenditureHistoryCreateManyWithoutPostInput struct {
	Create  []QuestExpenditureHistoryCreateWithoutPostInput `json:"create,omitempty"`
	Connect []QuestExpenditureHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type QuestExpenditureHistoryCreateWithoutPostInput struct {
	Type          int32                                                      `json:"type"`
	PayType       *int32                                                     `json:"payType,omitempty"`
	OrderNum      *int32                                                     `json:"orderNum,omitempty"`
	Description   *string                                                    `json:"description,omitempty"`
	User          *UserCreateOneWithoutQuestExpenditureHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutQuestExpenditureHistoryInput `json:"motherHistory,omitempty"`
	CashHistory   *CashHistoryCreateOneWithoutQehInput                       `json:"cashHistory,omitempty"`
	Price         *int32                                                     `json:"price,omitempty"`
	Qty           *float64                                                   `json:"qty,omitempty"`
	OPrice        *int32                                                     `json:"oPrice,omitempty"`
	CurrentPrice  *float64                                                   `json:"currentPrice,omitempty"`
	Memo          *string                                                    `json:"memo,omitempty"`
}

type UserCreateOneWithoutQuestExpenditureHistoriesInput struct {
	Create  *UserCreateWithoutQuestExpenditureHistoriesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                            `json:"connect,omitempty"`
}

type UserCreateWithoutQuestExpenditureHistoriesInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type OfferorCreateManyWithoutUserInput struct {
	Create  []OfferorCreateWithoutUserInput `json:"create,omitempty"`
	Connect []OfferorWhereUniqueInput       `json:"connect,omitempty"`
}

type OfferorCreateWithoutUserInput struct {
	Price int32                             `json:"price"`
	Offer OfferCreateOneWithoutOfferorInput `json:"offer"`
}

type OfferCreateOneWithoutOfferorInput struct {
	Create  *OfferCreateWithoutOfferorInput `json:"create,omitempty"`
	Connect *OfferWhereUniqueInput          `json:"connect,omitempty"`
}

type OfferCreateWithoutOfferorInput struct {
	Coin     CoinCreateOneWithoutOfferInput `json:"coin"`
	Qty      int32                          `json:"qty"`
	FromDate string                         `json:"fromDate"`
	ToDate   string                         `json:"toDate"`
}

type CoinCreateOneWithoutOfferInput struct {
	Create  *CoinCreateWithoutOfferInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput        `json:"connect,omitempty"`
}

type CoinCreateWithoutOfferInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type OrderHistoryCreateManyWithoutCoinInput struct {
	Create  []OrderHistoryCreateWithoutCoinInput `json:"create,omitempty"`
	Connect []OrderHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type OrderHistoryCreateWithoutCoinInput struct {
	Type                    int32                                                    `json:"type"`
	OrderNum                int32                                                    `json:"orderNum"`
	User                    *UserCreateOneWithoutOrderHistoriesInput                 `json:"user,omitempty"`
	MotherHistory           *MotherHistoryCreateOneWithoutOrderHistoryInput          `json:"motherHistory,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutOrderHistoryInput `json:"orderUserDealsHistories,omitempty"`
	OrderPrice              float64                                                  `json:"orderPrice"`
	DealPrice               *float64                                                 `json:"dealPrice,omitempty"`
	OrderQty                float64                                                  `json:"orderQty"`
	DealQty                 *float64                                                 `json:"dealQty,omitempty"`
	LeftQty                 float64                                                  `json:"leftQty"`
	DealFee                 *float64                                                 `json:"dealFee,omitempty"`
	TakerFee                *float64                                                 `json:"takerFee,omitempty"`
	MakerFee                *float64                                                 `json:"makerFee,omitempty"`
	Memo                    *string                                                  `json:"memo,omitempty"`
	Description             *string                                                  `json:"description,omitempty"`
	Offset                  *int32                                                   `json:"offset,omitempty"`
	IsCancel                *bool                                                    `json:"isCancel,omitempty"`
}

type UserCreateOneWithoutOrderHistoriesInput struct {
	Create  *UserCreateWithoutOrderHistoriesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                 `json:"connect,omitempty"`
}

type UserCreateWithoutOrderHistoriesInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type ReportCreateManyWithoutTargetUserInput struct {
	Create  []ReportCreateWithoutTargetUserInput `json:"create,omitempty"`
	Connect []ReportWhereUniqueInput             `json:"connect,omitempty"`
}

type ReportCreateWithoutTargetUserInput struct {
	Type       int32                             `json:"type"`
	ReportUser UserCreateOneWithoutMyReportInput `json:"reportUser"`
	ReportType int32                             `json:"reportType"`
	TargetPost *PostCreateOneInput               `json:"targetPost,omitempty"`
}

type UserCreateOneWithoutMyReportInput struct {
	Create  *UserCreateWithoutMyReportInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput           `json:"connect,omitempty"`
}

type UserCreateWithoutMyReportInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type QuestMemberCreateManyWithoutUserInput struct {
	Create  []QuestMemberCreateWithoutUserInput `json:"create,omitempty"`
	Connect []QuestMemberWhereUniqueInput       `json:"connect,omitempty"`
}

type QuestMemberCreateWithoutUserInput struct {
	Post  PostCreateOneWithoutQuestMembersInput `json:"post"`
	Note  *string                               `json:"note,omitempty"`
	IsDel *bool                                 `json:"isDel,omitempty"`
}

type PostCreateOneWithoutQuestMembersInput struct {
	Create  *PostCreateWithoutQuestMembersInput `json:"create,omitempty"`
	Connect *PostWhereUniqueInput               `json:"connect,omitempty"`
}

type PostCreateWithoutQuestMembersInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type PostRewardHistoryCreateManyWithoutPostInput struct {
	Create  []PostRewardHistoryCreateWithoutPostInput `json:"create,omitempty"`
	Connect []PostRewardHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type PostRewardHistoryCreateWithoutPostInput struct {
	Type          int32                                                `json:"type"`
	Description   *string                                              `json:"description,omitempty"`
	User          *UserCreateOneWithoutPostRewardHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutPostRewardHistoryInput `json:"motherHistory,omitempty"`
	Comment       *CommentCreateOneWithoutPostRewardHistoryInput       `json:"comment,omitempty"`
	Qty           *float64                                             `json:"qty,omitempty"`
	CurrentPrice  *float64                                             `json:"currentPrice,omitempty"`
	Memo          *string                                              `json:"memo,omitempty"`
}

type UserCreateOneWithoutPostRewardHistoriesInput struct {
	Create  *UserCreateWithoutPostRewardHistoriesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                      `json:"connect,omitempty"`
}

type UserCreateWithoutPostRewardHistoriesInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type AdminUserCreateOneWithoutMembersInput struct {
	Create  *AdminUserCreateWithoutMembersInput `json:"create,omitempty"`
	Connect *AdminUserWhereUniqueInput          `json:"connect,omitempty"`
}

type AdminUserCreateWithoutMembersInput struct {
	Role               Role                                         `json:"role"`
	Email              string                                       `json:"email"`
	Password           *string                                      `json:"password,omitempty"`
	NickName           string                                       `json:"nickName"`
	OtpKey             *string                                      `json:"otpKey,omitempty"`
	Level              *string                                      `json:"level,omitempty"`
	CreateNotification *NotificationCreateOneWithoutCreateUserInput `json:"createNotification,omitempty"`
	UpdateNotification *NotificationCreateOneWithoutUpdateUserInput `json:"updateNotification,omitempty"`
}

type NotificationCreateOneWithoutCreateUserInput struct {
	Create  *NotificationCreateWithoutCreateUserInput `json:"create,omitempty"`
	Connect *NotificationWhereUniqueInput             `json:"connect,omitempty"`
}

type NotificationCreateWithoutCreateUserInput struct {
	NotiType     *int32                                            `json:"notiType,omitempty"`
	PushType     int32                                             `json:"pushType"`
	PushState    int32                                             `json:"pushState"`
	User         *UserCreateManyInput                              `json:"user,omitempty"`
	SendFailUser *UserCreateManyInput                              `json:"sendFailUser,omitempty"`
	ByUser       *UserCreateOneInput                               `json:"byUser,omitempty"`
	Post         *PostCreateOneInput                               `json:"post,omitempty"`
	Coin         *CoinCreateOneInput                               `json:"coin,omitempty"`
	Topic        *string                                           `json:"topic,omitempty"`
	LinkType     string                                            `json:"linkType"`
	LinkValue    string                                            `json:"linkValue"`
	Message      string                                            `json:"message"`
	Image        *string                                           `json:"image,omitempty"`
	PublishType  int32                                             `json:"publishType"`
	PublishDate  string                                            `json:"publishDate"`
	UpdateUser   *AdminUserCreateOneWithoutUpdateNotificationInput `json:"updateUser,omitempty"`
	IsDel        *bool                                             `json:"isDel,omitempty"`
}

type UserCreateManyInput struct {
	Create  []UserCreateInput      `json:"create,omitempty"`
	Connect []UserWhereUniqueInput `json:"connect,omitempty"`
}

type UserCreateInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type RewardDropAttendingUserCreateManyWithoutUserInput struct {
	Create  []RewardDropAttendingUserCreateWithoutUserInput `json:"create,omitempty"`
	Connect []RewardDropAttendingUserWhereUniqueInput       `json:"connect,omitempty"`
}

type RewardDropAttendingUserCreateWithoutUserInput struct {
	RewardDropEvent RewardDropEventCreateOneWithoutAttendingUsersInput `json:"rewardDropEvent"`
	Memo            string                                             `json:"memo"`
	IsDel           *bool                                              `json:"isDel,omitempty"`
}

type RewardDropEventCreateOneWithoutAttendingUsersInput struct {
	Create  *RewardDropEventCreateWithoutAttendingUsersInput `json:"create,omitempty"`
	Connect *RewardDropEventWhereUniqueInput                 `json:"connect,omitempty"`
}

type RewardDropEventCreateWithoutAttendingUsersInput struct {
	EventId        string              `json:"eventID"`
	Type           int32               `json:"type"`
	Title          string              `json:"title"`
	Cash           *int32              `json:"cash,omitempty"`
	Coin           *CoinCreateOneInput `json:"coin,omitempty"`
	Qty            *int32              `json:"qty,omitempty"`
	LimitUserCount int32               `json:"limitUserCount"`
	FromDate       string              `json:"fromDate"`
	ToDate         string              `json:"toDate"`
	IsDel          *bool               `json:"isDel,omitempty"`
}

type CoinCreateOneInput struct {
	Create  *CoinCreateInput      `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput `json:"connect,omitempty"`
}

type CoinCreateInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type OrderDealsHistoryCreateManyWithoutCoinInput struct {
	Create  []OrderDealsHistoryCreateWithoutCoinInput `json:"create,omitempty"`
	Connect []OrderDealsHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type OrderDealsHistoryCreateWithoutCoinInput struct {
	Type      int32    `json:"type"`
	DealId    int32    `json:"dealId"`
	DealPrice float64  `json:"dealPrice"`
	DealQty   float64  `json:"dealQty"`
	Time      *float64 `json:"time,omitempty"`
}

type OrderUserDealsHistoryCreateManyWithoutCoinInput struct {
	Create  []OrderUserDealsHistoryCreateWithoutCoinInput `json:"create,omitempty"`
	Connect []OrderUserDealsHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type OrderUserDealsHistoryCreateWithoutCoinInput struct {
	Type          int32                                                     `json:"type"`
	Role          *int32                                                    `json:"role,omitempty"`
	DealId        int32                                                     `json:"dealId"`
	UniqueKey     string                                                    `json:"uniqueKey"`
	UniqueId      int32                                                     `json:"uniqueId"`
	User          *UserCreateOneWithoutOrderUserDealsHistoriesInput         `json:"user,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutOrderUserDealsHistoryInput  `json:"motherHistory,omitempty"`
	OrderHistory  *OrderHistoryCreateOneWithoutOrderUserDealsHistoriesInput `json:"orderHistory,omitempty"`
	DealPrice     float64                                                   `json:"dealPrice"`
	DealQty       float64                                                   `json:"dealQty"`
	Fee           float64                                                   `json:"fee"`
	DealOrderId   *int32                                                    `json:"dealOrderId,omitempty"`
	Time          *float64                                                  `json:"time,omitempty"`
}

type UserCreateOneWithoutOrderUserDealsHistoriesInput struct {
	Create  *UserCreateWithoutOrderUserDealsHistoriesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                          `json:"connect,omitempty"`
}

type UserCreateWithoutOrderUserDealsHistoriesInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type MotherHistoryCreateManyWithoutUserInput struct {
	Create  []MotherHistoryCreateWithoutUserInput `json:"create,omitempty"`
	Connect []MotherHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type MotherHistoryCreateWithoutUserInput struct {
	Type                    int32                                                      `json:"type"`
	RoleTime                string                                                     `json:"roleTime"`
	Coin                    *CoinCreateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	Post                    *PostCreateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryCreateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryCreateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryCreateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryCreateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryCreateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type PostCreateOneWithoutMotherHistoriesInput struct {
	Create  *PostCreateWithoutMotherHistoriesInput `json:"create,omitempty"`
	Connect *PostWhereUniqueInput                  `json:"connect,omitempty"`
}

type PostCreateWithoutMotherHistoriesInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type CommentCreateManyWithoutPostInput struct {
	Create  []CommentCreateWithoutPostInput `json:"create,omitempty"`
	Connect []CommentWhereUniqueInput       `json:"connect,omitempty"`
}

type CommentCreateWithoutPostInput struct {
	Type              *int32                                         `json:"type,omitempty"`
	Content           string                                         `json:"content"`
	Image             *FileInfoCreateOneInput                        `json:"image,omitempty"`
	Url               *string                                        `json:"url,omitempty"`
	Reply             *CommentReplyCreateManyWithoutCommentInput     `json:"reply,omitempty"`
	Owner             UserCreateOneWithoutCommentsInput              `json:"owner"`
	PostRewardHistory *PostRewardHistoryCreateOneWithoutCommentInput `json:"postRewardHistory,omitempty"`
	IsDel             *bool                                          `json:"isDel,omitempty"`
}

type FileInfoCreateOneInput struct {
	Create  *FileInfoCreateInput      `json:"create,omitempty"`
	Connect *FileInfoWhereUniqueInput `json:"connect,omitempty"`
}

type FileInfoCreateInput struct {
	Coin         *CoinCreateOneWithoutPictureInput  `json:"coin,omitempty"`
	Post         *PostCreateOneWithoutFileListInput `json:"post,omitempty"`
	TempFileId   *string                            `json:"tempFileId,omitempty"`
	LocationPath *string                            `json:"locationPath,omitempty"`
	Name         *string                            `json:"name,omitempty"`
	ContentType  *string                            `json:"contentType,omitempty"`
	Url          string                             `json:"url"`
	Owner        *UserCreateOneWithoutFileListInput `json:"owner,omitempty"`
	IsVideo      *bool                              `json:"isVideo,omitempty"`
	IsDel        *bool                              `json:"isDel,omitempty"`
}

type CommentReplyCreateManyWithoutCommentInput struct {
	Create  []CommentReplyCreateWithoutCommentInput `json:"create,omitempty"`
	Connect []CommentReplyWhereUniqueInput          `json:"connect,omitempty"`
}

type CommentReplyCreateWithoutCommentInput struct {
	Content string             `json:"content"`
	Owner   UserCreateOneInput `json:"owner"`
	IsDel   *bool              `json:"isDel,omitempty"`
}

type UserCreateOneInput struct {
	Create  *UserCreateInput      `json:"create,omitempty"`
	Connect *UserWhereUniqueInput `json:"connect,omitempty"`
}

type UserCreateOneWithoutCommentsInput struct {
	Create  *UserCreateWithoutCommentsInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput           `json:"connect,omitempty"`
}

type UserCreateWithoutCommentsInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type OrderHistoryCreateManyWithoutUserInput struct {
	Create  []OrderHistoryCreateWithoutUserInput `json:"create,omitempty"`
	Connect []OrderHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type OrderHistoryCreateWithoutUserInput struct {
	Type                    int32                                                    `json:"type"`
	OrderNum                int32                                                    `json:"orderNum"`
	Coin                    *CoinCreateOneWithoutOrderHistoriesInput                 `json:"coin,omitempty"`
	MotherHistory           *MotherHistoryCreateOneWithoutOrderHistoryInput          `json:"motherHistory,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutOrderHistoryInput `json:"orderUserDealsHistories,omitempty"`
	OrderPrice              float64                                                  `json:"orderPrice"`
	DealPrice               *float64                                                 `json:"dealPrice,omitempty"`
	OrderQty                float64                                                  `json:"orderQty"`
	DealQty                 *float64                                                 `json:"dealQty,omitempty"`
	LeftQty                 float64                                                  `json:"leftQty"`
	DealFee                 *float64                                                 `json:"dealFee,omitempty"`
	TakerFee                *float64                                                 `json:"takerFee,omitempty"`
	MakerFee                *float64                                                 `json:"makerFee,omitempty"`
	Memo                    *string                                                  `json:"memo,omitempty"`
	Description             *string                                                  `json:"description,omitempty"`
	Offset                  *int32                                                   `json:"offset,omitempty"`
	IsCancel                *bool                                                    `json:"isCancel,omitempty"`
}

type CoinCreateOneWithoutOrderHistoriesInput struct {
	Create  *CoinCreateWithoutOrderHistoriesInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput                 `json:"connect,omitempty"`
}

type CoinCreateWithoutOrderHistoriesInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type MotherHistoryCreateManyWithoutCoinInput struct {
	Create  []MotherHistoryCreateWithoutCoinInput `json:"create,omitempty"`
	Connect []MotherHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type MotherHistoryCreateWithoutCoinInput struct {
	Type                    int32                                                      `json:"type"`
	RoleTime                string                                                     `json:"roleTime"`
	User                    *UserCreateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostCreateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryCreateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryCreateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryCreateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryCreateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryCreateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type UserCreateOneWithoutMotherHistoriesInput struct {
	Create  *UserCreateWithoutMotherHistoriesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                  `json:"connect,omitempty"`
}

type UserCreateWithoutMotherHistoriesInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type OrderUserDealsHistoryCreateManyWithoutUserInput struct {
	Create  []OrderUserDealsHistoryCreateWithoutUserInput `json:"create,omitempty"`
	Connect []OrderUserDealsHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type OrderUserDealsHistoryCreateWithoutUserInput struct {
	Type          int32                                                     `json:"type"`
	Role          *int32                                                    `json:"role,omitempty"`
	DealId        int32                                                     `json:"dealId"`
	UniqueKey     string                                                    `json:"uniqueKey"`
	UniqueId      int32                                                     `json:"uniqueId"`
	Coin          *CoinCreateOneWithoutOrderUserDealsHistoriesInput         `json:"coin,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutOrderUserDealsHistoryInput  `json:"motherHistory,omitempty"`
	OrderHistory  *OrderHistoryCreateOneWithoutOrderUserDealsHistoriesInput `json:"orderHistory,omitempty"`
	DealPrice     float64                                                   `json:"dealPrice"`
	DealQty       float64                                                   `json:"dealQty"`
	Fee           float64                                                   `json:"fee"`
	DealOrderId   *int32                                                    `json:"dealOrderId,omitempty"`
	Time          *float64                                                  `json:"time,omitempty"`
}

type CoinCreateOneWithoutOrderUserDealsHistoriesInput struct {
	Create  *CoinCreateWithoutOrderUserDealsHistoriesInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput                          `json:"connect,omitempty"`
}

type CoinCreateWithoutOrderUserDealsHistoriesInput struct {
	Categories          *CategoryCreateManyWithoutCoinsInput         `json:"categories,omitempty"`
	Name                string                                       `json:"name"`
	Qty                 float64                                      `json:"qty"`
	StandardPrice       *float64                                     `json:"standardPrice,omitempty"`
	CurrentPrice        *float64                                     `json:"currentPrice,omitempty"`
	Image               FileCreateOneWithoutCoinInput                `json:"image"`
	Picture             *FileInfoCreateOneWithoutCoinInput           `json:"picture,omitempty"`
	Description         string                                       `json:"description"`
	Wallets             *WalletCreateManyWithoutCoinInput            `json:"wallets,omitempty"`
	Owner               UserCreateOneWithoutCoinInput                `json:"owner"`
	Posts               *PostCreateManyWithoutCoinInput              `json:"posts,omitempty"`
	Offer               *OfferCreateOneWithoutCoinInput              `json:"offer,omitempty"`
	Status              *int32                                       `json:"status,omitempty"`
	Weight              string                                       `json:"weight"`
	OrderHistories      *OrderHistoryCreateManyWithoutCoinInput      `json:"orderHistories,omitempty"`
	OrderDealsHistories *OrderDealsHistoryCreateManyWithoutCoinInput `json:"orderDealsHistories,omitempty"`
	MotherHistories     *MotherHistoryCreateManyWithoutCoinInput     `json:"motherHistories,omitempty"`
	CoinPriceTable      *CoinPriceTableCreateOneWithoutCoinInput     `json:"coinPriceTable,omitempty"`
	CoinKline           *CoinKlineCreateManyWithoutCoinInput         `json:"coinKline,omitempty"`
	DeployTxhash        *string                                      `json:"deployTxhash,omitempty"`
	ContractAddress     *string                                      `json:"contractAddress,omitempty"`
	ODda                *float64                                     `json:"oDDA,omitempty"`
}

type CoinPriceTableCreateOneWithoutCoinInput struct {
	Create  *CoinPriceTableCreateWithoutCoinInput `json:"create,omitempty"`
	Connect *CoinPriceTableWhereUniqueInput       `json:"connect,omitempty"`
}

type CoinPriceTableCreateWithoutCoinInput struct {
	Type      int32                               `json:"type"`
	InfoValue *CoinPriceTableCreateinfoValueInput `json:"infoValue,omitempty"`
}

type CoinPriceTableCreateinfoValueInput struct {
	Set []float64 `json:"set,omitempty"`
}

type CoinKlineCreateManyWithoutCoinInput struct {
	Create  []CoinKlineCreateWithoutCoinInput `json:"create,omitempty"`
	Connect []CoinKlineWhereUniqueInput       `json:"connect,omitempty"`
}

type CoinKlineCreateWithoutCoinInput struct {
	Open   float64 `json:"open"`
	Close  float64 `json:"close"`
	High   float64 `json:"high"`
	Low    float64 `json:"low"`
	Volume float64 `json:"volume"`
	Deal   float64 `json:"deal"`
}

type MotherHistoryCreateOneWithoutOrderUserDealsHistoryInput struct {
	Create  *MotherHistoryCreateWithoutOrderUserDealsHistoryInput `json:"create,omitempty"`
	Connect *MotherHistoryWhereUniqueInput                        `json:"connect,omitempty"`
}

type MotherHistoryCreateWithoutOrderUserDealsHistoryInput struct {
	Type                    int32                                                      `json:"type"`
	RoleTime                string                                                     `json:"roleTime"`
	Coin                    *CoinCreateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserCreateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostCreateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderHistory            *OrderHistoryCreateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryCreateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryCreateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryCreateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryCreateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type OrderHistoryCreateOneWithoutMotherHistoryInput struct {
	Create  *OrderHistoryCreateWithoutMotherHistoryInput `json:"create,omitempty"`
	Connect *OrderHistoryWhereUniqueInput                `json:"connect,omitempty"`
}

type OrderHistoryCreateWithoutMotherHistoryInput struct {
	Type                    int32                                                    `json:"type"`
	OrderNum                int32                                                    `json:"orderNum"`
	User                    *UserCreateOneWithoutOrderHistoriesInput                 `json:"user,omitempty"`
	Coin                    *CoinCreateOneWithoutOrderHistoriesInput                 `json:"coin,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutOrderHistoryInput `json:"orderUserDealsHistories,omitempty"`
	OrderPrice              float64                                                  `json:"orderPrice"`
	DealPrice               *float64                                                 `json:"dealPrice,omitempty"`
	OrderQty                float64                                                  `json:"orderQty"`
	DealQty                 *float64                                                 `json:"dealQty,omitempty"`
	LeftQty                 float64                                                  `json:"leftQty"`
	DealFee                 *float64                                                 `json:"dealFee,omitempty"`
	TakerFee                *float64                                                 `json:"takerFee,omitempty"`
	MakerFee                *float64                                                 `json:"makerFee,omitempty"`
	Memo                    *string                                                  `json:"memo,omitempty"`
	Description             *string                                                  `json:"description,omitempty"`
	Offset                  *int32                                                   `json:"offset,omitempty"`
	IsCancel                *bool                                                    `json:"isCancel,omitempty"`
}

type OrderUserDealsHistoryCreateManyWithoutOrderHistoryInput struct {
	Create  []OrderUserDealsHistoryCreateWithoutOrderHistoryInput `json:"create,omitempty"`
	Connect []OrderUserDealsHistoryWhereUniqueInput               `json:"connect,omitempty"`
}

type OrderUserDealsHistoryCreateWithoutOrderHistoryInput struct {
	Type          int32                                                    `json:"type"`
	Role          *int32                                                   `json:"role,omitempty"`
	DealId        int32                                                    `json:"dealId"`
	UniqueKey     string                                                   `json:"uniqueKey"`
	UniqueId      int32                                                    `json:"uniqueId"`
	Coin          *CoinCreateOneWithoutOrderUserDealsHistoriesInput        `json:"coin,omitempty"`
	User          *UserCreateOneWithoutOrderUserDealsHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutOrderUserDealsHistoryInput `json:"motherHistory,omitempty"`
	DealPrice     float64                                                  `json:"dealPrice"`
	DealQty       float64                                                  `json:"dealQty"`
	Fee           float64                                                  `json:"fee"`
	DealOrderId   *int32                                                   `json:"dealOrderId,omitempty"`
	Time          *float64                                                 `json:"time,omitempty"`
}

type CashHistoryCreateOneWithoutMotherHistoryInput struct {
	Create  *CashHistoryCreateWithoutMotherHistoryInput `json:"create,omitempty"`
	Connect *CashHistoryWhereUniqueInput                `json:"connect,omitempty"`
}

type CashHistoryCreateWithoutMotherHistoryInput struct {
	Type                int32                                                    `json:"type"`
	Property            *int32                                                   `json:"property,omitempty"`
	OrderNum            *int32                                                   `json:"orderNum,omitempty"`
	Description         *string                                                  `json:"description,omitempty"`
	User                *UserCreateOneWithoutCashHistoriesInput                  `json:"user,omitempty"`
	Qeh                 *QuestExpenditureHistoryCreateOneWithoutCashHistoryInput `json:"qeh,omitempty"`
	AergoAccountHistory *AergoAccountHistoryCreateOneWithoutCashHistoryInput     `json:"aergoAccountHistory,omitempty"`
	Price               *int32                                                   `json:"price,omitempty"`
	OPrice              *float64                                                 `json:"oPrice,omitempty"`
	OPriceBack          *float64                                                 `json:"oPriceBack,omitempty"`
	Qty                 *float64                                                 `json:"qty,omitempty"`
	Memo                *string                                                  `json:"memo,omitempty"`
}

type UserCreateOneWithoutCashHistoriesInput struct {
	Create  *UserCreateWithoutCashHistoriesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                `json:"connect,omitempty"`
}

type UserCreateWithoutCashHistoriesInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type QuestExpenditureHistoryCreateManyWithoutUserInput struct {
	Create  []QuestExpenditureHistoryCreateWithoutUserInput `json:"create,omitempty"`
	Connect []QuestExpenditureHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type QuestExpenditureHistoryCreateWithoutUserInput struct {
	Type          int32                                                      `json:"type"`
	PayType       *int32                                                     `json:"payType,omitempty"`
	OrderNum      *int32                                                     `json:"orderNum,omitempty"`
	Description   *string                                                    `json:"description,omitempty"`
	Post          *PostCreateOneWithoutQuestExpenditureHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutQuestExpenditureHistoryInput `json:"motherHistory,omitempty"`
	CashHistory   *CashHistoryCreateOneWithoutQehInput                       `json:"cashHistory,omitempty"`
	Price         *int32                                                     `json:"price,omitempty"`
	Qty           *float64                                                   `json:"qty,omitempty"`
	OPrice        *int32                                                     `json:"oPrice,omitempty"`
	CurrentPrice  *float64                                                   `json:"currentPrice,omitempty"`
	Memo          *string                                                    `json:"memo,omitempty"`
}

type PostCreateOneWithoutQuestExpenditureHistoriesInput struct {
	Create  *PostCreateWithoutQuestExpenditureHistoriesInput `json:"create,omitempty"`
	Connect *PostWhereUniqueInput                            `json:"connect,omitempty"`
}

type PostCreateWithoutQuestExpenditureHistoriesInput struct {
	Type                  *int32                                       `json:"type,omitempty"`
	PayType               *int32                                       `json:"payType,omitempty"`
	Categories            *CategoryCreateManyWithoutPostsInput         `json:"categories,omitempty"`
	Content               string                                       `json:"content"`
	ToUser                *UserCreateOneWithoutRequestPostsInput       `json:"toUser,omitempty"`
	Owner                 UserCreateOneWithoutPostsInput               `json:"owner"`
	Coin                  CoinCreateOneWithoutPostsInput               `json:"coin"`
	AirDrop               *AirDropCreateOneWithoutPostInput            `json:"airDrop,omitempty"`
	Image                 *FileCreateOneWithoutPostInput               `json:"image,omitempty"`
	FileList              *FileInfoCreateManyWithoutPostInput          `json:"fileList,omitempty"`
	QuestTitle            *string                                      `json:"questTitle,omitempty"`
	QuestCost             *float64                                     `json:"questCost,omitempty"`
	QuestMinMemberCount   *int32                                       `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount *int32                                       `json:"questLimitMemberCount,omitempty"`
	QuestToDate           *string                                      `json:"questToDate,omitempty"`
	QuestMembers          *QuestMemberCreateManyWithoutPostInput       `json:"questMembers,omitempty"`
	QuestStatus           *int32                                       `json:"questStatus,omitempty"`
	MotherHistories       *MotherHistoryCreateManyWithoutPostInput     `json:"motherHistories,omitempty"`
	PostRewardHistories   *PostRewardHistoryCreateManyWithoutPostInput `json:"postRewardHistories,omitempty"`
	Comments              *CommentCreateManyWithoutPostInput           `json:"comments,omitempty"`
	Likes                 *UserCreateManyWithoutLikesInput             `json:"likes,omitempty"`
	Views                 *UserCreateManyWithoutViewsInput             `json:"views,omitempty"`
	UpdateHistories       *UpdatePostHistoryCreateManyWithoutPostInput `json:"updateHistories,omitempty"`
	IsBanner              *bool                                        `json:"isBanner,omitempty"`
	IsDel                 *bool                                        `json:"isDel,omitempty"`
	EnableEarlyAccess     *bool                                        `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt        *string                                      `json:"publicAccessAt,omitempty"`
	OrderIndex            *float64                                     `json:"order_index,omitempty"`
}

type UserCreateManyWithoutLikesInput struct {
	Create  []UserCreateWithoutLikesInput `json:"create,omitempty"`
	Connect []UserWhereUniqueInput        `json:"connect,omitempty"`
}

type UserCreateWithoutLikesInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type CashHistoryCreateManyWithoutUserInput struct {
	Create  []CashHistoryCreateWithoutUserInput `json:"create,omitempty"`
	Connect []CashHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type CashHistoryCreateWithoutUserInput struct {
	Type                int32                                                    `json:"type"`
	Property            *int32                                                   `json:"property,omitempty"`
	OrderNum            *int32                                                   `json:"orderNum,omitempty"`
	Description         *string                                                  `json:"description,omitempty"`
	MotherHistory       *MotherHistoryCreateOneWithoutCashHistoryInput           `json:"motherHistory,omitempty"`
	Qeh                 *QuestExpenditureHistoryCreateOneWithoutCashHistoryInput `json:"qeh,omitempty"`
	AergoAccountHistory *AergoAccountHistoryCreateOneWithoutCashHistoryInput     `json:"aergoAccountHistory,omitempty"`
	Price               *int32                                                   `json:"price,omitempty"`
	OPrice              *float64                                                 `json:"oPrice,omitempty"`
	OPriceBack          *float64                                                 `json:"oPriceBack,omitempty"`
	Qty                 *float64                                                 `json:"qty,omitempty"`
	Memo                *string                                                  `json:"memo,omitempty"`
}

type MotherHistoryCreateOneWithoutCashHistoryInput struct {
	Create  *MotherHistoryCreateWithoutCashHistoryInput `json:"create,omitempty"`
	Connect *MotherHistoryWhereUniqueInput              `json:"connect,omitempty"`
}

type MotherHistoryCreateWithoutCashHistoryInput struct {
	Type                    int32                                                      `json:"type"`
	RoleTime                string                                                     `json:"roleTime"`
	Coin                    *CoinCreateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserCreateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostCreateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryCreateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryCreateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryCreateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryCreateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput struct {
	Create  *OrderUserDealsHistoryCreateWithoutMotherHistoryInput `json:"create,omitempty"`
	Connect *OrderUserDealsHistoryWhereUniqueInput                `json:"connect,omitempty"`
}

type OrderUserDealsHistoryCreateWithoutMotherHistoryInput struct {
	Type         int32                                                     `json:"type"`
	Role         *int32                                                    `json:"role,omitempty"`
	DealId       int32                                                     `json:"dealId"`
	UniqueKey    string                                                    `json:"uniqueKey"`
	UniqueId     int32                                                     `json:"uniqueId"`
	Coin         *CoinCreateOneWithoutOrderUserDealsHistoriesInput         `json:"coin,omitempty"`
	User         *UserCreateOneWithoutOrderUserDealsHistoriesInput         `json:"user,omitempty"`
	OrderHistory *OrderHistoryCreateOneWithoutOrderUserDealsHistoriesInput `json:"orderHistory,omitempty"`
	DealPrice    float64                                                   `json:"dealPrice"`
	DealQty      float64                                                   `json:"dealQty"`
	Fee          float64                                                   `json:"fee"`
	DealOrderId  *int32                                                    `json:"dealOrderId,omitempty"`
	Time         *float64                                                  `json:"time,omitempty"`
}

type OrderHistoryCreateOneWithoutOrderUserDealsHistoriesInput struct {
	Create  *OrderHistoryCreateWithoutOrderUserDealsHistoriesInput `json:"create,omitempty"`
	Connect *OrderHistoryWhereUniqueInput                          `json:"connect,omitempty"`
}

type OrderHistoryCreateWithoutOrderUserDealsHistoriesInput struct {
	Type          int32                                           `json:"type"`
	OrderNum      int32                                           `json:"orderNum"`
	User          *UserCreateOneWithoutOrderHistoriesInput        `json:"user,omitempty"`
	Coin          *CoinCreateOneWithoutOrderHistoriesInput        `json:"coin,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutOrderHistoryInput `json:"motherHistory,omitempty"`
	OrderPrice    float64                                         `json:"orderPrice"`
	DealPrice     *float64                                        `json:"dealPrice,omitempty"`
	OrderQty      float64                                         `json:"orderQty"`
	DealQty       *float64                                        `json:"dealQty,omitempty"`
	LeftQty       float64                                         `json:"leftQty"`
	DealFee       *float64                                        `json:"dealFee,omitempty"`
	TakerFee      *float64                                        `json:"takerFee,omitempty"`
	MakerFee      *float64                                        `json:"makerFee,omitempty"`
	Memo          *string                                         `json:"memo,omitempty"`
	Description   *string                                         `json:"description,omitempty"`
	Offset        *int32                                          `json:"offset,omitempty"`
	IsCancel      *bool                                           `json:"isCancel,omitempty"`
}

type MotherHistoryCreateOneWithoutOrderHistoryInput struct {
	Create  *MotherHistoryCreateWithoutOrderHistoryInput `json:"create,omitempty"`
	Connect *MotherHistoryWhereUniqueInput               `json:"connect,omitempty"`
}

type MotherHistoryCreateWithoutOrderHistoryInput struct {
	Type                    int32                                                      `json:"type"`
	RoleTime                string                                                     `json:"roleTime"`
	Coin                    *CoinCreateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserCreateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostCreateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	CashHistory             *CashHistoryCreateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryCreateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryCreateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryCreateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type AergoAccountHistoryCreateOneWithoutMotherHistoryInput struct {
	Create  *AergoAccountHistoryCreateWithoutMotherHistoryInput `json:"create,omitempty"`
	Connect *AergoAccountHistoryWhereUniqueInput                `json:"connect,omitempty"`
}

type AergoAccountHistoryCreateWithoutMotherHistoryInput struct {
	Type         int32                                                `json:"type"`
	AergoAccount AergoAccountCreateOneWithoutHistoriesInput           `json:"aergoAccount"`
	CashHistory  *CashHistoryCreateOneWithoutAergoAccountHistoryInput `json:"cashHistory,omitempty"`
	AergoAmount  *string                                              `json:"aergoAmount,omitempty"`
	AmountFee    *float64                                             `json:"amount_fee,omitempty"`
	Amount       *float64                                             `json:"amount,omitempty"`
	MarketPrice  *string                                              `json:"marketPrice,omitempty"`
	TxHash       *string                                              `json:"txHash,omitempty"`
	Memo         *string                                              `json:"memo,omitempty"`
	Description  *string                                              `json:"description,omitempty"`
	BlockNo      *int32                                               `json:"blockNo,omitempty"`
	Status       *int32                                               `json:"status,omitempty"`
}

type AergoAccountCreateOneWithoutHistoriesInput struct {
	Create  *AergoAccountCreateWithoutHistoriesInput `json:"create,omitempty"`
	Connect *AergoAccountWhereUniqueInput            `json:"connect,omitempty"`
}

type AergoAccountCreateWithoutHistoriesInput struct {
	ContractAddress string                                 `json:"contractAddress"`
	Amount          *float64                               `json:"amount,omitempty"`
	Owner           *UserCreateOneWithoutAergoAccountInput `json:"owner,omitempty"`
	LatestBlock     *int32                                 `json:"latestBlock,omitempty"`
}

type UserCreateOneWithoutAergoAccountInput struct {
	Create  *UserCreateWithoutAergoAccountInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput               `json:"connect,omitempty"`
}

type UserCreateWithoutAergoAccountInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type AirDropHistoryCreateManyWithoutUserInput struct {
	Create  []AirDropHistoryCreateWithoutUserInput `json:"create,omitempty"`
	Connect []AirDropHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type AirDropHistoryCreateWithoutUserInput struct {
	Type          int32                                             `json:"type"`
	Description   *string                                           `json:"description,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutAirDropHistoryInput `json:"motherHistory,omitempty"`
	AirDrop       *AirDropCreateOneWithoutAirDropHistoriesInput     `json:"airDrop,omitempty"`
	AirDropMember *AirDropMemberCreateOneWithoutAirDropHistoryInput `json:"airDropMember,omitempty"`
	Qty           *float64                                          `json:"qty,omitempty"`
	CurrentPrice  *float64                                          `json:"currentPrice,omitempty"`
	Memo          *string                                           `json:"memo,omitempty"`
}

type MotherHistoryCreateOneWithoutAirDropHistoryInput struct {
	Create  *MotherHistoryCreateWithoutAirDropHistoryInput `json:"create,omitempty"`
	Connect *MotherHistoryWhereUniqueInput                 `json:"connect,omitempty"`
}

type MotherHistoryCreateWithoutAirDropHistoryInput struct {
	Type                    int32                                                      `json:"type"`
	RoleTime                string                                                     `json:"roleTime"`
	Coin                    *CoinCreateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserCreateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostCreateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryCreateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryCreateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryCreateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryCreateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput struct {
	Create  *QuestExpenditureHistoryCreateWithoutMotherHistoryInput `json:"create,omitempty"`
	Connect *QuestExpenditureHistoryWhereUniqueInput                `json:"connect,omitempty"`
}

type QuestExpenditureHistoryCreateWithoutMotherHistoryInput struct {
	Type         int32                                               `json:"type"`
	PayType      *int32                                              `json:"payType,omitempty"`
	OrderNum     *int32                                              `json:"orderNum,omitempty"`
	Description  *string                                             `json:"description,omitempty"`
	User         *UserCreateOneWithoutQuestExpenditureHistoriesInput `json:"user,omitempty"`
	Post         *PostCreateOneWithoutQuestExpenditureHistoriesInput `json:"post,omitempty"`
	CashHistory  *CashHistoryCreateOneWithoutQehInput                `json:"cashHistory,omitempty"`
	Price        *int32                                              `json:"price,omitempty"`
	Qty          *float64                                            `json:"qty,omitempty"`
	OPrice       *int32                                              `json:"oPrice,omitempty"`
	CurrentPrice *float64                                            `json:"currentPrice,omitempty"`
	Memo         *string                                             `json:"memo,omitempty"`
}

type CashHistoryCreateOneWithoutQehInput struct {
	Create  *CashHistoryCreateWithoutQehInput `json:"create,omitempty"`
	Connect *CashHistoryWhereUniqueInput      `json:"connect,omitempty"`
}

type CashHistoryCreateWithoutQehInput struct {
	Type                int32                                                `json:"type"`
	Property            *int32                                               `json:"property,omitempty"`
	OrderNum            *int32                                               `json:"orderNum,omitempty"`
	Description         *string                                              `json:"description,omitempty"`
	User                *UserCreateOneWithoutCashHistoriesInput              `json:"user,omitempty"`
	MotherHistory       *MotherHistoryCreateOneWithoutCashHistoryInput       `json:"motherHistory,omitempty"`
	AergoAccountHistory *AergoAccountHistoryCreateOneWithoutCashHistoryInput `json:"aergoAccountHistory,omitempty"`
	Price               *int32                                               `json:"price,omitempty"`
	OPrice              *float64                                             `json:"oPrice,omitempty"`
	OPriceBack          *float64                                             `json:"oPriceBack,omitempty"`
	Qty                 *float64                                             `json:"qty,omitempty"`
	Memo                *string                                              `json:"memo,omitempty"`
}

type AergoAccountHistoryCreateOneWithoutCashHistoryInput struct {
	Create  *AergoAccountHistoryCreateWithoutCashHistoryInput `json:"create,omitempty"`
	Connect *AergoAccountHistoryWhereUniqueInput              `json:"connect,omitempty"`
}

type AergoAccountHistoryCreateWithoutCashHistoryInput struct {
	Type          int32                                                  `json:"type"`
	MotherHistory *MotherHistoryCreateOneWithoutAergoAccountHistoryInput `json:"motherHistory,omitempty"`
	AergoAccount  AergoAccountCreateOneWithoutHistoriesInput             `json:"aergoAccount"`
	AergoAmount   *string                                                `json:"aergoAmount,omitempty"`
	AmountFee     *float64                                               `json:"amount_fee,omitempty"`
	Amount        *float64                                               `json:"amount,omitempty"`
	MarketPrice   *string                                                `json:"marketPrice,omitempty"`
	TxHash        *string                                                `json:"txHash,omitempty"`
	Memo          *string                                                `json:"memo,omitempty"`
	Description   *string                                                `json:"description,omitempty"`
	BlockNo       *int32                                                 `json:"blockNo,omitempty"`
	Status        *int32                                                 `json:"status,omitempty"`
}

type MotherHistoryCreateOneWithoutAergoAccountHistoryInput struct {
	Create  *MotherHistoryCreateWithoutAergoAccountHistoryInput `json:"create,omitempty"`
	Connect *MotherHistoryWhereUniqueInput                      `json:"connect,omitempty"`
}

type MotherHistoryCreateWithoutAergoAccountHistoryInput struct {
	Type                    int32                                                      `json:"type"`
	RoleTime                string                                                     `json:"roleTime"`
	Coin                    *CoinCreateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserCreateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostCreateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryCreateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryCreateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryCreateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryCreateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type AirDropHistoryCreateOneWithoutMotherHistoryInput struct {
	Create  *AirDropHistoryCreateWithoutMotherHistoryInput `json:"create,omitempty"`
	Connect *AirDropHistoryWhereUniqueInput                `json:"connect,omitempty"`
}

type AirDropHistoryCreateWithoutMotherHistoryInput struct {
	Type          int32                                             `json:"type"`
	Description   *string                                           `json:"description,omitempty"`
	User          *UserCreateOneWithoutAirDropHistoriesInput        `json:"user,omitempty"`
	AirDrop       *AirDropCreateOneWithoutAirDropHistoriesInput     `json:"airDrop,omitempty"`
	AirDropMember *AirDropMemberCreateOneWithoutAirDropHistoryInput `json:"airDropMember,omitempty"`
	Qty           *float64                                          `json:"qty,omitempty"`
	CurrentPrice  *float64                                          `json:"currentPrice,omitempty"`
	Memo          *string                                           `json:"memo,omitempty"`
}

type UserCreateOneWithoutAirDropHistoriesInput struct {
	Create  *UserCreateWithoutAirDropHistoriesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                   `json:"connect,omitempty"`
}

type UserCreateWithoutAirDropHistoriesInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type AirDropMemberCreateManyWithoutUserInput struct {
	Create  []AirDropMemberCreateWithoutUserInput `json:"create,omitempty"`
	Connect []AirDropMemberWhereUniqueInput       `json:"connect,omitempty"`
}

type AirDropMemberCreateWithoutUserInput struct {
	AirDrop        AirDropCreateOneWithoutMembersInput               `json:"airDrop"`
	DropNum        int32                                             `json:"dropNum"`
	Qty            float64                                           `json:"qty"`
	AirDropHistory *AirDropHistoryCreateOneWithoutAirDropMemberInput `json:"airDropHistory,omitempty"`
	IsDel          *bool                                             `json:"isDel,omitempty"`
}

type AirDropCreateOneWithoutMembersInput struct {
	Create  *AirDropCreateWithoutMembersInput `json:"create,omitempty"`
	Connect *AirDropWhereUniqueInput          `json:"connect,omitempty"`
}

type AirDropCreateWithoutMembersInput struct {
	Status            *int32                                       `json:"status,omitempty"`
	Post              PostCreateOneWithoutAirDropInput             `json:"post"`
	DeployTxhash      *string                                      `json:"deployTxhash,omitempty"`
	ContractAddress   *string                                      `json:"contractAddress,omitempty"`
	RandomArrayString *string                                      `json:"randomArrayString,omitempty"`
	Amount            float64                                      `json:"amount"`
	Left              float64                                      `json:"left"`
	ToDate            *string                                      `json:"toDate,omitempty"`
	AirDropHistories  *AirDropHistoryCreateManyWithoutAirDropInput `json:"airDropHistories,omitempty"`
	IsDel             *bool                                        `json:"isDel,omitempty"`
}

type PostCreateOneWithoutAirDropInput struct {
	Create  *PostCreateWithoutAirDropInput `json:"create,omitempty"`
	Connect *PostWhereUniqueInput          `json:"connect,omitempty"`
}

type PostCreateWithoutAirDropInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type UserCreateManyWithoutViewsInput struct {
	Create  []UserCreateWithoutViewsInput `json:"create,omitempty"`
	Connect []UserWhereUniqueInput        `json:"connect,omitempty"`
}

type UserCreateWithoutViewsInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PostRewardHistoryCreateManyWithoutUserInput struct {
	Create  []PostRewardHistoryCreateWithoutUserInput `json:"create,omitempty"`
	Connect []PostRewardHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type PostRewardHistoryCreateWithoutUserInput struct {
	Type          int32                                                `json:"type"`
	Description   *string                                              `json:"description,omitempty"`
	Post          *PostCreateOneWithoutPostRewardHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutPostRewardHistoryInput `json:"motherHistory,omitempty"`
	Comment       *CommentCreateOneWithoutPostRewardHistoryInput       `json:"comment,omitempty"`
	Qty           *float64                                             `json:"qty,omitempty"`
	CurrentPrice  *float64                                             `json:"currentPrice,omitempty"`
	Memo          *string                                              `json:"memo,omitempty"`
}

type PostCreateOneWithoutPostRewardHistoriesInput struct {
	Create  *PostCreateWithoutPostRewardHistoriesInput `json:"create,omitempty"`
	Connect *PostWhereUniqueInput                      `json:"connect,omitempty"`
}

type PostCreateWithoutPostRewardHistoriesInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryCreateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type UpdatePostHistoryCreateManyWithoutPostInput struct {
	Create  []UpdatePostHistoryCreateWithoutPostInput `json:"create,omitempty"`
	Connect []UpdatePostHistoryWhereUniqueInput       `json:"connect,omitempty"`
}

type UpdatePostHistoryCreateWithoutPostInput struct {
	Action         int32                    `json:"action"`
	BeforeContent  *string                  `json:"beforeContent,omitempty"`
	BeforeImageUrl *string                  `json:"beforeImageUrl,omitempty"`
	User           *UserCreateOneInput      `json:"user,omitempty"`
	Admin          *AdminUserCreateOneInput `json:"admin,omitempty"`
}

type AdminUserCreateOneInput struct {
	Create  *AdminUserCreateInput      `json:"create,omitempty"`
	Connect *AdminUserWhereUniqueInput `json:"connect,omitempty"`
}

type MotherHistoryCreateOneWithoutPostRewardHistoryInput struct {
	Create  *MotherHistoryCreateWithoutPostRewardHistoryInput `json:"create,omitempty"`
	Connect *MotherHistoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type MotherHistoryCreateWithoutPostRewardHistoryInput struct {
	Type                    int32                                                      `json:"type"`
	RoleTime                string                                                     `json:"roleTime"`
	Coin                    *CoinCreateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserCreateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostCreateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryCreateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryCreateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryCreateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryCreateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
}

type CommentCreateOneWithoutPostRewardHistoryInput struct {
	Create  *CommentCreateWithoutPostRewardHistoryInput `json:"create,omitempty"`
	Connect *CommentWhereUniqueInput                    `json:"connect,omitempty"`
}

type CommentCreateWithoutPostRewardHistoryInput struct {
	Type    *int32                                     `json:"type,omitempty"`
	Post    PostCreateOneWithoutCommentsInput          `json:"post"`
	Content string                                     `json:"content"`
	Image   *FileInfoCreateOneInput                    `json:"image,omitempty"`
	Url     *string                                    `json:"url,omitempty"`
	Reply   *CommentReplyCreateManyWithoutCommentInput `json:"reply,omitempty"`
	Owner   UserCreateOneWithoutCommentsInput          `json:"owner"`
	IsDel   *bool                                      `json:"isDel,omitempty"`
}

type AergoAccountCreateOneWithoutOwnerInput struct {
	Create  *AergoAccountCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect *AergoAccountWhereUniqueInput        `json:"connect,omitempty"`
}

type AergoAccountCreateWithoutOwnerInput struct {
	ContractAddress string                                                 `json:"contractAddress"`
	Amount          *float64                                               `json:"amount,omitempty"`
	LatestBlock     *int32                                                 `json:"latestBlock,omitempty"`
	Histories       *AergoAccountHistoryCreateManyWithoutAergoAccountInput `json:"histories,omitempty"`
}

type AergoAccountHistoryCreateManyWithoutAergoAccountInput struct {
	Create  []AergoAccountHistoryCreateWithoutAergoAccountInput `json:"create,omitempty"`
	Connect []AergoAccountHistoryWhereUniqueInput               `json:"connect,omitempty"`
}

type AergoAccountHistoryCreateWithoutAergoAccountInput struct {
	Type          int32                                                  `json:"type"`
	MotherHistory *MotherHistoryCreateOneWithoutAergoAccountHistoryInput `json:"motherHistory,omitempty"`
	CashHistory   *CashHistoryCreateOneWithoutAergoAccountHistoryInput   `json:"cashHistory,omitempty"`
	AergoAmount   *string                                                `json:"aergoAmount,omitempty"`
	AmountFee     *float64                                               `json:"amount_fee,omitempty"`
	Amount        *float64                                               `json:"amount,omitempty"`
	MarketPrice   *string                                                `json:"marketPrice,omitempty"`
	TxHash        *string                                                `json:"txHash,omitempty"`
	Memo          *string                                                `json:"memo,omitempty"`
	Description   *string                                                `json:"description,omitempty"`
	BlockNo       *int32                                                 `json:"blockNo,omitempty"`
	Status        *int32                                                 `json:"status,omitempty"`
}

type CashHistoryCreateOneWithoutAergoAccountHistoryInput struct {
	Create  *CashHistoryCreateWithoutAergoAccountHistoryInput `json:"create,omitempty"`
	Connect *CashHistoryWhereUniqueInput                      `json:"connect,omitempty"`
}

type CashHistoryCreateWithoutAergoAccountHistoryInput struct {
	Type          int32                                                    `json:"type"`
	Property      *int32                                                   `json:"property,omitempty"`
	OrderNum      *int32                                                   `json:"orderNum,omitempty"`
	Description   *string                                                  `json:"description,omitempty"`
	User          *UserCreateOneWithoutCashHistoriesInput                  `json:"user,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutCashHistoryInput           `json:"motherHistory,omitempty"`
	Qeh           *QuestExpenditureHistoryCreateOneWithoutCashHistoryInput `json:"qeh,omitempty"`
	Price         *int32                                                   `json:"price,omitempty"`
	OPrice        *float64                                                 `json:"oPrice,omitempty"`
	OPriceBack    *float64                                                 `json:"oPriceBack,omitempty"`
	Qty           *float64                                                 `json:"qty,omitempty"`
	Memo          *string                                                  `json:"memo,omitempty"`
}

type QuestExpenditureHistoryCreateOneWithoutCashHistoryInput struct {
	Create  *QuestExpenditureHistoryCreateWithoutCashHistoryInput `json:"create,omitempty"`
	Connect *QuestExpenditureHistoryWhereUniqueInput              `json:"connect,omitempty"`
}

type QuestExpenditureHistoryCreateWithoutCashHistoryInput struct {
	Type          int32                                                      `json:"type"`
	PayType       *int32                                                     `json:"payType,omitempty"`
	OrderNum      *int32                                                     `json:"orderNum,omitempty"`
	Description   *string                                                    `json:"description,omitempty"`
	User          *UserCreateOneWithoutQuestExpenditureHistoriesInput        `json:"user,omitempty"`
	Post          *PostCreateOneWithoutQuestExpenditureHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutQuestExpenditureHistoryInput `json:"motherHistory,omitempty"`
	Price         *int32                                                     `json:"price,omitempty"`
	Qty           *float64                                                   `json:"qty,omitempty"`
	OPrice        *int32                                                     `json:"oPrice,omitempty"`
	CurrentPrice  *float64                                                   `json:"currentPrice,omitempty"`
	Memo          *string                                                    `json:"memo,omitempty"`
}

type MotherHistoryCreateOneWithoutQuestExpenditureHistoryInput struct {
	Create  *MotherHistoryCreateWithoutQuestExpenditureHistoryInput `json:"create,omitempty"`
	Connect *MotherHistoryWhereUniqueInput                          `json:"connect,omitempty"`
}

type MotherHistoryCreateWithoutQuestExpenditureHistoryInput struct {
	Type                  int32                                                    `json:"type"`
	RoleTime              string                                                   `json:"roleTime"`
	Coin                  *CoinCreateOneWithoutMotherHistoriesInput                `json:"coin,omitempty"`
	User                  *UserCreateOneWithoutMotherHistoriesInput                `json:"user,omitempty"`
	Post                  *PostCreateOneWithoutMotherHistoriesInput                `json:"post,omitempty"`
	OrderUserDealsHistory *OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput `json:"orderUserDealsHistory,omitempty"`
	OrderHistory          *OrderHistoryCreateOneWithoutMotherHistoryInput          `json:"orderHistory,omitempty"`
	CashHistory           *CashHistoryCreateOneWithoutMotherHistoryInput           `json:"cashHistory,omitempty"`
	AergoAccountHistory   *AergoAccountHistoryCreateOneWithoutMotherHistoryInput   `json:"aergoAccountHistory,omitempty"`
	AirDropHistory        *AirDropHistoryCreateOneWithoutMotherHistoryInput        `json:"airDropHistory,omitempty"`
	PostRewardHistory     *PostRewardHistoryCreateOneWithoutMotherHistoryInput     `json:"postRewardHistory,omitempty"`
}

type PostRewardHistoryCreateOneWithoutMotherHistoryInput struct {
	Create  *PostRewardHistoryCreateWithoutMotherHistoryInput `json:"create,omitempty"`
	Connect *PostRewardHistoryWhereUniqueInput                `json:"connect,omitempty"`
}

type PostRewardHistoryCreateWithoutMotherHistoryInput struct {
	Type         int32                                          `json:"type"`
	Description  *string                                        `json:"description,omitempty"`
	User         *UserCreateOneWithoutPostRewardHistoriesInput  `json:"user,omitempty"`
	Post         *PostCreateOneWithoutPostRewardHistoriesInput  `json:"post,omitempty"`
	Comment      *CommentCreateOneWithoutPostRewardHistoryInput `json:"comment,omitempty"`
	Qty          *float64                                       `json:"qty,omitempty"`
	CurrentPrice *float64                                       `json:"currentPrice,omitempty"`
	Memo         *string                                        `json:"memo,omitempty"`
}

type FeeCreateOneWithoutRankRelationInput struct {
	Create  *FeeCreateWithoutRankRelationInput `json:"create,omitempty"`
	Connect *FeeWhereUniqueInput               `json:"connect,omitempty"`
}

type FeeCreateWithoutRankRelationInput struct {
	Type              int32                               `json:"type"`
	Key               int32                               `json:"key"`
	Memo              *string                             `json:"memo,omitempty"`
	Rank              *int32                              `json:"rank,omitempty"`
	AskTakerFee       *float64                            `json:"askTakerFee,omitempty"`
	AskMakerFee       *float64                            `json:"askMakerFee,omitempty"`
	BidTakerFee       *float64                            `json:"bidTakerFee,omitempty"`
	BidMakerFee       *float64                            `json:"bidMakerFee,omitempty"`
	MyCoinAskTakerFee *float64                            `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskMakerFee *float64                            `json:"myCoinAskMakerFee,omitempty"`
	MyCoinBidTakerFee *float64                            `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidMakerFee *float64                            `json:"myCoinBidMakerFee,omitempty"`
	EventRelation     *UserCreateManyWithoutEventFeeInput `json:"eventRelation,omitempty"`
}

type UserCreateManyWithoutEventFeeInput struct {
	Create  []UserCreateWithoutEventFeeInput `json:"create,omitempty"`
	Connect []UserWhereUniqueInput           `json:"connect,omitempty"`
}

type UserCreateWithoutEventFeeInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type InviteCodeCreateOneWithoutOwnerInput struct {
	Create  *InviteCodeCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect *InviteCodeWhereUniqueInput        `json:"connect,omitempty"`
}

type InviteCodeCreateWithoutOwnerInput struct {
	NumId       *int32                                             `json:"numId,omitempty"`
	Code        string                                             `json:"code"`
	InviteUsers *InviteUserHistoryCreateManyWithoutInviteCodeInput `json:"inviteUsers,omitempty"`
}

type InviteUserHistoryCreateManyWithoutInviteCodeInput struct {
	Create  []InviteUserHistoryCreateWithoutInviteCodeInput `json:"create,omitempty"`
	Connect []InviteUserHistoryWhereUniqueInput             `json:"connect,omitempty"`
}

type InviteUserHistoryCreateWithoutInviteCodeInput struct {
	User UserCreateOneInput `json:"user"`
}

type PageCreateOneWithoutOwnerInput struct {
	Create  *PageCreateWithoutOwnerInput `json:"create,omitempty"`
	Connect *PageWhereUniqueInput        `json:"connect,omitempty"`
}

type PageCreateWithoutOwnerInput struct {
	PageId           string                                          `json:"pageId"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeCreateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeCreateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchCreateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramCreateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvCreateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanCreateManyInput                         `json:"fans,omitempty"`
	Comments         *PageCommentCreateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemCreateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageCreateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentCreateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type PageBadgeCreateManyWithoutPageInput struct {
	Create  []PageBadgeCreateWithoutPageInput `json:"create,omitempty"`
	Connect []PageBadgeWhereUniqueInput       `json:"connect,omitempty"`
}

type PageBadgeCreateWithoutPageInput struct {
	Badge BadgeCreateOneWithoutPagesInput            `json:"badge"`
	Vote  *int32                                     `json:"vote,omitempty"`
	Voter *BadgeVoterCreateManyWithoutPageBadgeInput `json:"voter,omitempty"`
}

type BadgeCreateOneWithoutPagesInput struct {
	Create  *BadgeCreateWithoutPagesInput `json:"create,omitempty"`
	Connect *BadgeWhereUniqueInput        `json:"connect,omitempty"`
}

type BadgeCreateWithoutPagesInput struct {
	Name        string  `json:"name"`
	ImageUrl    *string `json:"imageUrl,omitempty"`
	Description string  `json:"description"`
	OrderIndex  int32   `json:"orderIndex"`
}

type BadgeVoterCreateManyWithoutPageBadgeInput struct {
	Create  []BadgeVoterCreateWithoutPageBadgeInput `json:"create,omitempty"`
	Connect []BadgeVoterWhereUniqueInput            `json:"connect,omitempty"`
}

type BadgeVoterCreateWithoutPageBadgeInput struct {
	ReviewContent *ReviewContentCreateOneInput `json:"reviewContent,omitempty"`
	User          *UserCreateOneInput          `json:"user,omitempty"`
	Ip            *string                      `json:"ip,omitempty"`
}

type ReviewContentCreateOneInput struct {
	Create  *ReviewContentCreateInput      `json:"create,omitempty"`
	Connect *ReviewContentWhereUniqueInput `json:"connect,omitempty"`
}

type ReviewContentCreateInput struct {
	ReviewContentPage *ReviewContentPageCreateOneWithoutReviewsInput            `json:"reviewContentPage,omitempty"`
	PreviewImageUrl   string                                                    `json:"previewImageUrl"`
	Title             *string                                                   `json:"title,omitempty"`
	Type              string                                                    `json:"type"`
	Url               string                                                    `json:"url"`
	Review            *string                                                   `json:"review,omitempty"`
	VideoId           *string                                                   `json:"videoId,omitempty"`
	ContentId         *string                                                   `json:"contentId,omitempty"`
	Viewers           *ReviewContentViewerCreateManyWithoutReviewContentInput   `json:"viewers,omitempty"`
	Reviewers         *ReviewContentReviewerCreateManyWithoutReviewContentInput `json:"reviewers,omitempty"`
	RelatedPage       PageCreateOneWithoutRelatedReviewsInput                   `json:"relatedPage"`
	Owner             UserCreateOneInput                                        `json:"owner"`
}

type ReviewContentPageCreateOneWithoutReviewsInput struct {
	Create  *ReviewContentPageCreateWithoutReviewsInput `json:"create,omitempty"`
	Connect *ReviewContentPageWhereUniqueInput          `json:"connect,omitempty"`
}

type ReviewContentPageCreateWithoutReviewsInput struct {
	Page       PageCreateOneWithoutReviewsInput                                  `json:"page"`
	Categories *ReviewContentCategoryCreateManyInput                             `json:"categories,omitempty"`
	Title      string                                                            `json:"title"`
	SubTitle   *string                                                           `json:"subTitle,omitempty"`
	Message    *string                                                           `json:"message,omitempty"`
	Viewers    *ReviewContentPageViewerCreateManyWithoutReviewContentPageInput   `json:"viewers,omitempty"`
	Comments   *PageCommentCreateManyWithoutRelatedReviewContentPageInput        `json:"comments,omitempty"`
	Owner      UserCreateOneInput                                                `json:"owner"`
	FeedBacks  *ReviewContentPageFeedBackCreateManyWithoutReviewContentPageInput `json:"feedBacks,omitempty"`
	ReleasedAt string                                                            `json:"releasedAt"`
	IsDrafts   *bool                                                             `json:"isDrafts,omitempty"`
	IsDel      *bool                                                             `json:"isDel,omitempty"`
}

type PageCreateOneWithoutReviewsInput struct {
	Create  *PageCreateWithoutReviewsInput `json:"create,omitempty"`
	Connect *PageWhereUniqueInput          `json:"connect,omitempty"`
}

type PageCreateWithoutReviewsInput struct {
	PageId           string                                          `json:"pageId"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeCreateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeCreateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchCreateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramCreateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvCreateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanCreateManyInput                         `json:"fans,omitempty"`
	Owner            *UserCreateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentCreateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemCreateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	RelatedReviews   *ReviewContentCreateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type YoutubeCreateOneWithoutPageInput struct {
	Create  *YoutubeCreateWithoutPageInput `json:"create,omitempty"`
	Connect *YoutubeWhereUniqueInput       `json:"connect,omitempty"`
}

type YoutubeCreateWithoutPageInput struct {
	ChannelId       string                                               `json:"channelId"`
	ChannelType     *string                                              `json:"channelType,omitempty"`
	ChannelName     *string                                              `json:"channelName,omitempty"`
	UserName        *string                                              `json:"userName,omitempty"`
	VideoCount      *string                                              `json:"videoCount,omitempty"`
	SubscriberCount *string                                              `json:"subscriberCount,omitempty"`
	VideoViewCount  *string                                              `json:"videoViewCount,omitempty"`
	ThumbnailUrl    *string                                              `json:"thumbnailUrl,omitempty"`
	BannerUrl       *string                                              `json:"bannerUrl,omitempty"`
	Description     *string                                              `json:"description,omitempty"`
	PublishedAt     *string                                              `json:"publishedAt,omitempty"`
	Country         *string                                              `json:"country,omitempty"`
	PageUrl         *string                                              `json:"pageUrl,omitempty"`
	Statistics      *YoutubeDailyStatisticsCreateManyWithoutYoutubeInput `json:"statistics,omitempty"`
}

type YoutubeDailyStatisticsCreateManyWithoutYoutubeInput struct {
	Create  []YoutubeDailyStatisticsCreateWithoutYoutubeInput `json:"create,omitempty"`
	Connect []YoutubeDailyStatisticsWhereUniqueInput          `json:"connect,omitempty"`
}

type YoutubeDailyStatisticsCreateWithoutYoutubeInput struct {
	Date            string `json:"date"`
	VideoCount      string `json:"videoCount"`
	SubscriberCount string `json:"subscriberCount"`
	VideoViewCount  string `json:"videoViewCount"`
}

type TwitchCreateOneWithoutPageInput struct {
	Create  *TwitchCreateWithoutPageInput `json:"create,omitempty"`
	Connect *TwitchWhereUniqueInput       `json:"connect,omitempty"`
}

type TwitchCreateWithoutPageInput struct {
	UserId           string                                             `json:"userId"`
	UserNo           string                                             `json:"userNo"`
	UserName         *string                                            `json:"userName,omitempty"`
	FollowerCount    *string                                            `json:"followerCount,omitempty"`
	FollowingCount   *string                                            `json:"followingCount,omitempty"`
	ChannelType      *string                                            `json:"channelType,omitempty"`
	ChannelViewCount *string                                            `json:"channelViewCount,omitempty"`
	AvatarUrl        *string                                            `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                            `json:"coverUrl,omitempty"`
	Description      *string                                            `json:"description,omitempty"`
	PageUrl          *string                                            `json:"pageUrl,omitempty"`
	Statistics       *TwitchDailyStatisticsCreateManyWithoutTwitchInput `json:"statistics,omitempty"`
}

type TwitchDailyStatisticsCreateManyWithoutTwitchInput struct {
	Create  []TwitchDailyStatisticsCreateWithoutTwitchInput `json:"create,omitempty"`
	Connect []TwitchDailyStatisticsWhereUniqueInput         `json:"connect,omitempty"`
}

type TwitchDailyStatisticsCreateWithoutTwitchInput struct {
	Date             string `json:"date"`
	FollowerCount    string `json:"followerCount"`
	FollowingCount   string `json:"followingCount"`
	ChannelViewCount string `json:"channelViewCount"`
}

type InstagramCreateOneWithoutPageInput struct {
	Create  *InstagramCreateWithoutPageInput `json:"create,omitempty"`
	Connect *InstagramWhereUniqueInput       `json:"connect,omitempty"`
}

type InstagramCreateWithoutPageInput struct {
	UserId         string                                                   `json:"userId"`
	UserNo         string                                                   `json:"userNo"`
	UserName       *string                                                  `json:"userName,omitempty"`
	PostCount      *string                                                  `json:"postCount,omitempty"`
	FollowerCount  *string                                                  `json:"followerCount,omitempty"`
	FollowingCount *string                                                  `json:"followingCount,omitempty"`
	AvatarUrl      *string                                                  `json:"avatarUrl,omitempty"`
	Description    *string                                                  `json:"description,omitempty"`
	PageUrl        *string                                                  `json:"pageUrl,omitempty"`
	Statistics     *InstagramDailyStatisticsCreateManyWithoutInstagramInput `json:"statistics,omitempty"`
}

type InstagramDailyStatisticsCreateManyWithoutInstagramInput struct {
	Create  []InstagramDailyStatisticsCreateWithoutInstagramInput `json:"create,omitempty"`
	Connect []InstagramDailyStatisticsWhereUniqueInput            `json:"connect,omitempty"`
}

type InstagramDailyStatisticsCreateWithoutInstagramInput struct {
	Date           string `json:"date"`
	PostCount      string `json:"postCount"`
	FollowerCount  string `json:"followerCount"`
	FollowingCount string `json:"followingCount"`
}

type AfreecaTvCreateOneWithoutPageInput struct {
	Create  *AfreecaTvCreateWithoutPageInput `json:"create,omitempty"`
	Connect *AfreecaTvWhereUniqueInput       `json:"connect,omitempty"`
}

type AfreecaTvCreateWithoutPageInput struct {
	StationNo     string                                                   `json:"stationNo"`
	StationName   *string                                                  `json:"stationName,omitempty"`
	StationTitle  *string                                                  `json:"stationTitle,omitempty"`
	UserId        string                                                   `json:"userId"`
	UserName      *string                                                  `json:"userName,omitempty"`
	AvatarUrl     *string                                                  `json:"avatarUrl,omitempty"`
	Description   *string                                                  `json:"description,omitempty"`
	PageUrl       *string                                                  `json:"pageUrl,omitempty"`
	Statistics    *AfreecaTvDailyStatisticsCreateManyWithoutAfreecaTvInput `json:"statistics,omitempty"`
	FollowerCount *string                                                  `json:"followerCount,omitempty"`
	ViewCount     *string                                                  `json:"viewCount,omitempty"`
	VisitCount    *string                                                  `json:"visitCount,omitempty"`
	FanCount      *string                                                  `json:"fanCount,omitempty"`
}

type AfreecaTvDailyStatisticsCreateManyWithoutAfreecaTvInput struct {
	Create  []AfreecaTvDailyStatisticsCreateWithoutAfreecaTvInput `json:"create,omitempty"`
	Connect []AfreecaTvDailyStatisticsWhereUniqueInput            `json:"connect,omitempty"`
}

type AfreecaTvDailyStatisticsCreateWithoutAfreecaTvInput struct {
	Date          string `json:"date"`
	FollowerCount string `json:"followerCount"`
	ViewCount     string `json:"viewCount"`
	VisitCount    string `json:"visitCount"`
	FanCount      string `json:"fanCount"`
}

type PageFanCreateManyInput struct {
	Create  []PageFanCreateInput      `json:"create,omitempty"`
	Connect []PageFanWhereUniqueInput `json:"connect,omitempty"`
}

type PageFanCreateInput struct {
	User UserCreateOneInput `json:"user"`
}

type UserCreateOneWithoutPageInput struct {
	Create  *UserCreateWithoutPageInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput       `json:"connect,omitempty"`
}

type UserCreateWithoutPageInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
}

type FeeCreateManyWithoutEventRelationInput struct {
	Create  []FeeCreateWithoutEventRelationInput `json:"create,omitempty"`
	Connect []FeeWhereUniqueInput                `json:"connect,omitempty"`
}

type FeeCreateWithoutEventRelationInput struct {
	Type              int32                                  `json:"type"`
	Key               int32                                  `json:"key"`
	Memo              *string                                `json:"memo,omitempty"`
	Rank              *int32                                 `json:"rank,omitempty"`
	AskTakerFee       *float64                               `json:"askTakerFee,omitempty"`
	AskMakerFee       *float64                               `json:"askMakerFee,omitempty"`
	BidTakerFee       *float64                               `json:"bidTakerFee,omitempty"`
	BidMakerFee       *float64                               `json:"bidMakerFee,omitempty"`
	MyCoinAskTakerFee *float64                               `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskMakerFee *float64                               `json:"myCoinAskMakerFee,omitempty"`
	MyCoinBidTakerFee *float64                               `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidMakerFee *float64                               `json:"myCoinBidMakerFee,omitempty"`
	RankRelation      *UserCreateManyWithoutUserRankFeeInput `json:"rankRelation,omitempty"`
}

type UserCreateManyWithoutUserRankFeeInput struct {
	Create  []UserCreateWithoutUserRankFeeInput `json:"create,omitempty"`
	Connect []UserWhereUniqueInput              `json:"connect,omitempty"`
}

type UserCreateWithoutUserRankFeeInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PageCommentCreateManyWithoutPageInput struct {
	Create  []PageCommentCreateWithoutPageInput `json:"create,omitempty"`
	Connect []PageCommentWhereUniqueInput       `json:"connect,omitempty"`
}

type PageCommentCreateWithoutPageInput struct {
	Content                  string                                             `json:"content"`
	Comments                 *PageCommentReplyCreateManyWithoutPageCommentInput `json:"comments,omitempty"`
	IpAddress                *string                                            `json:"ipAddress,omitempty"`
	ImageUrl                 *string                                            `json:"imageUrl,omitempty"`
	ThumbnailImageUrl        *string                                            `json:"thumbnailImageUrl,omitempty"`
	Owner                    *UserCreateOneInput                                `json:"owner,omitempty"`
	RelatedReviewContentPage *ReviewContentPageCreateOneWithoutCommentsInput    `json:"relatedReviewContentPage,omitempty"`
	IsDel                    *bool                                              `json:"isDel,omitempty"`
}

type PageCommentReplyCreateManyWithoutPageCommentInput struct {
	Create  []PageCommentReplyCreateWithoutPageCommentInput `json:"create,omitempty"`
	Connect []PageCommentReplyWhereUniqueInput              `json:"connect,omitempty"`
}

type PageCommentReplyCreateWithoutPageCommentInput struct {
	Content           string              `json:"content"`
	IpAddress         *string             `json:"ipAddress,omitempty"`
	ImageUrl          *string             `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string             `json:"thumbnailImageUrl,omitempty"`
	Owner             *UserCreateOneInput `json:"owner,omitempty"`
	IsDel             *bool               `json:"isDel,omitempty"`
}

type ReviewContentPageCreateOneWithoutCommentsInput struct {
	Create  *ReviewContentPageCreateWithoutCommentsInput `json:"create,omitempty"`
	Connect *ReviewContentPageWhereUniqueInput           `json:"connect,omitempty"`
}

type ReviewContentPageCreateWithoutCommentsInput struct {
	Page       PageCreateOneWithoutReviewsInput                                  `json:"page"`
	Categories *ReviewContentCategoryCreateManyInput                             `json:"categories,omitempty"`
	Title      string                                                            `json:"title"`
	SubTitle   *string                                                           `json:"subTitle,omitempty"`
	Message    *string                                                           `json:"message,omitempty"`
	Viewers    *ReviewContentPageViewerCreateManyWithoutReviewContentPageInput   `json:"viewers,omitempty"`
	Reviews    *ReviewContentCreateManyWithoutReviewContentPageInput             `json:"reviews,omitempty"`
	Owner      UserCreateOneInput                                                `json:"owner"`
	FeedBacks  *ReviewContentPageFeedBackCreateManyWithoutReviewContentPageInput `json:"feedBacks,omitempty"`
	ReleasedAt string                                                            `json:"releasedAt"`
	IsDrafts   *bool                                                             `json:"isDrafts,omitempty"`
	IsDel      *bool                                                             `json:"isDel,omitempty"`
}

type ReviewContentCategoryCreateManyInput struct {
	Create  []ReviewContentCategoryCreateInput      `json:"create,omitempty"`
	Connect []ReviewContentCategoryWhereUniqueInput `json:"connect,omitempty"`
}

type ReviewContentCategoryCreateInput struct {
	Name     string `json:"name"`
	ImageUrl string `json:"imageUrl"`
}

type ReviewContentPageViewerCreateManyWithoutReviewContentPageInput struct {
	Create  []ReviewContentPageViewerCreateWithoutReviewContentPageInput `json:"create,omitempty"`
	Connect []ReviewContentPageViewerWhereUniqueInput                    `json:"connect,omitempty"`
}

type ReviewContentPageViewerCreateWithoutReviewContentPageInput struct {
	User *UserCreateOneInput `json:"user,omitempty"`
	Ip   *string             `json:"ip,omitempty"`
}

type ReviewContentCreateManyWithoutReviewContentPageInput struct {
	Create  []ReviewContentCreateWithoutReviewContentPageInput `json:"create,omitempty"`
	Connect []ReviewContentWhereUniqueInput                    `json:"connect,omitempty"`
}

type ReviewContentCreateWithoutReviewContentPageInput struct {
	PreviewImageUrl string                                                    `json:"previewImageUrl"`
	Title           *string                                                   `json:"title,omitempty"`
	Type            string                                                    `json:"type"`
	Url             string                                                    `json:"url"`
	Review          *string                                                   `json:"review,omitempty"`
	VideoId         *string                                                   `json:"videoId,omitempty"`
	ContentId       *string                                                   `json:"contentId,omitempty"`
	Viewers         *ReviewContentViewerCreateManyWithoutReviewContentInput   `json:"viewers,omitempty"`
	Reviewers       *ReviewContentReviewerCreateManyWithoutReviewContentInput `json:"reviewers,omitempty"`
	RelatedPage     PageCreateOneWithoutRelatedReviewsInput                   `json:"relatedPage"`
	Owner           UserCreateOneInput                                        `json:"owner"`
}

type ReviewContentViewerCreateManyWithoutReviewContentInput struct {
	Create  []ReviewContentViewerCreateWithoutReviewContentInput `json:"create,omitempty"`
	Connect []ReviewContentViewerWhereUniqueInput                `json:"connect,omitempty"`
}

type ReviewContentViewerCreateWithoutReviewContentInput struct {
	User *UserCreateOneInput `json:"user,omitempty"`
	Ip   *string             `json:"ip,omitempty"`
}

type ReviewContentReviewerCreateManyWithoutReviewContentInput struct {
	Create  []ReviewContentReviewerCreateWithoutReviewContentInput `json:"create,omitempty"`
	Connect []ReviewContentReviewerWhereUniqueInput                `json:"connect,omitempty"`
}

type ReviewContentReviewerCreateWithoutReviewContentInput struct {
	Review string             `json:"review"`
	Owner  UserCreateOneInput `json:"owner"`
}

type PageCreateOneWithoutRelatedReviewsInput struct {
	Create  *PageCreateWithoutRelatedReviewsInput `json:"create,omitempty"`
	Connect *PageWhereUniqueInput                 `json:"connect,omitempty"`
}

type PageCreateWithoutRelatedReviewsInput struct {
	PageId           string                                       `json:"pageId"`
	NickName         *string                                      `json:"nickName,omitempty"`
	AvatarUrl        *string                                      `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                      `json:"coverUrl,omitempty"`
	Description      *string                                      `json:"description,omitempty"`
	Badges           *PageBadgeCreateManyWithoutPageInput         `json:"badges,omitempty"`
	Youtube          *YoutubeCreateOneWithoutPageInput            `json:"youtube,omitempty"`
	Twitch           *TwitchCreateOneWithoutPageInput             `json:"twitch,omitempty"`
	Instagram        *InstagramCreateOneWithoutPageInput          `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvCreateOneWithoutPageInput          `json:"afreecaTV,omitempty"`
	Fans             *PageFanCreateManyInput                      `json:"fans,omitempty"`
	Owner            *UserCreateOneWithoutPageInput               `json:"owner,omitempty"`
	Comments         *PageCommentCreateManyWithoutPageInput       `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemCreateManyWithoutPageInput   `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageCreateManyWithoutPageInput `json:"reviews,omitempty"`
}

type RequestPageItemCreateManyWithoutPageInput struct {
	Create  []RequestPageItemCreateWithoutPageInput `json:"create,omitempty"`
	Connect []RequestPageItemWhereUniqueInput       `json:"connect,omitempty"`
}

type RequestPageItemCreateWithoutPageInput struct {
	Type      int32               `json:"type"`
	Note      *string             `json:"note,omitempty"`
	IpAddress *string             `json:"ipAddress,omitempty"`
	Owner     *UserCreateOneInput `json:"owner,omitempty"`
}

type ReviewContentPageCreateManyWithoutPageInput struct {
	Create  []ReviewContentPageCreateWithoutPageInput `json:"create,omitempty"`
	Connect []ReviewContentPageWhereUniqueInput       `json:"connect,omitempty"`
}

type ReviewContentPageCreateWithoutPageInput struct {
	Categories *ReviewContentCategoryCreateManyInput                             `json:"categories,omitempty"`
	Title      string                                                            `json:"title"`
	SubTitle   *string                                                           `json:"subTitle,omitempty"`
	Message    *string                                                           `json:"message,omitempty"`
	Viewers    *ReviewContentPageViewerCreateManyWithoutReviewContentPageInput   `json:"viewers,omitempty"`
	Reviews    *ReviewContentCreateManyWithoutReviewContentPageInput             `json:"reviews,omitempty"`
	Comments   *PageCommentCreateManyWithoutRelatedReviewContentPageInput        `json:"comments,omitempty"`
	Owner      UserCreateOneInput                                                `json:"owner"`
	FeedBacks  *ReviewContentPageFeedBackCreateManyWithoutReviewContentPageInput `json:"feedBacks,omitempty"`
	ReleasedAt string                                                            `json:"releasedAt"`
	IsDrafts   *bool                                                             `json:"isDrafts,omitempty"`
	IsDel      *bool                                                             `json:"isDel,omitempty"`
}

type PageCommentCreateManyWithoutRelatedReviewContentPageInput struct {
	Create  []PageCommentCreateWithoutRelatedReviewContentPageInput `json:"create,omitempty"`
	Connect []PageCommentWhereUniqueInput                           `json:"connect,omitempty"`
}

type PageCommentCreateWithoutRelatedReviewContentPageInput struct {
	Page              PageCreateOneWithoutCommentsInput                  `json:"page"`
	Content           string                                             `json:"content"`
	Comments          *PageCommentReplyCreateManyWithoutPageCommentInput `json:"comments,omitempty"`
	IpAddress         *string                                            `json:"ipAddress,omitempty"`
	ImageUrl          *string                                            `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string                                            `json:"thumbnailImageUrl,omitempty"`
	Owner             *UserCreateOneInput                                `json:"owner,omitempty"`
	IsDel             *bool                                              `json:"isDel,omitempty"`
}

type PageCreateOneWithoutCommentsInput struct {
	Create  *PageCreateWithoutCommentsInput `json:"create,omitempty"`
	Connect *PageWhereUniqueInput           `json:"connect,omitempty"`
}

type PageCreateWithoutCommentsInput struct {
	PageId           string                                          `json:"pageId"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeCreateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeCreateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchCreateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramCreateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvCreateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanCreateManyInput                         `json:"fans,omitempty"`
	Owner            *UserCreateOneWithoutPageInput                  `json:"owner,omitempty"`
	RequestPageItems *RequestPageItemCreateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageCreateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentCreateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type ReviewContentCreateManyWithoutRelatedPageInput struct {
	Create  []ReviewContentCreateWithoutRelatedPageInput `json:"create,omitempty"`
	Connect []ReviewContentWhereUniqueInput              `json:"connect,omitempty"`
}

type ReviewContentCreateWithoutRelatedPageInput struct {
	ReviewContentPage *ReviewContentPageCreateOneWithoutReviewsInput            `json:"reviewContentPage,omitempty"`
	PreviewImageUrl   string                                                    `json:"previewImageUrl"`
	Title             *string                                                   `json:"title,omitempty"`
	Type              string                                                    `json:"type"`
	Url               string                                                    `json:"url"`
	Review            *string                                                   `json:"review,omitempty"`
	VideoId           *string                                                   `json:"videoId,omitempty"`
	ContentId         *string                                                   `json:"contentId,omitempty"`
	Viewers           *ReviewContentViewerCreateManyWithoutReviewContentInput   `json:"viewers,omitempty"`
	Reviewers         *ReviewContentReviewerCreateManyWithoutReviewContentInput `json:"reviewers,omitempty"`
	Owner             UserCreateOneInput                                        `json:"owner"`
}

type ReviewContentPageFeedBackCreateManyWithoutReviewContentPageInput struct {
	Create  []ReviewContentPageFeedBackCreateWithoutReviewContentPageInput `json:"create,omitempty"`
	Connect []ReviewContentPageFeedBackWhereUniqueInput                    `json:"connect,omitempty"`
}

type ReviewContentPageFeedBackCreateWithoutReviewContentPageInput struct {
	IsLike    bool                `json:"isLike"`
	Message   *string             `json:"message,omitempty"`
	Owner     *UserCreateOneInput `json:"owner,omitempty"`
	IpAddress *string             `json:"ipAddress,omitempty"`
}

type AirDropHistoryCreateManyWithoutAirDropInput struct {
	Create  []AirDropHistoryCreateWithoutAirDropInput `json:"create,omitempty"`
	Connect []AirDropHistoryWhereUniqueInput          `json:"connect,omitempty"`
}

type AirDropHistoryCreateWithoutAirDropInput struct {
	Type          int32                                             `json:"type"`
	Description   *string                                           `json:"description,omitempty"`
	User          *UserCreateOneWithoutAirDropHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutAirDropHistoryInput `json:"motherHistory,omitempty"`
	AirDropMember *AirDropMemberCreateOneWithoutAirDropHistoryInput `json:"airDropMember,omitempty"`
	Qty           *float64                                          `json:"qty,omitempty"`
	CurrentPrice  *float64                                          `json:"currentPrice,omitempty"`
	Memo          *string                                           `json:"memo,omitempty"`
}

type AirDropMemberCreateOneWithoutAirDropHistoryInput struct {
	Create  *AirDropMemberCreateWithoutAirDropHistoryInput `json:"create,omitempty"`
	Connect *AirDropMemberWhereUniqueInput                 `json:"connect,omitempty"`
}

type AirDropMemberCreateWithoutAirDropHistoryInput struct {
	AirDrop AirDropCreateOneWithoutMembersInput     `json:"airDrop"`
	User    UserCreateOneWithoutAirDropMembersInput `json:"user"`
	DropNum int32                                   `json:"dropNum"`
	Qty     float64                                 `json:"qty"`
	IsDel   *bool                                   `json:"isDel,omitempty"`
}

type AirDropHistoryCreateOneWithoutAirDropMemberInput struct {
	Create  *AirDropHistoryCreateWithoutAirDropMemberInput `json:"create,omitempty"`
	Connect *AirDropHistoryWhereUniqueInput                `json:"connect,omitempty"`
}

type AirDropHistoryCreateWithoutAirDropMemberInput struct {
	Type          int32                                             `json:"type"`
	Description   *string                                           `json:"description,omitempty"`
	User          *UserCreateOneWithoutAirDropHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutAirDropHistoryInput `json:"motherHistory,omitempty"`
	AirDrop       *AirDropCreateOneWithoutAirDropHistoriesInput     `json:"airDrop,omitempty"`
	Qty           *float64                                          `json:"qty,omitempty"`
	CurrentPrice  *float64                                          `json:"currentPrice,omitempty"`
	Memo          *string                                           `json:"memo,omitempty"`
}

type AirDropCreateOneWithoutAirDropHistoriesInput struct {
	Create  *AirDropCreateWithoutAirDropHistoriesInput `json:"create,omitempty"`
	Connect *AirDropWhereUniqueInput                   `json:"connect,omitempty"`
}

type AirDropCreateWithoutAirDropHistoriesInput struct {
	Status            *int32                                      `json:"status,omitempty"`
	Post              PostCreateOneWithoutAirDropInput            `json:"post"`
	DeployTxhash      *string                                     `json:"deployTxhash,omitempty"`
	ContractAddress   *string                                     `json:"contractAddress,omitempty"`
	RandomArrayString *string                                     `json:"randomArrayString,omitempty"`
	Amount            float64                                     `json:"amount"`
	Left              float64                                     `json:"left"`
	Members           *AirDropMemberCreateManyWithoutAirDropInput `json:"members,omitempty"`
	ToDate            *string                                     `json:"toDate,omitempty"`
	IsDel             *bool                                       `json:"isDel,omitempty"`
}

type PostRewardHistoryCreateOneWithoutCommentInput struct {
	Create  *PostRewardHistoryCreateWithoutCommentInput `json:"create,omitempty"`
	Connect *PostRewardHistoryWhereUniqueInput          `json:"connect,omitempty"`
}

type PostRewardHistoryCreateWithoutCommentInput struct {
	Type          int32                                                `json:"type"`
	Description   *string                                              `json:"description,omitempty"`
	User          *UserCreateOneWithoutPostRewardHistoriesInput        `json:"user,omitempty"`
	Post          *PostCreateOneWithoutPostRewardHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutPostRewardHistoryInput `json:"motherHistory,omitempty"`
	Qty           *float64                                             `json:"qty,omitempty"`
	CurrentPrice  *float64                                             `json:"currentPrice,omitempty"`
	Memo          *string                                              `json:"memo,omitempty"`
}

type AdminUserCreateOneWithoutUpdateNotificationInput struct {
	Create  *AdminUserCreateWithoutUpdateNotificationInput `json:"create,omitempty"`
	Connect *AdminUserWhereUniqueInput                     `json:"connect,omitempty"`
}

type AdminUserCreateWithoutUpdateNotificationInput struct {
	Role               Role                                         `json:"role"`
	Email              string                                       `json:"email"`
	Password           *string                                      `json:"password,omitempty"`
	NickName           string                                       `json:"nickName"`
	OtpKey             *string                                      `json:"otpKey,omitempty"`
	Level              *string                                      `json:"level,omitempty"`
	Members            *UserCreateManyWithoutAdminUserInput         `json:"members,omitempty"`
	CreateNotification *NotificationCreateOneWithoutCreateUserInput `json:"createNotification,omitempty"`
}

type NotificationCreateOneWithoutUpdateUserInput struct {
	Create  *NotificationCreateWithoutUpdateUserInput `json:"create,omitempty"`
	Connect *NotificationWhereUniqueInput             `json:"connect,omitempty"`
}

type NotificationCreateWithoutUpdateUserInput struct {
	NotiType     *int32                                            `json:"notiType,omitempty"`
	PushType     int32                                             `json:"pushType"`
	PushState    int32                                             `json:"pushState"`
	User         *UserCreateManyInput                              `json:"user,omitempty"`
	SendFailUser *UserCreateManyInput                              `json:"sendFailUser,omitempty"`
	ByUser       *UserCreateOneInput                               `json:"byUser,omitempty"`
	Post         *PostCreateOneInput                               `json:"post,omitempty"`
	Coin         *CoinCreateOneInput                               `json:"coin,omitempty"`
	Topic        *string                                           `json:"topic,omitempty"`
	LinkType     string                                            `json:"linkType"`
	LinkValue    string                                            `json:"linkValue"`
	Message      string                                            `json:"message"`
	Image        *string                                           `json:"image,omitempty"`
	PublishType  int32                                             `json:"publishType"`
	PublishDate  string                                            `json:"publishDate"`
	CreateUser   *AdminUserCreateOneWithoutCreateNotificationInput `json:"createUser,omitempty"`
	IsDel        *bool                                             `json:"isDel,omitempty"`
}

type AdminUserCreateOneWithoutCreateNotificationInput struct {
	Create  *AdminUserCreateWithoutCreateNotificationInput `json:"create,omitempty"`
	Connect *AdminUserWhereUniqueInput                     `json:"connect,omitempty"`
}

type AdminUserCreateWithoutCreateNotificationInput struct {
	Role               Role                                         `json:"role"`
	Email              string                                       `json:"email"`
	Password           *string                                      `json:"password,omitempty"`
	NickName           string                                       `json:"nickName"`
	OtpKey             *string                                      `json:"otpKey,omitempty"`
	Level              *string                                      `json:"level,omitempty"`
	Members            *UserCreateManyWithoutAdminUserInput         `json:"members,omitempty"`
	UpdateNotification *NotificationCreateOneWithoutUpdateUserInput `json:"updateNotification,omitempty"`
}

type UserCreateOneWithoutTargetReportInput struct {
	Create  *UserCreateWithoutTargetReportInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput               `json:"connect,omitempty"`
}

type UserCreateWithoutTargetReportInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type UserCreateOneWithoutFilesInput struct {
	Create  *UserCreateWithoutFilesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput        `json:"connect,omitempty"`
}

type UserCreateWithoutFilesInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type AdminUserUpdateInput struct {
	Role               *Role                                        `json:"role,omitempty"`
	Email              *string                                      `json:"email,omitempty"`
	Password           *string                                      `json:"password,omitempty"`
	NickName           *string                                      `json:"nickName,omitempty"`
	OtpKey             *string                                      `json:"otpKey,omitempty"`
	Level              *string                                      `json:"level,omitempty"`
	Members            *UserUpdateManyWithoutAdminUserInput         `json:"members,omitempty"`
	CreateNotification *NotificationUpdateOneWithoutCreateUserInput `json:"createNotification,omitempty"`
	UpdateNotification *NotificationUpdateOneWithoutUpdateUserInput `json:"updateNotification,omitempty"`
}

type UserUpdateManyWithoutAdminUserInput struct {
	Create     []UserCreateWithoutAdminUserInput                `json:"create,omitempty"`
	Delete     []UserWhereUniqueInput                           `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                           `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                           `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                           `json:"disconnect,omitempty"`
	Update     []UserUpdateWithWhereUniqueWithoutAdminUserInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueWithoutAdminUserInput `json:"upsert,omitempty"`
	DeleteMany []UserScalarWhereInput                           `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput             `json:"updateMany,omitempty"`
}

type UserUpdateWithWhereUniqueWithoutAdminUserInput struct {
	Where UserWhereUniqueInput                `json:"where"`
	Data  UserUpdateWithoutAdminUserDataInput `json:"data"`
}

type UserUpdateWithoutAdminUserDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type CategoryUpdateManyWithoutFeedUsersInput struct {
	Create     []CategoryCreateWithoutFeedUsersInput                `json:"create,omitempty"`
	Delete     []CategoryWhereUniqueInput                           `json:"delete,omitempty"`
	Connect    []CategoryWhereUniqueInput                           `json:"connect,omitempty"`
	Set        []CategoryWhereUniqueInput                           `json:"set,omitempty"`
	Disconnect []CategoryWhereUniqueInput                           `json:"disconnect,omitempty"`
	Update     []CategoryUpdateWithWhereUniqueWithoutFeedUsersInput `json:"update,omitempty"`
	Upsert     []CategoryUpsertWithWhereUniqueWithoutFeedUsersInput `json:"upsert,omitempty"`
	DeleteMany []CategoryScalarWhereInput                           `json:"deleteMany,omitempty"`
	UpdateMany []CategoryUpdateManyWithWhereNestedInput             `json:"updateMany,omitempty"`
}

type CategoryUpdateWithWhereUniqueWithoutFeedUsersInput struct {
	Where CategoryWhereUniqueInput                `json:"where"`
	Data  CategoryUpdateWithoutFeedUsersDataInput `json:"data"`
}

type CategoryUpdateWithoutFeedUsersDataInput struct {
	Name       *string                               `json:"name,omitempty"`
	Posts      *PostUpdateManyWithoutCategoriesInput `json:"posts,omitempty"`
	Coins      *CoinUpdateManyWithoutCategoriesInput `json:"coins,omitempty"`
	OrderIndex *float64                              `json:"order_index,omitempty"`
}

type PostUpdateManyWithoutCategoriesInput struct {
	Create     []PostCreateWithoutCategoriesInput                `json:"create,omitempty"`
	Delete     []PostWhereUniqueInput                            `json:"delete,omitempty"`
	Connect    []PostWhereUniqueInput                            `json:"connect,omitempty"`
	Set        []PostWhereUniqueInput                            `json:"set,omitempty"`
	Disconnect []PostWhereUniqueInput                            `json:"disconnect,omitempty"`
	Update     []PostUpdateWithWhereUniqueWithoutCategoriesInput `json:"update,omitempty"`
	Upsert     []PostUpsertWithWhereUniqueWithoutCategoriesInput `json:"upsert,omitempty"`
	DeleteMany []PostScalarWhereInput                            `json:"deleteMany,omitempty"`
	UpdateMany []PostUpdateManyWithWhereNestedInput              `json:"updateMany,omitempty"`
}

type PostUpdateWithWhereUniqueWithoutCategoriesInput struct {
	Where PostWhereUniqueInput                 `json:"where"`
	Data  PostUpdateWithoutCategoriesDataInput `json:"data"`
}

type PostUpdateWithoutCategoriesDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type UserUpdateOneWithoutRequestPostsInput struct {
	Create     *UserCreateWithoutRequestPostsInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutRequestPostsDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutRequestPostsInput     `json:"upsert,omitempty"`
	Delete     *bool                                   `json:"delete,omitempty"`
	Disconnect *bool                                   `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                   `json:"connect,omitempty"`
}

type UserUpdateWithoutRequestPostsDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type CoinUpdateOneWithoutOwnerInput struct {
	Create     *CoinCreateWithoutOwnerInput     `json:"create,omitempty"`
	Update     *CoinUpdateWithoutOwnerDataInput `json:"update,omitempty"`
	Upsert     *CoinUpsertWithoutOwnerInput     `json:"upsert,omitempty"`
	Delete     *bool                            `json:"delete,omitempty"`
	Disconnect *bool                            `json:"disconnect,omitempty"`
	Connect    *CoinWhereUniqueInput            `json:"connect,omitempty"`
}

type CoinUpdateWithoutOwnerDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type CategoryUpdateManyWithoutCoinsInput struct {
	Create     []CategoryCreateWithoutCoinsInput                `json:"create,omitempty"`
	Delete     []CategoryWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []CategoryWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []CategoryWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []CategoryWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []CategoryUpdateWithWhereUniqueWithoutCoinsInput `json:"update,omitempty"`
	Upsert     []CategoryUpsertWithWhereUniqueWithoutCoinsInput `json:"upsert,omitempty"`
	DeleteMany []CategoryScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []CategoryUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type CategoryUpdateWithWhereUniqueWithoutCoinsInput struct {
	Where CategoryWhereUniqueInput            `json:"where"`
	Data  CategoryUpdateWithoutCoinsDataInput `json:"data"`
}

type CategoryUpdateWithoutCoinsDataInput struct {
	Name       *string                                   `json:"name,omitempty"`
	Posts      *PostUpdateManyWithoutCategoriesInput     `json:"posts,omitempty"`
	FeedUsers  *UserUpdateManyWithoutFeedCategoriesInput `json:"feedUsers,omitempty"`
	OrderIndex *float64                                  `json:"order_index,omitempty"`
}

type UserUpdateManyWithoutFeedCategoriesInput struct {
	Create     []UserCreateWithoutFeedCategoriesInput                `json:"create,omitempty"`
	Delete     []UserWhereUniqueInput                                `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                                `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                                `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                                `json:"disconnect,omitempty"`
	Update     []UserUpdateWithWhereUniqueWithoutFeedCategoriesInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueWithoutFeedCategoriesInput `json:"upsert,omitempty"`
	DeleteMany []UserScalarWhereInput                                `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput                  `json:"updateMany,omitempty"`
}

type UserUpdateWithWhereUniqueWithoutFeedCategoriesInput struct {
	Where UserWhereUniqueInput                     `json:"where"`
	Data  UserUpdateWithoutFeedCategoriesDataInput `json:"data"`
}

type UserUpdateWithoutFeedCategoriesDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type VerificationUpdateOneWithoutUserInput struct {
	Create     *VerificationCreateWithoutUserInput     `json:"create,omitempty"`
	Update     *VerificationUpdateWithoutUserDataInput `json:"update,omitempty"`
	Upsert     *VerificationUpsertWithoutUserInput     `json:"upsert,omitempty"`
	Delete     *bool                                   `json:"delete,omitempty"`
	Disconnect *bool                                   `json:"disconnect,omitempty"`
	Connect    *VerificationWhereUniqueInput           `json:"connect,omitempty"`
}

type VerificationUpdateWithoutUserDataInput struct {
	Level          *int32                                                    `json:"level,omitempty"`
	HasEmail       *bool                                                     `json:"hasEmail,omitempty"`
	HasPin         *bool                                                     `json:"hasPin,omitempty"`
	HasPhone       *bool                                                     `json:"hasPhone,omitempty"`
	HasBankAccount *bool                                                     `json:"hasBankAccount,omitempty"`
	HasInter       *bool                                                     `json:"hasInter,omitempty"`
	PinNumber      *string                                                   `json:"pinNumber,omitempty"`
	Phone          *PhoneVerificationUpdateOneWithoutVerificationInput       `json:"phone,omitempty"`
	BankAccount    *BankAccountVerificationUpdateOneWithoutVerificationInput `json:"bankAccount,omitempty"`
}

type PhoneVerificationUpdateOneWithoutVerificationInput struct {
	Create     *PhoneVerificationCreateWithoutVerificationInput     `json:"create,omitempty"`
	Update     *PhoneVerificationUpdateWithoutVerificationDataInput `json:"update,omitempty"`
	Upsert     *PhoneVerificationUpsertWithoutVerificationInput     `json:"upsert,omitempty"`
	Delete     *bool                                                `json:"delete,omitempty"`
	Disconnect *bool                                                `json:"disconnect,omitempty"`
	Connect    *PhoneVerificationWhereUniqueInput                   `json:"connect,omitempty"`
}

type PhoneVerificationUpdateWithoutVerificationDataInput struct {
	Name        *string `json:"name,omitempty"`
	Birth       *string `json:"birth,omitempty"`
	Foreigner   *bool   `json:"foreigner,omitempty"`
	Gender      *string `json:"gender,omitempty"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	Ci          *string `json:"CI,omitempty"`
	Di          *string `json:"DI,omitempty"`
	ImpUid      *string `json:"imp_uid,omitempty"`
	MerchantUid *string `json:"merchant_uid,omitempty"`
}

type PhoneVerificationUpsertWithoutVerificationInput struct {
	Update PhoneVerificationUpdateWithoutVerificationDataInput `json:"update"`
	Create PhoneVerificationCreateWithoutVerificationInput     `json:"create"`
}

type BankAccountVerificationUpdateOneWithoutVerificationInput struct {
	Create     *BankAccountVerificationCreateWithoutVerificationInput     `json:"create,omitempty"`
	Update     *BankAccountVerificationUpdateWithoutVerificationDataInput `json:"update,omitempty"`
	Upsert     *BankAccountVerificationUpsertWithoutVerificationInput     `json:"upsert,omitempty"`
	Delete     *bool                                                      `json:"delete,omitempty"`
	Disconnect *bool                                                      `json:"disconnect,omitempty"`
	Connect    *BankAccountVerificationWhereUniqueInput                   `json:"connect,omitempty"`
}

type BankAccountVerificationUpdateWithoutVerificationDataInput struct {
	Bank            *BankUpdateOneRequiredInput                                   `json:"bank,omitempty"`
	HolderName      *string                                                       `json:"holderName,omitempty"`
	AccountNumber   *string                                                       `json:"accountNumber,omitempty"`
	TransactionInfo *BankAccountVerificationTransactionInfoUpdateOneRequiredInput `json:"transactionInfo,omitempty"`
	VerifyAt        *string                                                       `json:"verifyAt,omitempty"`
}

type BankUpdateOneRequiredInput struct {
	Create  *BankCreateInput       `json:"create,omitempty"`
	Update  *BankUpdateDataInput   `json:"update,omitempty"`
	Upsert  *BankUpsertNestedInput `json:"upsert,omitempty"`
	Connect *BankWhereUniqueInput  `json:"connect,omitempty"`
}

type BankUpdateDataInput struct {
	Code *string `json:"code,omitempty"`
	Name *string `json:"name,omitempty"`
}

type BankUpsertNestedInput struct {
	Update BankUpdateDataInput `json:"update"`
	Create BankCreateInput     `json:"create"`
}

type BankAccountVerificationTransactionInfoUpdateOneRequiredInput struct {
	Create  *BankAccountVerificationTransactionInfoCreateInput       `json:"create,omitempty"`
	Update  *BankAccountVerificationTransactionInfoUpdateDataInput   `json:"update,omitempty"`
	Upsert  *BankAccountVerificationTransactionInfoUpsertNestedInput `json:"upsert,omitempty"`
	Connect *BankAccountVerificationTransactionInfoWhereUniqueInput  `json:"connect,omitempty"`
}

type BankAccountVerificationTransactionInfoUpdateDataInput struct {
	TransactionDt *string `json:"transactionDt,omitempty"`
	TransactionNo *string `json:"transactionNo,omitempty"`
	ExpireAt      *string `json:"expireAt,omitempty"`
}

type BankAccountVerificationTransactionInfoUpsertNestedInput struct {
	Update BankAccountVerificationTransactionInfoUpdateDataInput `json:"update"`
	Create BankAccountVerificationTransactionInfoCreateInput     `json:"create"`
}

type BankAccountVerificationUpsertWithoutVerificationInput struct {
	Update BankAccountVerificationUpdateWithoutVerificationDataInput `json:"update"`
	Create BankAccountVerificationCreateWithoutVerificationInput     `json:"create"`
}

type VerificationUpsertWithoutUserInput struct {
	Update VerificationUpdateWithoutUserDataInput `json:"update"`
	Create VerificationCreateWithoutUserInput     `json:"create"`
}

type WalletUpdateManyWithoutOwnerInput struct {
	Create     []WalletCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []WalletWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []WalletWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []WalletWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []WalletWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []WalletUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []WalletUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []WalletScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []WalletUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type WalletUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where WalletWhereUniqueInput            `json:"where"`
	Data  WalletUpdateWithoutOwnerDataInput `json:"data"`
}

type WalletUpdateWithoutOwnerDataInput struct {
	Coin                       *CoinUpdateOneRequiredWithoutWalletsInput `json:"coin,omitempty"`
	NumIdCoinName              *string                                   `json:"numIdCoinName,omitempty"`
	CumulativePurchaseQuantity *float64                                  `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseValue    *float64                                  `json:"cumulativePurchaseValue,omitempty"`
}

type CoinUpdateOneRequiredWithoutWalletsInput struct {
	Create  *CoinCreateWithoutWalletsInput     `json:"create,omitempty"`
	Update  *CoinUpdateWithoutWalletsDataInput `json:"update,omitempty"`
	Upsert  *CoinUpsertWithoutWalletsInput     `json:"upsert,omitempty"`
	Connect *CoinWhereUniqueInput              `json:"connect,omitempty"`
}

type CoinUpdateWithoutWalletsDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type FileUpdateOneRequiredWithoutCoinInput struct {
	Create  *FileCreateWithoutCoinInput     `json:"create,omitempty"`
	Update  *FileUpdateWithoutCoinDataInput `json:"update,omitempty"`
	Upsert  *FileUpsertWithoutCoinInput     `json:"upsert,omitempty"`
	Connect *FileWhereUniqueInput           `json:"connect,omitempty"`
}

type FileUpdateWithoutCoinDataInput struct {
	Post         *PostUpdateOneWithoutImageInput `json:"post,omitempty"`
	LocationPath *string                         `json:"locationPath,omitempty"`
	Name         *string                         `json:"name,omitempty"`
	ContentType  *string                         `json:"contentType,omitempty"`
	Url          *string                         `json:"url,omitempty"`
	Owner        *UserUpdateOneWithoutFilesInput `json:"owner,omitempty"`
	IsDel        *bool                           `json:"isDel,omitempty"`
}

type PostUpdateOneWithoutImageInput struct {
	Create     *PostCreateWithoutImageInput     `json:"create,omitempty"`
	Update     *PostUpdateWithoutImageDataInput `json:"update,omitempty"`
	Upsert     *PostUpsertWithoutImageInput     `json:"upsert,omitempty"`
	Delete     *bool                            `json:"delete,omitempty"`
	Disconnect *bool                            `json:"disconnect,omitempty"`
	Connect    *PostWhereUniqueInput            `json:"connect,omitempty"`
}

type PostUpdateWithoutImageDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type CategoryUpdateManyWithoutPostsInput struct {
	Create     []CategoryCreateWithoutPostsInput                `json:"create,omitempty"`
	Delete     []CategoryWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []CategoryWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []CategoryWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []CategoryWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []CategoryUpdateWithWhereUniqueWithoutPostsInput `json:"update,omitempty"`
	Upsert     []CategoryUpsertWithWhereUniqueWithoutPostsInput `json:"upsert,omitempty"`
	DeleteMany []CategoryScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []CategoryUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type CategoryUpdateWithWhereUniqueWithoutPostsInput struct {
	Where CategoryWhereUniqueInput            `json:"where"`
	Data  CategoryUpdateWithoutPostsDataInput `json:"data"`
}

type CategoryUpdateWithoutPostsDataInput struct {
	Name       *string                                   `json:"name,omitempty"`
	FeedUsers  *UserUpdateManyWithoutFeedCategoriesInput `json:"feedUsers,omitempty"`
	Coins      *CoinUpdateManyWithoutCategoriesInput     `json:"coins,omitempty"`
	OrderIndex *float64                                  `json:"order_index,omitempty"`
}

type CoinUpdateManyWithoutCategoriesInput struct {
	Create     []CoinCreateWithoutCategoriesInput                `json:"create,omitempty"`
	Delete     []CoinWhereUniqueInput                            `json:"delete,omitempty"`
	Connect    []CoinWhereUniqueInput                            `json:"connect,omitempty"`
	Set        []CoinWhereUniqueInput                            `json:"set,omitempty"`
	Disconnect []CoinWhereUniqueInput                            `json:"disconnect,omitempty"`
	Update     []CoinUpdateWithWhereUniqueWithoutCategoriesInput `json:"update,omitempty"`
	Upsert     []CoinUpsertWithWhereUniqueWithoutCategoriesInput `json:"upsert,omitempty"`
	DeleteMany []CoinScalarWhereInput                            `json:"deleteMany,omitempty"`
	UpdateMany []CoinUpdateManyWithWhereNestedInput              `json:"updateMany,omitempty"`
}

type CoinUpdateWithWhereUniqueWithoutCategoriesInput struct {
	Where CoinWhereUniqueInput                 `json:"where"`
	Data  CoinUpdateWithoutCategoriesDataInput `json:"data"`
}

type CoinUpdateWithoutCategoriesDataInput struct {
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type FileInfoUpdateOneWithoutCoinInput struct {
	Create     *FileInfoCreateWithoutCoinInput     `json:"create,omitempty"`
	Update     *FileInfoUpdateWithoutCoinDataInput `json:"update,omitempty"`
	Upsert     *FileInfoUpsertWithoutCoinInput     `json:"upsert,omitempty"`
	Delete     *bool                               `json:"delete,omitempty"`
	Disconnect *bool                               `json:"disconnect,omitempty"`
	Connect    *FileInfoWhereUniqueInput           `json:"connect,omitempty"`
}

type FileInfoUpdateWithoutCoinDataInput struct {
	Post         *PostUpdateOneWithoutFileListInput `json:"post,omitempty"`
	TempFileId   *string                            `json:"tempFileId,omitempty"`
	LocationPath *string                            `json:"locationPath,omitempty"`
	Name         *string                            `json:"name,omitempty"`
	ContentType  *string                            `json:"contentType,omitempty"`
	Url          *string                            `json:"url,omitempty"`
	Owner        *UserUpdateOneWithoutFileListInput `json:"owner,omitempty"`
	IsVideo      *bool                              `json:"isVideo,omitempty"`
	IsDel        *bool                              `json:"isDel,omitempty"`
}

type PostUpdateOneWithoutFileListInput struct {
	Create     *PostCreateWithoutFileListInput     `json:"create,omitempty"`
	Update     *PostUpdateWithoutFileListDataInput `json:"update,omitempty"`
	Upsert     *PostUpsertWithoutFileListInput     `json:"upsert,omitempty"`
	Delete     *bool                               `json:"delete,omitempty"`
	Disconnect *bool                               `json:"disconnect,omitempty"`
	Connect    *PostWhereUniqueInput               `json:"connect,omitempty"`
}

type PostUpdateWithoutFileListDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type UserUpdateOneRequiredWithoutPostsInput struct {
	Create  *UserCreateWithoutPostsInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutPostsDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutPostsInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput            `json:"connect,omitempty"`
}

type UserUpdateWithoutPostsDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PostUpdateManyWithoutToUserInput struct {
	Create     []PostCreateWithoutToUserInput                `json:"create,omitempty"`
	Delete     []PostWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []PostWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []PostWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []PostWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []PostUpdateWithWhereUniqueWithoutToUserInput `json:"update,omitempty"`
	Upsert     []PostUpsertWithWhereUniqueWithoutToUserInput `json:"upsert,omitempty"`
	DeleteMany []PostScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []PostUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type PostUpdateWithWhereUniqueWithoutToUserInput struct {
	Where PostWhereUniqueInput             `json:"where"`
	Data  PostUpdateWithoutToUserDataInput `json:"data"`
}

type PostUpdateWithoutToUserDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type CoinUpdateOneRequiredWithoutPostsInput struct {
	Create  *CoinCreateWithoutPostsInput     `json:"create,omitempty"`
	Update  *CoinUpdateWithoutPostsDataInput `json:"update,omitempty"`
	Upsert  *CoinUpsertWithoutPostsInput     `json:"upsert,omitempty"`
	Connect *CoinWhereUniqueInput            `json:"connect,omitempty"`
}

type CoinUpdateWithoutPostsDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type WalletUpdateManyWithoutCoinInput struct {
	Create     []WalletCreateWithoutCoinInput                `json:"create,omitempty"`
	Delete     []WalletWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []WalletWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []WalletWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []WalletWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []WalletUpdateWithWhereUniqueWithoutCoinInput `json:"update,omitempty"`
	Upsert     []WalletUpsertWithWhereUniqueWithoutCoinInput `json:"upsert,omitempty"`
	DeleteMany []WalletScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []WalletUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type WalletUpdateWithWhereUniqueWithoutCoinInput struct {
	Where WalletWhereUniqueInput           `json:"where"`
	Data  WalletUpdateWithoutCoinDataInput `json:"data"`
}

type WalletUpdateWithoutCoinDataInput struct {
	Owner                      *UserUpdateOneRequiredWithoutWalletsInput `json:"owner,omitempty"`
	NumIdCoinName              *string                                   `json:"numIdCoinName,omitempty"`
	CumulativePurchaseQuantity *float64                                  `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseValue    *float64                                  `json:"cumulativePurchaseValue,omitempty"`
}

type UserUpdateOneRequiredWithoutWalletsInput struct {
	Create  *UserCreateWithoutWalletsInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutWalletsDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutWalletsInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput              `json:"connect,omitempty"`
}

type UserUpdateWithoutWalletsDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PostUpdateManyWithoutOwnerInput struct {
	Create     []PostCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []PostWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []PostWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []PostWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []PostWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []PostUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []PostUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []PostScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []PostUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type PostUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where PostWhereUniqueInput            `json:"where"`
	Data  PostUpdateWithoutOwnerDataInput `json:"data"`
}

type PostUpdateWithoutOwnerDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type AirDropUpdateOneWithoutPostInput struct {
	Create     *AirDropCreateWithoutPostInput     `json:"create,omitempty"`
	Update     *AirDropUpdateWithoutPostDataInput `json:"update,omitempty"`
	Upsert     *AirDropUpsertWithoutPostInput     `json:"upsert,omitempty"`
	Delete     *bool                              `json:"delete,omitempty"`
	Disconnect *bool                              `json:"disconnect,omitempty"`
	Connect    *AirDropWhereUniqueInput           `json:"connect,omitempty"`
}

type AirDropUpdateWithoutPostDataInput struct {
	Status            *int32                                       `json:"status,omitempty"`
	DeployTxhash      *string                                      `json:"deployTxhash,omitempty"`
	ContractAddress   *string                                      `json:"contractAddress,omitempty"`
	RandomArrayString *string                                      `json:"randomArrayString,omitempty"`
	Amount            *float64                                     `json:"amount,omitempty"`
	Left              *float64                                     `json:"left,omitempty"`
	Members           *AirDropMemberUpdateManyWithoutAirDropInput  `json:"members,omitempty"`
	ToDate            *string                                      `json:"toDate,omitempty"`
	AirDropHistories  *AirDropHistoryUpdateManyWithoutAirDropInput `json:"airDropHistories,omitempty"`
	IsDel             *bool                                        `json:"isDel,omitempty"`
}

type AirDropMemberUpdateManyWithoutAirDropInput struct {
	Create     []AirDropMemberCreateWithoutAirDropInput                `json:"create,omitempty"`
	Delete     []AirDropMemberWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []AirDropMemberWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []AirDropMemberWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []AirDropMemberWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []AirDropMemberUpdateWithWhereUniqueWithoutAirDropInput `json:"update,omitempty"`
	Upsert     []AirDropMemberUpsertWithWhereUniqueWithoutAirDropInput `json:"upsert,omitempty"`
	DeleteMany []AirDropMemberScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []AirDropMemberUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type AirDropMemberUpdateWithWhereUniqueWithoutAirDropInput struct {
	Where AirDropMemberWhereUniqueInput              `json:"where"`
	Data  AirDropMemberUpdateWithoutAirDropDataInput `json:"data"`
}

type AirDropMemberUpdateWithoutAirDropDataInput struct {
	User           *UserUpdateOneRequiredWithoutAirDropMembersInput  `json:"user,omitempty"`
	DropNum        *int32                                            `json:"dropNum,omitempty"`
	Qty            *float64                                          `json:"qty,omitempty"`
	AirDropHistory *AirDropHistoryUpdateOneWithoutAirDropMemberInput `json:"airDropHistory,omitempty"`
	IsDel          *bool                                             `json:"isDel,omitempty"`
}

type UserUpdateOneRequiredWithoutAirDropMembersInput struct {
	Create  *UserCreateWithoutAirDropMembersInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutAirDropMembersDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutAirDropMembersInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput                     `json:"connect,omitempty"`
}

type UserUpdateWithoutAirDropMembersDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type CommentUpdateManyWithoutOwnerInput struct {
	Create     []CommentCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []CommentWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []CommentWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []CommentWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []CommentWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []CommentUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []CommentUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []CommentScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []CommentUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type CommentUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where CommentWhereUniqueInput            `json:"where"`
	Data  CommentUpdateWithoutOwnerDataInput `json:"data"`
}

type CommentUpdateWithoutOwnerDataInput struct {
	Type              *int32                                         `json:"type,omitempty"`
	Post              *PostUpdateOneRequiredWithoutCommentsInput     `json:"post,omitempty"`
	Content           *string                                        `json:"content,omitempty"`
	Image             *FileInfoUpdateOneInput                        `json:"image,omitempty"`
	Url               *string                                        `json:"url,omitempty"`
	Reply             *CommentReplyUpdateManyWithoutCommentInput     `json:"reply,omitempty"`
	PostRewardHistory *PostRewardHistoryUpdateOneWithoutCommentInput `json:"postRewardHistory,omitempty"`
	IsDel             *bool                                          `json:"isDel,omitempty"`
}

type PostUpdateOneRequiredWithoutCommentsInput struct {
	Create  *PostCreateWithoutCommentsInput     `json:"create,omitempty"`
	Update  *PostUpdateWithoutCommentsDataInput `json:"update,omitempty"`
	Upsert  *PostUpsertWithoutCommentsInput     `json:"upsert,omitempty"`
	Connect *PostWhereUniqueInput               `json:"connect,omitempty"`
}

type PostUpdateWithoutCommentsDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type FileUpdateOneWithoutPostInput struct {
	Create     *FileCreateWithoutPostInput     `json:"create,omitempty"`
	Update     *FileUpdateWithoutPostDataInput `json:"update,omitempty"`
	Upsert     *FileUpsertWithoutPostInput     `json:"upsert,omitempty"`
	Delete     *bool                           `json:"delete,omitempty"`
	Disconnect *bool                           `json:"disconnect,omitempty"`
	Connect    *FileWhereUniqueInput           `json:"connect,omitempty"`
}

type FileUpdateWithoutPostDataInput struct {
	Coin         *CoinUpdateOneWithoutImageInput `json:"coin,omitempty"`
	LocationPath *string                         `json:"locationPath,omitempty"`
	Name         *string                         `json:"name,omitempty"`
	ContentType  *string                         `json:"contentType,omitempty"`
	Url          *string                         `json:"url,omitempty"`
	Owner        *UserUpdateOneWithoutFilesInput `json:"owner,omitempty"`
	IsDel        *bool                           `json:"isDel,omitempty"`
}

type CoinUpdateOneWithoutImageInput struct {
	Create     *CoinCreateWithoutImageInput     `json:"create,omitempty"`
	Update     *CoinUpdateWithoutImageDataInput `json:"update,omitempty"`
	Upsert     *CoinUpsertWithoutImageInput     `json:"upsert,omitempty"`
	Delete     *bool                            `json:"delete,omitempty"`
	Disconnect *bool                            `json:"disconnect,omitempty"`
	Connect    *CoinWhereUniqueInput            `json:"connect,omitempty"`
}

type CoinUpdateWithoutImageDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type UserUpdateOneRequiredWithoutCoinInput struct {
	Create  *UserCreateWithoutCoinInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutCoinDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutCoinInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput           `json:"connect,omitempty"`
}

type UserUpdateWithoutCoinDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type FileUpdateManyWithoutOwnerInput struct {
	Create     []FileCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []FileWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []FileWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []FileWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []FileWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []FileUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []FileUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []FileScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []FileUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type FileUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where FileWhereUniqueInput            `json:"where"`
	Data  FileUpdateWithoutOwnerDataInput `json:"data"`
}

type FileUpdateWithoutOwnerDataInput struct {
	Coin         *CoinUpdateOneWithoutImageInput `json:"coin,omitempty"`
	Post         *PostUpdateOneWithoutImageInput `json:"post,omitempty"`
	LocationPath *string                         `json:"locationPath,omitempty"`
	Name         *string                         `json:"name,omitempty"`
	ContentType  *string                         `json:"contentType,omitempty"`
	Url          *string                         `json:"url,omitempty"`
	IsDel        *bool                           `json:"isDel,omitempty"`
}

type FileUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  FileWhereUniqueInput            `json:"where"`
	Update FileUpdateWithoutOwnerDataInput `json:"update"`
	Create FileCreateWithoutOwnerInput     `json:"create"`
}

type FileScalarWhereInput struct {
	ID                        *string                `json:"id,omitempty"`
	IDNot                     *string                `json:"id_not,omitempty"`
	IDIn                      []string               `json:"id_in,omitempty"`
	IDNotIn                   []string               `json:"id_not_in,omitempty"`
	IDLt                      *string                `json:"id_lt,omitempty"`
	IDLte                     *string                `json:"id_lte,omitempty"`
	IDGt                      *string                `json:"id_gt,omitempty"`
	IDGte                     *string                `json:"id_gte,omitempty"`
	IDContains                *string                `json:"id_contains,omitempty"`
	IDNotContains             *string                `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                `json:"id_not_ends_with,omitempty"`
	LocationPath              *string                `json:"locationPath,omitempty"`
	LocationPathNot           *string                `json:"locationPath_not,omitempty"`
	LocationPathIn            []string               `json:"locationPath_in,omitempty"`
	LocationPathNotIn         []string               `json:"locationPath_not_in,omitempty"`
	LocationPathLt            *string                `json:"locationPath_lt,omitempty"`
	LocationPathLte           *string                `json:"locationPath_lte,omitempty"`
	LocationPathGt            *string                `json:"locationPath_gt,omitempty"`
	LocationPathGte           *string                `json:"locationPath_gte,omitempty"`
	LocationPathContains      *string                `json:"locationPath_contains,omitempty"`
	LocationPathNotContains   *string                `json:"locationPath_not_contains,omitempty"`
	LocationPathStartsWith    *string                `json:"locationPath_starts_with,omitempty"`
	LocationPathNotStartsWith *string                `json:"locationPath_not_starts_with,omitempty"`
	LocationPathEndsWith      *string                `json:"locationPath_ends_with,omitempty"`
	LocationPathNotEndsWith   *string                `json:"locationPath_not_ends_with,omitempty"`
	Name                      *string                `json:"name,omitempty"`
	NameNot                   *string                `json:"name_not,omitempty"`
	NameIn                    []string               `json:"name_in,omitempty"`
	NameNotIn                 []string               `json:"name_not_in,omitempty"`
	NameLt                    *string                `json:"name_lt,omitempty"`
	NameLte                   *string                `json:"name_lte,omitempty"`
	NameGt                    *string                `json:"name_gt,omitempty"`
	NameGte                   *string                `json:"name_gte,omitempty"`
	NameContains              *string                `json:"name_contains,omitempty"`
	NameNotContains           *string                `json:"name_not_contains,omitempty"`
	NameStartsWith            *string                `json:"name_starts_with,omitempty"`
	NameNotStartsWith         *string                `json:"name_not_starts_with,omitempty"`
	NameEndsWith              *string                `json:"name_ends_with,omitempty"`
	NameNotEndsWith           *string                `json:"name_not_ends_with,omitempty"`
	ContentType               *string                `json:"contentType,omitempty"`
	ContentTypeNot            *string                `json:"contentType_not,omitempty"`
	ContentTypeIn             []string               `json:"contentType_in,omitempty"`
	ContentTypeNotIn          []string               `json:"contentType_not_in,omitempty"`
	ContentTypeLt             *string                `json:"contentType_lt,omitempty"`
	ContentTypeLte            *string                `json:"contentType_lte,omitempty"`
	ContentTypeGt             *string                `json:"contentType_gt,omitempty"`
	ContentTypeGte            *string                `json:"contentType_gte,omitempty"`
	ContentTypeContains       *string                `json:"contentType_contains,omitempty"`
	ContentTypeNotContains    *string                `json:"contentType_not_contains,omitempty"`
	ContentTypeStartsWith     *string                `json:"contentType_starts_with,omitempty"`
	ContentTypeNotStartsWith  *string                `json:"contentType_not_starts_with,omitempty"`
	ContentTypeEndsWith       *string                `json:"contentType_ends_with,omitempty"`
	ContentTypeNotEndsWith    *string                `json:"contentType_not_ends_with,omitempty"`
	Url                       *string                `json:"url,omitempty"`
	UrlNot                    *string                `json:"url_not,omitempty"`
	UrlIn                     []string               `json:"url_in,omitempty"`
	UrlNotIn                  []string               `json:"url_not_in,omitempty"`
	UrlLt                     *string                `json:"url_lt,omitempty"`
	UrlLte                    *string                `json:"url_lte,omitempty"`
	UrlGt                     *string                `json:"url_gt,omitempty"`
	UrlGte                    *string                `json:"url_gte,omitempty"`
	UrlContains               *string                `json:"url_contains,omitempty"`
	UrlNotContains            *string                `json:"url_not_contains,omitempty"`
	UrlStartsWith             *string                `json:"url_starts_with,omitempty"`
	UrlNotStartsWith          *string                `json:"url_not_starts_with,omitempty"`
	UrlEndsWith               *string                `json:"url_ends_with,omitempty"`
	UrlNotEndsWith            *string                `json:"url_not_ends_with,omitempty"`
	CreatedAt                 *string                `json:"createdAt,omitempty"`
	CreatedAtNot              *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string                `json:"createdAt_gte,omitempty"`
	IsDel                     *bool                  `json:"isDel,omitempty"`
	IsDelNot                  *bool                  `json:"isDel_not,omitempty"`
	And                       []FileScalarWhereInput `json:"AND,omitempty"`
	Or                        []FileScalarWhereInput `json:"OR,omitempty"`
	Not                       []FileScalarWhereInput `json:"NOT,omitempty"`
}

type FileUpdateManyWithWhereNestedInput struct {
	Where FileScalarWhereInput    `json:"where"`
	Data  FileUpdateManyDataInput `json:"data"`
}

type FileUpdateManyDataInput struct {
	LocationPath *string `json:"locationPath,omitempty"`
	Name         *string `json:"name,omitempty"`
	ContentType  *string `json:"contentType,omitempty"`
	Url          *string `json:"url,omitempty"`
	IsDel        *bool   `json:"isDel,omitempty"`
}

type FileInfoUpdateManyWithoutOwnerInput struct {
	Create     []FileInfoCreateWithoutOwnerInput                `json:"create,omitempty"`
	Delete     []FileInfoWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []FileInfoWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []FileInfoWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []FileInfoWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []FileInfoUpdateWithWhereUniqueWithoutOwnerInput `json:"update,omitempty"`
	Upsert     []FileInfoUpsertWithWhereUniqueWithoutOwnerInput `json:"upsert,omitempty"`
	DeleteMany []FileInfoScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []FileInfoUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type FileInfoUpdateWithWhereUniqueWithoutOwnerInput struct {
	Where FileInfoWhereUniqueInput            `json:"where"`
	Data  FileInfoUpdateWithoutOwnerDataInput `json:"data"`
}

type FileInfoUpdateWithoutOwnerDataInput struct {
	Coin         *CoinUpdateOneWithoutPictureInput  `json:"coin,omitempty"`
	Post         *PostUpdateOneWithoutFileListInput `json:"post,omitempty"`
	TempFileId   *string                            `json:"tempFileId,omitempty"`
	LocationPath *string                            `json:"locationPath,omitempty"`
	Name         *string                            `json:"name,omitempty"`
	ContentType  *string                            `json:"contentType,omitempty"`
	Url          *string                            `json:"url,omitempty"`
	IsVideo      *bool                              `json:"isVideo,omitempty"`
	IsDel        *bool                              `json:"isDel,omitempty"`
}

type CoinUpdateOneWithoutPictureInput struct {
	Create     *CoinCreateWithoutPictureInput     `json:"create,omitempty"`
	Update     *CoinUpdateWithoutPictureDataInput `json:"update,omitempty"`
	Upsert     *CoinUpsertWithoutPictureInput     `json:"upsert,omitempty"`
	Delete     *bool                              `json:"delete,omitempty"`
	Disconnect *bool                              `json:"disconnect,omitempty"`
	Connect    *CoinWhereUniqueInput              `json:"connect,omitempty"`
}

type CoinUpdateWithoutPictureDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type PostUpdateManyWithoutCoinInput struct {
	Create     []PostCreateWithoutCoinInput                `json:"create,omitempty"`
	Delete     []PostWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []PostWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []PostWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []PostWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []PostUpdateWithWhereUniqueWithoutCoinInput `json:"update,omitempty"`
	Upsert     []PostUpsertWithWhereUniqueWithoutCoinInput `json:"upsert,omitempty"`
	DeleteMany []PostScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []PostUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type PostUpdateWithWhereUniqueWithoutCoinInput struct {
	Where PostWhereUniqueInput           `json:"where"`
	Data  PostUpdateWithoutCoinDataInput `json:"data"`
}

type PostUpdateWithoutCoinDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type FileInfoUpdateManyWithoutPostInput struct {
	Create     []FileInfoCreateWithoutPostInput                `json:"create,omitempty"`
	Delete     []FileInfoWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []FileInfoWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []FileInfoWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []FileInfoWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []FileInfoUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
	Upsert     []FileInfoUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
	DeleteMany []FileInfoScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []FileInfoUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type FileInfoUpdateWithWhereUniqueWithoutPostInput struct {
	Where FileInfoWhereUniqueInput           `json:"where"`
	Data  FileInfoUpdateWithoutPostDataInput `json:"data"`
}

type FileInfoUpdateWithoutPostDataInput struct {
	Coin         *CoinUpdateOneWithoutPictureInput  `json:"coin,omitempty"`
	TempFileId   *string                            `json:"tempFileId,omitempty"`
	LocationPath *string                            `json:"locationPath,omitempty"`
	Name         *string                            `json:"name,omitempty"`
	ContentType  *string                            `json:"contentType,omitempty"`
	Url          *string                            `json:"url,omitempty"`
	Owner        *UserUpdateOneWithoutFileListInput `json:"owner,omitempty"`
	IsVideo      *bool                              `json:"isVideo,omitempty"`
	IsDel        *bool                              `json:"isDel,omitempty"`
}

type UserUpdateOneWithoutFileListInput struct {
	Create     *UserCreateWithoutFileListInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutFileListDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutFileListInput     `json:"upsert,omitempty"`
	Delete     *bool                               `json:"delete,omitempty"`
	Disconnect *bool                               `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput               `json:"connect,omitempty"`
}

type UserUpdateWithoutFileListDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PostUpdateManyWithoutLikesInput struct {
	Create     []PostCreateWithoutLikesInput                `json:"create,omitempty"`
	Delete     []PostWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []PostWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []PostWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []PostWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []PostUpdateWithWhereUniqueWithoutLikesInput `json:"update,omitempty"`
	Upsert     []PostUpsertWithWhereUniqueWithoutLikesInput `json:"upsert,omitempty"`
	DeleteMany []PostScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []PostUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type PostUpdateWithWhereUniqueWithoutLikesInput struct {
	Where PostWhereUniqueInput            `json:"where"`
	Data  PostUpdateWithoutLikesDataInput `json:"data"`
}

type PostUpdateWithoutLikesDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type QuestMemberUpdateManyWithoutPostInput struct {
	Create     []QuestMemberCreateWithoutPostInput                `json:"create,omitempty"`
	Delete     []QuestMemberWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []QuestMemberWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []QuestMemberWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []QuestMemberWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []QuestMemberUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
	Upsert     []QuestMemberUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
	DeleteMany []QuestMemberScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []QuestMemberUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type QuestMemberUpdateWithWhereUniqueWithoutPostInput struct {
	Where QuestMemberWhereUniqueInput           `json:"where"`
	Data  QuestMemberUpdateWithoutPostDataInput `json:"data"`
}

type QuestMemberUpdateWithoutPostDataInput struct {
	User  *UserUpdateOneRequiredWithoutJoinedQuestsInput `json:"user,omitempty"`
	Note  *string                                        `json:"note,omitempty"`
	IsDel *bool                                          `json:"isDel,omitempty"`
}

type UserUpdateOneRequiredWithoutJoinedQuestsInput struct {
	Create  *UserCreateWithoutJoinedQuestsInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutJoinedQuestsDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutJoinedQuestsInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput                   `json:"connect,omitempty"`
}

type UserUpdateWithoutJoinedQuestsDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PostUpdateManyWithoutViewsInput struct {
	Create     []PostCreateWithoutViewsInput                `json:"create,omitempty"`
	Delete     []PostWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []PostWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []PostWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []PostWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []PostUpdateWithWhereUniqueWithoutViewsInput `json:"update,omitempty"`
	Upsert     []PostUpsertWithWhereUniqueWithoutViewsInput `json:"upsert,omitempty"`
	DeleteMany []PostScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []PostUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type PostUpdateWithWhereUniqueWithoutViewsInput struct {
	Where PostWhereUniqueInput            `json:"where"`
	Data  PostUpdateWithoutViewsDataInput `json:"data"`
}

type PostUpdateWithoutViewsDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type MotherHistoryUpdateManyWithoutPostInput struct {
	Create     []MotherHistoryCreateWithoutPostInput                `json:"create,omitempty"`
	Delete     []MotherHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []MotherHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []MotherHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []MotherHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []MotherHistoryUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
	Upsert     []MotherHistoryUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
	DeleteMany []MotherHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []MotherHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type MotherHistoryUpdateWithWhereUniqueWithoutPostInput struct {
	Where MotherHistoryWhereUniqueInput           `json:"where"`
	Data  MotherHistoryUpdateWithoutPostDataInput `json:"data"`
}

type MotherHistoryUpdateWithoutPostDataInput struct {
	Type                    *int32                                                     `json:"type,omitempty"`
	RoleTime                *string                                                    `json:"roleTime,omitempty"`
	Coin                    *CoinUpdateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserUpdateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryUpdateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryUpdateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryUpdateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryUpdateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryUpdateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type CoinUpdateOneWithoutMotherHistoriesInput struct {
	Create     *CoinCreateWithoutMotherHistoriesInput     `json:"create,omitempty"`
	Update     *CoinUpdateWithoutMotherHistoriesDataInput `json:"update,omitempty"`
	Upsert     *CoinUpsertWithoutMotherHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                      `json:"delete,omitempty"`
	Disconnect *bool                                      `json:"disconnect,omitempty"`
	Connect    *CoinWhereUniqueInput                      `json:"connect,omitempty"`
}

type CoinUpdateWithoutMotherHistoriesDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type OfferUpdateOneWithoutCoinInput struct {
	Create     *OfferCreateWithoutCoinInput     `json:"create,omitempty"`
	Update     *OfferUpdateWithoutCoinDataInput `json:"update,omitempty"`
	Upsert     *OfferUpsertWithoutCoinInput     `json:"upsert,omitempty"`
	Delete     *bool                            `json:"delete,omitempty"`
	Disconnect *bool                            `json:"disconnect,omitempty"`
	Connect    *OfferWhereUniqueInput           `json:"connect,omitempty"`
}

type OfferUpdateWithoutCoinDataInput struct {
	Qty      *int32                              `json:"qty,omitempty"`
	Offeror  *OfferorUpdateManyWithoutOfferInput `json:"offeror,omitempty"`
	FromDate *string                             `json:"fromDate,omitempty"`
	ToDate   *string                             `json:"toDate,omitempty"`
}

type OfferorUpdateManyWithoutOfferInput struct {
	Create     []OfferorCreateWithoutOfferInput                `json:"create,omitempty"`
	Delete     []OfferorWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []OfferorWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []OfferorWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []OfferorWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []OfferorUpdateWithWhereUniqueWithoutOfferInput `json:"update,omitempty"`
	Upsert     []OfferorUpsertWithWhereUniqueWithoutOfferInput `json:"upsert,omitempty"`
	DeleteMany []OfferorScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []OfferorUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type OfferorUpdateWithWhereUniqueWithoutOfferInput struct {
	Where OfferorWhereUniqueInput            `json:"where"`
	Data  OfferorUpdateWithoutOfferDataInput `json:"data"`
}

type OfferorUpdateWithoutOfferDataInput struct {
	Price *int32                                      `json:"price,omitempty"`
	User  *UserUpdateOneRequiredWithoutJoinOfferInput `json:"user,omitempty"`
}

type UserUpdateOneRequiredWithoutJoinOfferInput struct {
	Create  *UserCreateWithoutJoinOfferInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutJoinOfferDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutJoinOfferInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput                `json:"connect,omitempty"`
}

type UserUpdateWithoutJoinOfferDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type ReportUpdateManyWithoutReportUserInput struct {
	Create     []ReportCreateWithoutReportUserInput                `json:"create,omitempty"`
	Delete     []ReportWhereUniqueInput                            `json:"delete,omitempty"`
	Connect    []ReportWhereUniqueInput                            `json:"connect,omitempty"`
	Set        []ReportWhereUniqueInput                            `json:"set,omitempty"`
	Disconnect []ReportWhereUniqueInput                            `json:"disconnect,omitempty"`
	Update     []ReportUpdateWithWhereUniqueWithoutReportUserInput `json:"update,omitempty"`
	Upsert     []ReportUpsertWithWhereUniqueWithoutReportUserInput `json:"upsert,omitempty"`
	DeleteMany []ReportScalarWhereInput                            `json:"deleteMany,omitempty"`
	UpdateMany []ReportUpdateManyWithWhereNestedInput              `json:"updateMany,omitempty"`
}

type ReportUpdateWithWhereUniqueWithoutReportUserInput struct {
	Where ReportWhereUniqueInput                 `json:"where"`
	Data  ReportUpdateWithoutReportUserDataInput `json:"data"`
}

type ReportUpdateWithoutReportUserDataInput struct {
	Type       *int32                                 `json:"type,omitempty"`
	ReportType *int32                                 `json:"reportType,omitempty"`
	TargetPost *PostUpdateOneInput                    `json:"targetPost,omitempty"`
	TargetUser *UserUpdateOneWithoutTargetReportInput `json:"targetUser,omitempty"`
}

type PostUpdateOneInput struct {
	Create     *PostCreateInput       `json:"create,omitempty"`
	Update     *PostUpdateDataInput   `json:"update,omitempty"`
	Upsert     *PostUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                  `json:"delete,omitempty"`
	Disconnect *bool                  `json:"disconnect,omitempty"`
	Connect    *PostWhereUniqueInput  `json:"connect,omitempty"`
}

type PostUpdateDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type QuestExpenditureHistoryUpdateManyWithoutPostInput struct {
	Create     []QuestExpenditureHistoryCreateWithoutPostInput                `json:"create,omitempty"`
	Delete     []QuestExpenditureHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []QuestExpenditureHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []QuestExpenditureHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []QuestExpenditureHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []QuestExpenditureHistoryUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
	Upsert     []QuestExpenditureHistoryUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
	DeleteMany []QuestExpenditureHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []QuestExpenditureHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type QuestExpenditureHistoryUpdateWithWhereUniqueWithoutPostInput struct {
	Where QuestExpenditureHistoryWhereUniqueInput           `json:"where"`
	Data  QuestExpenditureHistoryUpdateWithoutPostDataInput `json:"data"`
}

type QuestExpenditureHistoryUpdateWithoutPostDataInput struct {
	Type          *int32                                                     `json:"type,omitempty"`
	PayType       *int32                                                     `json:"payType,omitempty"`
	OrderNum      *int32                                                     `json:"orderNum,omitempty"`
	Description   *string                                                    `json:"description,omitempty"`
	User          *UserUpdateOneWithoutQuestExpenditureHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutQuestExpenditureHistoryInput `json:"motherHistory,omitempty"`
	CashHistory   *CashHistoryUpdateOneWithoutQehInput                       `json:"cashHistory,omitempty"`
	Price         *int32                                                     `json:"price,omitempty"`
	Qty           *float64                                                   `json:"qty,omitempty"`
	OPrice        *int32                                                     `json:"oPrice,omitempty"`
	CurrentPrice  *float64                                                   `json:"currentPrice,omitempty"`
	Memo          *string                                                    `json:"memo,omitempty"`
}

type UserUpdateOneWithoutQuestExpenditureHistoriesInput struct {
	Create     *UserCreateWithoutQuestExpenditureHistoriesInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutQuestExpenditureHistoriesDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutQuestExpenditureHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                                `json:"delete,omitempty"`
	Disconnect *bool                                                `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                                `json:"connect,omitempty"`
}

type UserUpdateWithoutQuestExpenditureHistoriesDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type OfferorUpdateManyWithoutUserInput struct {
	Create     []OfferorCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []OfferorWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []OfferorWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []OfferorWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []OfferorWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []OfferorUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []OfferorUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []OfferorScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []OfferorUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type OfferorUpdateWithWhereUniqueWithoutUserInput struct {
	Where OfferorWhereUniqueInput           `json:"where"`
	Data  OfferorUpdateWithoutUserDataInput `json:"data"`
}

type OfferorUpdateWithoutUserDataInput struct {
	Price *int32                                     `json:"price,omitempty"`
	Offer *OfferUpdateOneRequiredWithoutOfferorInput `json:"offer,omitempty"`
}

type OfferUpdateOneRequiredWithoutOfferorInput struct {
	Create  *OfferCreateWithoutOfferorInput     `json:"create,omitempty"`
	Update  *OfferUpdateWithoutOfferorDataInput `json:"update,omitempty"`
	Upsert  *OfferUpsertWithoutOfferorInput     `json:"upsert,omitempty"`
	Connect *OfferWhereUniqueInput              `json:"connect,omitempty"`
}

type OfferUpdateWithoutOfferorDataInput struct {
	Coin     *CoinUpdateOneRequiredWithoutOfferInput `json:"coin,omitempty"`
	Qty      *int32                                  `json:"qty,omitempty"`
	FromDate *string                                 `json:"fromDate,omitempty"`
	ToDate   *string                                 `json:"toDate,omitempty"`
}

type CoinUpdateOneRequiredWithoutOfferInput struct {
	Create  *CoinCreateWithoutOfferInput     `json:"create,omitempty"`
	Update  *CoinUpdateWithoutOfferDataInput `json:"update,omitempty"`
	Upsert  *CoinUpsertWithoutOfferInput     `json:"upsert,omitempty"`
	Connect *CoinWhereUniqueInput            `json:"connect,omitempty"`
}

type CoinUpdateWithoutOfferDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type OrderHistoryUpdateManyWithoutCoinInput struct {
	Create     []OrderHistoryCreateWithoutCoinInput                `json:"create,omitempty"`
	Delete     []OrderHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []OrderHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []OrderHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []OrderHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []OrderHistoryUpdateWithWhereUniqueWithoutCoinInput `json:"update,omitempty"`
	Upsert     []OrderHistoryUpsertWithWhereUniqueWithoutCoinInput `json:"upsert,omitempty"`
	DeleteMany []OrderHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []OrderHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type OrderHistoryUpdateWithWhereUniqueWithoutCoinInput struct {
	Where OrderHistoryWhereUniqueInput           `json:"where"`
	Data  OrderHistoryUpdateWithoutCoinDataInput `json:"data"`
}

type OrderHistoryUpdateWithoutCoinDataInput struct {
	Type                    *int32                                                   `json:"type,omitempty"`
	OrderNum                *int32                                                   `json:"orderNum,omitempty"`
	User                    *UserUpdateOneWithoutOrderHistoriesInput                 `json:"user,omitempty"`
	MotherHistory           *MotherHistoryUpdateOneWithoutOrderHistoryInput          `json:"motherHistory,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutOrderHistoryInput `json:"orderUserDealsHistories,omitempty"`
	OrderPrice              *float64                                                 `json:"orderPrice,omitempty"`
	DealPrice               *float64                                                 `json:"dealPrice,omitempty"`
	OrderQty                *float64                                                 `json:"orderQty,omitempty"`
	DealQty                 *float64                                                 `json:"dealQty,omitempty"`
	LeftQty                 *float64                                                 `json:"leftQty,omitempty"`
	DealFee                 *float64                                                 `json:"dealFee,omitempty"`
	TakerFee                *float64                                                 `json:"takerFee,omitempty"`
	MakerFee                *float64                                                 `json:"makerFee,omitempty"`
	Memo                    *string                                                  `json:"memo,omitempty"`
	Description             *string                                                  `json:"description,omitempty"`
	Offset                  *int32                                                   `json:"offset,omitempty"`
	IsCancel                *bool                                                    `json:"isCancel,omitempty"`
}

type UserUpdateOneWithoutOrderHistoriesInput struct {
	Create     *UserCreateWithoutOrderHistoriesInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutOrderHistoriesDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutOrderHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                     `json:"delete,omitempty"`
	Disconnect *bool                                     `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                     `json:"connect,omitempty"`
}

type UserUpdateWithoutOrderHistoriesDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type ReportUpdateManyWithoutTargetUserInput struct {
	Create     []ReportCreateWithoutTargetUserInput                `json:"create,omitempty"`
	Delete     []ReportWhereUniqueInput                            `json:"delete,omitempty"`
	Connect    []ReportWhereUniqueInput                            `json:"connect,omitempty"`
	Set        []ReportWhereUniqueInput                            `json:"set,omitempty"`
	Disconnect []ReportWhereUniqueInput                            `json:"disconnect,omitempty"`
	Update     []ReportUpdateWithWhereUniqueWithoutTargetUserInput `json:"update,omitempty"`
	Upsert     []ReportUpsertWithWhereUniqueWithoutTargetUserInput `json:"upsert,omitempty"`
	DeleteMany []ReportScalarWhereInput                            `json:"deleteMany,omitempty"`
	UpdateMany []ReportUpdateManyWithWhereNestedInput              `json:"updateMany,omitempty"`
}

type ReportUpdateWithWhereUniqueWithoutTargetUserInput struct {
	Where ReportWhereUniqueInput                 `json:"where"`
	Data  ReportUpdateWithoutTargetUserDataInput `json:"data"`
}

type ReportUpdateWithoutTargetUserDataInput struct {
	Type       *int32                                     `json:"type,omitempty"`
	ReportUser *UserUpdateOneRequiredWithoutMyReportInput `json:"reportUser,omitempty"`
	ReportType *int32                                     `json:"reportType,omitempty"`
	TargetPost *PostUpdateOneInput                        `json:"targetPost,omitempty"`
}

type UserUpdateOneRequiredWithoutMyReportInput struct {
	Create  *UserCreateWithoutMyReportInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutMyReportDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutMyReportInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput               `json:"connect,omitempty"`
}

type UserUpdateWithoutMyReportDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type QuestMemberUpdateManyWithoutUserInput struct {
	Create     []QuestMemberCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []QuestMemberWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []QuestMemberWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []QuestMemberWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []QuestMemberWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []QuestMemberUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []QuestMemberUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []QuestMemberScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []QuestMemberUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type QuestMemberUpdateWithWhereUniqueWithoutUserInput struct {
	Where QuestMemberWhereUniqueInput           `json:"where"`
	Data  QuestMemberUpdateWithoutUserDataInput `json:"data"`
}

type QuestMemberUpdateWithoutUserDataInput struct {
	Post  *PostUpdateOneRequiredWithoutQuestMembersInput `json:"post,omitempty"`
	Note  *string                                        `json:"note,omitempty"`
	IsDel *bool                                          `json:"isDel,omitempty"`
}

type PostUpdateOneRequiredWithoutQuestMembersInput struct {
	Create  *PostCreateWithoutQuestMembersInput     `json:"create,omitempty"`
	Update  *PostUpdateWithoutQuestMembersDataInput `json:"update,omitempty"`
	Upsert  *PostUpsertWithoutQuestMembersInput     `json:"upsert,omitempty"`
	Connect *PostWhereUniqueInput                   `json:"connect,omitempty"`
}

type PostUpdateWithoutQuestMembersDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type PostRewardHistoryUpdateManyWithoutPostInput struct {
	Create     []PostRewardHistoryCreateWithoutPostInput                `json:"create,omitempty"`
	Delete     []PostRewardHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []PostRewardHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []PostRewardHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []PostRewardHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []PostRewardHistoryUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
	Upsert     []PostRewardHistoryUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
	DeleteMany []PostRewardHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []PostRewardHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type PostRewardHistoryUpdateWithWhereUniqueWithoutPostInput struct {
	Where PostRewardHistoryWhereUniqueInput           `json:"where"`
	Data  PostRewardHistoryUpdateWithoutPostDataInput `json:"data"`
}

type PostRewardHistoryUpdateWithoutPostDataInput struct {
	Type          *int32                                               `json:"type,omitempty"`
	Description   *string                                              `json:"description,omitempty"`
	User          *UserUpdateOneWithoutPostRewardHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutPostRewardHistoryInput `json:"motherHistory,omitempty"`
	Comment       *CommentUpdateOneWithoutPostRewardHistoryInput       `json:"comment,omitempty"`
	Qty           *float64                                             `json:"qty,omitempty"`
	CurrentPrice  *float64                                             `json:"currentPrice,omitempty"`
	Memo          *string                                              `json:"memo,omitempty"`
}

type UserUpdateOneWithoutPostRewardHistoriesInput struct {
	Create     *UserCreateWithoutPostRewardHistoriesInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutPostRewardHistoriesDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutPostRewardHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                          `json:"delete,omitempty"`
	Disconnect *bool                                          `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                          `json:"connect,omitempty"`
}

type UserUpdateWithoutPostRewardHistoriesDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type AdminUserUpdateOneWithoutMembersInput struct {
	Create     *AdminUserCreateWithoutMembersInput     `json:"create,omitempty"`
	Update     *AdminUserUpdateWithoutMembersDataInput `json:"update,omitempty"`
	Upsert     *AdminUserUpsertWithoutMembersInput     `json:"upsert,omitempty"`
	Delete     *bool                                   `json:"delete,omitempty"`
	Disconnect *bool                                   `json:"disconnect,omitempty"`
	Connect    *AdminUserWhereUniqueInput              `json:"connect,omitempty"`
}

type AdminUserUpdateWithoutMembersDataInput struct {
	Role               *Role                                        `json:"role,omitempty"`
	Email              *string                                      `json:"email,omitempty"`
	Password           *string                                      `json:"password,omitempty"`
	NickName           *string                                      `json:"nickName,omitempty"`
	OtpKey             *string                                      `json:"otpKey,omitempty"`
	Level              *string                                      `json:"level,omitempty"`
	CreateNotification *NotificationUpdateOneWithoutCreateUserInput `json:"createNotification,omitempty"`
	UpdateNotification *NotificationUpdateOneWithoutUpdateUserInput `json:"updateNotification,omitempty"`
}

type NotificationUpdateOneWithoutCreateUserInput struct {
	Create     *NotificationCreateWithoutCreateUserInput     `json:"create,omitempty"`
	Update     *NotificationUpdateWithoutCreateUserDataInput `json:"update,omitempty"`
	Upsert     *NotificationUpsertWithoutCreateUserInput     `json:"upsert,omitempty"`
	Delete     *bool                                         `json:"delete,omitempty"`
	Disconnect *bool                                         `json:"disconnect,omitempty"`
	Connect    *NotificationWhereUniqueInput                 `json:"connect,omitempty"`
}

type NotificationUpdateWithoutCreateUserDataInput struct {
	NotiType     *int32                                            `json:"notiType,omitempty"`
	PushType     *int32                                            `json:"pushType,omitempty"`
	PushState    *int32                                            `json:"pushState,omitempty"`
	User         *UserUpdateManyInput                              `json:"user,omitempty"`
	SendFailUser *UserUpdateManyInput                              `json:"sendFailUser,omitempty"`
	ByUser       *UserUpdateOneInput                               `json:"byUser,omitempty"`
	Post         *PostUpdateOneInput                               `json:"post,omitempty"`
	Coin         *CoinUpdateOneInput                               `json:"coin,omitempty"`
	Topic        *string                                           `json:"topic,omitempty"`
	LinkType     *string                                           `json:"linkType,omitempty"`
	LinkValue    *string                                           `json:"linkValue,omitempty"`
	Message      *string                                           `json:"message,omitempty"`
	Image        *string                                           `json:"image,omitempty"`
	PublishType  *int32                                            `json:"publishType,omitempty"`
	PublishDate  *string                                           `json:"publishDate,omitempty"`
	UpdateUser   *AdminUserUpdateOneWithoutUpdateNotificationInput `json:"updateUser,omitempty"`
	IsDel        *bool                                             `json:"isDel,omitempty"`
}

type UserUpdateManyInput struct {
	Create     []UserCreateInput                      `json:"create,omitempty"`
	Update     []UserUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []UserWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []UserScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type UserUpdateWithWhereUniqueNestedInput struct {
	Where UserWhereUniqueInput `json:"where"`
	Data  UserUpdateDataInput  `json:"data"`
}

type UserUpdateDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type RewardDropAttendingUserUpdateManyWithoutUserInput struct {
	Create     []RewardDropAttendingUserCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []RewardDropAttendingUserWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []RewardDropAttendingUserWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []RewardDropAttendingUserWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []RewardDropAttendingUserWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []RewardDropAttendingUserUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []RewardDropAttendingUserUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []RewardDropAttendingUserScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []RewardDropAttendingUserUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type RewardDropAttendingUserUpdateWithWhereUniqueWithoutUserInput struct {
	Where RewardDropAttendingUserWhereUniqueInput           `json:"where"`
	Data  RewardDropAttendingUserUpdateWithoutUserDataInput `json:"data"`
}

type RewardDropAttendingUserUpdateWithoutUserDataInput struct {
	RewardDropEvent *RewardDropEventUpdateOneRequiredWithoutAttendingUsersInput `json:"rewardDropEvent,omitempty"`
	Memo            *string                                                     `json:"memo,omitempty"`
	IsDel           *bool                                                       `json:"isDel,omitempty"`
}

type RewardDropEventUpdateOneRequiredWithoutAttendingUsersInput struct {
	Create  *RewardDropEventCreateWithoutAttendingUsersInput     `json:"create,omitempty"`
	Update  *RewardDropEventUpdateWithoutAttendingUsersDataInput `json:"update,omitempty"`
	Upsert  *RewardDropEventUpsertWithoutAttendingUsersInput     `json:"upsert,omitempty"`
	Connect *RewardDropEventWhereUniqueInput                     `json:"connect,omitempty"`
}

type RewardDropEventUpdateWithoutAttendingUsersDataInput struct {
	EventId        *string             `json:"eventID,omitempty"`
	Type           *int32              `json:"type,omitempty"`
	Title          *string             `json:"title,omitempty"`
	Cash           *int32              `json:"cash,omitempty"`
	Coin           *CoinUpdateOneInput `json:"coin,omitempty"`
	Qty            *int32              `json:"qty,omitempty"`
	LimitUserCount *int32              `json:"limitUserCount,omitempty"`
	FromDate       *string             `json:"fromDate,omitempty"`
	ToDate         *string             `json:"toDate,omitempty"`
	IsDel          *bool               `json:"isDel,omitempty"`
}

type CoinUpdateOneInput struct {
	Create     *CoinCreateInput       `json:"create,omitempty"`
	Update     *CoinUpdateDataInput   `json:"update,omitempty"`
	Upsert     *CoinUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                  `json:"delete,omitempty"`
	Disconnect *bool                  `json:"disconnect,omitempty"`
	Connect    *CoinWhereUniqueInput  `json:"connect,omitempty"`
}

type CoinUpdateDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type OrderDealsHistoryUpdateManyWithoutCoinInput struct {
	Create     []OrderDealsHistoryCreateWithoutCoinInput                `json:"create,omitempty"`
	Delete     []OrderDealsHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []OrderDealsHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []OrderDealsHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []OrderDealsHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []OrderDealsHistoryUpdateWithWhereUniqueWithoutCoinInput `json:"update,omitempty"`
	Upsert     []OrderDealsHistoryUpsertWithWhereUniqueWithoutCoinInput `json:"upsert,omitempty"`
	DeleteMany []OrderDealsHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []OrderDealsHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type OrderDealsHistoryUpdateWithWhereUniqueWithoutCoinInput struct {
	Where OrderDealsHistoryWhereUniqueInput           `json:"where"`
	Data  OrderDealsHistoryUpdateWithoutCoinDataInput `json:"data"`
}

type OrderDealsHistoryUpdateWithoutCoinDataInput struct {
	Type      *int32   `json:"type,omitempty"`
	DealId    *int32   `json:"dealId,omitempty"`
	DealPrice *float64 `json:"dealPrice,omitempty"`
	DealQty   *float64 `json:"dealQty,omitempty"`
	Time      *float64 `json:"time,omitempty"`
}

type OrderDealsHistoryUpsertWithWhereUniqueWithoutCoinInput struct {
	Where  OrderDealsHistoryWhereUniqueInput           `json:"where"`
	Update OrderDealsHistoryUpdateWithoutCoinDataInput `json:"update"`
	Create OrderDealsHistoryCreateWithoutCoinInput     `json:"create"`
}

type OrderDealsHistoryScalarWhereInput struct {
	ID              *string                             `json:"id,omitempty"`
	IDNot           *string                             `json:"id_not,omitempty"`
	IDIn            []string                            `json:"id_in,omitempty"`
	IDNotIn         []string                            `json:"id_not_in,omitempty"`
	IDLt            *string                             `json:"id_lt,omitempty"`
	IDLte           *string                             `json:"id_lte,omitempty"`
	IDGt            *string                             `json:"id_gt,omitempty"`
	IDGte           *string                             `json:"id_gte,omitempty"`
	IDContains      *string                             `json:"id_contains,omitempty"`
	IDNotContains   *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                             `json:"id_not_ends_with,omitempty"`
	Type            *int32                              `json:"type,omitempty"`
	TypeNot         *int32                              `json:"type_not,omitempty"`
	TypeIn          []int32                             `json:"type_in,omitempty"`
	TypeNotIn       []int32                             `json:"type_not_in,omitempty"`
	TypeLt          *int32                              `json:"type_lt,omitempty"`
	TypeLte         *int32                              `json:"type_lte,omitempty"`
	TypeGt          *int32                              `json:"type_gt,omitempty"`
	TypeGte         *int32                              `json:"type_gte,omitempty"`
	DealId          *int32                              `json:"dealId,omitempty"`
	DealIdNot       *int32                              `json:"dealId_not,omitempty"`
	DealIdIn        []int32                             `json:"dealId_in,omitempty"`
	DealIdNotIn     []int32                             `json:"dealId_not_in,omitempty"`
	DealIdLt        *int32                              `json:"dealId_lt,omitempty"`
	DealIdLte       *int32                              `json:"dealId_lte,omitempty"`
	DealIdGt        *int32                              `json:"dealId_gt,omitempty"`
	DealIdGte       *int32                              `json:"dealId_gte,omitempty"`
	DealPrice       *float64                            `json:"dealPrice,omitempty"`
	DealPriceNot    *float64                            `json:"dealPrice_not,omitempty"`
	DealPriceIn     []float64                           `json:"dealPrice_in,omitempty"`
	DealPriceNotIn  []float64                           `json:"dealPrice_not_in,omitempty"`
	DealPriceLt     *float64                            `json:"dealPrice_lt,omitempty"`
	DealPriceLte    *float64                            `json:"dealPrice_lte,omitempty"`
	DealPriceGt     *float64                            `json:"dealPrice_gt,omitempty"`
	DealPriceGte    *float64                            `json:"dealPrice_gte,omitempty"`
	DealQty         *float64                            `json:"dealQty,omitempty"`
	DealQtyNot      *float64                            `json:"dealQty_not,omitempty"`
	DealQtyIn       []float64                           `json:"dealQty_in,omitempty"`
	DealQtyNotIn    []float64                           `json:"dealQty_not_in,omitempty"`
	DealQtyLt       *float64                            `json:"dealQty_lt,omitempty"`
	DealQtyLte      *float64                            `json:"dealQty_lte,omitempty"`
	DealQtyGt       *float64                            `json:"dealQty_gt,omitempty"`
	DealQtyGte      *float64                            `json:"dealQty_gte,omitempty"`
	Time            *float64                            `json:"time,omitempty"`
	TimeNot         *float64                            `json:"time_not,omitempty"`
	TimeIn          []float64                           `json:"time_in,omitempty"`
	TimeNotIn       []float64                           `json:"time_not_in,omitempty"`
	TimeLt          *float64                            `json:"time_lt,omitempty"`
	TimeLte         *float64                            `json:"time_lte,omitempty"`
	TimeGt          *float64                            `json:"time_gt,omitempty"`
	TimeGte         *float64                            `json:"time_gte,omitempty"`
	CreatedAt       *string                             `json:"createdAt,omitempty"`
	CreatedAtNot    *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                             `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                             `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                             `json:"updatedAt_gte,omitempty"`
	And             []OrderDealsHistoryScalarWhereInput `json:"AND,omitempty"`
	Or              []OrderDealsHistoryScalarWhereInput `json:"OR,omitempty"`
	Not             []OrderDealsHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type OrderDealsHistoryUpdateManyWithWhereNestedInput struct {
	Where OrderDealsHistoryScalarWhereInput    `json:"where"`
	Data  OrderDealsHistoryUpdateManyDataInput `json:"data"`
}

type OrderDealsHistoryUpdateManyDataInput struct {
	Type      *int32   `json:"type,omitempty"`
	DealId    *int32   `json:"dealId,omitempty"`
	DealPrice *float64 `json:"dealPrice,omitempty"`
	DealQty   *float64 `json:"dealQty,omitempty"`
	Time      *float64 `json:"time,omitempty"`
}

type OrderUserDealsHistoryUpdateManyWithoutCoinInput struct {
	Create     []OrderUserDealsHistoryCreateWithoutCoinInput                `json:"create,omitempty"`
	Delete     []OrderUserDealsHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []OrderUserDealsHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []OrderUserDealsHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []OrderUserDealsHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []OrderUserDealsHistoryUpdateWithWhereUniqueWithoutCoinInput `json:"update,omitempty"`
	Upsert     []OrderUserDealsHistoryUpsertWithWhereUniqueWithoutCoinInput `json:"upsert,omitempty"`
	DeleteMany []OrderUserDealsHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []OrderUserDealsHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type OrderUserDealsHistoryUpdateWithWhereUniqueWithoutCoinInput struct {
	Where OrderUserDealsHistoryWhereUniqueInput           `json:"where"`
	Data  OrderUserDealsHistoryUpdateWithoutCoinDataInput `json:"data"`
}

type OrderUserDealsHistoryUpdateWithoutCoinDataInput struct {
	Type          *int32                                                    `json:"type,omitempty"`
	Role          *int32                                                    `json:"role,omitempty"`
	DealId        *int32                                                    `json:"dealId,omitempty"`
	UniqueKey     *string                                                   `json:"uniqueKey,omitempty"`
	UniqueId      *int32                                                    `json:"uniqueId,omitempty"`
	User          *UserUpdateOneWithoutOrderUserDealsHistoriesInput         `json:"user,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutOrderUserDealsHistoryInput  `json:"motherHistory,omitempty"`
	OrderHistory  *OrderHistoryUpdateOneWithoutOrderUserDealsHistoriesInput `json:"orderHistory,omitempty"`
	DealPrice     *float64                                                  `json:"dealPrice,omitempty"`
	DealQty       *float64                                                  `json:"dealQty,omitempty"`
	Fee           *float64                                                  `json:"fee,omitempty"`
	DealOrderId   *int32                                                    `json:"dealOrderId,omitempty"`
	Time          *float64                                                  `json:"time,omitempty"`
}

type UserUpdateOneWithoutOrderUserDealsHistoriesInput struct {
	Create     *UserCreateWithoutOrderUserDealsHistoriesInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutOrderUserDealsHistoriesDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutOrderUserDealsHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                              `json:"delete,omitempty"`
	Disconnect *bool                                              `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                              `json:"connect,omitempty"`
}

type UserUpdateWithoutOrderUserDealsHistoriesDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type MotherHistoryUpdateManyWithoutUserInput struct {
	Create     []MotherHistoryCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []MotherHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []MotherHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []MotherHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []MotherHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []MotherHistoryUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []MotherHistoryUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []MotherHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []MotherHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type MotherHistoryUpdateWithWhereUniqueWithoutUserInput struct {
	Where MotherHistoryWhereUniqueInput           `json:"where"`
	Data  MotherHistoryUpdateWithoutUserDataInput `json:"data"`
}

type MotherHistoryUpdateWithoutUserDataInput struct {
	Type                    *int32                                                     `json:"type,omitempty"`
	RoleTime                *string                                                    `json:"roleTime,omitempty"`
	Coin                    *CoinUpdateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	Post                    *PostUpdateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryUpdateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryUpdateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryUpdateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryUpdateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryUpdateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type PostUpdateOneWithoutMotherHistoriesInput struct {
	Create     *PostCreateWithoutMotherHistoriesInput     `json:"create,omitempty"`
	Update     *PostUpdateWithoutMotherHistoriesDataInput `json:"update,omitempty"`
	Upsert     *PostUpsertWithoutMotherHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                      `json:"delete,omitempty"`
	Disconnect *bool                                      `json:"disconnect,omitempty"`
	Connect    *PostWhereUniqueInput                      `json:"connect,omitempty"`
}

type PostUpdateWithoutMotherHistoriesDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type CommentUpdateManyWithoutPostInput struct {
	Create     []CommentCreateWithoutPostInput                `json:"create,omitempty"`
	Delete     []CommentWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []CommentWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []CommentWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []CommentWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []CommentUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
	Upsert     []CommentUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
	DeleteMany []CommentScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []CommentUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type CommentUpdateWithWhereUniqueWithoutPostInput struct {
	Where CommentWhereUniqueInput           `json:"where"`
	Data  CommentUpdateWithoutPostDataInput `json:"data"`
}

type CommentUpdateWithoutPostDataInput struct {
	Type              *int32                                         `json:"type,omitempty"`
	Content           *string                                        `json:"content,omitempty"`
	Image             *FileInfoUpdateOneInput                        `json:"image,omitempty"`
	Url               *string                                        `json:"url,omitempty"`
	Reply             *CommentReplyUpdateManyWithoutCommentInput     `json:"reply,omitempty"`
	Owner             *UserUpdateOneRequiredWithoutCommentsInput     `json:"owner,omitempty"`
	PostRewardHistory *PostRewardHistoryUpdateOneWithoutCommentInput `json:"postRewardHistory,omitempty"`
	IsDel             *bool                                          `json:"isDel,omitempty"`
}

type FileInfoUpdateOneInput struct {
	Create     *FileInfoCreateInput       `json:"create,omitempty"`
	Update     *FileInfoUpdateDataInput   `json:"update,omitempty"`
	Upsert     *FileInfoUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                      `json:"delete,omitempty"`
	Disconnect *bool                      `json:"disconnect,omitempty"`
	Connect    *FileInfoWhereUniqueInput  `json:"connect,omitempty"`
}

type FileInfoUpdateDataInput struct {
	Coin         *CoinUpdateOneWithoutPictureInput  `json:"coin,omitempty"`
	Post         *PostUpdateOneWithoutFileListInput `json:"post,omitempty"`
	TempFileId   *string                            `json:"tempFileId,omitempty"`
	LocationPath *string                            `json:"locationPath,omitempty"`
	Name         *string                            `json:"name,omitempty"`
	ContentType  *string                            `json:"contentType,omitempty"`
	Url          *string                            `json:"url,omitempty"`
	Owner        *UserUpdateOneWithoutFileListInput `json:"owner,omitempty"`
	IsVideo      *bool                              `json:"isVideo,omitempty"`
	IsDel        *bool                              `json:"isDel,omitempty"`
}

type FileInfoUpsertNestedInput struct {
	Update FileInfoUpdateDataInput `json:"update"`
	Create FileInfoCreateInput     `json:"create"`
}

type CommentReplyUpdateManyWithoutCommentInput struct {
	Create     []CommentReplyCreateWithoutCommentInput                `json:"create,omitempty"`
	Delete     []CommentReplyWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []CommentReplyWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []CommentReplyWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []CommentReplyWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []CommentReplyUpdateWithWhereUniqueWithoutCommentInput `json:"update,omitempty"`
	Upsert     []CommentReplyUpsertWithWhereUniqueWithoutCommentInput `json:"upsert,omitempty"`
	DeleteMany []CommentReplyScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []CommentReplyUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type CommentReplyUpdateWithWhereUniqueWithoutCommentInput struct {
	Where CommentReplyWhereUniqueInput              `json:"where"`
	Data  CommentReplyUpdateWithoutCommentDataInput `json:"data"`
}

type CommentReplyUpdateWithoutCommentDataInput struct {
	Content *string                     `json:"content,omitempty"`
	Owner   *UserUpdateOneRequiredInput `json:"owner,omitempty"`
	IsDel   *bool                       `json:"isDel,omitempty"`
}

type UserUpdateOneRequiredInput struct {
	Create  *UserCreateInput       `json:"create,omitempty"`
	Update  *UserUpdateDataInput   `json:"update,omitempty"`
	Upsert  *UserUpsertNestedInput `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput  `json:"connect,omitempty"`
}

type UserUpsertNestedInput struct {
	Update UserUpdateDataInput `json:"update"`
	Create UserCreateInput     `json:"create"`
}

type CommentReplyUpsertWithWhereUniqueWithoutCommentInput struct {
	Where  CommentReplyWhereUniqueInput              `json:"where"`
	Update CommentReplyUpdateWithoutCommentDataInput `json:"update"`
	Create CommentReplyCreateWithoutCommentInput     `json:"create"`
}

type CommentReplyScalarWhereInput struct {
	ID                   *string                        `json:"id,omitempty"`
	IDNot                *string                        `json:"id_not,omitempty"`
	IDIn                 []string                       `json:"id_in,omitempty"`
	IDNotIn              []string                       `json:"id_not_in,omitempty"`
	IDLt                 *string                        `json:"id_lt,omitempty"`
	IDLte                *string                        `json:"id_lte,omitempty"`
	IDGt                 *string                        `json:"id_gt,omitempty"`
	IDGte                *string                        `json:"id_gte,omitempty"`
	IDContains           *string                        `json:"id_contains,omitempty"`
	IDNotContains        *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                        `json:"id_not_ends_with,omitempty"`
	Content              *string                        `json:"content,omitempty"`
	ContentNot           *string                        `json:"content_not,omitempty"`
	ContentIn            []string                       `json:"content_in,omitempty"`
	ContentNotIn         []string                       `json:"content_not_in,omitempty"`
	ContentLt            *string                        `json:"content_lt,omitempty"`
	ContentLte           *string                        `json:"content_lte,omitempty"`
	ContentGt            *string                        `json:"content_gt,omitempty"`
	ContentGte           *string                        `json:"content_gte,omitempty"`
	ContentContains      *string                        `json:"content_contains,omitempty"`
	ContentNotContains   *string                        `json:"content_not_contains,omitempty"`
	ContentStartsWith    *string                        `json:"content_starts_with,omitempty"`
	ContentNotStartsWith *string                        `json:"content_not_starts_with,omitempty"`
	ContentEndsWith      *string                        `json:"content_ends_with,omitempty"`
	ContentNotEndsWith   *string                        `json:"content_not_ends_with,omitempty"`
	CreatedAt            *string                        `json:"createdAt,omitempty"`
	CreatedAtNot         *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                        `json:"updatedAt_gte,omitempty"`
	IsDel                *bool                          `json:"isDel,omitempty"`
	IsDelNot             *bool                          `json:"isDel_not,omitempty"`
	And                  []CommentReplyScalarWhereInput `json:"AND,omitempty"`
	Or                   []CommentReplyScalarWhereInput `json:"OR,omitempty"`
	Not                  []CommentReplyScalarWhereInput `json:"NOT,omitempty"`
}

type CommentReplyUpdateManyWithWhereNestedInput struct {
	Where CommentReplyScalarWhereInput    `json:"where"`
	Data  CommentReplyUpdateManyDataInput `json:"data"`
}

type CommentReplyUpdateManyDataInput struct {
	Content *string `json:"content,omitempty"`
	IsDel   *bool   `json:"isDel,omitempty"`
}

type UserUpdateOneRequiredWithoutCommentsInput struct {
	Create  *UserCreateWithoutCommentsInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutCommentsDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutCommentsInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput               `json:"connect,omitempty"`
}

type UserUpdateWithoutCommentsDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type OrderHistoryUpdateManyWithoutUserInput struct {
	Create     []OrderHistoryCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []OrderHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []OrderHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []OrderHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []OrderHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []OrderHistoryUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []OrderHistoryUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []OrderHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []OrderHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type OrderHistoryUpdateWithWhereUniqueWithoutUserInput struct {
	Where OrderHistoryWhereUniqueInput           `json:"where"`
	Data  OrderHistoryUpdateWithoutUserDataInput `json:"data"`
}

type OrderHistoryUpdateWithoutUserDataInput struct {
	Type                    *int32                                                   `json:"type,omitempty"`
	OrderNum                *int32                                                   `json:"orderNum,omitempty"`
	Coin                    *CoinUpdateOneWithoutOrderHistoriesInput                 `json:"coin,omitempty"`
	MotherHistory           *MotherHistoryUpdateOneWithoutOrderHistoryInput          `json:"motherHistory,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutOrderHistoryInput `json:"orderUserDealsHistories,omitempty"`
	OrderPrice              *float64                                                 `json:"orderPrice,omitempty"`
	DealPrice               *float64                                                 `json:"dealPrice,omitempty"`
	OrderQty                *float64                                                 `json:"orderQty,omitempty"`
	DealQty                 *float64                                                 `json:"dealQty,omitempty"`
	LeftQty                 *float64                                                 `json:"leftQty,omitempty"`
	DealFee                 *float64                                                 `json:"dealFee,omitempty"`
	TakerFee                *float64                                                 `json:"takerFee,omitempty"`
	MakerFee                *float64                                                 `json:"makerFee,omitempty"`
	Memo                    *string                                                  `json:"memo,omitempty"`
	Description             *string                                                  `json:"description,omitempty"`
	Offset                  *int32                                                   `json:"offset,omitempty"`
	IsCancel                *bool                                                    `json:"isCancel,omitempty"`
}

type CoinUpdateOneWithoutOrderHistoriesInput struct {
	Create     *CoinCreateWithoutOrderHistoriesInput     `json:"create,omitempty"`
	Update     *CoinUpdateWithoutOrderHistoriesDataInput `json:"update,omitempty"`
	Upsert     *CoinUpsertWithoutOrderHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                     `json:"delete,omitempty"`
	Disconnect *bool                                     `json:"disconnect,omitempty"`
	Connect    *CoinWhereUniqueInput                     `json:"connect,omitempty"`
}

type CoinUpdateWithoutOrderHistoriesDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type MotherHistoryUpdateManyWithoutCoinInput struct {
	Create     []MotherHistoryCreateWithoutCoinInput                `json:"create,omitempty"`
	Delete     []MotherHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []MotherHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []MotherHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []MotherHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []MotherHistoryUpdateWithWhereUniqueWithoutCoinInput `json:"update,omitempty"`
	Upsert     []MotherHistoryUpsertWithWhereUniqueWithoutCoinInput `json:"upsert,omitempty"`
	DeleteMany []MotherHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []MotherHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type MotherHistoryUpdateWithWhereUniqueWithoutCoinInput struct {
	Where MotherHistoryWhereUniqueInput           `json:"where"`
	Data  MotherHistoryUpdateWithoutCoinDataInput `json:"data"`
}

type MotherHistoryUpdateWithoutCoinDataInput struct {
	Type                    *int32                                                     `json:"type,omitempty"`
	RoleTime                *string                                                    `json:"roleTime,omitempty"`
	User                    *UserUpdateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostUpdateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryUpdateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryUpdateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryUpdateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryUpdateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryUpdateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type UserUpdateOneWithoutMotherHistoriesInput struct {
	Create     *UserCreateWithoutMotherHistoriesInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutMotherHistoriesDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutMotherHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                      `json:"delete,omitempty"`
	Disconnect *bool                                      `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                      `json:"connect,omitempty"`
}

type UserUpdateWithoutMotherHistoriesDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type OrderUserDealsHistoryUpdateManyWithoutUserInput struct {
	Create     []OrderUserDealsHistoryCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []OrderUserDealsHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []OrderUserDealsHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []OrderUserDealsHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []OrderUserDealsHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []OrderUserDealsHistoryUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []OrderUserDealsHistoryUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []OrderUserDealsHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []OrderUserDealsHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type OrderUserDealsHistoryUpdateWithWhereUniqueWithoutUserInput struct {
	Where OrderUserDealsHistoryWhereUniqueInput           `json:"where"`
	Data  OrderUserDealsHistoryUpdateWithoutUserDataInput `json:"data"`
}

type OrderUserDealsHistoryUpdateWithoutUserDataInput struct {
	Type          *int32                                                    `json:"type,omitempty"`
	Role          *int32                                                    `json:"role,omitempty"`
	DealId        *int32                                                    `json:"dealId,omitempty"`
	UniqueKey     *string                                                   `json:"uniqueKey,omitempty"`
	UniqueId      *int32                                                    `json:"uniqueId,omitempty"`
	Coin          *CoinUpdateOneWithoutOrderUserDealsHistoriesInput         `json:"coin,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutOrderUserDealsHistoryInput  `json:"motherHistory,omitempty"`
	OrderHistory  *OrderHistoryUpdateOneWithoutOrderUserDealsHistoriesInput `json:"orderHistory,omitempty"`
	DealPrice     *float64                                                  `json:"dealPrice,omitempty"`
	DealQty       *float64                                                  `json:"dealQty,omitempty"`
	Fee           *float64                                                  `json:"fee,omitempty"`
	DealOrderId   *int32                                                    `json:"dealOrderId,omitempty"`
	Time          *float64                                                  `json:"time,omitempty"`
}

type CoinUpdateOneWithoutOrderUserDealsHistoriesInput struct {
	Create     *CoinCreateWithoutOrderUserDealsHistoriesInput     `json:"create,omitempty"`
	Update     *CoinUpdateWithoutOrderUserDealsHistoriesDataInput `json:"update,omitempty"`
	Upsert     *CoinUpsertWithoutOrderUserDealsHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                              `json:"delete,omitempty"`
	Disconnect *bool                                              `json:"disconnect,omitempty"`
	Connect    *CoinWhereUniqueInput                              `json:"connect,omitempty"`
}

type CoinUpdateWithoutOrderUserDealsHistoriesDataInput struct {
	Categories          *CategoryUpdateManyWithoutCoinsInput         `json:"categories,omitempty"`
	Name                *string                                      `json:"name,omitempty"`
	Qty                 *float64                                     `json:"qty,omitempty"`
	StandardPrice       *float64                                     `json:"standardPrice,omitempty"`
	CurrentPrice        *float64                                     `json:"currentPrice,omitempty"`
	Image               *FileUpdateOneRequiredWithoutCoinInput       `json:"image,omitempty"`
	Picture             *FileInfoUpdateOneWithoutCoinInput           `json:"picture,omitempty"`
	Description         *string                                      `json:"description,omitempty"`
	Wallets             *WalletUpdateManyWithoutCoinInput            `json:"wallets,omitempty"`
	Owner               *UserUpdateOneRequiredWithoutCoinInput       `json:"owner,omitempty"`
	Posts               *PostUpdateManyWithoutCoinInput              `json:"posts,omitempty"`
	Offer               *OfferUpdateOneWithoutCoinInput              `json:"offer,omitempty"`
	Status              *int32                                       `json:"status,omitempty"`
	Weight              *string                                      `json:"weight,omitempty"`
	OrderHistories      *OrderHistoryUpdateManyWithoutCoinInput      `json:"orderHistories,omitempty"`
	OrderDealsHistories *OrderDealsHistoryUpdateManyWithoutCoinInput `json:"orderDealsHistories,omitempty"`
	MotherHistories     *MotherHistoryUpdateManyWithoutCoinInput     `json:"motherHistories,omitempty"`
	CoinPriceTable      *CoinPriceTableUpdateOneWithoutCoinInput     `json:"coinPriceTable,omitempty"`
	CoinKline           *CoinKlineUpdateManyWithoutCoinInput         `json:"coinKline,omitempty"`
	DeployTxhash        *string                                      `json:"deployTxhash,omitempty"`
	ContractAddress     *string                                      `json:"contractAddress,omitempty"`
	ODda                *float64                                     `json:"oDDA,omitempty"`
}

type CoinPriceTableUpdateOneWithoutCoinInput struct {
	Create     *CoinPriceTableCreateWithoutCoinInput     `json:"create,omitempty"`
	Update     *CoinPriceTableUpdateWithoutCoinDataInput `json:"update,omitempty"`
	Upsert     *CoinPriceTableUpsertWithoutCoinInput     `json:"upsert,omitempty"`
	Delete     *bool                                     `json:"delete,omitempty"`
	Disconnect *bool                                     `json:"disconnect,omitempty"`
	Connect    *CoinPriceTableWhereUniqueInput           `json:"connect,omitempty"`
}

type CoinPriceTableUpdateWithoutCoinDataInput struct {
	Type      *int32                              `json:"type,omitempty"`
	InfoValue *CoinPriceTableUpdateinfoValueInput `json:"infoValue,omitempty"`
}

type CoinPriceTableUpdateinfoValueInput struct {
	Set []float64 `json:"set,omitempty"`
}

type CoinPriceTableUpsertWithoutCoinInput struct {
	Update CoinPriceTableUpdateWithoutCoinDataInput `json:"update"`
	Create CoinPriceTableCreateWithoutCoinInput     `json:"create"`
}

type CoinKlineUpdateManyWithoutCoinInput struct {
	Create     []CoinKlineCreateWithoutCoinInput                `json:"create,omitempty"`
	Delete     []CoinKlineWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []CoinKlineWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []CoinKlineWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []CoinKlineWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []CoinKlineUpdateWithWhereUniqueWithoutCoinInput `json:"update,omitempty"`
	Upsert     []CoinKlineUpsertWithWhereUniqueWithoutCoinInput `json:"upsert,omitempty"`
	DeleteMany []CoinKlineScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []CoinKlineUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type CoinKlineUpdateWithWhereUniqueWithoutCoinInput struct {
	Where CoinKlineWhereUniqueInput           `json:"where"`
	Data  CoinKlineUpdateWithoutCoinDataInput `json:"data"`
}

type CoinKlineUpdateWithoutCoinDataInput struct {
	Open   *float64 `json:"open,omitempty"`
	Close  *float64 `json:"close,omitempty"`
	High   *float64 `json:"high,omitempty"`
	Low    *float64 `json:"low,omitempty"`
	Volume *float64 `json:"volume,omitempty"`
	Deal   *float64 `json:"deal,omitempty"`
}

type CoinKlineUpsertWithWhereUniqueWithoutCoinInput struct {
	Where  CoinKlineWhereUniqueInput           `json:"where"`
	Update CoinKlineUpdateWithoutCoinDataInput `json:"update"`
	Create CoinKlineCreateWithoutCoinInput     `json:"create"`
}

type CoinKlineScalarWhereInput struct {
	ID              *string                     `json:"id,omitempty"`
	IDNot           *string                     `json:"id_not,omitempty"`
	IDIn            []string                    `json:"id_in,omitempty"`
	IDNotIn         []string                    `json:"id_not_in,omitempty"`
	IDLt            *string                     `json:"id_lt,omitempty"`
	IDLte           *string                     `json:"id_lte,omitempty"`
	IDGt            *string                     `json:"id_gt,omitempty"`
	IDGte           *string                     `json:"id_gte,omitempty"`
	IDContains      *string                     `json:"id_contains,omitempty"`
	IDNotContains   *string                     `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                     `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                     `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                     `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                     `json:"id_not_ends_with,omitempty"`
	Open            *float64                    `json:"open,omitempty"`
	OpenNot         *float64                    `json:"open_not,omitempty"`
	OpenIn          []float64                   `json:"open_in,omitempty"`
	OpenNotIn       []float64                   `json:"open_not_in,omitempty"`
	OpenLt          *float64                    `json:"open_lt,omitempty"`
	OpenLte         *float64                    `json:"open_lte,omitempty"`
	OpenGt          *float64                    `json:"open_gt,omitempty"`
	OpenGte         *float64                    `json:"open_gte,omitempty"`
	Close           *float64                    `json:"close,omitempty"`
	CloseNot        *float64                    `json:"close_not,omitempty"`
	CloseIn         []float64                   `json:"close_in,omitempty"`
	CloseNotIn      []float64                   `json:"close_not_in,omitempty"`
	CloseLt         *float64                    `json:"close_lt,omitempty"`
	CloseLte        *float64                    `json:"close_lte,omitempty"`
	CloseGt         *float64                    `json:"close_gt,omitempty"`
	CloseGte        *float64                    `json:"close_gte,omitempty"`
	High            *float64                    `json:"high,omitempty"`
	HighNot         *float64                    `json:"high_not,omitempty"`
	HighIn          []float64                   `json:"high_in,omitempty"`
	HighNotIn       []float64                   `json:"high_not_in,omitempty"`
	HighLt          *float64                    `json:"high_lt,omitempty"`
	HighLte         *float64                    `json:"high_lte,omitempty"`
	HighGt          *float64                    `json:"high_gt,omitempty"`
	HighGte         *float64                    `json:"high_gte,omitempty"`
	Low             *float64                    `json:"low,omitempty"`
	LowNot          *float64                    `json:"low_not,omitempty"`
	LowIn           []float64                   `json:"low_in,omitempty"`
	LowNotIn        []float64                   `json:"low_not_in,omitempty"`
	LowLt           *float64                    `json:"low_lt,omitempty"`
	LowLte          *float64                    `json:"low_lte,omitempty"`
	LowGt           *float64                    `json:"low_gt,omitempty"`
	LowGte          *float64                    `json:"low_gte,omitempty"`
	Volume          *float64                    `json:"volume,omitempty"`
	VolumeNot       *float64                    `json:"volume_not,omitempty"`
	VolumeIn        []float64                   `json:"volume_in,omitempty"`
	VolumeNotIn     []float64                   `json:"volume_not_in,omitempty"`
	VolumeLt        *float64                    `json:"volume_lt,omitempty"`
	VolumeLte       *float64                    `json:"volume_lte,omitempty"`
	VolumeGt        *float64                    `json:"volume_gt,omitempty"`
	VolumeGte       *float64                    `json:"volume_gte,omitempty"`
	Deal            *float64                    `json:"deal,omitempty"`
	DealNot         *float64                    `json:"deal_not,omitempty"`
	DealIn          []float64                   `json:"deal_in,omitempty"`
	DealNotIn       []float64                   `json:"deal_not_in,omitempty"`
	DealLt          *float64                    `json:"deal_lt,omitempty"`
	DealLte         *float64                    `json:"deal_lte,omitempty"`
	DealGt          *float64                    `json:"deal_gt,omitempty"`
	DealGte         *float64                    `json:"deal_gte,omitempty"`
	CreatedAt       *string                     `json:"createdAt,omitempty"`
	CreatedAtNot    *string                     `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                    `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                    `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                     `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                     `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                     `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                     `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                     `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                     `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                    `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                    `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                     `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                     `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                     `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                     `json:"updatedAt_gte,omitempty"`
	And             []CoinKlineScalarWhereInput `json:"AND,omitempty"`
	Or              []CoinKlineScalarWhereInput `json:"OR,omitempty"`
	Not             []CoinKlineScalarWhereInput `json:"NOT,omitempty"`
}

type CoinKlineUpdateManyWithWhereNestedInput struct {
	Where CoinKlineScalarWhereInput    `json:"where"`
	Data  CoinKlineUpdateManyDataInput `json:"data"`
}

type CoinKlineUpdateManyDataInput struct {
	Open   *float64 `json:"open,omitempty"`
	Close  *float64 `json:"close,omitempty"`
	High   *float64 `json:"high,omitempty"`
	Low    *float64 `json:"low,omitempty"`
	Volume *float64 `json:"volume,omitempty"`
	Deal   *float64 `json:"deal,omitempty"`
}

type CoinUpsertWithoutOrderUserDealsHistoriesInput struct {
	Update CoinUpdateWithoutOrderUserDealsHistoriesDataInput `json:"update"`
	Create CoinCreateWithoutOrderUserDealsHistoriesInput     `json:"create"`
}

type MotherHistoryUpdateOneWithoutOrderUserDealsHistoryInput struct {
	Create     *MotherHistoryCreateWithoutOrderUserDealsHistoryInput     `json:"create,omitempty"`
	Update     *MotherHistoryUpdateWithoutOrderUserDealsHistoryDataInput `json:"update,omitempty"`
	Upsert     *MotherHistoryUpsertWithoutOrderUserDealsHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                     `json:"delete,omitempty"`
	Disconnect *bool                                                     `json:"disconnect,omitempty"`
	Connect    *MotherHistoryWhereUniqueInput                            `json:"connect,omitempty"`
}

type MotherHistoryUpdateWithoutOrderUserDealsHistoryDataInput struct {
	Type                    *int32                                                     `json:"type,omitempty"`
	RoleTime                *string                                                    `json:"roleTime,omitempty"`
	Coin                    *CoinUpdateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserUpdateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostUpdateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderHistory            *OrderHistoryUpdateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryUpdateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryUpdateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryUpdateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryUpdateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type OrderHistoryUpdateOneWithoutMotherHistoryInput struct {
	Create     *OrderHistoryCreateWithoutMotherHistoryInput     `json:"create,omitempty"`
	Update     *OrderHistoryUpdateWithoutMotherHistoryDataInput `json:"update,omitempty"`
	Upsert     *OrderHistoryUpsertWithoutMotherHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                            `json:"delete,omitempty"`
	Disconnect *bool                                            `json:"disconnect,omitempty"`
	Connect    *OrderHistoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type OrderHistoryUpdateWithoutMotherHistoryDataInput struct {
	Type                    *int32                                                   `json:"type,omitempty"`
	OrderNum                *int32                                                   `json:"orderNum,omitempty"`
	User                    *UserUpdateOneWithoutOrderHistoriesInput                 `json:"user,omitempty"`
	Coin                    *CoinUpdateOneWithoutOrderHistoriesInput                 `json:"coin,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutOrderHistoryInput `json:"orderUserDealsHistories,omitempty"`
	OrderPrice              *float64                                                 `json:"orderPrice,omitempty"`
	DealPrice               *float64                                                 `json:"dealPrice,omitempty"`
	OrderQty                *float64                                                 `json:"orderQty,omitempty"`
	DealQty                 *float64                                                 `json:"dealQty,omitempty"`
	LeftQty                 *float64                                                 `json:"leftQty,omitempty"`
	DealFee                 *float64                                                 `json:"dealFee,omitempty"`
	TakerFee                *float64                                                 `json:"takerFee,omitempty"`
	MakerFee                *float64                                                 `json:"makerFee,omitempty"`
	Memo                    *string                                                  `json:"memo,omitempty"`
	Description             *string                                                  `json:"description,omitempty"`
	Offset                  *int32                                                   `json:"offset,omitempty"`
	IsCancel                *bool                                                    `json:"isCancel,omitempty"`
}

type OrderUserDealsHistoryUpdateManyWithoutOrderHistoryInput struct {
	Create     []OrderUserDealsHistoryCreateWithoutOrderHistoryInput                `json:"create,omitempty"`
	Delete     []OrderUserDealsHistoryWhereUniqueInput                              `json:"delete,omitempty"`
	Connect    []OrderUserDealsHistoryWhereUniqueInput                              `json:"connect,omitempty"`
	Set        []OrderUserDealsHistoryWhereUniqueInput                              `json:"set,omitempty"`
	Disconnect []OrderUserDealsHistoryWhereUniqueInput                              `json:"disconnect,omitempty"`
	Update     []OrderUserDealsHistoryUpdateWithWhereUniqueWithoutOrderHistoryInput `json:"update,omitempty"`
	Upsert     []OrderUserDealsHistoryUpsertWithWhereUniqueWithoutOrderHistoryInput `json:"upsert,omitempty"`
	DeleteMany []OrderUserDealsHistoryScalarWhereInput                              `json:"deleteMany,omitempty"`
	UpdateMany []OrderUserDealsHistoryUpdateManyWithWhereNestedInput                `json:"updateMany,omitempty"`
}

type OrderUserDealsHistoryUpdateWithWhereUniqueWithoutOrderHistoryInput struct {
	Where OrderUserDealsHistoryWhereUniqueInput                   `json:"where"`
	Data  OrderUserDealsHistoryUpdateWithoutOrderHistoryDataInput `json:"data"`
}

type OrderUserDealsHistoryUpdateWithoutOrderHistoryDataInput struct {
	Type          *int32                                                   `json:"type,omitempty"`
	Role          *int32                                                   `json:"role,omitempty"`
	DealId        *int32                                                   `json:"dealId,omitempty"`
	UniqueKey     *string                                                  `json:"uniqueKey,omitempty"`
	UniqueId      *int32                                                   `json:"uniqueId,omitempty"`
	Coin          *CoinUpdateOneWithoutOrderUserDealsHistoriesInput        `json:"coin,omitempty"`
	User          *UserUpdateOneWithoutOrderUserDealsHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutOrderUserDealsHistoryInput `json:"motherHistory,omitempty"`
	DealPrice     *float64                                                 `json:"dealPrice,omitempty"`
	DealQty       *float64                                                 `json:"dealQty,omitempty"`
	Fee           *float64                                                 `json:"fee,omitempty"`
	DealOrderId   *int32                                                   `json:"dealOrderId,omitempty"`
	Time          *float64                                                 `json:"time,omitempty"`
}

type OrderUserDealsHistoryUpsertWithWhereUniqueWithoutOrderHistoryInput struct {
	Where  OrderUserDealsHistoryWhereUniqueInput                   `json:"where"`
	Update OrderUserDealsHistoryUpdateWithoutOrderHistoryDataInput `json:"update"`
	Create OrderUserDealsHistoryCreateWithoutOrderHistoryInput     `json:"create"`
}

type OrderUserDealsHistoryScalarWhereInput struct {
	ID                     *string                                 `json:"id,omitempty"`
	IDNot                  *string                                 `json:"id_not,omitempty"`
	IDIn                   []string                                `json:"id_in,omitempty"`
	IDNotIn                []string                                `json:"id_not_in,omitempty"`
	IDLt                   *string                                 `json:"id_lt,omitempty"`
	IDLte                  *string                                 `json:"id_lte,omitempty"`
	IDGt                   *string                                 `json:"id_gt,omitempty"`
	IDGte                  *string                                 `json:"id_gte,omitempty"`
	IDContains             *string                                 `json:"id_contains,omitempty"`
	IDNotContains          *string                                 `json:"id_not_contains,omitempty"`
	IDStartsWith           *string                                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string                                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string                                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string                                 `json:"id_not_ends_with,omitempty"`
	Type                   *int32                                  `json:"type,omitempty"`
	TypeNot                *int32                                  `json:"type_not,omitempty"`
	TypeIn                 []int32                                 `json:"type_in,omitempty"`
	TypeNotIn              []int32                                 `json:"type_not_in,omitempty"`
	TypeLt                 *int32                                  `json:"type_lt,omitempty"`
	TypeLte                *int32                                  `json:"type_lte,omitempty"`
	TypeGt                 *int32                                  `json:"type_gt,omitempty"`
	TypeGte                *int32                                  `json:"type_gte,omitempty"`
	Role                   *int32                                  `json:"role,omitempty"`
	RoleNot                *int32                                  `json:"role_not,omitempty"`
	RoleIn                 []int32                                 `json:"role_in,omitempty"`
	RoleNotIn              []int32                                 `json:"role_not_in,omitempty"`
	RoleLt                 *int32                                  `json:"role_lt,omitempty"`
	RoleLte                *int32                                  `json:"role_lte,omitempty"`
	RoleGt                 *int32                                  `json:"role_gt,omitempty"`
	RoleGte                *int32                                  `json:"role_gte,omitempty"`
	DealId                 *int32                                  `json:"dealId,omitempty"`
	DealIdNot              *int32                                  `json:"dealId_not,omitempty"`
	DealIdIn               []int32                                 `json:"dealId_in,omitempty"`
	DealIdNotIn            []int32                                 `json:"dealId_not_in,omitempty"`
	DealIdLt               *int32                                  `json:"dealId_lt,omitempty"`
	DealIdLte              *int32                                  `json:"dealId_lte,omitempty"`
	DealIdGt               *int32                                  `json:"dealId_gt,omitempty"`
	DealIdGte              *int32                                  `json:"dealId_gte,omitempty"`
	UniqueKey              *string                                 `json:"uniqueKey,omitempty"`
	UniqueKeyNot           *string                                 `json:"uniqueKey_not,omitempty"`
	UniqueKeyIn            []string                                `json:"uniqueKey_in,omitempty"`
	UniqueKeyNotIn         []string                                `json:"uniqueKey_not_in,omitempty"`
	UniqueKeyLt            *string                                 `json:"uniqueKey_lt,omitempty"`
	UniqueKeyLte           *string                                 `json:"uniqueKey_lte,omitempty"`
	UniqueKeyGt            *string                                 `json:"uniqueKey_gt,omitempty"`
	UniqueKeyGte           *string                                 `json:"uniqueKey_gte,omitempty"`
	UniqueKeyContains      *string                                 `json:"uniqueKey_contains,omitempty"`
	UniqueKeyNotContains   *string                                 `json:"uniqueKey_not_contains,omitempty"`
	UniqueKeyStartsWith    *string                                 `json:"uniqueKey_starts_with,omitempty"`
	UniqueKeyNotStartsWith *string                                 `json:"uniqueKey_not_starts_with,omitempty"`
	UniqueKeyEndsWith      *string                                 `json:"uniqueKey_ends_with,omitempty"`
	UniqueKeyNotEndsWith   *string                                 `json:"uniqueKey_not_ends_with,omitempty"`
	UniqueId               *int32                                  `json:"uniqueId,omitempty"`
	UniqueIdNot            *int32                                  `json:"uniqueId_not,omitempty"`
	UniqueIdIn             []int32                                 `json:"uniqueId_in,omitempty"`
	UniqueIdNotIn          []int32                                 `json:"uniqueId_not_in,omitempty"`
	UniqueIdLt             *int32                                  `json:"uniqueId_lt,omitempty"`
	UniqueIdLte            *int32                                  `json:"uniqueId_lte,omitempty"`
	UniqueIdGt             *int32                                  `json:"uniqueId_gt,omitempty"`
	UniqueIdGte            *int32                                  `json:"uniqueId_gte,omitempty"`
	DealPrice              *float64                                `json:"dealPrice,omitempty"`
	DealPriceNot           *float64                                `json:"dealPrice_not,omitempty"`
	DealPriceIn            []float64                               `json:"dealPrice_in,omitempty"`
	DealPriceNotIn         []float64                               `json:"dealPrice_not_in,omitempty"`
	DealPriceLt            *float64                                `json:"dealPrice_lt,omitempty"`
	DealPriceLte           *float64                                `json:"dealPrice_lte,omitempty"`
	DealPriceGt            *float64                                `json:"dealPrice_gt,omitempty"`
	DealPriceGte           *float64                                `json:"dealPrice_gte,omitempty"`
	DealQty                *float64                                `json:"dealQty,omitempty"`
	DealQtyNot             *float64                                `json:"dealQty_not,omitempty"`
	DealQtyIn              []float64                               `json:"dealQty_in,omitempty"`
	DealQtyNotIn           []float64                               `json:"dealQty_not_in,omitempty"`
	DealQtyLt              *float64                                `json:"dealQty_lt,omitempty"`
	DealQtyLte             *float64                                `json:"dealQty_lte,omitempty"`
	DealQtyGt              *float64                                `json:"dealQty_gt,omitempty"`
	DealQtyGte             *float64                                `json:"dealQty_gte,omitempty"`
	Fee                    *float64                                `json:"fee,omitempty"`
	FeeNot                 *float64                                `json:"fee_not,omitempty"`
	FeeIn                  []float64                               `json:"fee_in,omitempty"`
	FeeNotIn               []float64                               `json:"fee_not_in,omitempty"`
	FeeLt                  *float64                                `json:"fee_lt,omitempty"`
	FeeLte                 *float64                                `json:"fee_lte,omitempty"`
	FeeGt                  *float64                                `json:"fee_gt,omitempty"`
	FeeGte                 *float64                                `json:"fee_gte,omitempty"`
	DealOrderId            *int32                                  `json:"dealOrderId,omitempty"`
	DealOrderIdNot         *int32                                  `json:"dealOrderId_not,omitempty"`
	DealOrderIdIn          []int32                                 `json:"dealOrderId_in,omitempty"`
	DealOrderIdNotIn       []int32                                 `json:"dealOrderId_not_in,omitempty"`
	DealOrderIdLt          *int32                                  `json:"dealOrderId_lt,omitempty"`
	DealOrderIdLte         *int32                                  `json:"dealOrderId_lte,omitempty"`
	DealOrderIdGt          *int32                                  `json:"dealOrderId_gt,omitempty"`
	DealOrderIdGte         *int32                                  `json:"dealOrderId_gte,omitempty"`
	Time                   *float64                                `json:"time,omitempty"`
	TimeNot                *float64                                `json:"time_not,omitempty"`
	TimeIn                 []float64                               `json:"time_in,omitempty"`
	TimeNotIn              []float64                               `json:"time_not_in,omitempty"`
	TimeLt                 *float64                                `json:"time_lt,omitempty"`
	TimeLte                *float64                                `json:"time_lte,omitempty"`
	TimeGt                 *float64                                `json:"time_gt,omitempty"`
	TimeGte                *float64                                `json:"time_gte,omitempty"`
	CreatedAt              *string                                 `json:"createdAt,omitempty"`
	CreatedAtNot           *string                                 `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string                                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string                                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                                 `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                                 `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string                                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string                                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                                 `json:"updatedAt_gte,omitempty"`
	And                    []OrderUserDealsHistoryScalarWhereInput `json:"AND,omitempty"`
	Or                     []OrderUserDealsHistoryScalarWhereInput `json:"OR,omitempty"`
	Not                    []OrderUserDealsHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type OrderUserDealsHistoryUpdateManyWithWhereNestedInput struct {
	Where OrderUserDealsHistoryScalarWhereInput    `json:"where"`
	Data  OrderUserDealsHistoryUpdateManyDataInput `json:"data"`
}

type OrderUserDealsHistoryUpdateManyDataInput struct {
	Type        *int32   `json:"type,omitempty"`
	Role        *int32   `json:"role,omitempty"`
	DealId      *int32   `json:"dealId,omitempty"`
	UniqueKey   *string  `json:"uniqueKey,omitempty"`
	UniqueId    *int32   `json:"uniqueId,omitempty"`
	DealPrice   *float64 `json:"dealPrice,omitempty"`
	DealQty     *float64 `json:"dealQty,omitempty"`
	Fee         *float64 `json:"fee,omitempty"`
	DealOrderId *int32   `json:"dealOrderId,omitempty"`
	Time        *float64 `json:"time,omitempty"`
}

type OrderHistoryUpsertWithoutMotherHistoryInput struct {
	Update OrderHistoryUpdateWithoutMotherHistoryDataInput `json:"update"`
	Create OrderHistoryCreateWithoutMotherHistoryInput     `json:"create"`
}

type CashHistoryUpdateOneWithoutMotherHistoryInput struct {
	Create     *CashHistoryCreateWithoutMotherHistoryInput     `json:"create,omitempty"`
	Update     *CashHistoryUpdateWithoutMotherHistoryDataInput `json:"update,omitempty"`
	Upsert     *CashHistoryUpsertWithoutMotherHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                           `json:"delete,omitempty"`
	Disconnect *bool                                           `json:"disconnect,omitempty"`
	Connect    *CashHistoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type CashHistoryUpdateWithoutMotherHistoryDataInput struct {
	Type                *int32                                                   `json:"type,omitempty"`
	Property            *int32                                                   `json:"property,omitempty"`
	OrderNum            *int32                                                   `json:"orderNum,omitempty"`
	Description         *string                                                  `json:"description,omitempty"`
	User                *UserUpdateOneWithoutCashHistoriesInput                  `json:"user,omitempty"`
	Qeh                 *QuestExpenditureHistoryUpdateOneWithoutCashHistoryInput `json:"qeh,omitempty"`
	AergoAccountHistory *AergoAccountHistoryUpdateOneWithoutCashHistoryInput     `json:"aergoAccountHistory,omitempty"`
	Price               *int32                                                   `json:"price,omitempty"`
	OPrice              *float64                                                 `json:"oPrice,omitempty"`
	OPriceBack          *float64                                                 `json:"oPriceBack,omitempty"`
	Qty                 *float64                                                 `json:"qty,omitempty"`
	Memo                *string                                                  `json:"memo,omitempty"`
}

type UserUpdateOneWithoutCashHistoriesInput struct {
	Create     *UserCreateWithoutCashHistoriesInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutCashHistoriesDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutCashHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                    `json:"delete,omitempty"`
	Disconnect *bool                                    `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                    `json:"connect,omitempty"`
}

type UserUpdateWithoutCashHistoriesDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type QuestExpenditureHistoryUpdateManyWithoutUserInput struct {
	Create     []QuestExpenditureHistoryCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []QuestExpenditureHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []QuestExpenditureHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []QuestExpenditureHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []QuestExpenditureHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []QuestExpenditureHistoryUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []QuestExpenditureHistoryUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []QuestExpenditureHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []QuestExpenditureHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type QuestExpenditureHistoryUpdateWithWhereUniqueWithoutUserInput struct {
	Where QuestExpenditureHistoryWhereUniqueInput           `json:"where"`
	Data  QuestExpenditureHistoryUpdateWithoutUserDataInput `json:"data"`
}

type QuestExpenditureHistoryUpdateWithoutUserDataInput struct {
	Type          *int32                                                     `json:"type,omitempty"`
	PayType       *int32                                                     `json:"payType,omitempty"`
	OrderNum      *int32                                                     `json:"orderNum,omitempty"`
	Description   *string                                                    `json:"description,omitempty"`
	Post          *PostUpdateOneWithoutQuestExpenditureHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutQuestExpenditureHistoryInput `json:"motherHistory,omitempty"`
	CashHistory   *CashHistoryUpdateOneWithoutQehInput                       `json:"cashHistory,omitempty"`
	Price         *int32                                                     `json:"price,omitempty"`
	Qty           *float64                                                   `json:"qty,omitempty"`
	OPrice        *int32                                                     `json:"oPrice,omitempty"`
	CurrentPrice  *float64                                                   `json:"currentPrice,omitempty"`
	Memo          *string                                                    `json:"memo,omitempty"`
}

type PostUpdateOneWithoutQuestExpenditureHistoriesInput struct {
	Create     *PostCreateWithoutQuestExpenditureHistoriesInput     `json:"create,omitempty"`
	Update     *PostUpdateWithoutQuestExpenditureHistoriesDataInput `json:"update,omitempty"`
	Upsert     *PostUpsertWithoutQuestExpenditureHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                                `json:"delete,omitempty"`
	Disconnect *bool                                                `json:"disconnect,omitempty"`
	Connect    *PostWhereUniqueInput                                `json:"connect,omitempty"`
}

type PostUpdateWithoutQuestExpenditureHistoriesDataInput struct {
	Type                  *int32                                       `json:"type,omitempty"`
	PayType               *int32                                       `json:"payType,omitempty"`
	Categories            *CategoryUpdateManyWithoutPostsInput         `json:"categories,omitempty"`
	Content               *string                                      `json:"content,omitempty"`
	ToUser                *UserUpdateOneWithoutRequestPostsInput       `json:"toUser,omitempty"`
	Owner                 *UserUpdateOneRequiredWithoutPostsInput      `json:"owner,omitempty"`
	Coin                  *CoinUpdateOneRequiredWithoutPostsInput      `json:"coin,omitempty"`
	AirDrop               *AirDropUpdateOneWithoutPostInput            `json:"airDrop,omitempty"`
	Image                 *FileUpdateOneWithoutPostInput               `json:"image,omitempty"`
	FileList              *FileInfoUpdateManyWithoutPostInput          `json:"fileList,omitempty"`
	QuestTitle            *string                                      `json:"questTitle,omitempty"`
	QuestCost             *float64                                     `json:"questCost,omitempty"`
	QuestMinMemberCount   *int32                                       `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount *int32                                       `json:"questLimitMemberCount,omitempty"`
	QuestToDate           *string                                      `json:"questToDate,omitempty"`
	QuestMembers          *QuestMemberUpdateManyWithoutPostInput       `json:"questMembers,omitempty"`
	QuestStatus           *int32                                       `json:"questStatus,omitempty"`
	MotherHistories       *MotherHistoryUpdateManyWithoutPostInput     `json:"motherHistories,omitempty"`
	PostRewardHistories   *PostRewardHistoryUpdateManyWithoutPostInput `json:"postRewardHistories,omitempty"`
	Comments              *CommentUpdateManyWithoutPostInput           `json:"comments,omitempty"`
	Likes                 *UserUpdateManyWithoutLikesInput             `json:"likes,omitempty"`
	Views                 *UserUpdateManyWithoutViewsInput             `json:"views,omitempty"`
	UpdateHistories       *UpdatePostHistoryUpdateManyWithoutPostInput `json:"updateHistories,omitempty"`
	IsBanner              *bool                                        `json:"isBanner,omitempty"`
	IsDel                 *bool                                        `json:"isDel,omitempty"`
	EnableEarlyAccess     *bool                                        `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt        *string                                      `json:"publicAccessAt,omitempty"`
	OrderIndex            *float64                                     `json:"order_index,omitempty"`
}

type UserUpdateManyWithoutLikesInput struct {
	Create     []UserCreateWithoutLikesInput                `json:"create,omitempty"`
	Delete     []UserWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []UserUpdateWithWhereUniqueWithoutLikesInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueWithoutLikesInput `json:"upsert,omitempty"`
	DeleteMany []UserScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type UserUpdateWithWhereUniqueWithoutLikesInput struct {
	Where UserWhereUniqueInput            `json:"where"`
	Data  UserUpdateWithoutLikesDataInput `json:"data"`
}

type UserUpdateWithoutLikesDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type CashHistoryUpdateManyWithoutUserInput struct {
	Create     []CashHistoryCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []CashHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []CashHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []CashHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []CashHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []CashHistoryUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []CashHistoryUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []CashHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []CashHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type CashHistoryUpdateWithWhereUniqueWithoutUserInput struct {
	Where CashHistoryWhereUniqueInput           `json:"where"`
	Data  CashHistoryUpdateWithoutUserDataInput `json:"data"`
}

type CashHistoryUpdateWithoutUserDataInput struct {
	Type                *int32                                                   `json:"type,omitempty"`
	Property            *int32                                                   `json:"property,omitempty"`
	OrderNum            *int32                                                   `json:"orderNum,omitempty"`
	Description         *string                                                  `json:"description,omitempty"`
	MotherHistory       *MotherHistoryUpdateOneWithoutCashHistoryInput           `json:"motherHistory,omitempty"`
	Qeh                 *QuestExpenditureHistoryUpdateOneWithoutCashHistoryInput `json:"qeh,omitempty"`
	AergoAccountHistory *AergoAccountHistoryUpdateOneWithoutCashHistoryInput     `json:"aergoAccountHistory,omitempty"`
	Price               *int32                                                   `json:"price,omitempty"`
	OPrice              *float64                                                 `json:"oPrice,omitempty"`
	OPriceBack          *float64                                                 `json:"oPriceBack,omitempty"`
	Qty                 *float64                                                 `json:"qty,omitempty"`
	Memo                *string                                                  `json:"memo,omitempty"`
}

type MotherHistoryUpdateOneWithoutCashHistoryInput struct {
	Create     *MotherHistoryCreateWithoutCashHistoryInput     `json:"create,omitempty"`
	Update     *MotherHistoryUpdateWithoutCashHistoryDataInput `json:"update,omitempty"`
	Upsert     *MotherHistoryUpsertWithoutCashHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                           `json:"delete,omitempty"`
	Disconnect *bool                                           `json:"disconnect,omitempty"`
	Connect    *MotherHistoryWhereUniqueInput                  `json:"connect,omitempty"`
}

type MotherHistoryUpdateWithoutCashHistoryDataInput struct {
	Type                    *int32                                                     `json:"type,omitempty"`
	RoleTime                *string                                                    `json:"roleTime,omitempty"`
	Coin                    *CoinUpdateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserUpdateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostUpdateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryUpdateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryUpdateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryUpdateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryUpdateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput struct {
	Create     *OrderUserDealsHistoryCreateWithoutMotherHistoryInput     `json:"create,omitempty"`
	Update     *OrderUserDealsHistoryUpdateWithoutMotherHistoryDataInput `json:"update,omitempty"`
	Upsert     *OrderUserDealsHistoryUpsertWithoutMotherHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                     `json:"delete,omitempty"`
	Disconnect *bool                                                     `json:"disconnect,omitempty"`
	Connect    *OrderUserDealsHistoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type OrderUserDealsHistoryUpdateWithoutMotherHistoryDataInput struct {
	Type         *int32                                                    `json:"type,omitempty"`
	Role         *int32                                                    `json:"role,omitempty"`
	DealId       *int32                                                    `json:"dealId,omitempty"`
	UniqueKey    *string                                                   `json:"uniqueKey,omitempty"`
	UniqueId     *int32                                                    `json:"uniqueId,omitempty"`
	Coin         *CoinUpdateOneWithoutOrderUserDealsHistoriesInput         `json:"coin,omitempty"`
	User         *UserUpdateOneWithoutOrderUserDealsHistoriesInput         `json:"user,omitempty"`
	OrderHistory *OrderHistoryUpdateOneWithoutOrderUserDealsHistoriesInput `json:"orderHistory,omitempty"`
	DealPrice    *float64                                                  `json:"dealPrice,omitempty"`
	DealQty      *float64                                                  `json:"dealQty,omitempty"`
	Fee          *float64                                                  `json:"fee,omitempty"`
	DealOrderId  *int32                                                    `json:"dealOrderId,omitempty"`
	Time         *float64                                                  `json:"time,omitempty"`
}

type OrderHistoryUpdateOneWithoutOrderUserDealsHistoriesInput struct {
	Create     *OrderHistoryCreateWithoutOrderUserDealsHistoriesInput     `json:"create,omitempty"`
	Update     *OrderHistoryUpdateWithoutOrderUserDealsHistoriesDataInput `json:"update,omitempty"`
	Upsert     *OrderHistoryUpsertWithoutOrderUserDealsHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                                      `json:"delete,omitempty"`
	Disconnect *bool                                                      `json:"disconnect,omitempty"`
	Connect    *OrderHistoryWhereUniqueInput                              `json:"connect,omitempty"`
}

type OrderHistoryUpdateWithoutOrderUserDealsHistoriesDataInput struct {
	Type          *int32                                          `json:"type,omitempty"`
	OrderNum      *int32                                          `json:"orderNum,omitempty"`
	User          *UserUpdateOneWithoutOrderHistoriesInput        `json:"user,omitempty"`
	Coin          *CoinUpdateOneWithoutOrderHistoriesInput        `json:"coin,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutOrderHistoryInput `json:"motherHistory,omitempty"`
	OrderPrice    *float64                                        `json:"orderPrice,omitempty"`
	DealPrice     *float64                                        `json:"dealPrice,omitempty"`
	OrderQty      *float64                                        `json:"orderQty,omitempty"`
	DealQty       *float64                                        `json:"dealQty,omitempty"`
	LeftQty       *float64                                        `json:"leftQty,omitempty"`
	DealFee       *float64                                        `json:"dealFee,omitempty"`
	TakerFee      *float64                                        `json:"takerFee,omitempty"`
	MakerFee      *float64                                        `json:"makerFee,omitempty"`
	Memo          *string                                         `json:"memo,omitempty"`
	Description   *string                                         `json:"description,omitempty"`
	Offset        *int32                                          `json:"offset,omitempty"`
	IsCancel      *bool                                           `json:"isCancel,omitempty"`
}

type MotherHistoryUpdateOneWithoutOrderHistoryInput struct {
	Create     *MotherHistoryCreateWithoutOrderHistoryInput     `json:"create,omitempty"`
	Update     *MotherHistoryUpdateWithoutOrderHistoryDataInput `json:"update,omitempty"`
	Upsert     *MotherHistoryUpsertWithoutOrderHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                            `json:"delete,omitempty"`
	Disconnect *bool                                            `json:"disconnect,omitempty"`
	Connect    *MotherHistoryWhereUniqueInput                   `json:"connect,omitempty"`
}

type MotherHistoryUpdateWithoutOrderHistoryDataInput struct {
	Type                    *int32                                                     `json:"type,omitempty"`
	RoleTime                *string                                                    `json:"roleTime,omitempty"`
	Coin                    *CoinUpdateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserUpdateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostUpdateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	CashHistory             *CashHistoryUpdateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryUpdateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryUpdateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryUpdateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type AergoAccountHistoryUpdateOneWithoutMotherHistoryInput struct {
	Create     *AergoAccountHistoryCreateWithoutMotherHistoryInput     `json:"create,omitempty"`
	Update     *AergoAccountHistoryUpdateWithoutMotherHistoryDataInput `json:"update,omitempty"`
	Upsert     *AergoAccountHistoryUpsertWithoutMotherHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                   `json:"delete,omitempty"`
	Disconnect *bool                                                   `json:"disconnect,omitempty"`
	Connect    *AergoAccountHistoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type AergoAccountHistoryUpdateWithoutMotherHistoryDataInput struct {
	Type         *int32                                               `json:"type,omitempty"`
	AergoAccount *AergoAccountUpdateOneRequiredWithoutHistoriesInput  `json:"aergoAccount,omitempty"`
	CashHistory  *CashHistoryUpdateOneWithoutAergoAccountHistoryInput `json:"cashHistory,omitempty"`
	AergoAmount  *string                                              `json:"aergoAmount,omitempty"`
	AmountFee    *float64                                             `json:"amount_fee,omitempty"`
	Amount       *float64                                             `json:"amount,omitempty"`
	MarketPrice  *string                                              `json:"marketPrice,omitempty"`
	TxHash       *string                                              `json:"txHash,omitempty"`
	Memo         *string                                              `json:"memo,omitempty"`
	Description  *string                                              `json:"description,omitempty"`
	BlockNo      *int32                                               `json:"blockNo,omitempty"`
	Status       *int32                                               `json:"status,omitempty"`
}

type AergoAccountUpdateOneRequiredWithoutHistoriesInput struct {
	Create  *AergoAccountCreateWithoutHistoriesInput     `json:"create,omitempty"`
	Update  *AergoAccountUpdateWithoutHistoriesDataInput `json:"update,omitempty"`
	Upsert  *AergoAccountUpsertWithoutHistoriesInput     `json:"upsert,omitempty"`
	Connect *AergoAccountWhereUniqueInput                `json:"connect,omitempty"`
}

type AergoAccountUpdateWithoutHistoriesDataInput struct {
	ContractAddress *string                                `json:"contractAddress,omitempty"`
	Amount          *float64                               `json:"amount,omitempty"`
	Owner           *UserUpdateOneWithoutAergoAccountInput `json:"owner,omitempty"`
	LatestBlock     *int32                                 `json:"latestBlock,omitempty"`
}

type UserUpdateOneWithoutAergoAccountInput struct {
	Create     *UserCreateWithoutAergoAccountInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutAergoAccountDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutAergoAccountInput     `json:"upsert,omitempty"`
	Delete     *bool                                   `json:"delete,omitempty"`
	Disconnect *bool                                   `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                   `json:"connect,omitempty"`
}

type UserUpdateWithoutAergoAccountDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type AirDropHistoryUpdateManyWithoutUserInput struct {
	Create     []AirDropHistoryCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []AirDropHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []AirDropHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []AirDropHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []AirDropHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []AirDropHistoryUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []AirDropHistoryUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []AirDropHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []AirDropHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type AirDropHistoryUpdateWithWhereUniqueWithoutUserInput struct {
	Where AirDropHistoryWhereUniqueInput           `json:"where"`
	Data  AirDropHistoryUpdateWithoutUserDataInput `json:"data"`
}

type AirDropHistoryUpdateWithoutUserDataInput struct {
	Type          *int32                                            `json:"type,omitempty"`
	Description   *string                                           `json:"description,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutAirDropHistoryInput `json:"motherHistory,omitempty"`
	AirDrop       *AirDropUpdateOneWithoutAirDropHistoriesInput     `json:"airDrop,omitempty"`
	AirDropMember *AirDropMemberUpdateOneWithoutAirDropHistoryInput `json:"airDropMember,omitempty"`
	Qty           *float64                                          `json:"qty,omitempty"`
	CurrentPrice  *float64                                          `json:"currentPrice,omitempty"`
	Memo          *string                                           `json:"memo,omitempty"`
}

type MotherHistoryUpdateOneWithoutAirDropHistoryInput struct {
	Create     *MotherHistoryCreateWithoutAirDropHistoryInput     `json:"create,omitempty"`
	Update     *MotherHistoryUpdateWithoutAirDropHistoryDataInput `json:"update,omitempty"`
	Upsert     *MotherHistoryUpsertWithoutAirDropHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                              `json:"delete,omitempty"`
	Disconnect *bool                                              `json:"disconnect,omitempty"`
	Connect    *MotherHistoryWhereUniqueInput                     `json:"connect,omitempty"`
}

type MotherHistoryUpdateWithoutAirDropHistoryDataInput struct {
	Type                    *int32                                                     `json:"type,omitempty"`
	RoleTime                *string                                                    `json:"roleTime,omitempty"`
	Coin                    *CoinUpdateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserUpdateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostUpdateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryUpdateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryUpdateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryUpdateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryUpdateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput struct {
	Create     *QuestExpenditureHistoryCreateWithoutMotherHistoryInput     `json:"create,omitempty"`
	Update     *QuestExpenditureHistoryUpdateWithoutMotherHistoryDataInput `json:"update,omitempty"`
	Upsert     *QuestExpenditureHistoryUpsertWithoutMotherHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                       `json:"delete,omitempty"`
	Disconnect *bool                                                       `json:"disconnect,omitempty"`
	Connect    *QuestExpenditureHistoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type QuestExpenditureHistoryUpdateWithoutMotherHistoryDataInput struct {
	Type         *int32                                              `json:"type,omitempty"`
	PayType      *int32                                              `json:"payType,omitempty"`
	OrderNum     *int32                                              `json:"orderNum,omitempty"`
	Description  *string                                             `json:"description,omitempty"`
	User         *UserUpdateOneWithoutQuestExpenditureHistoriesInput `json:"user,omitempty"`
	Post         *PostUpdateOneWithoutQuestExpenditureHistoriesInput `json:"post,omitempty"`
	CashHistory  *CashHistoryUpdateOneWithoutQehInput                `json:"cashHistory,omitempty"`
	Price        *int32                                              `json:"price,omitempty"`
	Qty          *float64                                            `json:"qty,omitempty"`
	OPrice       *int32                                              `json:"oPrice,omitempty"`
	CurrentPrice *float64                                            `json:"currentPrice,omitempty"`
	Memo         *string                                             `json:"memo,omitempty"`
}

type CashHistoryUpdateOneWithoutQehInput struct {
	Create     *CashHistoryCreateWithoutQehInput     `json:"create,omitempty"`
	Update     *CashHistoryUpdateWithoutQehDataInput `json:"update,omitempty"`
	Upsert     *CashHistoryUpsertWithoutQehInput     `json:"upsert,omitempty"`
	Delete     *bool                                 `json:"delete,omitempty"`
	Disconnect *bool                                 `json:"disconnect,omitempty"`
	Connect    *CashHistoryWhereUniqueInput          `json:"connect,omitempty"`
}

type CashHistoryUpdateWithoutQehDataInput struct {
	Type                *int32                                               `json:"type,omitempty"`
	Property            *int32                                               `json:"property,omitempty"`
	OrderNum            *int32                                               `json:"orderNum,omitempty"`
	Description         *string                                              `json:"description,omitempty"`
	User                *UserUpdateOneWithoutCashHistoriesInput              `json:"user,omitempty"`
	MotherHistory       *MotherHistoryUpdateOneWithoutCashHistoryInput       `json:"motherHistory,omitempty"`
	AergoAccountHistory *AergoAccountHistoryUpdateOneWithoutCashHistoryInput `json:"aergoAccountHistory,omitempty"`
	Price               *int32                                               `json:"price,omitempty"`
	OPrice              *float64                                             `json:"oPrice,omitempty"`
	OPriceBack          *float64                                             `json:"oPriceBack,omitempty"`
	Qty                 *float64                                             `json:"qty,omitempty"`
	Memo                *string                                              `json:"memo,omitempty"`
}

type AergoAccountHistoryUpdateOneWithoutCashHistoryInput struct {
	Create     *AergoAccountHistoryCreateWithoutCashHistoryInput     `json:"create,omitempty"`
	Update     *AergoAccountHistoryUpdateWithoutCashHistoryDataInput `json:"update,omitempty"`
	Upsert     *AergoAccountHistoryUpsertWithoutCashHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                 `json:"delete,omitempty"`
	Disconnect *bool                                                 `json:"disconnect,omitempty"`
	Connect    *AergoAccountHistoryWhereUniqueInput                  `json:"connect,omitempty"`
}

type AergoAccountHistoryUpdateWithoutCashHistoryDataInput struct {
	Type          *int32                                                 `json:"type,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutAergoAccountHistoryInput `json:"motherHistory,omitempty"`
	AergoAccount  *AergoAccountUpdateOneRequiredWithoutHistoriesInput    `json:"aergoAccount,omitempty"`
	AergoAmount   *string                                                `json:"aergoAmount,omitempty"`
	AmountFee     *float64                                               `json:"amount_fee,omitempty"`
	Amount        *float64                                               `json:"amount,omitempty"`
	MarketPrice   *string                                                `json:"marketPrice,omitempty"`
	TxHash        *string                                                `json:"txHash,omitempty"`
	Memo          *string                                                `json:"memo,omitempty"`
	Description   *string                                                `json:"description,omitempty"`
	BlockNo       *int32                                                 `json:"blockNo,omitempty"`
	Status        *int32                                                 `json:"status,omitempty"`
}

type MotherHistoryUpdateOneWithoutAergoAccountHistoryInput struct {
	Create     *MotherHistoryCreateWithoutAergoAccountHistoryInput     `json:"create,omitempty"`
	Update     *MotherHistoryUpdateWithoutAergoAccountHistoryDataInput `json:"update,omitempty"`
	Upsert     *MotherHistoryUpsertWithoutAergoAccountHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                   `json:"delete,omitempty"`
	Disconnect *bool                                                   `json:"disconnect,omitempty"`
	Connect    *MotherHistoryWhereUniqueInput                          `json:"connect,omitempty"`
}

type MotherHistoryUpdateWithoutAergoAccountHistoryDataInput struct {
	Type                    *int32                                                     `json:"type,omitempty"`
	RoleTime                *string                                                    `json:"roleTime,omitempty"`
	Coin                    *CoinUpdateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserUpdateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostUpdateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryUpdateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryUpdateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryUpdateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryUpdateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type AirDropHistoryUpdateOneWithoutMotherHistoryInput struct {
	Create     *AirDropHistoryCreateWithoutMotherHistoryInput     `json:"create,omitempty"`
	Update     *AirDropHistoryUpdateWithoutMotherHistoryDataInput `json:"update,omitempty"`
	Upsert     *AirDropHistoryUpsertWithoutMotherHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                              `json:"delete,omitempty"`
	Disconnect *bool                                              `json:"disconnect,omitempty"`
	Connect    *AirDropHistoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type AirDropHistoryUpdateWithoutMotherHistoryDataInput struct {
	Type          *int32                                            `json:"type,omitempty"`
	Description   *string                                           `json:"description,omitempty"`
	User          *UserUpdateOneWithoutAirDropHistoriesInput        `json:"user,omitempty"`
	AirDrop       *AirDropUpdateOneWithoutAirDropHistoriesInput     `json:"airDrop,omitempty"`
	AirDropMember *AirDropMemberUpdateOneWithoutAirDropHistoryInput `json:"airDropMember,omitempty"`
	Qty           *float64                                          `json:"qty,omitempty"`
	CurrentPrice  *float64                                          `json:"currentPrice,omitempty"`
	Memo          *string                                           `json:"memo,omitempty"`
}

type UserUpdateOneWithoutAirDropHistoriesInput struct {
	Create     *UserCreateWithoutAirDropHistoriesInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutAirDropHistoriesDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutAirDropHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                       `json:"delete,omitempty"`
	Disconnect *bool                                       `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                       `json:"connect,omitempty"`
}

type UserUpdateWithoutAirDropHistoriesDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type AirDropMemberUpdateManyWithoutUserInput struct {
	Create     []AirDropMemberCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []AirDropMemberWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []AirDropMemberWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []AirDropMemberWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []AirDropMemberWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []AirDropMemberUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []AirDropMemberUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []AirDropMemberScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []AirDropMemberUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type AirDropMemberUpdateWithWhereUniqueWithoutUserInput struct {
	Where AirDropMemberWhereUniqueInput           `json:"where"`
	Data  AirDropMemberUpdateWithoutUserDataInput `json:"data"`
}

type AirDropMemberUpdateWithoutUserDataInput struct {
	AirDrop        *AirDropUpdateOneRequiredWithoutMembersInput      `json:"airDrop,omitempty"`
	DropNum        *int32                                            `json:"dropNum,omitempty"`
	Qty            *float64                                          `json:"qty,omitempty"`
	AirDropHistory *AirDropHistoryUpdateOneWithoutAirDropMemberInput `json:"airDropHistory,omitempty"`
	IsDel          *bool                                             `json:"isDel,omitempty"`
}

type AirDropUpdateOneRequiredWithoutMembersInput struct {
	Create  *AirDropCreateWithoutMembersInput     `json:"create,omitempty"`
	Update  *AirDropUpdateWithoutMembersDataInput `json:"update,omitempty"`
	Upsert  *AirDropUpsertWithoutMembersInput     `json:"upsert,omitempty"`
	Connect *AirDropWhereUniqueInput              `json:"connect,omitempty"`
}

type AirDropUpdateWithoutMembersDataInput struct {
	Status            *int32                                       `json:"status,omitempty"`
	Post              *PostUpdateOneRequiredWithoutAirDropInput    `json:"post,omitempty"`
	DeployTxhash      *string                                      `json:"deployTxhash,omitempty"`
	ContractAddress   *string                                      `json:"contractAddress,omitempty"`
	RandomArrayString *string                                      `json:"randomArrayString,omitempty"`
	Amount            *float64                                     `json:"amount,omitempty"`
	Left              *float64                                     `json:"left,omitempty"`
	ToDate            *string                                      `json:"toDate,omitempty"`
	AirDropHistories  *AirDropHistoryUpdateManyWithoutAirDropInput `json:"airDropHistories,omitempty"`
	IsDel             *bool                                        `json:"isDel,omitempty"`
}

type PostUpdateOneRequiredWithoutAirDropInput struct {
	Create  *PostCreateWithoutAirDropInput     `json:"create,omitempty"`
	Update  *PostUpdateWithoutAirDropDataInput `json:"update,omitempty"`
	Upsert  *PostUpsertWithoutAirDropInput     `json:"upsert,omitempty"`
	Connect *PostWhereUniqueInput              `json:"connect,omitempty"`
}

type PostUpdateWithoutAirDropDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type UserUpdateManyWithoutViewsInput struct {
	Create     []UserCreateWithoutViewsInput                `json:"create,omitempty"`
	Delete     []UserWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []UserUpdateWithWhereUniqueWithoutViewsInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueWithoutViewsInput `json:"upsert,omitempty"`
	DeleteMany []UserScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type UserUpdateWithWhereUniqueWithoutViewsInput struct {
	Where UserWhereUniqueInput            `json:"where"`
	Data  UserUpdateWithoutViewsDataInput `json:"data"`
}

type UserUpdateWithoutViewsDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type PostRewardHistoryUpdateManyWithoutUserInput struct {
	Create     []PostRewardHistoryCreateWithoutUserInput                `json:"create,omitempty"`
	Delete     []PostRewardHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []PostRewardHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []PostRewardHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []PostRewardHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []PostRewardHistoryUpdateWithWhereUniqueWithoutUserInput `json:"update,omitempty"`
	Upsert     []PostRewardHistoryUpsertWithWhereUniqueWithoutUserInput `json:"upsert,omitempty"`
	DeleteMany []PostRewardHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []PostRewardHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type PostRewardHistoryUpdateWithWhereUniqueWithoutUserInput struct {
	Where PostRewardHistoryWhereUniqueInput           `json:"where"`
	Data  PostRewardHistoryUpdateWithoutUserDataInput `json:"data"`
}

type PostRewardHistoryUpdateWithoutUserDataInput struct {
	Type          *int32                                               `json:"type,omitempty"`
	Description   *string                                              `json:"description,omitempty"`
	Post          *PostUpdateOneWithoutPostRewardHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutPostRewardHistoryInput `json:"motherHistory,omitempty"`
	Comment       *CommentUpdateOneWithoutPostRewardHistoryInput       `json:"comment,omitempty"`
	Qty           *float64                                             `json:"qty,omitempty"`
	CurrentPrice  *float64                                             `json:"currentPrice,omitempty"`
	Memo          *string                                              `json:"memo,omitempty"`
}

type PostUpdateOneWithoutPostRewardHistoriesInput struct {
	Create     *PostCreateWithoutPostRewardHistoriesInput     `json:"create,omitempty"`
	Update     *PostUpdateWithoutPostRewardHistoriesDataInput `json:"update,omitempty"`
	Upsert     *PostUpsertWithoutPostRewardHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                          `json:"delete,omitempty"`
	Disconnect *bool                                          `json:"disconnect,omitempty"`
	Connect    *PostWhereUniqueInput                          `json:"connect,omitempty"`
}

type PostUpdateWithoutPostRewardHistoriesDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type UpdatePostHistoryUpdateManyWithoutPostInput struct {
	Create     []UpdatePostHistoryCreateWithoutPostInput                `json:"create,omitempty"`
	Delete     []UpdatePostHistoryWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []UpdatePostHistoryWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []UpdatePostHistoryWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []UpdatePostHistoryWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []UpdatePostHistoryUpdateWithWhereUniqueWithoutPostInput `json:"update,omitempty"`
	Upsert     []UpdatePostHistoryUpsertWithWhereUniqueWithoutPostInput `json:"upsert,omitempty"`
	DeleteMany []UpdatePostHistoryScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []UpdatePostHistoryUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type UpdatePostHistoryUpdateWithWhereUniqueWithoutPostInput struct {
	Where UpdatePostHistoryWhereUniqueInput           `json:"where"`
	Data  UpdatePostHistoryUpdateWithoutPostDataInput `json:"data"`
}

type UpdatePostHistoryUpdateWithoutPostDataInput struct {
	Action         *int32                   `json:"action,omitempty"`
	BeforeContent  *string                  `json:"beforeContent,omitempty"`
	BeforeImageUrl *string                  `json:"beforeImageUrl,omitempty"`
	User           *UserUpdateOneInput      `json:"user,omitempty"`
	Admin          *AdminUserUpdateOneInput `json:"admin,omitempty"`
}

type UserUpdateOneInput struct {
	Create     *UserCreateInput       `json:"create,omitempty"`
	Update     *UserUpdateDataInput   `json:"update,omitempty"`
	Upsert     *UserUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                  `json:"delete,omitempty"`
	Disconnect *bool                  `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput  `json:"connect,omitempty"`
}

type AdminUserUpdateOneInput struct {
	Create     *AdminUserCreateInput       `json:"create,omitempty"`
	Update     *AdminUserUpdateDataInput   `json:"update,omitempty"`
	Upsert     *AdminUserUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                       `json:"delete,omitempty"`
	Disconnect *bool                       `json:"disconnect,omitempty"`
	Connect    *AdminUserWhereUniqueInput  `json:"connect,omitempty"`
}

type AdminUserUpdateDataInput struct {
	Role               *Role                                        `json:"role,omitempty"`
	Email              *string                                      `json:"email,omitempty"`
	Password           *string                                      `json:"password,omitempty"`
	NickName           *string                                      `json:"nickName,omitempty"`
	OtpKey             *string                                      `json:"otpKey,omitempty"`
	Level              *string                                      `json:"level,omitempty"`
	Members            *UserUpdateManyWithoutAdminUserInput         `json:"members,omitempty"`
	CreateNotification *NotificationUpdateOneWithoutCreateUserInput `json:"createNotification,omitempty"`
	UpdateNotification *NotificationUpdateOneWithoutUpdateUserInput `json:"updateNotification,omitempty"`
}

type NotificationUpdateOneWithoutUpdateUserInput struct {
	Create     *NotificationCreateWithoutUpdateUserInput     `json:"create,omitempty"`
	Update     *NotificationUpdateWithoutUpdateUserDataInput `json:"update,omitempty"`
	Upsert     *NotificationUpsertWithoutUpdateUserInput     `json:"upsert,omitempty"`
	Delete     *bool                                         `json:"delete,omitempty"`
	Disconnect *bool                                         `json:"disconnect,omitempty"`
	Connect    *NotificationWhereUniqueInput                 `json:"connect,omitempty"`
}

type NotificationUpdateWithoutUpdateUserDataInput struct {
	NotiType     *int32                                            `json:"notiType,omitempty"`
	PushType     *int32                                            `json:"pushType,omitempty"`
	PushState    *int32                                            `json:"pushState,omitempty"`
	User         *UserUpdateManyInput                              `json:"user,omitempty"`
	SendFailUser *UserUpdateManyInput                              `json:"sendFailUser,omitempty"`
	ByUser       *UserUpdateOneInput                               `json:"byUser,omitempty"`
	Post         *PostUpdateOneInput                               `json:"post,omitempty"`
	Coin         *CoinUpdateOneInput                               `json:"coin,omitempty"`
	Topic        *string                                           `json:"topic,omitempty"`
	LinkType     *string                                           `json:"linkType,omitempty"`
	LinkValue    *string                                           `json:"linkValue,omitempty"`
	Message      *string                                           `json:"message,omitempty"`
	Image        *string                                           `json:"image,omitempty"`
	PublishType  *int32                                            `json:"publishType,omitempty"`
	PublishDate  *string                                           `json:"publishDate,omitempty"`
	CreateUser   *AdminUserUpdateOneWithoutCreateNotificationInput `json:"createUser,omitempty"`
	IsDel        *bool                                             `json:"isDel,omitempty"`
}

type AdminUserUpdateOneWithoutCreateNotificationInput struct {
	Create     *AdminUserCreateWithoutCreateNotificationInput     `json:"create,omitempty"`
	Update     *AdminUserUpdateWithoutCreateNotificationDataInput `json:"update,omitempty"`
	Upsert     *AdminUserUpsertWithoutCreateNotificationInput     `json:"upsert,omitempty"`
	Delete     *bool                                              `json:"delete,omitempty"`
	Disconnect *bool                                              `json:"disconnect,omitempty"`
	Connect    *AdminUserWhereUniqueInput                         `json:"connect,omitempty"`
}

type AdminUserUpdateWithoutCreateNotificationDataInput struct {
	Role               *Role                                        `json:"role,omitempty"`
	Email              *string                                      `json:"email,omitempty"`
	Password           *string                                      `json:"password,omitempty"`
	NickName           *string                                      `json:"nickName,omitempty"`
	OtpKey             *string                                      `json:"otpKey,omitempty"`
	Level              *string                                      `json:"level,omitempty"`
	Members            *UserUpdateManyWithoutAdminUserInput         `json:"members,omitempty"`
	UpdateNotification *NotificationUpdateOneWithoutUpdateUserInput `json:"updateNotification,omitempty"`
}

type AdminUserUpsertWithoutCreateNotificationInput struct {
	Update AdminUserUpdateWithoutCreateNotificationDataInput `json:"update"`
	Create AdminUserCreateWithoutCreateNotificationInput     `json:"create"`
}

type NotificationUpsertWithoutUpdateUserInput struct {
	Update NotificationUpdateWithoutUpdateUserDataInput `json:"update"`
	Create NotificationCreateWithoutUpdateUserInput     `json:"create"`
}

type AdminUserUpsertNestedInput struct {
	Update AdminUserUpdateDataInput `json:"update"`
	Create AdminUserCreateInput     `json:"create"`
}

type UpdatePostHistoryUpsertWithWhereUniqueWithoutPostInput struct {
	Where  UpdatePostHistoryWhereUniqueInput           `json:"where"`
	Update UpdatePostHistoryUpdateWithoutPostDataInput `json:"update"`
	Create UpdatePostHistoryCreateWithoutPostInput     `json:"create"`
}

type UpdatePostHistoryScalarWhereInput struct {
	ID                          *string                             `json:"id,omitempty"`
	IDNot                       *string                             `json:"id_not,omitempty"`
	IDIn                        []string                            `json:"id_in,omitempty"`
	IDNotIn                     []string                            `json:"id_not_in,omitempty"`
	IDLt                        *string                             `json:"id_lt,omitempty"`
	IDLte                       *string                             `json:"id_lte,omitempty"`
	IDGt                        *string                             `json:"id_gt,omitempty"`
	IDGte                       *string                             `json:"id_gte,omitempty"`
	IDContains                  *string                             `json:"id_contains,omitempty"`
	IDNotContains               *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                             `json:"id_not_ends_with,omitempty"`
	Action                      *int32                              `json:"action,omitempty"`
	ActionNot                   *int32                              `json:"action_not,omitempty"`
	ActionIn                    []int32                             `json:"action_in,omitempty"`
	ActionNotIn                 []int32                             `json:"action_not_in,omitempty"`
	ActionLt                    *int32                              `json:"action_lt,omitempty"`
	ActionLte                   *int32                              `json:"action_lte,omitempty"`
	ActionGt                    *int32                              `json:"action_gt,omitempty"`
	ActionGte                   *int32                              `json:"action_gte,omitempty"`
	BeforeContent               *string                             `json:"beforeContent,omitempty"`
	BeforeContentNot            *string                             `json:"beforeContent_not,omitempty"`
	BeforeContentIn             []string                            `json:"beforeContent_in,omitempty"`
	BeforeContentNotIn          []string                            `json:"beforeContent_not_in,omitempty"`
	BeforeContentLt             *string                             `json:"beforeContent_lt,omitempty"`
	BeforeContentLte            *string                             `json:"beforeContent_lte,omitempty"`
	BeforeContentGt             *string                             `json:"beforeContent_gt,omitempty"`
	BeforeContentGte            *string                             `json:"beforeContent_gte,omitempty"`
	BeforeContentContains       *string                             `json:"beforeContent_contains,omitempty"`
	BeforeContentNotContains    *string                             `json:"beforeContent_not_contains,omitempty"`
	BeforeContentStartsWith     *string                             `json:"beforeContent_starts_with,omitempty"`
	BeforeContentNotStartsWith  *string                             `json:"beforeContent_not_starts_with,omitempty"`
	BeforeContentEndsWith       *string                             `json:"beforeContent_ends_with,omitempty"`
	BeforeContentNotEndsWith    *string                             `json:"beforeContent_not_ends_with,omitempty"`
	BeforeImageUrl              *string                             `json:"beforeImageUrl,omitempty"`
	BeforeImageUrlNot           *string                             `json:"beforeImageUrl_not,omitempty"`
	BeforeImageUrlIn            []string                            `json:"beforeImageUrl_in,omitempty"`
	BeforeImageUrlNotIn         []string                            `json:"beforeImageUrl_not_in,omitempty"`
	BeforeImageUrlLt            *string                             `json:"beforeImageUrl_lt,omitempty"`
	BeforeImageUrlLte           *string                             `json:"beforeImageUrl_lte,omitempty"`
	BeforeImageUrlGt            *string                             `json:"beforeImageUrl_gt,omitempty"`
	BeforeImageUrlGte           *string                             `json:"beforeImageUrl_gte,omitempty"`
	BeforeImageUrlContains      *string                             `json:"beforeImageUrl_contains,omitempty"`
	BeforeImageUrlNotContains   *string                             `json:"beforeImageUrl_not_contains,omitempty"`
	BeforeImageUrlStartsWith    *string                             `json:"beforeImageUrl_starts_with,omitempty"`
	BeforeImageUrlNotStartsWith *string                             `json:"beforeImageUrl_not_starts_with,omitempty"`
	BeforeImageUrlEndsWith      *string                             `json:"beforeImageUrl_ends_with,omitempty"`
	BeforeImageUrlNotEndsWith   *string                             `json:"beforeImageUrl_not_ends_with,omitempty"`
	CreatedAt                   *string                             `json:"createdAt,omitempty"`
	CreatedAtNot                *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                             `json:"createdAt_gte,omitempty"`
	And                         []UpdatePostHistoryScalarWhereInput `json:"AND,omitempty"`
	Or                          []UpdatePostHistoryScalarWhereInput `json:"OR,omitempty"`
	Not                         []UpdatePostHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type UpdatePostHistoryUpdateManyWithWhereNestedInput struct {
	Where UpdatePostHistoryScalarWhereInput    `json:"where"`
	Data  UpdatePostHistoryUpdateManyDataInput `json:"data"`
}

type UpdatePostHistoryUpdateManyDataInput struct {
	Action         *int32  `json:"action,omitempty"`
	BeforeContent  *string `json:"beforeContent,omitempty"`
	BeforeImageUrl *string `json:"beforeImageUrl,omitempty"`
}

type PostUpsertWithoutPostRewardHistoriesInput struct {
	Update PostUpdateWithoutPostRewardHistoriesDataInput `json:"update"`
	Create PostCreateWithoutPostRewardHistoriesInput     `json:"create"`
}

type MotherHistoryUpdateOneWithoutPostRewardHistoryInput struct {
	Create     *MotherHistoryCreateWithoutPostRewardHistoryInput     `json:"create,omitempty"`
	Update     *MotherHistoryUpdateWithoutPostRewardHistoryDataInput `json:"update,omitempty"`
	Upsert     *MotherHistoryUpsertWithoutPostRewardHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                 `json:"delete,omitempty"`
	Disconnect *bool                                                 `json:"disconnect,omitempty"`
	Connect    *MotherHistoryWhereUniqueInput                        `json:"connect,omitempty"`
}

type MotherHistoryUpdateWithoutPostRewardHistoryDataInput struct {
	Type                    *int32                                                     `json:"type,omitempty"`
	RoleTime                *string                                                    `json:"roleTime,omitempty"`
	Coin                    *CoinUpdateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserUpdateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostUpdateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryUpdateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryUpdateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryUpdateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryUpdateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
}

type MotherHistoryUpsertWithoutPostRewardHistoryInput struct {
	Update MotherHistoryUpdateWithoutPostRewardHistoryDataInput `json:"update"`
	Create MotherHistoryCreateWithoutPostRewardHistoryInput     `json:"create"`
}

type CommentUpdateOneWithoutPostRewardHistoryInput struct {
	Create     *CommentCreateWithoutPostRewardHistoryInput     `json:"create,omitempty"`
	Update     *CommentUpdateWithoutPostRewardHistoryDataInput `json:"update,omitempty"`
	Upsert     *CommentUpsertWithoutPostRewardHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                           `json:"delete,omitempty"`
	Disconnect *bool                                           `json:"disconnect,omitempty"`
	Connect    *CommentWhereUniqueInput                        `json:"connect,omitempty"`
}

type CommentUpdateWithoutPostRewardHistoryDataInput struct {
	Type    *int32                                     `json:"type,omitempty"`
	Post    *PostUpdateOneRequiredWithoutCommentsInput `json:"post,omitempty"`
	Content *string                                    `json:"content,omitempty"`
	Image   *FileInfoUpdateOneInput                    `json:"image,omitempty"`
	Url     *string                                    `json:"url,omitempty"`
	Reply   *CommentReplyUpdateManyWithoutCommentInput `json:"reply,omitempty"`
	Owner   *UserUpdateOneRequiredWithoutCommentsInput `json:"owner,omitempty"`
	IsDel   *bool                                      `json:"isDel,omitempty"`
}

type CommentUpsertWithoutPostRewardHistoryInput struct {
	Update CommentUpdateWithoutPostRewardHistoryDataInput `json:"update"`
	Create CommentCreateWithoutPostRewardHistoryInput     `json:"create"`
}

type PostRewardHistoryUpsertWithWhereUniqueWithoutUserInput struct {
	Where  PostRewardHistoryWhereUniqueInput           `json:"where"`
	Update PostRewardHistoryUpdateWithoutUserDataInput `json:"update"`
	Create PostRewardHistoryCreateWithoutUserInput     `json:"create"`
}

type PostRewardHistoryScalarWhereInput struct {
	ID                       *string                             `json:"id,omitempty"`
	IDNot                    *string                             `json:"id_not,omitempty"`
	IDIn                     []string                            `json:"id_in,omitempty"`
	IDNotIn                  []string                            `json:"id_not_in,omitempty"`
	IDLt                     *string                             `json:"id_lt,omitempty"`
	IDLte                    *string                             `json:"id_lte,omitempty"`
	IDGt                     *string                             `json:"id_gt,omitempty"`
	IDGte                    *string                             `json:"id_gte,omitempty"`
	IDContains               *string                             `json:"id_contains,omitempty"`
	IDNotContains            *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                             `json:"id_not_ends_with,omitempty"`
	Type                     *int32                              `json:"type,omitempty"`
	TypeNot                  *int32                              `json:"type_not,omitempty"`
	TypeIn                   []int32                             `json:"type_in,omitempty"`
	TypeNotIn                []int32                             `json:"type_not_in,omitempty"`
	TypeLt                   *int32                              `json:"type_lt,omitempty"`
	TypeLte                  *int32                              `json:"type_lte,omitempty"`
	TypeGt                   *int32                              `json:"type_gt,omitempty"`
	TypeGte                  *int32                              `json:"type_gte,omitempty"`
	Description              *string                             `json:"description,omitempty"`
	DescriptionNot           *string                             `json:"description_not,omitempty"`
	DescriptionIn            []string                            `json:"description_in,omitempty"`
	DescriptionNotIn         []string                            `json:"description_not_in,omitempty"`
	DescriptionLt            *string                             `json:"description_lt,omitempty"`
	DescriptionLte           *string                             `json:"description_lte,omitempty"`
	DescriptionGt            *string                             `json:"description_gt,omitempty"`
	DescriptionGte           *string                             `json:"description_gte,omitempty"`
	DescriptionContains      *string                             `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                             `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                             `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                             `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                             `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                             `json:"description_not_ends_with,omitempty"`
	Qty                      *float64                            `json:"qty,omitempty"`
	QtyNot                   *float64                            `json:"qty_not,omitempty"`
	QtyIn                    []float64                           `json:"qty_in,omitempty"`
	QtyNotIn                 []float64                           `json:"qty_not_in,omitempty"`
	QtyLt                    *float64                            `json:"qty_lt,omitempty"`
	QtyLte                   *float64                            `json:"qty_lte,omitempty"`
	QtyGt                    *float64                            `json:"qty_gt,omitempty"`
	QtyGte                   *float64                            `json:"qty_gte,omitempty"`
	CurrentPrice             *float64                            `json:"currentPrice,omitempty"`
	CurrentPriceNot          *float64                            `json:"currentPrice_not,omitempty"`
	CurrentPriceIn           []float64                           `json:"currentPrice_in,omitempty"`
	CurrentPriceNotIn        []float64                           `json:"currentPrice_not_in,omitempty"`
	CurrentPriceLt           *float64                            `json:"currentPrice_lt,omitempty"`
	CurrentPriceLte          *float64                            `json:"currentPrice_lte,omitempty"`
	CurrentPriceGt           *float64                            `json:"currentPrice_gt,omitempty"`
	CurrentPriceGte          *float64                            `json:"currentPrice_gte,omitempty"`
	Memo                     *string                             `json:"memo,omitempty"`
	MemoNot                  *string                             `json:"memo_not,omitempty"`
	MemoIn                   []string                            `json:"memo_in,omitempty"`
	MemoNotIn                []string                            `json:"memo_not_in,omitempty"`
	MemoLt                   *string                             `json:"memo_lt,omitempty"`
	MemoLte                  *string                             `json:"memo_lte,omitempty"`
	MemoGt                   *string                             `json:"memo_gt,omitempty"`
	MemoGte                  *string                             `json:"memo_gte,omitempty"`
	MemoContains             *string                             `json:"memo_contains,omitempty"`
	MemoNotContains          *string                             `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                             `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                             `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                             `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                             `json:"memo_not_ends_with,omitempty"`
	CreatedAt                *string                             `json:"createdAt,omitempty"`
	CreatedAtNot             *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                             `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                             `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                             `json:"updatedAt_gte,omitempty"`
	And                      []PostRewardHistoryScalarWhereInput `json:"AND,omitempty"`
	Or                       []PostRewardHistoryScalarWhereInput `json:"OR,omitempty"`
	Not                      []PostRewardHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type PostRewardHistoryUpdateManyWithWhereNestedInput struct {
	Where PostRewardHistoryScalarWhereInput    `json:"where"`
	Data  PostRewardHistoryUpdateManyDataInput `json:"data"`
}

type PostRewardHistoryUpdateManyDataInput struct {
	Type         *int32   `json:"type,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
}

type AergoAccountUpdateOneWithoutOwnerInput struct {
	Create     *AergoAccountCreateWithoutOwnerInput     `json:"create,omitempty"`
	Update     *AergoAccountUpdateWithoutOwnerDataInput `json:"update,omitempty"`
	Upsert     *AergoAccountUpsertWithoutOwnerInput     `json:"upsert,omitempty"`
	Delete     *bool                                    `json:"delete,omitempty"`
	Disconnect *bool                                    `json:"disconnect,omitempty"`
	Connect    *AergoAccountWhereUniqueInput            `json:"connect,omitempty"`
}

type AergoAccountUpdateWithoutOwnerDataInput struct {
	ContractAddress *string                                                `json:"contractAddress,omitempty"`
	Amount          *float64                                               `json:"amount,omitempty"`
	LatestBlock     *int32                                                 `json:"latestBlock,omitempty"`
	Histories       *AergoAccountHistoryUpdateManyWithoutAergoAccountInput `json:"histories,omitempty"`
}

type AergoAccountHistoryUpdateManyWithoutAergoAccountInput struct {
	Create     []AergoAccountHistoryCreateWithoutAergoAccountInput                `json:"create,omitempty"`
	Delete     []AergoAccountHistoryWhereUniqueInput                              `json:"delete,omitempty"`
	Connect    []AergoAccountHistoryWhereUniqueInput                              `json:"connect,omitempty"`
	Set        []AergoAccountHistoryWhereUniqueInput                              `json:"set,omitempty"`
	Disconnect []AergoAccountHistoryWhereUniqueInput                              `json:"disconnect,omitempty"`
	Update     []AergoAccountHistoryUpdateWithWhereUniqueWithoutAergoAccountInput `json:"update,omitempty"`
	Upsert     []AergoAccountHistoryUpsertWithWhereUniqueWithoutAergoAccountInput `json:"upsert,omitempty"`
	DeleteMany []AergoAccountHistoryScalarWhereInput                              `json:"deleteMany,omitempty"`
	UpdateMany []AergoAccountHistoryUpdateManyWithWhereNestedInput                `json:"updateMany,omitempty"`
}

type AergoAccountHistoryUpdateWithWhereUniqueWithoutAergoAccountInput struct {
	Where AergoAccountHistoryWhereUniqueInput                   `json:"where"`
	Data  AergoAccountHistoryUpdateWithoutAergoAccountDataInput `json:"data"`
}

type AergoAccountHistoryUpdateWithoutAergoAccountDataInput struct {
	Type          *int32                                                 `json:"type,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutAergoAccountHistoryInput `json:"motherHistory,omitempty"`
	CashHistory   *CashHistoryUpdateOneWithoutAergoAccountHistoryInput   `json:"cashHistory,omitempty"`
	AergoAmount   *string                                                `json:"aergoAmount,omitempty"`
	AmountFee     *float64                                               `json:"amount_fee,omitempty"`
	Amount        *float64                                               `json:"amount,omitempty"`
	MarketPrice   *string                                                `json:"marketPrice,omitempty"`
	TxHash        *string                                                `json:"txHash,omitempty"`
	Memo          *string                                                `json:"memo,omitempty"`
	Description   *string                                                `json:"description,omitempty"`
	BlockNo       *int32                                                 `json:"blockNo,omitempty"`
	Status        *int32                                                 `json:"status,omitempty"`
}

type CashHistoryUpdateOneWithoutAergoAccountHistoryInput struct {
	Create     *CashHistoryCreateWithoutAergoAccountHistoryInput     `json:"create,omitempty"`
	Update     *CashHistoryUpdateWithoutAergoAccountHistoryDataInput `json:"update,omitempty"`
	Upsert     *CashHistoryUpsertWithoutAergoAccountHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                 `json:"delete,omitempty"`
	Disconnect *bool                                                 `json:"disconnect,omitempty"`
	Connect    *CashHistoryWhereUniqueInput                          `json:"connect,omitempty"`
}

type CashHistoryUpdateWithoutAergoAccountHistoryDataInput struct {
	Type          *int32                                                   `json:"type,omitempty"`
	Property      *int32                                                   `json:"property,omitempty"`
	OrderNum      *int32                                                   `json:"orderNum,omitempty"`
	Description   *string                                                  `json:"description,omitempty"`
	User          *UserUpdateOneWithoutCashHistoriesInput                  `json:"user,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutCashHistoryInput           `json:"motherHistory,omitempty"`
	Qeh           *QuestExpenditureHistoryUpdateOneWithoutCashHistoryInput `json:"qeh,omitempty"`
	Price         *int32                                                   `json:"price,omitempty"`
	OPrice        *float64                                                 `json:"oPrice,omitempty"`
	OPriceBack    *float64                                                 `json:"oPriceBack,omitempty"`
	Qty           *float64                                                 `json:"qty,omitempty"`
	Memo          *string                                                  `json:"memo,omitempty"`
}

type QuestExpenditureHistoryUpdateOneWithoutCashHistoryInput struct {
	Create     *QuestExpenditureHistoryCreateWithoutCashHistoryInput     `json:"create,omitempty"`
	Update     *QuestExpenditureHistoryUpdateWithoutCashHistoryDataInput `json:"update,omitempty"`
	Upsert     *QuestExpenditureHistoryUpsertWithoutCashHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                     `json:"delete,omitempty"`
	Disconnect *bool                                                     `json:"disconnect,omitempty"`
	Connect    *QuestExpenditureHistoryWhereUniqueInput                  `json:"connect,omitempty"`
}

type QuestExpenditureHistoryUpdateWithoutCashHistoryDataInput struct {
	Type          *int32                                                     `json:"type,omitempty"`
	PayType       *int32                                                     `json:"payType,omitempty"`
	OrderNum      *int32                                                     `json:"orderNum,omitempty"`
	Description   *string                                                    `json:"description,omitempty"`
	User          *UserUpdateOneWithoutQuestExpenditureHistoriesInput        `json:"user,omitempty"`
	Post          *PostUpdateOneWithoutQuestExpenditureHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutQuestExpenditureHistoryInput `json:"motherHistory,omitempty"`
	Price         *int32                                                     `json:"price,omitempty"`
	Qty           *float64                                                   `json:"qty,omitempty"`
	OPrice        *int32                                                     `json:"oPrice,omitempty"`
	CurrentPrice  *float64                                                   `json:"currentPrice,omitempty"`
	Memo          *string                                                    `json:"memo,omitempty"`
}

type MotherHistoryUpdateOneWithoutQuestExpenditureHistoryInput struct {
	Create     *MotherHistoryCreateWithoutQuestExpenditureHistoryInput     `json:"create,omitempty"`
	Update     *MotherHistoryUpdateWithoutQuestExpenditureHistoryDataInput `json:"update,omitempty"`
	Upsert     *MotherHistoryUpsertWithoutQuestExpenditureHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                       `json:"delete,omitempty"`
	Disconnect *bool                                                       `json:"disconnect,omitempty"`
	Connect    *MotherHistoryWhereUniqueInput                              `json:"connect,omitempty"`
}

type MotherHistoryUpdateWithoutQuestExpenditureHistoryDataInput struct {
	Type                  *int32                                                   `json:"type,omitempty"`
	RoleTime              *string                                                  `json:"roleTime,omitempty"`
	Coin                  *CoinUpdateOneWithoutMotherHistoriesInput                `json:"coin,omitempty"`
	User                  *UserUpdateOneWithoutMotherHistoriesInput                `json:"user,omitempty"`
	Post                  *PostUpdateOneWithoutMotherHistoriesInput                `json:"post,omitempty"`
	OrderUserDealsHistory *OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput `json:"orderUserDealsHistory,omitempty"`
	OrderHistory          *OrderHistoryUpdateOneWithoutMotherHistoryInput          `json:"orderHistory,omitempty"`
	CashHistory           *CashHistoryUpdateOneWithoutMotherHistoryInput           `json:"cashHistory,omitempty"`
	AergoAccountHistory   *AergoAccountHistoryUpdateOneWithoutMotherHistoryInput   `json:"aergoAccountHistory,omitempty"`
	AirDropHistory        *AirDropHistoryUpdateOneWithoutMotherHistoryInput        `json:"airDropHistory,omitempty"`
	PostRewardHistory     *PostRewardHistoryUpdateOneWithoutMotherHistoryInput     `json:"postRewardHistory,omitempty"`
}

type PostRewardHistoryUpdateOneWithoutMotherHistoryInput struct {
	Create     *PostRewardHistoryCreateWithoutMotherHistoryInput     `json:"create,omitempty"`
	Update     *PostRewardHistoryUpdateWithoutMotherHistoryDataInput `json:"update,omitempty"`
	Upsert     *PostRewardHistoryUpsertWithoutMotherHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                                 `json:"delete,omitempty"`
	Disconnect *bool                                                 `json:"disconnect,omitempty"`
	Connect    *PostRewardHistoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type PostRewardHistoryUpdateWithoutMotherHistoryDataInput struct {
	Type         *int32                                         `json:"type,omitempty"`
	Description  *string                                        `json:"description,omitempty"`
	User         *UserUpdateOneWithoutPostRewardHistoriesInput  `json:"user,omitempty"`
	Post         *PostUpdateOneWithoutPostRewardHistoriesInput  `json:"post,omitempty"`
	Comment      *CommentUpdateOneWithoutPostRewardHistoryInput `json:"comment,omitempty"`
	Qty          *float64                                       `json:"qty,omitempty"`
	CurrentPrice *float64                                       `json:"currentPrice,omitempty"`
	Memo         *string                                        `json:"memo,omitempty"`
}

type PostRewardHistoryUpsertWithoutMotherHistoryInput struct {
	Update PostRewardHistoryUpdateWithoutMotherHistoryDataInput `json:"update"`
	Create PostRewardHistoryCreateWithoutMotherHistoryInput     `json:"create"`
}

type MotherHistoryUpsertWithoutQuestExpenditureHistoryInput struct {
	Update MotherHistoryUpdateWithoutQuestExpenditureHistoryDataInput `json:"update"`
	Create MotherHistoryCreateWithoutQuestExpenditureHistoryInput     `json:"create"`
}

type QuestExpenditureHistoryUpsertWithoutCashHistoryInput struct {
	Update QuestExpenditureHistoryUpdateWithoutCashHistoryDataInput `json:"update"`
	Create QuestExpenditureHistoryCreateWithoutCashHistoryInput     `json:"create"`
}

type CashHistoryUpsertWithoutAergoAccountHistoryInput struct {
	Update CashHistoryUpdateWithoutAergoAccountHistoryDataInput `json:"update"`
	Create CashHistoryCreateWithoutAergoAccountHistoryInput     `json:"create"`
}

type AergoAccountHistoryUpsertWithWhereUniqueWithoutAergoAccountInput struct {
	Where  AergoAccountHistoryWhereUniqueInput                   `json:"where"`
	Update AergoAccountHistoryUpdateWithoutAergoAccountDataInput `json:"update"`
	Create AergoAccountHistoryCreateWithoutAergoAccountInput     `json:"create"`
}

type AergoAccountHistoryScalarWhereInput struct {
	ID                       *string                               `json:"id,omitempty"`
	IDNot                    *string                               `json:"id_not,omitempty"`
	IDIn                     []string                              `json:"id_in,omitempty"`
	IDNotIn                  []string                              `json:"id_not_in,omitempty"`
	IDLt                     *string                               `json:"id_lt,omitempty"`
	IDLte                    *string                               `json:"id_lte,omitempty"`
	IDGt                     *string                               `json:"id_gt,omitempty"`
	IDGte                    *string                               `json:"id_gte,omitempty"`
	IDContains               *string                               `json:"id_contains,omitempty"`
	IDNotContains            *string                               `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                               `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                               `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                               `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                               `json:"id_not_ends_with,omitempty"`
	Type                     *int32                                `json:"type,omitempty"`
	TypeNot                  *int32                                `json:"type_not,omitempty"`
	TypeIn                   []int32                               `json:"type_in,omitempty"`
	TypeNotIn                []int32                               `json:"type_not_in,omitempty"`
	TypeLt                   *int32                                `json:"type_lt,omitempty"`
	TypeLte                  *int32                                `json:"type_lte,omitempty"`
	TypeGt                   *int32                                `json:"type_gt,omitempty"`
	TypeGte                  *int32                                `json:"type_gte,omitempty"`
	AergoAmount              *string                               `json:"aergoAmount,omitempty"`
	AergoAmountNot           *string                               `json:"aergoAmount_not,omitempty"`
	AergoAmountIn            []string                              `json:"aergoAmount_in,omitempty"`
	AergoAmountNotIn         []string                              `json:"aergoAmount_not_in,omitempty"`
	AergoAmountLt            *string                               `json:"aergoAmount_lt,omitempty"`
	AergoAmountLte           *string                               `json:"aergoAmount_lte,omitempty"`
	AergoAmountGt            *string                               `json:"aergoAmount_gt,omitempty"`
	AergoAmountGte           *string                               `json:"aergoAmount_gte,omitempty"`
	AergoAmountContains      *string                               `json:"aergoAmount_contains,omitempty"`
	AergoAmountNotContains   *string                               `json:"aergoAmount_not_contains,omitempty"`
	AergoAmountStartsWith    *string                               `json:"aergoAmount_starts_with,omitempty"`
	AergoAmountNotStartsWith *string                               `json:"aergoAmount_not_starts_with,omitempty"`
	AergoAmountEndsWith      *string                               `json:"aergoAmount_ends_with,omitempty"`
	AergoAmountNotEndsWith   *string                               `json:"aergoAmount_not_ends_with,omitempty"`
	AmountFee                *float64                              `json:"amount_fee,omitempty"`
	AmountFeeNot             *float64                              `json:"amount_fee_not,omitempty"`
	AmountFeeIn              []float64                             `json:"amount_fee_in,omitempty"`
	AmountFeeNotIn           []float64                             `json:"amount_fee_not_in,omitempty"`
	AmountFeeLt              *float64                              `json:"amount_fee_lt,omitempty"`
	AmountFeeLte             *float64                              `json:"amount_fee_lte,omitempty"`
	AmountFeeGt              *float64                              `json:"amount_fee_gt,omitempty"`
	AmountFeeGte             *float64                              `json:"amount_fee_gte,omitempty"`
	Amount                   *float64                              `json:"amount,omitempty"`
	AmountNot                *float64                              `json:"amount_not,omitempty"`
	AmountIn                 []float64                             `json:"amount_in,omitempty"`
	AmountNotIn              []float64                             `json:"amount_not_in,omitempty"`
	AmountLt                 *float64                              `json:"amount_lt,omitempty"`
	AmountLte                *float64                              `json:"amount_lte,omitempty"`
	AmountGt                 *float64                              `json:"amount_gt,omitempty"`
	AmountGte                *float64                              `json:"amount_gte,omitempty"`
	MarketPrice              *string                               `json:"marketPrice,omitempty"`
	MarketPriceNot           *string                               `json:"marketPrice_not,omitempty"`
	MarketPriceIn            []string                              `json:"marketPrice_in,omitempty"`
	MarketPriceNotIn         []string                              `json:"marketPrice_not_in,omitempty"`
	MarketPriceLt            *string                               `json:"marketPrice_lt,omitempty"`
	MarketPriceLte           *string                               `json:"marketPrice_lte,omitempty"`
	MarketPriceGt            *string                               `json:"marketPrice_gt,omitempty"`
	MarketPriceGte           *string                               `json:"marketPrice_gte,omitempty"`
	MarketPriceContains      *string                               `json:"marketPrice_contains,omitempty"`
	MarketPriceNotContains   *string                               `json:"marketPrice_not_contains,omitempty"`
	MarketPriceStartsWith    *string                               `json:"marketPrice_starts_with,omitempty"`
	MarketPriceNotStartsWith *string                               `json:"marketPrice_not_starts_with,omitempty"`
	MarketPriceEndsWith      *string                               `json:"marketPrice_ends_with,omitempty"`
	MarketPriceNotEndsWith   *string                               `json:"marketPrice_not_ends_with,omitempty"`
	TxHash                   *string                               `json:"txHash,omitempty"`
	TxHashNot                *string                               `json:"txHash_not,omitempty"`
	TxHashIn                 []string                              `json:"txHash_in,omitempty"`
	TxHashNotIn              []string                              `json:"txHash_not_in,omitempty"`
	TxHashLt                 *string                               `json:"txHash_lt,omitempty"`
	TxHashLte                *string                               `json:"txHash_lte,omitempty"`
	TxHashGt                 *string                               `json:"txHash_gt,omitempty"`
	TxHashGte                *string                               `json:"txHash_gte,omitempty"`
	TxHashContains           *string                               `json:"txHash_contains,omitempty"`
	TxHashNotContains        *string                               `json:"txHash_not_contains,omitempty"`
	TxHashStartsWith         *string                               `json:"txHash_starts_with,omitempty"`
	TxHashNotStartsWith      *string                               `json:"txHash_not_starts_with,omitempty"`
	TxHashEndsWith           *string                               `json:"txHash_ends_with,omitempty"`
	TxHashNotEndsWith        *string                               `json:"txHash_not_ends_with,omitempty"`
	Memo                     *string                               `json:"memo,omitempty"`
	MemoNot                  *string                               `json:"memo_not,omitempty"`
	MemoIn                   []string                              `json:"memo_in,omitempty"`
	MemoNotIn                []string                              `json:"memo_not_in,omitempty"`
	MemoLt                   *string                               `json:"memo_lt,omitempty"`
	MemoLte                  *string                               `json:"memo_lte,omitempty"`
	MemoGt                   *string                               `json:"memo_gt,omitempty"`
	MemoGte                  *string                               `json:"memo_gte,omitempty"`
	MemoContains             *string                               `json:"memo_contains,omitempty"`
	MemoNotContains          *string                               `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                               `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                               `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                               `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                               `json:"memo_not_ends_with,omitempty"`
	Description              *string                               `json:"description,omitempty"`
	DescriptionNot           *string                               `json:"description_not,omitempty"`
	DescriptionIn            []string                              `json:"description_in,omitempty"`
	DescriptionNotIn         []string                              `json:"description_not_in,omitempty"`
	DescriptionLt            *string                               `json:"description_lt,omitempty"`
	DescriptionLte           *string                               `json:"description_lte,omitempty"`
	DescriptionGt            *string                               `json:"description_gt,omitempty"`
	DescriptionGte           *string                               `json:"description_gte,omitempty"`
	DescriptionContains      *string                               `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                               `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                               `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                               `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                               `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                               `json:"description_not_ends_with,omitempty"`
	BlockNo                  *int32                                `json:"blockNo,omitempty"`
	BlockNoNot               *int32                                `json:"blockNo_not,omitempty"`
	BlockNoIn                []int32                               `json:"blockNo_in,omitempty"`
	BlockNoNotIn             []int32                               `json:"blockNo_not_in,omitempty"`
	BlockNoLt                *int32                                `json:"blockNo_lt,omitempty"`
	BlockNoLte               *int32                                `json:"blockNo_lte,omitempty"`
	BlockNoGt                *int32                                `json:"blockNo_gt,omitempty"`
	BlockNoGte               *int32                                `json:"blockNo_gte,omitempty"`
	Status                   *int32                                `json:"status,omitempty"`
	StatusNot                *int32                                `json:"status_not,omitempty"`
	StatusIn                 []int32                               `json:"status_in,omitempty"`
	StatusNotIn              []int32                               `json:"status_not_in,omitempty"`
	StatusLt                 *int32                                `json:"status_lt,omitempty"`
	StatusLte                *int32                                `json:"status_lte,omitempty"`
	StatusGt                 *int32                                `json:"status_gt,omitempty"`
	StatusGte                *int32                                `json:"status_gte,omitempty"`
	CreatedAt                *string                               `json:"createdAt,omitempty"`
	CreatedAtNot             *string                               `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                               `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                               `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                               `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                               `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                               `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                               `json:"updatedAt_gte,omitempty"`
	And                      []AergoAccountHistoryScalarWhereInput `json:"AND,omitempty"`
	Or                       []AergoAccountHistoryScalarWhereInput `json:"OR,omitempty"`
	Not                      []AergoAccountHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type AergoAccountHistoryUpdateManyWithWhereNestedInput struct {
	Where AergoAccountHistoryScalarWhereInput    `json:"where"`
	Data  AergoAccountHistoryUpdateManyDataInput `json:"data"`
}

type AergoAccountHistoryUpdateManyDataInput struct {
	Type        *int32   `json:"type,omitempty"`
	AergoAmount *string  `json:"aergoAmount,omitempty"`
	AmountFee   *float64 `json:"amount_fee,omitempty"`
	Amount      *float64 `json:"amount,omitempty"`
	MarketPrice *string  `json:"marketPrice,omitempty"`
	TxHash      *string  `json:"txHash,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
	Description *string  `json:"description,omitempty"`
	BlockNo     *int32   `json:"blockNo,omitempty"`
	Status      *int32   `json:"status,omitempty"`
}

type AergoAccountUpsertWithoutOwnerInput struct {
	Update AergoAccountUpdateWithoutOwnerDataInput `json:"update"`
	Create AergoAccountCreateWithoutOwnerInput     `json:"create"`
}

type FeeUpdateOneWithoutRankRelationInput struct {
	Create     *FeeCreateWithoutRankRelationInput     `json:"create,omitempty"`
	Update     *FeeUpdateWithoutRankRelationDataInput `json:"update,omitempty"`
	Upsert     *FeeUpsertWithoutRankRelationInput     `json:"upsert,omitempty"`
	Delete     *bool                                  `json:"delete,omitempty"`
	Disconnect *bool                                  `json:"disconnect,omitempty"`
	Connect    *FeeWhereUniqueInput                   `json:"connect,omitempty"`
}

type FeeUpdateWithoutRankRelationDataInput struct {
	Type              *int32                              `json:"type,omitempty"`
	Key               *int32                              `json:"key,omitempty"`
	Memo              *string                             `json:"memo,omitempty"`
	Rank              *int32                              `json:"rank,omitempty"`
	AskTakerFee       *float64                            `json:"askTakerFee,omitempty"`
	AskMakerFee       *float64                            `json:"askMakerFee,omitempty"`
	BidTakerFee       *float64                            `json:"bidTakerFee,omitempty"`
	BidMakerFee       *float64                            `json:"bidMakerFee,omitempty"`
	MyCoinAskTakerFee *float64                            `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskMakerFee *float64                            `json:"myCoinAskMakerFee,omitempty"`
	MyCoinBidTakerFee *float64                            `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidMakerFee *float64                            `json:"myCoinBidMakerFee,omitempty"`
	EventRelation     *UserUpdateManyWithoutEventFeeInput `json:"eventRelation,omitempty"`
}

type UserUpdateManyWithoutEventFeeInput struct {
	Create     []UserCreateWithoutEventFeeInput                `json:"create,omitempty"`
	Delete     []UserWhereUniqueInput                          `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                          `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                          `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                          `json:"disconnect,omitempty"`
	Update     []UserUpdateWithWhereUniqueWithoutEventFeeInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueWithoutEventFeeInput `json:"upsert,omitempty"`
	DeleteMany []UserScalarWhereInput                          `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput            `json:"updateMany,omitempty"`
}

type UserUpdateWithWhereUniqueWithoutEventFeeInput struct {
	Where UserWhereUniqueInput               `json:"where"`
	Data  UserUpdateWithoutEventFeeDataInput `json:"data"`
}

type UserUpdateWithoutEventFeeDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type InviteCodeUpdateOneWithoutOwnerInput struct {
	Create     *InviteCodeCreateWithoutOwnerInput     `json:"create,omitempty"`
	Update     *InviteCodeUpdateWithoutOwnerDataInput `json:"update,omitempty"`
	Upsert     *InviteCodeUpsertWithoutOwnerInput     `json:"upsert,omitempty"`
	Delete     *bool                                  `json:"delete,omitempty"`
	Disconnect *bool                                  `json:"disconnect,omitempty"`
	Connect    *InviteCodeWhereUniqueInput            `json:"connect,omitempty"`
}

type InviteCodeUpdateWithoutOwnerDataInput struct {
	NumId       *int32                                             `json:"numId,omitempty"`
	Code        *string                                            `json:"code,omitempty"`
	InviteUsers *InviteUserHistoryUpdateManyWithoutInviteCodeInput `json:"inviteUsers,omitempty"`
}

type InviteUserHistoryUpdateManyWithoutInviteCodeInput struct {
	Create     []InviteUserHistoryCreateWithoutInviteCodeInput                `json:"create,omitempty"`
	Delete     []InviteUserHistoryWhereUniqueInput                            `json:"delete,omitempty"`
	Connect    []InviteUserHistoryWhereUniqueInput                            `json:"connect,omitempty"`
	Set        []InviteUserHistoryWhereUniqueInput                            `json:"set,omitempty"`
	Disconnect []InviteUserHistoryWhereUniqueInput                            `json:"disconnect,omitempty"`
	Update     []InviteUserHistoryUpdateWithWhereUniqueWithoutInviteCodeInput `json:"update,omitempty"`
	Upsert     []InviteUserHistoryUpsertWithWhereUniqueWithoutInviteCodeInput `json:"upsert,omitempty"`
	DeleteMany []InviteUserHistoryScalarWhereInput                            `json:"deleteMany,omitempty"`
}

type InviteUserHistoryUpdateWithWhereUniqueWithoutInviteCodeInput struct {
	Where InviteUserHistoryWhereUniqueInput                 `json:"where"`
	Data  InviteUserHistoryUpdateWithoutInviteCodeDataInput `json:"data"`
}

type InviteUserHistoryUpdateWithoutInviteCodeDataInput struct {
	User *UserUpdateOneRequiredInput `json:"user,omitempty"`
}

type InviteUserHistoryUpsertWithWhereUniqueWithoutInviteCodeInput struct {
	Where  InviteUserHistoryWhereUniqueInput                 `json:"where"`
	Update InviteUserHistoryUpdateWithoutInviteCodeDataInput `json:"update"`
	Create InviteUserHistoryCreateWithoutInviteCodeInput     `json:"create"`
}

type InviteUserHistoryScalarWhereInput struct {
	ID              *string                             `json:"id,omitempty"`
	IDNot           *string                             `json:"id_not,omitempty"`
	IDIn            []string                            `json:"id_in,omitempty"`
	IDNotIn         []string                            `json:"id_not_in,omitempty"`
	IDLt            *string                             `json:"id_lt,omitempty"`
	IDLte           *string                             `json:"id_lte,omitempty"`
	IDGt            *string                             `json:"id_gt,omitempty"`
	IDGte           *string                             `json:"id_gte,omitempty"`
	IDContains      *string                             `json:"id_contains,omitempty"`
	IDNotContains   *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                             `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string                             `json:"createdAt,omitempty"`
	CreatedAtNot    *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                             `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                             `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                             `json:"updatedAt_gte,omitempty"`
	And             []InviteUserHistoryScalarWhereInput `json:"AND,omitempty"`
	Or              []InviteUserHistoryScalarWhereInput `json:"OR,omitempty"`
	Not             []InviteUserHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type InviteCodeUpsertWithoutOwnerInput struct {
	Update InviteCodeUpdateWithoutOwnerDataInput `json:"update"`
	Create InviteCodeCreateWithoutOwnerInput     `json:"create"`
}

type PageUpdateOneWithoutOwnerInput struct {
	Create     *PageCreateWithoutOwnerInput     `json:"create,omitempty"`
	Update     *PageUpdateWithoutOwnerDataInput `json:"update,omitempty"`
	Upsert     *PageUpsertWithoutOwnerInput     `json:"upsert,omitempty"`
	Delete     *bool                            `json:"delete,omitempty"`
	Disconnect *bool                            `json:"disconnect,omitempty"`
	Connect    *PageWhereUniqueInput            `json:"connect,omitempty"`
}

type PageUpdateWithoutOwnerDataInput struct {
	PageId           *string                                         `json:"pageId,omitempty"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeUpdateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeUpdateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchUpdateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramUpdateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvUpdateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanUpdateManyInput                         `json:"fans,omitempty"`
	Comments         *PageCommentUpdateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemUpdateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageUpdateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentUpdateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type PageBadgeUpdateManyWithoutPageInput struct {
	Create     []PageBadgeCreateWithoutPageInput                `json:"create,omitempty"`
	Delete     []PageBadgeWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []PageBadgeWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []PageBadgeWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []PageBadgeWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []PageBadgeUpdateWithWhereUniqueWithoutPageInput `json:"update,omitempty"`
	Upsert     []PageBadgeUpsertWithWhereUniqueWithoutPageInput `json:"upsert,omitempty"`
	DeleteMany []PageBadgeScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []PageBadgeUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type PageBadgeUpdateWithWhereUniqueWithoutPageInput struct {
	Where PageBadgeWhereUniqueInput           `json:"where"`
	Data  PageBadgeUpdateWithoutPageDataInput `json:"data"`
}

type PageBadgeUpdateWithoutPageDataInput struct {
	Badge *BadgeUpdateOneRequiredWithoutPagesInput   `json:"badge,omitempty"`
	Vote  *int32                                     `json:"vote,omitempty"`
	Voter *BadgeVoterUpdateManyWithoutPageBadgeInput `json:"voter,omitempty"`
}

type BadgeUpdateOneRequiredWithoutPagesInput struct {
	Create  *BadgeCreateWithoutPagesInput     `json:"create,omitempty"`
	Update  *BadgeUpdateWithoutPagesDataInput `json:"update,omitempty"`
	Upsert  *BadgeUpsertWithoutPagesInput     `json:"upsert,omitempty"`
	Connect *BadgeWhereUniqueInput            `json:"connect,omitempty"`
}

type BadgeUpdateWithoutPagesDataInput struct {
	Name        *string `json:"name,omitempty"`
	ImageUrl    *string `json:"imageUrl,omitempty"`
	Description *string `json:"description,omitempty"`
	OrderIndex  *int32  `json:"orderIndex,omitempty"`
}

type BadgeUpsertWithoutPagesInput struct {
	Update BadgeUpdateWithoutPagesDataInput `json:"update"`
	Create BadgeCreateWithoutPagesInput     `json:"create"`
}

type BadgeVoterUpdateManyWithoutPageBadgeInput struct {
	Create     []BadgeVoterCreateWithoutPageBadgeInput                `json:"create,omitempty"`
	Delete     []BadgeVoterWhereUniqueInput                           `json:"delete,omitempty"`
	Connect    []BadgeVoterWhereUniqueInput                           `json:"connect,omitempty"`
	Set        []BadgeVoterWhereUniqueInput                           `json:"set,omitempty"`
	Disconnect []BadgeVoterWhereUniqueInput                           `json:"disconnect,omitempty"`
	Update     []BadgeVoterUpdateWithWhereUniqueWithoutPageBadgeInput `json:"update,omitempty"`
	Upsert     []BadgeVoterUpsertWithWhereUniqueWithoutPageBadgeInput `json:"upsert,omitempty"`
	DeleteMany []BadgeVoterScalarWhereInput                           `json:"deleteMany,omitempty"`
	UpdateMany []BadgeVoterUpdateManyWithWhereNestedInput             `json:"updateMany,omitempty"`
}

type BadgeVoterUpdateWithWhereUniqueWithoutPageBadgeInput struct {
	Where BadgeVoterWhereUniqueInput                `json:"where"`
	Data  BadgeVoterUpdateWithoutPageBadgeDataInput `json:"data"`
}

type BadgeVoterUpdateWithoutPageBadgeDataInput struct {
	ReviewContent *ReviewContentUpdateOneInput `json:"reviewContent,omitempty"`
	User          *UserUpdateOneInput          `json:"user,omitempty"`
	Ip            *string                      `json:"ip,omitempty"`
}

type ReviewContentUpdateOneInput struct {
	Create     *ReviewContentCreateInput       `json:"create,omitempty"`
	Update     *ReviewContentUpdateDataInput   `json:"update,omitempty"`
	Upsert     *ReviewContentUpsertNestedInput `json:"upsert,omitempty"`
	Delete     *bool                           `json:"delete,omitempty"`
	Disconnect *bool                           `json:"disconnect,omitempty"`
	Connect    *ReviewContentWhereUniqueInput  `json:"connect,omitempty"`
}

type ReviewContentUpdateDataInput struct {
	ReviewContentPage *ReviewContentPageUpdateOneWithoutReviewsInput            `json:"reviewContentPage,omitempty"`
	PreviewImageUrl   *string                                                   `json:"previewImageUrl,omitempty"`
	Title             *string                                                   `json:"title,omitempty"`
	Type              *string                                                   `json:"type,omitempty"`
	Url               *string                                                   `json:"url,omitempty"`
	Review            *string                                                   `json:"review,omitempty"`
	VideoId           *string                                                   `json:"videoId,omitempty"`
	ContentId         *string                                                   `json:"contentId,omitempty"`
	Viewers           *ReviewContentViewerUpdateManyWithoutReviewContentInput   `json:"viewers,omitempty"`
	Reviewers         *ReviewContentReviewerUpdateManyWithoutReviewContentInput `json:"reviewers,omitempty"`
	RelatedPage       *PageUpdateOneRequiredWithoutRelatedReviewsInput          `json:"relatedPage,omitempty"`
	Owner             *UserUpdateOneRequiredInput                               `json:"owner,omitempty"`
}

type ReviewContentPageUpdateOneWithoutReviewsInput struct {
	Create     *ReviewContentPageCreateWithoutReviewsInput     `json:"create,omitempty"`
	Update     *ReviewContentPageUpdateWithoutReviewsDataInput `json:"update,omitempty"`
	Upsert     *ReviewContentPageUpsertWithoutReviewsInput     `json:"upsert,omitempty"`
	Delete     *bool                                           `json:"delete,omitempty"`
	Disconnect *bool                                           `json:"disconnect,omitempty"`
	Connect    *ReviewContentPageWhereUniqueInput              `json:"connect,omitempty"`
}

type ReviewContentPageUpdateWithoutReviewsDataInput struct {
	Page       *PageUpdateOneRequiredWithoutReviewsInput                         `json:"page,omitempty"`
	Categories *ReviewContentCategoryUpdateManyInput                             `json:"categories,omitempty"`
	Title      *string                                                           `json:"title,omitempty"`
	SubTitle   *string                                                           `json:"subTitle,omitempty"`
	Message    *string                                                           `json:"message,omitempty"`
	Viewers    *ReviewContentPageViewerUpdateManyWithoutReviewContentPageInput   `json:"viewers,omitempty"`
	Comments   *PageCommentUpdateManyWithoutRelatedReviewContentPageInput        `json:"comments,omitempty"`
	Owner      *UserUpdateOneRequiredInput                                       `json:"owner,omitempty"`
	FeedBacks  *ReviewContentPageFeedBackUpdateManyWithoutReviewContentPageInput `json:"feedBacks,omitempty"`
	ReleasedAt *string                                                           `json:"releasedAt,omitempty"`
	IsDrafts   *bool                                                             `json:"isDrafts,omitempty"`
	IsDel      *bool                                                             `json:"isDel,omitempty"`
}

type PageUpdateOneRequiredWithoutReviewsInput struct {
	Create  *PageCreateWithoutReviewsInput     `json:"create,omitempty"`
	Update  *PageUpdateWithoutReviewsDataInput `json:"update,omitempty"`
	Upsert  *PageUpsertWithoutReviewsInput     `json:"upsert,omitempty"`
	Connect *PageWhereUniqueInput              `json:"connect,omitempty"`
}

type PageUpdateWithoutReviewsDataInput struct {
	PageId           *string                                         `json:"pageId,omitempty"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeUpdateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeUpdateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchUpdateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramUpdateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvUpdateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanUpdateManyInput                         `json:"fans,omitempty"`
	Owner            *UserUpdateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentUpdateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemUpdateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	RelatedReviews   *ReviewContentUpdateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type YoutubeUpdateOneWithoutPageInput struct {
	Create     *YoutubeCreateWithoutPageInput     `json:"create,omitempty"`
	Update     *YoutubeUpdateWithoutPageDataInput `json:"update,omitempty"`
	Upsert     *YoutubeUpsertWithoutPageInput     `json:"upsert,omitempty"`
	Delete     *bool                              `json:"delete,omitempty"`
	Disconnect *bool                              `json:"disconnect,omitempty"`
	Connect    *YoutubeWhereUniqueInput           `json:"connect,omitempty"`
}

type YoutubeUpdateWithoutPageDataInput struct {
	ChannelId       *string                                              `json:"channelId,omitempty"`
	ChannelType     *string                                              `json:"channelType,omitempty"`
	ChannelName     *string                                              `json:"channelName,omitempty"`
	UserName        *string                                              `json:"userName,omitempty"`
	VideoCount      *string                                              `json:"videoCount,omitempty"`
	SubscriberCount *string                                              `json:"subscriberCount,omitempty"`
	VideoViewCount  *string                                              `json:"videoViewCount,omitempty"`
	ThumbnailUrl    *string                                              `json:"thumbnailUrl,omitempty"`
	BannerUrl       *string                                              `json:"bannerUrl,omitempty"`
	Description     *string                                              `json:"description,omitempty"`
	PublishedAt     *string                                              `json:"publishedAt,omitempty"`
	Country         *string                                              `json:"country,omitempty"`
	PageUrl         *string                                              `json:"pageUrl,omitempty"`
	Statistics      *YoutubeDailyStatisticsUpdateManyWithoutYoutubeInput `json:"statistics,omitempty"`
}

type YoutubeDailyStatisticsUpdateManyWithoutYoutubeInput struct {
	Create     []YoutubeDailyStatisticsCreateWithoutYoutubeInput                `json:"create,omitempty"`
	Delete     []YoutubeDailyStatisticsWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []YoutubeDailyStatisticsWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []YoutubeDailyStatisticsWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []YoutubeDailyStatisticsWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []YoutubeDailyStatisticsUpdateWithWhereUniqueWithoutYoutubeInput `json:"update,omitempty"`
	Upsert     []YoutubeDailyStatisticsUpsertWithWhereUniqueWithoutYoutubeInput `json:"upsert,omitempty"`
	DeleteMany []YoutubeDailyStatisticsScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []YoutubeDailyStatisticsUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type YoutubeDailyStatisticsUpdateWithWhereUniqueWithoutYoutubeInput struct {
	Where YoutubeDailyStatisticsWhereUniqueInput              `json:"where"`
	Data  YoutubeDailyStatisticsUpdateWithoutYoutubeDataInput `json:"data"`
}

type YoutubeDailyStatisticsUpdateWithoutYoutubeDataInput struct {
	Date            *string `json:"date,omitempty"`
	VideoCount      *string `json:"videoCount,omitempty"`
	SubscriberCount *string `json:"subscriberCount,omitempty"`
	VideoViewCount  *string `json:"videoViewCount,omitempty"`
}

type YoutubeDailyStatisticsUpsertWithWhereUniqueWithoutYoutubeInput struct {
	Where  YoutubeDailyStatisticsWhereUniqueInput              `json:"where"`
	Update YoutubeDailyStatisticsUpdateWithoutYoutubeDataInput `json:"update"`
	Create YoutubeDailyStatisticsCreateWithoutYoutubeInput     `json:"create"`
}

type YoutubeDailyStatisticsScalarWhereInput struct {
	ID                           *string                                  `json:"id,omitempty"`
	IDNot                        *string                                  `json:"id_not,omitempty"`
	IDIn                         []string                                 `json:"id_in,omitempty"`
	IDNotIn                      []string                                 `json:"id_not_in,omitempty"`
	IDLt                         *string                                  `json:"id_lt,omitempty"`
	IDLte                        *string                                  `json:"id_lte,omitempty"`
	IDGt                         *string                                  `json:"id_gt,omitempty"`
	IDGte                        *string                                  `json:"id_gte,omitempty"`
	IDContains                   *string                                  `json:"id_contains,omitempty"`
	IDNotContains                *string                                  `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                                  `json:"id_not_ends_with,omitempty"`
	Date                         *string                                  `json:"date,omitempty"`
	DateNot                      *string                                  `json:"date_not,omitempty"`
	DateIn                       []string                                 `json:"date_in,omitempty"`
	DateNotIn                    []string                                 `json:"date_not_in,omitempty"`
	DateLt                       *string                                  `json:"date_lt,omitempty"`
	DateLte                      *string                                  `json:"date_lte,omitempty"`
	DateGt                       *string                                  `json:"date_gt,omitempty"`
	DateGte                      *string                                  `json:"date_gte,omitempty"`
	DateContains                 *string                                  `json:"date_contains,omitempty"`
	DateNotContains              *string                                  `json:"date_not_contains,omitempty"`
	DateStartsWith               *string                                  `json:"date_starts_with,omitempty"`
	DateNotStartsWith            *string                                  `json:"date_not_starts_with,omitempty"`
	DateEndsWith                 *string                                  `json:"date_ends_with,omitempty"`
	DateNotEndsWith              *string                                  `json:"date_not_ends_with,omitempty"`
	VideoCount                   *string                                  `json:"videoCount,omitempty"`
	VideoCountNot                *string                                  `json:"videoCount_not,omitempty"`
	VideoCountIn                 []string                                 `json:"videoCount_in,omitempty"`
	VideoCountNotIn              []string                                 `json:"videoCount_not_in,omitempty"`
	VideoCountLt                 *string                                  `json:"videoCount_lt,omitempty"`
	VideoCountLte                *string                                  `json:"videoCount_lte,omitempty"`
	VideoCountGt                 *string                                  `json:"videoCount_gt,omitempty"`
	VideoCountGte                *string                                  `json:"videoCount_gte,omitempty"`
	VideoCountContains           *string                                  `json:"videoCount_contains,omitempty"`
	VideoCountNotContains        *string                                  `json:"videoCount_not_contains,omitempty"`
	VideoCountStartsWith         *string                                  `json:"videoCount_starts_with,omitempty"`
	VideoCountNotStartsWith      *string                                  `json:"videoCount_not_starts_with,omitempty"`
	VideoCountEndsWith           *string                                  `json:"videoCount_ends_with,omitempty"`
	VideoCountNotEndsWith        *string                                  `json:"videoCount_not_ends_with,omitempty"`
	SubscriberCount              *string                                  `json:"subscriberCount,omitempty"`
	SubscriberCountNot           *string                                  `json:"subscriberCount_not,omitempty"`
	SubscriberCountIn            []string                                 `json:"subscriberCount_in,omitempty"`
	SubscriberCountNotIn         []string                                 `json:"subscriberCount_not_in,omitempty"`
	SubscriberCountLt            *string                                  `json:"subscriberCount_lt,omitempty"`
	SubscriberCountLte           *string                                  `json:"subscriberCount_lte,omitempty"`
	SubscriberCountGt            *string                                  `json:"subscriberCount_gt,omitempty"`
	SubscriberCountGte           *string                                  `json:"subscriberCount_gte,omitempty"`
	SubscriberCountContains      *string                                  `json:"subscriberCount_contains,omitempty"`
	SubscriberCountNotContains   *string                                  `json:"subscriberCount_not_contains,omitempty"`
	SubscriberCountStartsWith    *string                                  `json:"subscriberCount_starts_with,omitempty"`
	SubscriberCountNotStartsWith *string                                  `json:"subscriberCount_not_starts_with,omitempty"`
	SubscriberCountEndsWith      *string                                  `json:"subscriberCount_ends_with,omitempty"`
	SubscriberCountNotEndsWith   *string                                  `json:"subscriberCount_not_ends_with,omitempty"`
	VideoViewCount               *string                                  `json:"videoViewCount,omitempty"`
	VideoViewCountNot            *string                                  `json:"videoViewCount_not,omitempty"`
	VideoViewCountIn             []string                                 `json:"videoViewCount_in,omitempty"`
	VideoViewCountNotIn          []string                                 `json:"videoViewCount_not_in,omitempty"`
	VideoViewCountLt             *string                                  `json:"videoViewCount_lt,omitempty"`
	VideoViewCountLte            *string                                  `json:"videoViewCount_lte,omitempty"`
	VideoViewCountGt             *string                                  `json:"videoViewCount_gt,omitempty"`
	VideoViewCountGte            *string                                  `json:"videoViewCount_gte,omitempty"`
	VideoViewCountContains       *string                                  `json:"videoViewCount_contains,omitempty"`
	VideoViewCountNotContains    *string                                  `json:"videoViewCount_not_contains,omitempty"`
	VideoViewCountStartsWith     *string                                  `json:"videoViewCount_starts_with,omitempty"`
	VideoViewCountNotStartsWith  *string                                  `json:"videoViewCount_not_starts_with,omitempty"`
	VideoViewCountEndsWith       *string                                  `json:"videoViewCount_ends_with,omitempty"`
	VideoViewCountNotEndsWith    *string                                  `json:"videoViewCount_not_ends_with,omitempty"`
	CreatedAt                    *string                                  `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                                  `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                                  `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                                  `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                                  `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                                 `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                                 `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                                  `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                                  `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                                  `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                                  `json:"updatedAt_gte,omitempty"`
	And                          []YoutubeDailyStatisticsScalarWhereInput `json:"AND,omitempty"`
	Or                           []YoutubeDailyStatisticsScalarWhereInput `json:"OR,omitempty"`
	Not                          []YoutubeDailyStatisticsScalarWhereInput `json:"NOT,omitempty"`
}

type YoutubeDailyStatisticsUpdateManyWithWhereNestedInput struct {
	Where YoutubeDailyStatisticsScalarWhereInput    `json:"where"`
	Data  YoutubeDailyStatisticsUpdateManyDataInput `json:"data"`
}

type YoutubeDailyStatisticsUpdateManyDataInput struct {
	Date            *string `json:"date,omitempty"`
	VideoCount      *string `json:"videoCount,omitempty"`
	SubscriberCount *string `json:"subscriberCount,omitempty"`
	VideoViewCount  *string `json:"videoViewCount,omitempty"`
}

type YoutubeUpsertWithoutPageInput struct {
	Update YoutubeUpdateWithoutPageDataInput `json:"update"`
	Create YoutubeCreateWithoutPageInput     `json:"create"`
}

type TwitchUpdateOneWithoutPageInput struct {
	Create     *TwitchCreateWithoutPageInput     `json:"create,omitempty"`
	Update     *TwitchUpdateWithoutPageDataInput `json:"update,omitempty"`
	Upsert     *TwitchUpsertWithoutPageInput     `json:"upsert,omitempty"`
	Delete     *bool                             `json:"delete,omitempty"`
	Disconnect *bool                             `json:"disconnect,omitempty"`
	Connect    *TwitchWhereUniqueInput           `json:"connect,omitempty"`
}

type TwitchUpdateWithoutPageDataInput struct {
	UserId           *string                                            `json:"userId,omitempty"`
	UserNo           *string                                            `json:"userNo,omitempty"`
	UserName         *string                                            `json:"userName,omitempty"`
	FollowerCount    *string                                            `json:"followerCount,omitempty"`
	FollowingCount   *string                                            `json:"followingCount,omitempty"`
	ChannelType      *string                                            `json:"channelType,omitempty"`
	ChannelViewCount *string                                            `json:"channelViewCount,omitempty"`
	AvatarUrl        *string                                            `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                            `json:"coverUrl,omitempty"`
	Description      *string                                            `json:"description,omitempty"`
	PageUrl          *string                                            `json:"pageUrl,omitempty"`
	Statistics       *TwitchDailyStatisticsUpdateManyWithoutTwitchInput `json:"statistics,omitempty"`
}

type TwitchDailyStatisticsUpdateManyWithoutTwitchInput struct {
	Create     []TwitchDailyStatisticsCreateWithoutTwitchInput                `json:"create,omitempty"`
	Delete     []TwitchDailyStatisticsWhereUniqueInput                        `json:"delete,omitempty"`
	Connect    []TwitchDailyStatisticsWhereUniqueInput                        `json:"connect,omitempty"`
	Set        []TwitchDailyStatisticsWhereUniqueInput                        `json:"set,omitempty"`
	Disconnect []TwitchDailyStatisticsWhereUniqueInput                        `json:"disconnect,omitempty"`
	Update     []TwitchDailyStatisticsUpdateWithWhereUniqueWithoutTwitchInput `json:"update,omitempty"`
	Upsert     []TwitchDailyStatisticsUpsertWithWhereUniqueWithoutTwitchInput `json:"upsert,omitempty"`
	DeleteMany []TwitchDailyStatisticsScalarWhereInput                        `json:"deleteMany,omitempty"`
	UpdateMany []TwitchDailyStatisticsUpdateManyWithWhereNestedInput          `json:"updateMany,omitempty"`
}

type TwitchDailyStatisticsUpdateWithWhereUniqueWithoutTwitchInput struct {
	Where TwitchDailyStatisticsWhereUniqueInput             `json:"where"`
	Data  TwitchDailyStatisticsUpdateWithoutTwitchDataInput `json:"data"`
}

type TwitchDailyStatisticsUpdateWithoutTwitchDataInput struct {
	Date             *string `json:"date,omitempty"`
	FollowerCount    *string `json:"followerCount,omitempty"`
	FollowingCount   *string `json:"followingCount,omitempty"`
	ChannelViewCount *string `json:"channelViewCount,omitempty"`
}

type TwitchDailyStatisticsUpsertWithWhereUniqueWithoutTwitchInput struct {
	Where  TwitchDailyStatisticsWhereUniqueInput             `json:"where"`
	Update TwitchDailyStatisticsUpdateWithoutTwitchDataInput `json:"update"`
	Create TwitchDailyStatisticsCreateWithoutTwitchInput     `json:"create"`
}

type TwitchDailyStatisticsScalarWhereInput struct {
	ID                            *string                                 `json:"id,omitempty"`
	IDNot                         *string                                 `json:"id_not,omitempty"`
	IDIn                          []string                                `json:"id_in,omitempty"`
	IDNotIn                       []string                                `json:"id_not_in,omitempty"`
	IDLt                          *string                                 `json:"id_lt,omitempty"`
	IDLte                         *string                                 `json:"id_lte,omitempty"`
	IDGt                          *string                                 `json:"id_gt,omitempty"`
	IDGte                         *string                                 `json:"id_gte,omitempty"`
	IDContains                    *string                                 `json:"id_contains,omitempty"`
	IDNotContains                 *string                                 `json:"id_not_contains,omitempty"`
	IDStartsWith                  *string                                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith               *string                                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith                    *string                                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith                 *string                                 `json:"id_not_ends_with,omitempty"`
	Date                          *string                                 `json:"date,omitempty"`
	DateNot                       *string                                 `json:"date_not,omitempty"`
	DateIn                        []string                                `json:"date_in,omitempty"`
	DateNotIn                     []string                                `json:"date_not_in,omitempty"`
	DateLt                        *string                                 `json:"date_lt,omitempty"`
	DateLte                       *string                                 `json:"date_lte,omitempty"`
	DateGt                        *string                                 `json:"date_gt,omitempty"`
	DateGte                       *string                                 `json:"date_gte,omitempty"`
	DateContains                  *string                                 `json:"date_contains,omitempty"`
	DateNotContains               *string                                 `json:"date_not_contains,omitempty"`
	DateStartsWith                *string                                 `json:"date_starts_with,omitempty"`
	DateNotStartsWith             *string                                 `json:"date_not_starts_with,omitempty"`
	DateEndsWith                  *string                                 `json:"date_ends_with,omitempty"`
	DateNotEndsWith               *string                                 `json:"date_not_ends_with,omitempty"`
	FollowerCount                 *string                                 `json:"followerCount,omitempty"`
	FollowerCountNot              *string                                 `json:"followerCount_not,omitempty"`
	FollowerCountIn               []string                                `json:"followerCount_in,omitempty"`
	FollowerCountNotIn            []string                                `json:"followerCount_not_in,omitempty"`
	FollowerCountLt               *string                                 `json:"followerCount_lt,omitempty"`
	FollowerCountLte              *string                                 `json:"followerCount_lte,omitempty"`
	FollowerCountGt               *string                                 `json:"followerCount_gt,omitempty"`
	FollowerCountGte              *string                                 `json:"followerCount_gte,omitempty"`
	FollowerCountContains         *string                                 `json:"followerCount_contains,omitempty"`
	FollowerCountNotContains      *string                                 `json:"followerCount_not_contains,omitempty"`
	FollowerCountStartsWith       *string                                 `json:"followerCount_starts_with,omitempty"`
	FollowerCountNotStartsWith    *string                                 `json:"followerCount_not_starts_with,omitempty"`
	FollowerCountEndsWith         *string                                 `json:"followerCount_ends_with,omitempty"`
	FollowerCountNotEndsWith      *string                                 `json:"followerCount_not_ends_with,omitempty"`
	FollowingCount                *string                                 `json:"followingCount,omitempty"`
	FollowingCountNot             *string                                 `json:"followingCount_not,omitempty"`
	FollowingCountIn              []string                                `json:"followingCount_in,omitempty"`
	FollowingCountNotIn           []string                                `json:"followingCount_not_in,omitempty"`
	FollowingCountLt              *string                                 `json:"followingCount_lt,omitempty"`
	FollowingCountLte             *string                                 `json:"followingCount_lte,omitempty"`
	FollowingCountGt              *string                                 `json:"followingCount_gt,omitempty"`
	FollowingCountGte             *string                                 `json:"followingCount_gte,omitempty"`
	FollowingCountContains        *string                                 `json:"followingCount_contains,omitempty"`
	FollowingCountNotContains     *string                                 `json:"followingCount_not_contains,omitempty"`
	FollowingCountStartsWith      *string                                 `json:"followingCount_starts_with,omitempty"`
	FollowingCountNotStartsWith   *string                                 `json:"followingCount_not_starts_with,omitempty"`
	FollowingCountEndsWith        *string                                 `json:"followingCount_ends_with,omitempty"`
	FollowingCountNotEndsWith     *string                                 `json:"followingCount_not_ends_with,omitempty"`
	ChannelViewCount              *string                                 `json:"channelViewCount,omitempty"`
	ChannelViewCountNot           *string                                 `json:"channelViewCount_not,omitempty"`
	ChannelViewCountIn            []string                                `json:"channelViewCount_in,omitempty"`
	ChannelViewCountNotIn         []string                                `json:"channelViewCount_not_in,omitempty"`
	ChannelViewCountLt            *string                                 `json:"channelViewCount_lt,omitempty"`
	ChannelViewCountLte           *string                                 `json:"channelViewCount_lte,omitempty"`
	ChannelViewCountGt            *string                                 `json:"channelViewCount_gt,omitempty"`
	ChannelViewCountGte           *string                                 `json:"channelViewCount_gte,omitempty"`
	ChannelViewCountContains      *string                                 `json:"channelViewCount_contains,omitempty"`
	ChannelViewCountNotContains   *string                                 `json:"channelViewCount_not_contains,omitempty"`
	ChannelViewCountStartsWith    *string                                 `json:"channelViewCount_starts_with,omitempty"`
	ChannelViewCountNotStartsWith *string                                 `json:"channelViewCount_not_starts_with,omitempty"`
	ChannelViewCountEndsWith      *string                                 `json:"channelViewCount_ends_with,omitempty"`
	ChannelViewCountNotEndsWith   *string                                 `json:"channelViewCount_not_ends_with,omitempty"`
	CreatedAt                     *string                                 `json:"createdAt,omitempty"`
	CreatedAtNot                  *string                                 `json:"createdAt_not,omitempty"`
	CreatedAtIn                   []string                                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                []string                                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                   *string                                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte                  *string                                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt                   *string                                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte                  *string                                 `json:"createdAt_gte,omitempty"`
	UpdatedAt                     *string                                 `json:"updatedAt,omitempty"`
	UpdatedAtNot                  *string                                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                   []string                                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                []string                                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                   *string                                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                  *string                                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                   *string                                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                  *string                                 `json:"updatedAt_gte,omitempty"`
	And                           []TwitchDailyStatisticsScalarWhereInput `json:"AND,omitempty"`
	Or                            []TwitchDailyStatisticsScalarWhereInput `json:"OR,omitempty"`
	Not                           []TwitchDailyStatisticsScalarWhereInput `json:"NOT,omitempty"`
}

type TwitchDailyStatisticsUpdateManyWithWhereNestedInput struct {
	Where TwitchDailyStatisticsScalarWhereInput    `json:"where"`
	Data  TwitchDailyStatisticsUpdateManyDataInput `json:"data"`
}

type TwitchDailyStatisticsUpdateManyDataInput struct {
	Date             *string `json:"date,omitempty"`
	FollowerCount    *string `json:"followerCount,omitempty"`
	FollowingCount   *string `json:"followingCount,omitempty"`
	ChannelViewCount *string `json:"channelViewCount,omitempty"`
}

type TwitchUpsertWithoutPageInput struct {
	Update TwitchUpdateWithoutPageDataInput `json:"update"`
	Create TwitchCreateWithoutPageInput     `json:"create"`
}

type InstagramUpdateOneWithoutPageInput struct {
	Create     *InstagramCreateWithoutPageInput     `json:"create,omitempty"`
	Update     *InstagramUpdateWithoutPageDataInput `json:"update,omitempty"`
	Upsert     *InstagramUpsertWithoutPageInput     `json:"upsert,omitempty"`
	Delete     *bool                                `json:"delete,omitempty"`
	Disconnect *bool                                `json:"disconnect,omitempty"`
	Connect    *InstagramWhereUniqueInput           `json:"connect,omitempty"`
}

type InstagramUpdateWithoutPageDataInput struct {
	UserId         *string                                                  `json:"userId,omitempty"`
	UserNo         *string                                                  `json:"userNo,omitempty"`
	UserName       *string                                                  `json:"userName,omitempty"`
	PostCount      *string                                                  `json:"postCount,omitempty"`
	FollowerCount  *string                                                  `json:"followerCount,omitempty"`
	FollowingCount *string                                                  `json:"followingCount,omitempty"`
	AvatarUrl      *string                                                  `json:"avatarUrl,omitempty"`
	Description    *string                                                  `json:"description,omitempty"`
	PageUrl        *string                                                  `json:"pageUrl,omitempty"`
	Statistics     *InstagramDailyStatisticsUpdateManyWithoutInstagramInput `json:"statistics,omitempty"`
}

type InstagramDailyStatisticsUpdateManyWithoutInstagramInput struct {
	Create     []InstagramDailyStatisticsCreateWithoutInstagramInput                `json:"create,omitempty"`
	Delete     []InstagramDailyStatisticsWhereUniqueInput                           `json:"delete,omitempty"`
	Connect    []InstagramDailyStatisticsWhereUniqueInput                           `json:"connect,omitempty"`
	Set        []InstagramDailyStatisticsWhereUniqueInput                           `json:"set,omitempty"`
	Disconnect []InstagramDailyStatisticsWhereUniqueInput                           `json:"disconnect,omitempty"`
	Update     []InstagramDailyStatisticsUpdateWithWhereUniqueWithoutInstagramInput `json:"update,omitempty"`
	Upsert     []InstagramDailyStatisticsUpsertWithWhereUniqueWithoutInstagramInput `json:"upsert,omitempty"`
	DeleteMany []InstagramDailyStatisticsScalarWhereInput                           `json:"deleteMany,omitempty"`
	UpdateMany []InstagramDailyStatisticsUpdateManyWithWhereNestedInput             `json:"updateMany,omitempty"`
}

type InstagramDailyStatisticsUpdateWithWhereUniqueWithoutInstagramInput struct {
	Where InstagramDailyStatisticsWhereUniqueInput                `json:"where"`
	Data  InstagramDailyStatisticsUpdateWithoutInstagramDataInput `json:"data"`
}

type InstagramDailyStatisticsUpdateWithoutInstagramDataInput struct {
	Date           *string `json:"date,omitempty"`
	PostCount      *string `json:"postCount,omitempty"`
	FollowerCount  *string `json:"followerCount,omitempty"`
	FollowingCount *string `json:"followingCount,omitempty"`
}

type InstagramDailyStatisticsUpsertWithWhereUniqueWithoutInstagramInput struct {
	Where  InstagramDailyStatisticsWhereUniqueInput                `json:"where"`
	Update InstagramDailyStatisticsUpdateWithoutInstagramDataInput `json:"update"`
	Create InstagramDailyStatisticsCreateWithoutInstagramInput     `json:"create"`
}

type InstagramDailyStatisticsScalarWhereInput struct {
	ID                          *string                                    `json:"id,omitempty"`
	IDNot                       *string                                    `json:"id_not,omitempty"`
	IDIn                        []string                                   `json:"id_in,omitempty"`
	IDNotIn                     []string                                   `json:"id_not_in,omitempty"`
	IDLt                        *string                                    `json:"id_lt,omitempty"`
	IDLte                       *string                                    `json:"id_lte,omitempty"`
	IDGt                        *string                                    `json:"id_gt,omitempty"`
	IDGte                       *string                                    `json:"id_gte,omitempty"`
	IDContains                  *string                                    `json:"id_contains,omitempty"`
	IDNotContains               *string                                    `json:"id_not_contains,omitempty"`
	IDStartsWith                *string                                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith             *string                                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith                  *string                                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith               *string                                    `json:"id_not_ends_with,omitempty"`
	Date                        *string                                    `json:"date,omitempty"`
	DateNot                     *string                                    `json:"date_not,omitempty"`
	DateIn                      []string                                   `json:"date_in,omitempty"`
	DateNotIn                   []string                                   `json:"date_not_in,omitempty"`
	DateLt                      *string                                    `json:"date_lt,omitempty"`
	DateLte                     *string                                    `json:"date_lte,omitempty"`
	DateGt                      *string                                    `json:"date_gt,omitempty"`
	DateGte                     *string                                    `json:"date_gte,omitempty"`
	DateContains                *string                                    `json:"date_contains,omitempty"`
	DateNotContains             *string                                    `json:"date_not_contains,omitempty"`
	DateStartsWith              *string                                    `json:"date_starts_with,omitempty"`
	DateNotStartsWith           *string                                    `json:"date_not_starts_with,omitempty"`
	DateEndsWith                *string                                    `json:"date_ends_with,omitempty"`
	DateNotEndsWith             *string                                    `json:"date_not_ends_with,omitempty"`
	PostCount                   *string                                    `json:"postCount,omitempty"`
	PostCountNot                *string                                    `json:"postCount_not,omitempty"`
	PostCountIn                 []string                                   `json:"postCount_in,omitempty"`
	PostCountNotIn              []string                                   `json:"postCount_not_in,omitempty"`
	PostCountLt                 *string                                    `json:"postCount_lt,omitempty"`
	PostCountLte                *string                                    `json:"postCount_lte,omitempty"`
	PostCountGt                 *string                                    `json:"postCount_gt,omitempty"`
	PostCountGte                *string                                    `json:"postCount_gte,omitempty"`
	PostCountContains           *string                                    `json:"postCount_contains,omitempty"`
	PostCountNotContains        *string                                    `json:"postCount_not_contains,omitempty"`
	PostCountStartsWith         *string                                    `json:"postCount_starts_with,omitempty"`
	PostCountNotStartsWith      *string                                    `json:"postCount_not_starts_with,omitempty"`
	PostCountEndsWith           *string                                    `json:"postCount_ends_with,omitempty"`
	PostCountNotEndsWith        *string                                    `json:"postCount_not_ends_with,omitempty"`
	FollowerCount               *string                                    `json:"followerCount,omitempty"`
	FollowerCountNot            *string                                    `json:"followerCount_not,omitempty"`
	FollowerCountIn             []string                                   `json:"followerCount_in,omitempty"`
	FollowerCountNotIn          []string                                   `json:"followerCount_not_in,omitempty"`
	FollowerCountLt             *string                                    `json:"followerCount_lt,omitempty"`
	FollowerCountLte            *string                                    `json:"followerCount_lte,omitempty"`
	FollowerCountGt             *string                                    `json:"followerCount_gt,omitempty"`
	FollowerCountGte            *string                                    `json:"followerCount_gte,omitempty"`
	FollowerCountContains       *string                                    `json:"followerCount_contains,omitempty"`
	FollowerCountNotContains    *string                                    `json:"followerCount_not_contains,omitempty"`
	FollowerCountStartsWith     *string                                    `json:"followerCount_starts_with,omitempty"`
	FollowerCountNotStartsWith  *string                                    `json:"followerCount_not_starts_with,omitempty"`
	FollowerCountEndsWith       *string                                    `json:"followerCount_ends_with,omitempty"`
	FollowerCountNotEndsWith    *string                                    `json:"followerCount_not_ends_with,omitempty"`
	FollowingCount              *string                                    `json:"followingCount,omitempty"`
	FollowingCountNot           *string                                    `json:"followingCount_not,omitempty"`
	FollowingCountIn            []string                                   `json:"followingCount_in,omitempty"`
	FollowingCountNotIn         []string                                   `json:"followingCount_not_in,omitempty"`
	FollowingCountLt            *string                                    `json:"followingCount_lt,omitempty"`
	FollowingCountLte           *string                                    `json:"followingCount_lte,omitempty"`
	FollowingCountGt            *string                                    `json:"followingCount_gt,omitempty"`
	FollowingCountGte           *string                                    `json:"followingCount_gte,omitempty"`
	FollowingCountContains      *string                                    `json:"followingCount_contains,omitempty"`
	FollowingCountNotContains   *string                                    `json:"followingCount_not_contains,omitempty"`
	FollowingCountStartsWith    *string                                    `json:"followingCount_starts_with,omitempty"`
	FollowingCountNotStartsWith *string                                    `json:"followingCount_not_starts_with,omitempty"`
	FollowingCountEndsWith      *string                                    `json:"followingCount_ends_with,omitempty"`
	FollowingCountNotEndsWith   *string                                    `json:"followingCount_not_ends_with,omitempty"`
	CreatedAt                   *string                                    `json:"createdAt,omitempty"`
	CreatedAtNot                *string                                    `json:"createdAt_not,omitempty"`
	CreatedAtIn                 []string                                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn              []string                                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                 *string                                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte                *string                                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt                 *string                                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte                *string                                    `json:"createdAt_gte,omitempty"`
	UpdatedAt                   *string                                    `json:"updatedAt,omitempty"`
	UpdatedAtNot                *string                                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                 []string                                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn              []string                                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                 *string                                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                *string                                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                 *string                                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                *string                                    `json:"updatedAt_gte,omitempty"`
	And                         []InstagramDailyStatisticsScalarWhereInput `json:"AND,omitempty"`
	Or                          []InstagramDailyStatisticsScalarWhereInput `json:"OR,omitempty"`
	Not                         []InstagramDailyStatisticsScalarWhereInput `json:"NOT,omitempty"`
}

type InstagramDailyStatisticsUpdateManyWithWhereNestedInput struct {
	Where InstagramDailyStatisticsScalarWhereInput    `json:"where"`
	Data  InstagramDailyStatisticsUpdateManyDataInput `json:"data"`
}

type InstagramDailyStatisticsUpdateManyDataInput struct {
	Date           *string `json:"date,omitempty"`
	PostCount      *string `json:"postCount,omitempty"`
	FollowerCount  *string `json:"followerCount,omitempty"`
	FollowingCount *string `json:"followingCount,omitempty"`
}

type InstagramUpsertWithoutPageInput struct {
	Update InstagramUpdateWithoutPageDataInput `json:"update"`
	Create InstagramCreateWithoutPageInput     `json:"create"`
}

type AfreecaTvUpdateOneWithoutPageInput struct {
	Create     *AfreecaTvCreateWithoutPageInput     `json:"create,omitempty"`
	Update     *AfreecaTvUpdateWithoutPageDataInput `json:"update,omitempty"`
	Upsert     *AfreecaTvUpsertWithoutPageInput     `json:"upsert,omitempty"`
	Delete     *bool                                `json:"delete,omitempty"`
	Disconnect *bool                                `json:"disconnect,omitempty"`
	Connect    *AfreecaTvWhereUniqueInput           `json:"connect,omitempty"`
}

type AfreecaTvUpdateWithoutPageDataInput struct {
	StationNo     *string                                                  `json:"stationNo,omitempty"`
	StationName   *string                                                  `json:"stationName,omitempty"`
	StationTitle  *string                                                  `json:"stationTitle,omitempty"`
	UserId        *string                                                  `json:"userId,omitempty"`
	UserName      *string                                                  `json:"userName,omitempty"`
	AvatarUrl     *string                                                  `json:"avatarUrl,omitempty"`
	Description   *string                                                  `json:"description,omitempty"`
	PageUrl       *string                                                  `json:"pageUrl,omitempty"`
	Statistics    *AfreecaTvDailyStatisticsUpdateManyWithoutAfreecaTvInput `json:"statistics,omitempty"`
	FollowerCount *string                                                  `json:"followerCount,omitempty"`
	ViewCount     *string                                                  `json:"viewCount,omitempty"`
	VisitCount    *string                                                  `json:"visitCount,omitempty"`
	FanCount      *string                                                  `json:"fanCount,omitempty"`
}

type AfreecaTvDailyStatisticsUpdateManyWithoutAfreecaTvInput struct {
	Create     []AfreecaTvDailyStatisticsCreateWithoutAfreecaTvInput                `json:"create,omitempty"`
	Delete     []AfreecaTvDailyStatisticsWhereUniqueInput                           `json:"delete,omitempty"`
	Connect    []AfreecaTvDailyStatisticsWhereUniqueInput                           `json:"connect,omitempty"`
	Set        []AfreecaTvDailyStatisticsWhereUniqueInput                           `json:"set,omitempty"`
	Disconnect []AfreecaTvDailyStatisticsWhereUniqueInput                           `json:"disconnect,omitempty"`
	Update     []AfreecaTvDailyStatisticsUpdateWithWhereUniqueWithoutAfreecaTvInput `json:"update,omitempty"`
	Upsert     []AfreecaTvDailyStatisticsUpsertWithWhereUniqueWithoutAfreecaTvInput `json:"upsert,omitempty"`
	DeleteMany []AfreecaTvDailyStatisticsScalarWhereInput                           `json:"deleteMany,omitempty"`
	UpdateMany []AfreecaTvDailyStatisticsUpdateManyWithWhereNestedInput             `json:"updateMany,omitempty"`
}

type AfreecaTvDailyStatisticsUpdateWithWhereUniqueWithoutAfreecaTvInput struct {
	Where AfreecaTvDailyStatisticsWhereUniqueInput                `json:"where"`
	Data  AfreecaTvDailyStatisticsUpdateWithoutAfreecaTvDataInput `json:"data"`
}

type AfreecaTvDailyStatisticsUpdateWithoutAfreecaTvDataInput struct {
	Date          *string `json:"date,omitempty"`
	FollowerCount *string `json:"followerCount,omitempty"`
	ViewCount     *string `json:"viewCount,omitempty"`
	VisitCount    *string `json:"visitCount,omitempty"`
	FanCount      *string `json:"fanCount,omitempty"`
}

type AfreecaTvDailyStatisticsUpsertWithWhereUniqueWithoutAfreecaTvInput struct {
	Where  AfreecaTvDailyStatisticsWhereUniqueInput                `json:"where"`
	Update AfreecaTvDailyStatisticsUpdateWithoutAfreecaTvDataInput `json:"update"`
	Create AfreecaTvDailyStatisticsCreateWithoutAfreecaTvInput     `json:"create"`
}

type AfreecaTvDailyStatisticsScalarWhereInput struct {
	ID                         *string                                    `json:"id,omitempty"`
	IDNot                      *string                                    `json:"id_not,omitempty"`
	IDIn                       []string                                   `json:"id_in,omitempty"`
	IDNotIn                    []string                                   `json:"id_not_in,omitempty"`
	IDLt                       *string                                    `json:"id_lt,omitempty"`
	IDLte                      *string                                    `json:"id_lte,omitempty"`
	IDGt                       *string                                    `json:"id_gt,omitempty"`
	IDGte                      *string                                    `json:"id_gte,omitempty"`
	IDContains                 *string                                    `json:"id_contains,omitempty"`
	IDNotContains              *string                                    `json:"id_not_contains,omitempty"`
	IDStartsWith               *string                                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string                                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string                                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string                                    `json:"id_not_ends_with,omitempty"`
	Date                       *string                                    `json:"date,omitempty"`
	DateNot                    *string                                    `json:"date_not,omitempty"`
	DateIn                     []string                                   `json:"date_in,omitempty"`
	DateNotIn                  []string                                   `json:"date_not_in,omitempty"`
	DateLt                     *string                                    `json:"date_lt,omitempty"`
	DateLte                    *string                                    `json:"date_lte,omitempty"`
	DateGt                     *string                                    `json:"date_gt,omitempty"`
	DateGte                    *string                                    `json:"date_gte,omitempty"`
	DateContains               *string                                    `json:"date_contains,omitempty"`
	DateNotContains            *string                                    `json:"date_not_contains,omitempty"`
	DateStartsWith             *string                                    `json:"date_starts_with,omitempty"`
	DateNotStartsWith          *string                                    `json:"date_not_starts_with,omitempty"`
	DateEndsWith               *string                                    `json:"date_ends_with,omitempty"`
	DateNotEndsWith            *string                                    `json:"date_not_ends_with,omitempty"`
	FollowerCount              *string                                    `json:"followerCount,omitempty"`
	FollowerCountNot           *string                                    `json:"followerCount_not,omitempty"`
	FollowerCountIn            []string                                   `json:"followerCount_in,omitempty"`
	FollowerCountNotIn         []string                                   `json:"followerCount_not_in,omitempty"`
	FollowerCountLt            *string                                    `json:"followerCount_lt,omitempty"`
	FollowerCountLte           *string                                    `json:"followerCount_lte,omitempty"`
	FollowerCountGt            *string                                    `json:"followerCount_gt,omitempty"`
	FollowerCountGte           *string                                    `json:"followerCount_gte,omitempty"`
	FollowerCountContains      *string                                    `json:"followerCount_contains,omitempty"`
	FollowerCountNotContains   *string                                    `json:"followerCount_not_contains,omitempty"`
	FollowerCountStartsWith    *string                                    `json:"followerCount_starts_with,omitempty"`
	FollowerCountNotStartsWith *string                                    `json:"followerCount_not_starts_with,omitempty"`
	FollowerCountEndsWith      *string                                    `json:"followerCount_ends_with,omitempty"`
	FollowerCountNotEndsWith   *string                                    `json:"followerCount_not_ends_with,omitempty"`
	ViewCount                  *string                                    `json:"viewCount,omitempty"`
	ViewCountNot               *string                                    `json:"viewCount_not,omitempty"`
	ViewCountIn                []string                                   `json:"viewCount_in,omitempty"`
	ViewCountNotIn             []string                                   `json:"viewCount_not_in,omitempty"`
	ViewCountLt                *string                                    `json:"viewCount_lt,omitempty"`
	ViewCountLte               *string                                    `json:"viewCount_lte,omitempty"`
	ViewCountGt                *string                                    `json:"viewCount_gt,omitempty"`
	ViewCountGte               *string                                    `json:"viewCount_gte,omitempty"`
	ViewCountContains          *string                                    `json:"viewCount_contains,omitempty"`
	ViewCountNotContains       *string                                    `json:"viewCount_not_contains,omitempty"`
	ViewCountStartsWith        *string                                    `json:"viewCount_starts_with,omitempty"`
	ViewCountNotStartsWith     *string                                    `json:"viewCount_not_starts_with,omitempty"`
	ViewCountEndsWith          *string                                    `json:"viewCount_ends_with,omitempty"`
	ViewCountNotEndsWith       *string                                    `json:"viewCount_not_ends_with,omitempty"`
	VisitCount                 *string                                    `json:"visitCount,omitempty"`
	VisitCountNot              *string                                    `json:"visitCount_not,omitempty"`
	VisitCountIn               []string                                   `json:"visitCount_in,omitempty"`
	VisitCountNotIn            []string                                   `json:"visitCount_not_in,omitempty"`
	VisitCountLt               *string                                    `json:"visitCount_lt,omitempty"`
	VisitCountLte              *string                                    `json:"visitCount_lte,omitempty"`
	VisitCountGt               *string                                    `json:"visitCount_gt,omitempty"`
	VisitCountGte              *string                                    `json:"visitCount_gte,omitempty"`
	VisitCountContains         *string                                    `json:"visitCount_contains,omitempty"`
	VisitCountNotContains      *string                                    `json:"visitCount_not_contains,omitempty"`
	VisitCountStartsWith       *string                                    `json:"visitCount_starts_with,omitempty"`
	VisitCountNotStartsWith    *string                                    `json:"visitCount_not_starts_with,omitempty"`
	VisitCountEndsWith         *string                                    `json:"visitCount_ends_with,omitempty"`
	VisitCountNotEndsWith      *string                                    `json:"visitCount_not_ends_with,omitempty"`
	FanCount                   *string                                    `json:"fanCount,omitempty"`
	FanCountNot                *string                                    `json:"fanCount_not,omitempty"`
	FanCountIn                 []string                                   `json:"fanCount_in,omitempty"`
	FanCountNotIn              []string                                   `json:"fanCount_not_in,omitempty"`
	FanCountLt                 *string                                    `json:"fanCount_lt,omitempty"`
	FanCountLte                *string                                    `json:"fanCount_lte,omitempty"`
	FanCountGt                 *string                                    `json:"fanCount_gt,omitempty"`
	FanCountGte                *string                                    `json:"fanCount_gte,omitempty"`
	FanCountContains           *string                                    `json:"fanCount_contains,omitempty"`
	FanCountNotContains        *string                                    `json:"fanCount_not_contains,omitempty"`
	FanCountStartsWith         *string                                    `json:"fanCount_starts_with,omitempty"`
	FanCountNotStartsWith      *string                                    `json:"fanCount_not_starts_with,omitempty"`
	FanCountEndsWith           *string                                    `json:"fanCount_ends_with,omitempty"`
	FanCountNotEndsWith        *string                                    `json:"fanCount_not_ends_with,omitempty"`
	CreatedAt                  *string                                    `json:"createdAt,omitempty"`
	CreatedAtNot               *string                                    `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string                                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string                                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                                    `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                                    `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                                    `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string                                   `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string                                   `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                                    `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                                    `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                                    `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                                    `json:"updatedAt_gte,omitempty"`
	And                        []AfreecaTvDailyStatisticsScalarWhereInput `json:"AND,omitempty"`
	Or                         []AfreecaTvDailyStatisticsScalarWhereInput `json:"OR,omitempty"`
	Not                        []AfreecaTvDailyStatisticsScalarWhereInput `json:"NOT,omitempty"`
}

type AfreecaTvDailyStatisticsUpdateManyWithWhereNestedInput struct {
	Where AfreecaTvDailyStatisticsScalarWhereInput    `json:"where"`
	Data  AfreecaTvDailyStatisticsUpdateManyDataInput `json:"data"`
}

type AfreecaTvDailyStatisticsUpdateManyDataInput struct {
	Date          *string `json:"date,omitempty"`
	FollowerCount *string `json:"followerCount,omitempty"`
	ViewCount     *string `json:"viewCount,omitempty"`
	VisitCount    *string `json:"visitCount,omitempty"`
	FanCount      *string `json:"fanCount,omitempty"`
}

type AfreecaTvUpsertWithoutPageInput struct {
	Update AfreecaTvUpdateWithoutPageDataInput `json:"update"`
	Create AfreecaTvCreateWithoutPageInput     `json:"create"`
}

type PageFanUpdateManyInput struct {
	Create     []PageFanCreateInput                      `json:"create,omitempty"`
	Update     []PageFanUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []PageFanUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []PageFanWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []PageFanWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []PageFanWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []PageFanWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []PageFanScalarWhereInput                 `json:"deleteMany,omitempty"`
}

type PageFanUpdateWithWhereUniqueNestedInput struct {
	Where PageFanWhereUniqueInput `json:"where"`
	Data  PageFanUpdateDataInput  `json:"data"`
}

type PageFanUpdateDataInput struct {
	User *UserUpdateOneRequiredInput `json:"user,omitempty"`
}

type PageFanUpsertWithWhereUniqueNestedInput struct {
	Where  PageFanWhereUniqueInput `json:"where"`
	Update PageFanUpdateDataInput  `json:"update"`
	Create PageFanCreateInput      `json:"create"`
}

type PageFanScalarWhereInput struct {
	ID              *string                   `json:"id,omitempty"`
	IDNot           *string                   `json:"id_not,omitempty"`
	IDIn            []string                  `json:"id_in,omitempty"`
	IDNotIn         []string                  `json:"id_not_in,omitempty"`
	IDLt            *string                   `json:"id_lt,omitempty"`
	IDLte           *string                   `json:"id_lte,omitempty"`
	IDGt            *string                   `json:"id_gt,omitempty"`
	IDGte           *string                   `json:"id_gte,omitempty"`
	IDContains      *string                   `json:"id_contains,omitempty"`
	IDNotContains   *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                   `json:"id_not_ends_with,omitempty"`
	CreatedAt       *string                   `json:"createdAt,omitempty"`
	CreatedAtNot    *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                   `json:"updatedAt_gte,omitempty"`
	And             []PageFanScalarWhereInput `json:"AND,omitempty"`
	Or              []PageFanScalarWhereInput `json:"OR,omitempty"`
	Not             []PageFanScalarWhereInput `json:"NOT,omitempty"`
}

type UserUpdateOneWithoutPageInput struct {
	Create     *UserCreateWithoutPageInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutPageDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutPageInput     `json:"upsert,omitempty"`
	Delete     *bool                           `json:"delete,omitempty"`
	Disconnect *bool                           `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput           `json:"connect,omitempty"`
}

type UserUpdateWithoutPageDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
}

type FeeUpdateManyWithoutEventRelationInput struct {
	Create     []FeeCreateWithoutEventRelationInput                `json:"create,omitempty"`
	Delete     []FeeWhereUniqueInput                               `json:"delete,omitempty"`
	Connect    []FeeWhereUniqueInput                               `json:"connect,omitempty"`
	Set        []FeeWhereUniqueInput                               `json:"set,omitempty"`
	Disconnect []FeeWhereUniqueInput                               `json:"disconnect,omitempty"`
	Update     []FeeUpdateWithWhereUniqueWithoutEventRelationInput `json:"update,omitempty"`
	Upsert     []FeeUpsertWithWhereUniqueWithoutEventRelationInput `json:"upsert,omitempty"`
	DeleteMany []FeeScalarWhereInput                               `json:"deleteMany,omitempty"`
	UpdateMany []FeeUpdateManyWithWhereNestedInput                 `json:"updateMany,omitempty"`
}

type FeeUpdateWithWhereUniqueWithoutEventRelationInput struct {
	Where FeeWhereUniqueInput                    `json:"where"`
	Data  FeeUpdateWithoutEventRelationDataInput `json:"data"`
}

type FeeUpdateWithoutEventRelationDataInput struct {
	Type              *int32                                 `json:"type,omitempty"`
	Key               *int32                                 `json:"key,omitempty"`
	Memo              *string                                `json:"memo,omitempty"`
	Rank              *int32                                 `json:"rank,omitempty"`
	AskTakerFee       *float64                               `json:"askTakerFee,omitempty"`
	AskMakerFee       *float64                               `json:"askMakerFee,omitempty"`
	BidTakerFee       *float64                               `json:"bidTakerFee,omitempty"`
	BidMakerFee       *float64                               `json:"bidMakerFee,omitempty"`
	MyCoinAskTakerFee *float64                               `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskMakerFee *float64                               `json:"myCoinAskMakerFee,omitempty"`
	MyCoinBidTakerFee *float64                               `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidMakerFee *float64                               `json:"myCoinBidMakerFee,omitempty"`
	RankRelation      *UserUpdateManyWithoutUserRankFeeInput `json:"rankRelation,omitempty"`
}

type UserUpdateManyWithoutUserRankFeeInput struct {
	Create     []UserCreateWithoutUserRankFeeInput                `json:"create,omitempty"`
	Delete     []UserWhereUniqueInput                             `json:"delete,omitempty"`
	Connect    []UserWhereUniqueInput                             `json:"connect,omitempty"`
	Set        []UserWhereUniqueInput                             `json:"set,omitempty"`
	Disconnect []UserWhereUniqueInput                             `json:"disconnect,omitempty"`
	Update     []UserUpdateWithWhereUniqueWithoutUserRankFeeInput `json:"update,omitempty"`
	Upsert     []UserUpsertWithWhereUniqueWithoutUserRankFeeInput `json:"upsert,omitempty"`
	DeleteMany []UserScalarWhereInput                             `json:"deleteMany,omitempty"`
	UpdateMany []UserUpdateManyWithWhereNestedInput               `json:"updateMany,omitempty"`
}

type UserUpdateWithWhereUniqueWithoutUserRankFeeInput struct {
	Where UserWhereUniqueInput                  `json:"where"`
	Data  UserUpdateWithoutUserRankFeeDataInput `json:"data"`
}

type UserUpdateWithoutUserRankFeeDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type UserUpsertWithWhereUniqueWithoutUserRankFeeInput struct {
	Where  UserWhereUniqueInput                  `json:"where"`
	Update UserUpdateWithoutUserRankFeeDataInput `json:"update"`
	Create UserCreateWithoutUserRankFeeInput     `json:"create"`
}

type UserScalarWhereInput struct {
	ID                           *string                `json:"id,omitempty"`
	IDNot                        *string                `json:"id_not,omitempty"`
	IDIn                         []string               `json:"id_in,omitempty"`
	IDNotIn                      []string               `json:"id_not_in,omitempty"`
	IDLt                         *string                `json:"id_lt,omitempty"`
	IDLte                        *string                `json:"id_lte,omitempty"`
	IDGt                         *string                `json:"id_gt,omitempty"`
	IDGte                        *string                `json:"id_gte,omitempty"`
	IDContains                   *string                `json:"id_contains,omitempty"`
	IDNotContains                *string                `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                `json:"id_not_ends_with,omitempty"`
	Role                         *Role                  `json:"role,omitempty"`
	RoleNot                      *Role                  `json:"role_not,omitempty"`
	RoleIn                       []Role                 `json:"role_in,omitempty"`
	RoleNotIn                    []Role                 `json:"role_not_in,omitempty"`
	FirebaseUid                  *string                `json:"firebaseUID,omitempty"`
	FirebaseUidNot               *string                `json:"firebaseUID_not,omitempty"`
	FirebaseUidIn                []string               `json:"firebaseUID_in,omitempty"`
	FirebaseUidNotIn             []string               `json:"firebaseUID_not_in,omitempty"`
	FirebaseUidLt                *string                `json:"firebaseUID_lt,omitempty"`
	FirebaseUidLte               *string                `json:"firebaseUID_lte,omitempty"`
	FirebaseUidGt                *string                `json:"firebaseUID_gt,omitempty"`
	FirebaseUidGte               *string                `json:"firebaseUID_gte,omitempty"`
	FirebaseUidContains          *string                `json:"firebaseUID_contains,omitempty"`
	FirebaseUidNotContains       *string                `json:"firebaseUID_not_contains,omitempty"`
	FirebaseUidStartsWith        *string                `json:"firebaseUID_starts_with,omitempty"`
	FirebaseUidNotStartsWith     *string                `json:"firebaseUID_not_starts_with,omitempty"`
	FirebaseUidEndsWith          *string                `json:"firebaseUID_ends_with,omitempty"`
	FirebaseUidNotEndsWith       *string                `json:"firebaseUID_not_ends_with,omitempty"`
	Provider                     *string                `json:"provider,omitempty"`
	ProviderNot                  *string                `json:"provider_not,omitempty"`
	ProviderIn                   []string               `json:"provider_in,omitempty"`
	ProviderNotIn                []string               `json:"provider_not_in,omitempty"`
	ProviderLt                   *string                `json:"provider_lt,omitempty"`
	ProviderLte                  *string                `json:"provider_lte,omitempty"`
	ProviderGt                   *string                `json:"provider_gt,omitempty"`
	ProviderGte                  *string                `json:"provider_gte,omitempty"`
	ProviderContains             *string                `json:"provider_contains,omitempty"`
	ProviderNotContains          *string                `json:"provider_not_contains,omitempty"`
	ProviderStartsWith           *string                `json:"provider_starts_with,omitempty"`
	ProviderNotStartsWith        *string                `json:"provider_not_starts_with,omitempty"`
	ProviderEndsWith             *string                `json:"provider_ends_with,omitempty"`
	ProviderNotEndsWith          *string                `json:"provider_not_ends_with,omitempty"`
	NickName                     *string                `json:"nickName,omitempty"`
	NickNameNot                  *string                `json:"nickName_not,omitempty"`
	NickNameIn                   []string               `json:"nickName_in,omitempty"`
	NickNameNotIn                []string               `json:"nickName_not_in,omitempty"`
	NickNameLt                   *string                `json:"nickName_lt,omitempty"`
	NickNameLte                  *string                `json:"nickName_lte,omitempty"`
	NickNameGt                   *string                `json:"nickName_gt,omitempty"`
	NickNameGte                  *string                `json:"nickName_gte,omitempty"`
	NickNameContains             *string                `json:"nickName_contains,omitempty"`
	NickNameNotContains          *string                `json:"nickName_not_contains,omitempty"`
	NickNameStartsWith           *string                `json:"nickName_starts_with,omitempty"`
	NickNameNotStartsWith        *string                `json:"nickName_not_starts_with,omitempty"`
	NickNameEndsWith             *string                `json:"nickName_ends_with,omitempty"`
	NickNameNotEndsWith          *string                `json:"nickName_not_ends_with,omitempty"`
	Email                        *string                `json:"email,omitempty"`
	EmailNot                     *string                `json:"email_not,omitempty"`
	EmailIn                      []string               `json:"email_in,omitempty"`
	EmailNotIn                   []string               `json:"email_not_in,omitempty"`
	EmailLt                      *string                `json:"email_lt,omitempty"`
	EmailLte                     *string                `json:"email_lte,omitempty"`
	EmailGt                      *string                `json:"email_gt,omitempty"`
	EmailGte                     *string                `json:"email_gte,omitempty"`
	EmailContains                *string                `json:"email_contains,omitempty"`
	EmailNotContains             *string                `json:"email_not_contains,omitempty"`
	EmailStartsWith              *string                `json:"email_starts_with,omitempty"`
	EmailNotStartsWith           *string                `json:"email_not_starts_with,omitempty"`
	EmailEndsWith                *string                `json:"email_ends_with,omitempty"`
	EmailNotEndsWith             *string                `json:"email_not_ends_with,omitempty"`
	BackupEmail                  *string                `json:"backupEmail,omitempty"`
	BackupEmailNot               *string                `json:"backupEmail_not,omitempty"`
	BackupEmailIn                []string               `json:"backupEmail_in,omitempty"`
	BackupEmailNotIn             []string               `json:"backupEmail_not_in,omitempty"`
	BackupEmailLt                *string                `json:"backupEmail_lt,omitempty"`
	BackupEmailLte               *string                `json:"backupEmail_lte,omitempty"`
	BackupEmailGt                *string                `json:"backupEmail_gt,omitempty"`
	BackupEmailGte               *string                `json:"backupEmail_gte,omitempty"`
	BackupEmailContains          *string                `json:"backupEmail_contains,omitempty"`
	BackupEmailNotContains       *string                `json:"backupEmail_not_contains,omitempty"`
	BackupEmailStartsWith        *string                `json:"backupEmail_starts_with,omitempty"`
	BackupEmailNotStartsWith     *string                `json:"backupEmail_not_starts_with,omitempty"`
	BackupEmailEndsWith          *string                `json:"backupEmail_ends_with,omitempty"`
	BackupEmailNotEndsWith       *string                `json:"backupEmail_not_ends_with,omitempty"`
	DeviceId                     *string                `json:"deviceId,omitempty"`
	DeviceIdNot                  *string                `json:"deviceId_not,omitempty"`
	DeviceIdIn                   []string               `json:"deviceId_in,omitempty"`
	DeviceIdNotIn                []string               `json:"deviceId_not_in,omitempty"`
	DeviceIdLt                   *string                `json:"deviceId_lt,omitempty"`
	DeviceIdLte                  *string                `json:"deviceId_lte,omitempty"`
	DeviceIdGt                   *string                `json:"deviceId_gt,omitempty"`
	DeviceIdGte                  *string                `json:"deviceId_gte,omitempty"`
	DeviceIdContains             *string                `json:"deviceId_contains,omitempty"`
	DeviceIdNotContains          *string                `json:"deviceId_not_contains,omitempty"`
	DeviceIdStartsWith           *string                `json:"deviceId_starts_with,omitempty"`
	DeviceIdNotStartsWith        *string                `json:"deviceId_not_starts_with,omitempty"`
	DeviceIdEndsWith             *string                `json:"deviceId_ends_with,omitempty"`
	DeviceIdNotEndsWith          *string                `json:"deviceId_not_ends_with,omitempty"`
	Platform                     *string                `json:"platform,omitempty"`
	PlatformNot                  *string                `json:"platform_not,omitempty"`
	PlatformIn                   []string               `json:"platform_in,omitempty"`
	PlatformNotIn                []string               `json:"platform_not_in,omitempty"`
	PlatformLt                   *string                `json:"platform_lt,omitempty"`
	PlatformLte                  *string                `json:"platform_lte,omitempty"`
	PlatformGt                   *string                `json:"platform_gt,omitempty"`
	PlatformGte                  *string                `json:"platform_gte,omitempty"`
	PlatformContains             *string                `json:"platform_contains,omitempty"`
	PlatformNotContains          *string                `json:"platform_not_contains,omitempty"`
	PlatformStartsWith           *string                `json:"platform_starts_with,omitempty"`
	PlatformNotStartsWith        *string                `json:"platform_not_starts_with,omitempty"`
	PlatformEndsWith             *string                `json:"platform_ends_with,omitempty"`
	PlatformNotEndsWith          *string                `json:"platform_not_ends_with,omitempty"`
	FcmToken                     *string                `json:"fcmToken,omitempty"`
	FcmTokenNot                  *string                `json:"fcmToken_not,omitempty"`
	FcmTokenIn                   []string               `json:"fcmToken_in,omitempty"`
	FcmTokenNotIn                []string               `json:"fcmToken_not_in,omitempty"`
	FcmTokenLt                   *string                `json:"fcmToken_lt,omitempty"`
	FcmTokenLte                  *string                `json:"fcmToken_lte,omitempty"`
	FcmTokenGt                   *string                `json:"fcmToken_gt,omitempty"`
	FcmTokenGte                  *string                `json:"fcmToken_gte,omitempty"`
	FcmTokenContains             *string                `json:"fcmToken_contains,omitempty"`
	FcmTokenNotContains          *string                `json:"fcmToken_not_contains,omitempty"`
	FcmTokenStartsWith           *string                `json:"fcmToken_starts_with,omitempty"`
	FcmTokenNotStartsWith        *string                `json:"fcmToken_not_starts_with,omitempty"`
	FcmTokenEndsWith             *string                `json:"fcmToken_ends_with,omitempty"`
	FcmTokenNotEndsWith          *string                `json:"fcmToken_not_ends_with,omitempty"`
	LinkedFacebook               *string                `json:"linkedFacebook,omitempty"`
	LinkedFacebookNot            *string                `json:"linkedFacebook_not,omitempty"`
	LinkedFacebookIn             []string               `json:"linkedFacebook_in,omitempty"`
	LinkedFacebookNotIn          []string               `json:"linkedFacebook_not_in,omitempty"`
	LinkedFacebookLt             *string                `json:"linkedFacebook_lt,omitempty"`
	LinkedFacebookLte            *string                `json:"linkedFacebook_lte,omitempty"`
	LinkedFacebookGt             *string                `json:"linkedFacebook_gt,omitempty"`
	LinkedFacebookGte            *string                `json:"linkedFacebook_gte,omitempty"`
	LinkedFacebookContains       *string                `json:"linkedFacebook_contains,omitempty"`
	LinkedFacebookNotContains    *string                `json:"linkedFacebook_not_contains,omitempty"`
	LinkedFacebookStartsWith     *string                `json:"linkedFacebook_starts_with,omitempty"`
	LinkedFacebookNotStartsWith  *string                `json:"linkedFacebook_not_starts_with,omitempty"`
	LinkedFacebookEndsWith       *string                `json:"linkedFacebook_ends_with,omitempty"`
	LinkedFacebookNotEndsWith    *string                `json:"linkedFacebook_not_ends_with,omitempty"`
	LinkedTwitter                *string                `json:"linkedTwitter,omitempty"`
	LinkedTwitterNot             *string                `json:"linkedTwitter_not,omitempty"`
	LinkedTwitterIn              []string               `json:"linkedTwitter_in,omitempty"`
	LinkedTwitterNotIn           []string               `json:"linkedTwitter_not_in,omitempty"`
	LinkedTwitterLt              *string                `json:"linkedTwitter_lt,omitempty"`
	LinkedTwitterLte             *string                `json:"linkedTwitter_lte,omitempty"`
	LinkedTwitterGt              *string                `json:"linkedTwitter_gt,omitempty"`
	LinkedTwitterGte             *string                `json:"linkedTwitter_gte,omitempty"`
	LinkedTwitterContains        *string                `json:"linkedTwitter_contains,omitempty"`
	LinkedTwitterNotContains     *string                `json:"linkedTwitter_not_contains,omitempty"`
	LinkedTwitterStartsWith      *string                `json:"linkedTwitter_starts_with,omitempty"`
	LinkedTwitterNotStartsWith   *string                `json:"linkedTwitter_not_starts_with,omitempty"`
	LinkedTwitterEndsWith        *string                `json:"linkedTwitter_ends_with,omitempty"`
	LinkedTwitterNotEndsWith     *string                `json:"linkedTwitter_not_ends_with,omitempty"`
	LinkedInstagram              *string                `json:"linkedInstagram,omitempty"`
	LinkedInstagramNot           *string                `json:"linkedInstagram_not,omitempty"`
	LinkedInstagramIn            []string               `json:"linkedInstagram_in,omitempty"`
	LinkedInstagramNotIn         []string               `json:"linkedInstagram_not_in,omitempty"`
	LinkedInstagramLt            *string                `json:"linkedInstagram_lt,omitempty"`
	LinkedInstagramLte           *string                `json:"linkedInstagram_lte,omitempty"`
	LinkedInstagramGt            *string                `json:"linkedInstagram_gt,omitempty"`
	LinkedInstagramGte           *string                `json:"linkedInstagram_gte,omitempty"`
	LinkedInstagramContains      *string                `json:"linkedInstagram_contains,omitempty"`
	LinkedInstagramNotContains   *string                `json:"linkedInstagram_not_contains,omitempty"`
	LinkedInstagramStartsWith    *string                `json:"linkedInstagram_starts_with,omitempty"`
	LinkedInstagramNotStartsWith *string                `json:"linkedInstagram_not_starts_with,omitempty"`
	LinkedInstagramEndsWith      *string                `json:"linkedInstagram_ends_with,omitempty"`
	LinkedInstagramNotEndsWith   *string                `json:"linkedInstagram_not_ends_with,omitempty"`
	LinkedYoutube                *string                `json:"linkedYoutube,omitempty"`
	LinkedYoutubeNot             *string                `json:"linkedYoutube_not,omitempty"`
	LinkedYoutubeIn              []string               `json:"linkedYoutube_in,omitempty"`
	LinkedYoutubeNotIn           []string               `json:"linkedYoutube_not_in,omitempty"`
	LinkedYoutubeLt              *string                `json:"linkedYoutube_lt,omitempty"`
	LinkedYoutubeLte             *string                `json:"linkedYoutube_lte,omitempty"`
	LinkedYoutubeGt              *string                `json:"linkedYoutube_gt,omitempty"`
	LinkedYoutubeGte             *string                `json:"linkedYoutube_gte,omitempty"`
	LinkedYoutubeContains        *string                `json:"linkedYoutube_contains,omitempty"`
	LinkedYoutubeNotContains     *string                `json:"linkedYoutube_not_contains,omitempty"`
	LinkedYoutubeStartsWith      *string                `json:"linkedYoutube_starts_with,omitempty"`
	LinkedYoutubeNotStartsWith   *string                `json:"linkedYoutube_not_starts_with,omitempty"`
	LinkedYoutubeEndsWith        *string                `json:"linkedYoutube_ends_with,omitempty"`
	LinkedYoutubeNotEndsWith     *string                `json:"linkedYoutube_not_ends_with,omitempty"`
	LinkedTwitch                 *string                `json:"linkedTwitch,omitempty"`
	LinkedTwitchNot              *string                `json:"linkedTwitch_not,omitempty"`
	LinkedTwitchIn               []string               `json:"linkedTwitch_in,omitempty"`
	LinkedTwitchNotIn            []string               `json:"linkedTwitch_not_in,omitempty"`
	LinkedTwitchLt               *string                `json:"linkedTwitch_lt,omitempty"`
	LinkedTwitchLte              *string                `json:"linkedTwitch_lte,omitempty"`
	LinkedTwitchGt               *string                `json:"linkedTwitch_gt,omitempty"`
	LinkedTwitchGte              *string                `json:"linkedTwitch_gte,omitempty"`
	LinkedTwitchContains         *string                `json:"linkedTwitch_contains,omitempty"`
	LinkedTwitchNotContains      *string                `json:"linkedTwitch_not_contains,omitempty"`
	LinkedTwitchStartsWith       *string                `json:"linkedTwitch_starts_with,omitempty"`
	LinkedTwitchNotStartsWith    *string                `json:"linkedTwitch_not_starts_with,omitempty"`
	LinkedTwitchEndsWith         *string                `json:"linkedTwitch_ends_with,omitempty"`
	LinkedTwitchNotEndsWith      *string                `json:"linkedTwitch_not_ends_with,omitempty"`
	ContentProvider              *string                `json:"contentProvider,omitempty"`
	ContentProviderNot           *string                `json:"contentProvider_not,omitempty"`
	ContentProviderIn            []string               `json:"contentProvider_in,omitempty"`
	ContentProviderNotIn         []string               `json:"contentProvider_not_in,omitempty"`
	ContentProviderLt            *string                `json:"contentProvider_lt,omitempty"`
	ContentProviderLte           *string                `json:"contentProvider_lte,omitempty"`
	ContentProviderGt            *string                `json:"contentProvider_gt,omitempty"`
	ContentProviderGte           *string                `json:"contentProvider_gte,omitempty"`
	ContentProviderContains      *string                `json:"contentProvider_contains,omitempty"`
	ContentProviderNotContains   *string                `json:"contentProvider_not_contains,omitempty"`
	ContentProviderStartsWith    *string                `json:"contentProvider_starts_with,omitempty"`
	ContentProviderNotStartsWith *string                `json:"contentProvider_not_starts_with,omitempty"`
	ContentProviderEndsWith      *string                `json:"contentProvider_ends_with,omitempty"`
	ContentProviderNotEndsWith   *string                `json:"contentProvider_not_ends_with,omitempty"`
	ContentId                    *string                `json:"contentId,omitempty"`
	ContentIdNot                 *string                `json:"contentId_not,omitempty"`
	ContentIdIn                  []string               `json:"contentId_in,omitempty"`
	ContentIdNotIn               []string               `json:"contentId_not_in,omitempty"`
	ContentIdLt                  *string                `json:"contentId_lt,omitempty"`
	ContentIdLte                 *string                `json:"contentId_lte,omitempty"`
	ContentIdGt                  *string                `json:"contentId_gt,omitempty"`
	ContentIdGte                 *string                `json:"contentId_gte,omitempty"`
	ContentIdContains            *string                `json:"contentId_contains,omitempty"`
	ContentIdNotContains         *string                `json:"contentId_not_contains,omitempty"`
	ContentIdStartsWith          *string                `json:"contentId_starts_with,omitempty"`
	ContentIdNotStartsWith       *string                `json:"contentId_not_starts_with,omitempty"`
	ContentIdEndsWith            *string                `json:"contentId_ends_with,omitempty"`
	ContentIdNotEndsWith         *string                `json:"contentId_not_ends_with,omitempty"`
	RevokeTokenKey               *string                `json:"revokeTokenKey,omitempty"`
	RevokeTokenKeyNot            *string                `json:"revokeTokenKey_not,omitempty"`
	RevokeTokenKeyIn             []string               `json:"revokeTokenKey_in,omitempty"`
	RevokeTokenKeyNotIn          []string               `json:"revokeTokenKey_not_in,omitempty"`
	RevokeTokenKeyLt             *string                `json:"revokeTokenKey_lt,omitempty"`
	RevokeTokenKeyLte            *string                `json:"revokeTokenKey_lte,omitempty"`
	RevokeTokenKeyGt             *string                `json:"revokeTokenKey_gt,omitempty"`
	RevokeTokenKeyGte            *string                `json:"revokeTokenKey_gte,omitempty"`
	RevokeTokenKeyContains       *string                `json:"revokeTokenKey_contains,omitempty"`
	RevokeTokenKeyNotContains    *string                `json:"revokeTokenKey_not_contains,omitempty"`
	RevokeTokenKeyStartsWith     *string                `json:"revokeTokenKey_starts_with,omitempty"`
	RevokeTokenKeyNotStartsWith  *string                `json:"revokeTokenKey_not_starts_with,omitempty"`
	RevokeTokenKeyEndsWith       *string                `json:"revokeTokenKey_ends_with,omitempty"`
	RevokeTokenKeyNotEndsWith    *string                `json:"revokeTokenKey_not_ends_with,omitempty"`
	SubscribePushNotification    *bool                  `json:"subscribePushNotification,omitempty"`
	SubscribePushNotificationNot *bool                  `json:"subscribePushNotification_not,omitempty"`
	SubscribeEmail               *bool                  `json:"subscribeEmail,omitempty"`
	SubscribeEmailNot            *bool                  `json:"subscribeEmail_not,omitempty"`
	DeletedAt                    *string                `json:"deletedAt,omitempty"`
	DeletedAtNot                 *string                `json:"deletedAt_not,omitempty"`
	DeletedAtIn                  []string               `json:"deletedAt_in,omitempty"`
	DeletedAtNotIn               []string               `json:"deletedAt_not_in,omitempty"`
	DeletedAtLt                  *string                `json:"deletedAt_lt,omitempty"`
	DeletedAtLte                 *string                `json:"deletedAt_lte,omitempty"`
	DeletedAtGt                  *string                `json:"deletedAt_gt,omitempty"`
	DeletedAtGte                 *string                `json:"deletedAt_gte,omitempty"`
	CreatedAt                    *string                `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                `json:"updatedAt_gte,omitempty"`
	Status                       *int32                 `json:"status,omitempty"`
	StatusNot                    *int32                 `json:"status_not,omitempty"`
	StatusIn                     []int32                `json:"status_in,omitempty"`
	StatusNotIn                  []int32                `json:"status_not_in,omitempty"`
	StatusLt                     *int32                 `json:"status_lt,omitempty"`
	StatusLte                    *int32                 `json:"status_lte,omitempty"`
	StatusGt                     *int32                 `json:"status_gt,omitempty"`
	StatusGte                    *int32                 `json:"status_gte,omitempty"`
	NumId                        *int32                 `json:"numId,omitempty"`
	NumIdNot                     *int32                 `json:"numId_not,omitempty"`
	NumIdIn                      []int32                `json:"numId_in,omitempty"`
	NumIdNotIn                   []int32                `json:"numId_not_in,omitempty"`
	NumIdLt                      *int32                 `json:"numId_lt,omitempty"`
	NumIdLte                     *int32                 `json:"numId_lte,omitempty"`
	NumIdGt                      *int32                 `json:"numId_gt,omitempty"`
	NumIdGte                     *int32                 `json:"numId_gte,omitempty"`
	UserRank                     *int32                 `json:"userRank,omitempty"`
	UserRankNot                  *int32                 `json:"userRank_not,omitempty"`
	UserRankIn                   []int32                `json:"userRank_in,omitempty"`
	UserRankNotIn                []int32                `json:"userRank_not_in,omitempty"`
	UserRankLt                   *int32                 `json:"userRank_lt,omitempty"`
	UserRankLte                  *int32                 `json:"userRank_lte,omitempty"`
	UserRankGt                   *int32                 `json:"userRank_gt,omitempty"`
	UserRankGte                  *int32                 `json:"userRank_gte,omitempty"`
	And                          []UserScalarWhereInput `json:"AND,omitempty"`
	Or                           []UserScalarWhereInput `json:"OR,omitempty"`
	Not                          []UserScalarWhereInput `json:"NOT,omitempty"`
}

type UserUpdateManyWithWhereNestedInput struct {
	Where UserScalarWhereInput    `json:"where"`
	Data  UserUpdateManyDataInput `json:"data"`
}

type UserUpdateManyDataInput struct {
	Role                      *Role   `json:"role,omitempty"`
	FirebaseUid               *string `json:"firebaseUID,omitempty"`
	Provider                  *string `json:"provider,omitempty"`
	NickName                  *string `json:"nickName,omitempty"`
	Email                     *string `json:"email,omitempty"`
	BackupEmail               *string `json:"backupEmail,omitempty"`
	DeviceId                  *string `json:"deviceId,omitempty"`
	Platform                  *string `json:"platform,omitempty"`
	FcmToken                  *string `json:"fcmToken,omitempty"`
	LinkedFacebook            *string `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string `json:"linkedTwitch,omitempty"`
	ContentProvider           *string `json:"contentProvider,omitempty"`
	ContentId                 *string `json:"contentId,omitempty"`
	RevokeTokenKey            *string `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool   `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool   `json:"subscribeEmail,omitempty"`
	DeletedAt                 *string `json:"deletedAt,omitempty"`
	Status                    *int32  `json:"status,omitempty"`
	NumId                     *int32  `json:"numId,omitempty"`
	UserRank                  *int32  `json:"userRank,omitempty"`
}

type FeeUpsertWithWhereUniqueWithoutEventRelationInput struct {
	Where  FeeWhereUniqueInput                    `json:"where"`
	Update FeeUpdateWithoutEventRelationDataInput `json:"update"`
	Create FeeCreateWithoutEventRelationInput     `json:"create"`
}

type FeeScalarWhereInput struct {
	ID                     *string               `json:"id,omitempty"`
	IDNot                  *string               `json:"id_not,omitempty"`
	IDIn                   []string              `json:"id_in,omitempty"`
	IDNotIn                []string              `json:"id_not_in,omitempty"`
	IDLt                   *string               `json:"id_lt,omitempty"`
	IDLte                  *string               `json:"id_lte,omitempty"`
	IDGt                   *string               `json:"id_gt,omitempty"`
	IDGte                  *string               `json:"id_gte,omitempty"`
	IDContains             *string               `json:"id_contains,omitempty"`
	IDNotContains          *string               `json:"id_not_contains,omitempty"`
	IDStartsWith           *string               `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string               `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string               `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string               `json:"id_not_ends_with,omitempty"`
	Type                   *int32                `json:"type,omitempty"`
	TypeNot                *int32                `json:"type_not,omitempty"`
	TypeIn                 []int32               `json:"type_in,omitempty"`
	TypeNotIn              []int32               `json:"type_not_in,omitempty"`
	TypeLt                 *int32                `json:"type_lt,omitempty"`
	TypeLte                *int32                `json:"type_lte,omitempty"`
	TypeGt                 *int32                `json:"type_gt,omitempty"`
	TypeGte                *int32                `json:"type_gte,omitempty"`
	Key                    *int32                `json:"key,omitempty"`
	KeyNot                 *int32                `json:"key_not,omitempty"`
	KeyIn                  []int32               `json:"key_in,omitempty"`
	KeyNotIn               []int32               `json:"key_not_in,omitempty"`
	KeyLt                  *int32                `json:"key_lt,omitempty"`
	KeyLte                 *int32                `json:"key_lte,omitempty"`
	KeyGt                  *int32                `json:"key_gt,omitempty"`
	KeyGte                 *int32                `json:"key_gte,omitempty"`
	Memo                   *string               `json:"memo,omitempty"`
	MemoNot                *string               `json:"memo_not,omitempty"`
	MemoIn                 []string              `json:"memo_in,omitempty"`
	MemoNotIn              []string              `json:"memo_not_in,omitempty"`
	MemoLt                 *string               `json:"memo_lt,omitempty"`
	MemoLte                *string               `json:"memo_lte,omitempty"`
	MemoGt                 *string               `json:"memo_gt,omitempty"`
	MemoGte                *string               `json:"memo_gte,omitempty"`
	MemoContains           *string               `json:"memo_contains,omitempty"`
	MemoNotContains        *string               `json:"memo_not_contains,omitempty"`
	MemoStartsWith         *string               `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith      *string               `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith           *string               `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith        *string               `json:"memo_not_ends_with,omitempty"`
	Rank                   *int32                `json:"rank,omitempty"`
	RankNot                *int32                `json:"rank_not,omitempty"`
	RankIn                 []int32               `json:"rank_in,omitempty"`
	RankNotIn              []int32               `json:"rank_not_in,omitempty"`
	RankLt                 *int32                `json:"rank_lt,omitempty"`
	RankLte                *int32                `json:"rank_lte,omitempty"`
	RankGt                 *int32                `json:"rank_gt,omitempty"`
	RankGte                *int32                `json:"rank_gte,omitempty"`
	AskTakerFee            *float64              `json:"askTakerFee,omitempty"`
	AskTakerFeeNot         *float64              `json:"askTakerFee_not,omitempty"`
	AskTakerFeeIn          []float64             `json:"askTakerFee_in,omitempty"`
	AskTakerFeeNotIn       []float64             `json:"askTakerFee_not_in,omitempty"`
	AskTakerFeeLt          *float64              `json:"askTakerFee_lt,omitempty"`
	AskTakerFeeLte         *float64              `json:"askTakerFee_lte,omitempty"`
	AskTakerFeeGt          *float64              `json:"askTakerFee_gt,omitempty"`
	AskTakerFeeGte         *float64              `json:"askTakerFee_gte,omitempty"`
	AskMakerFee            *float64              `json:"askMakerFee,omitempty"`
	AskMakerFeeNot         *float64              `json:"askMakerFee_not,omitempty"`
	AskMakerFeeIn          []float64             `json:"askMakerFee_in,omitempty"`
	AskMakerFeeNotIn       []float64             `json:"askMakerFee_not_in,omitempty"`
	AskMakerFeeLt          *float64              `json:"askMakerFee_lt,omitempty"`
	AskMakerFeeLte         *float64              `json:"askMakerFee_lte,omitempty"`
	AskMakerFeeGt          *float64              `json:"askMakerFee_gt,omitempty"`
	AskMakerFeeGte         *float64              `json:"askMakerFee_gte,omitempty"`
	BidTakerFee            *float64              `json:"bidTakerFee,omitempty"`
	BidTakerFeeNot         *float64              `json:"bidTakerFee_not,omitempty"`
	BidTakerFeeIn          []float64             `json:"bidTakerFee_in,omitempty"`
	BidTakerFeeNotIn       []float64             `json:"bidTakerFee_not_in,omitempty"`
	BidTakerFeeLt          *float64              `json:"bidTakerFee_lt,omitempty"`
	BidTakerFeeLte         *float64              `json:"bidTakerFee_lte,omitempty"`
	BidTakerFeeGt          *float64              `json:"bidTakerFee_gt,omitempty"`
	BidTakerFeeGte         *float64              `json:"bidTakerFee_gte,omitempty"`
	BidMakerFee            *float64              `json:"bidMakerFee,omitempty"`
	BidMakerFeeNot         *float64              `json:"bidMakerFee_not,omitempty"`
	BidMakerFeeIn          []float64             `json:"bidMakerFee_in,omitempty"`
	BidMakerFeeNotIn       []float64             `json:"bidMakerFee_not_in,omitempty"`
	BidMakerFeeLt          *float64              `json:"bidMakerFee_lt,omitempty"`
	BidMakerFeeLte         *float64              `json:"bidMakerFee_lte,omitempty"`
	BidMakerFeeGt          *float64              `json:"bidMakerFee_gt,omitempty"`
	BidMakerFeeGte         *float64              `json:"bidMakerFee_gte,omitempty"`
	MyCoinAskTakerFee      *float64              `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskTakerFeeNot   *float64              `json:"myCoinAskTakerFee_not,omitempty"`
	MyCoinAskTakerFeeIn    []float64             `json:"myCoinAskTakerFee_in,omitempty"`
	MyCoinAskTakerFeeNotIn []float64             `json:"myCoinAskTakerFee_not_in,omitempty"`
	MyCoinAskTakerFeeLt    *float64              `json:"myCoinAskTakerFee_lt,omitempty"`
	MyCoinAskTakerFeeLte   *float64              `json:"myCoinAskTakerFee_lte,omitempty"`
	MyCoinAskTakerFeeGt    *float64              `json:"myCoinAskTakerFee_gt,omitempty"`
	MyCoinAskTakerFeeGte   *float64              `json:"myCoinAskTakerFee_gte,omitempty"`
	MyCoinAskMakerFee      *float64              `json:"myCoinAskMakerFee,omitempty"`
	MyCoinAskMakerFeeNot   *float64              `json:"myCoinAskMakerFee_not,omitempty"`
	MyCoinAskMakerFeeIn    []float64             `json:"myCoinAskMakerFee_in,omitempty"`
	MyCoinAskMakerFeeNotIn []float64             `json:"myCoinAskMakerFee_not_in,omitempty"`
	MyCoinAskMakerFeeLt    *float64              `json:"myCoinAskMakerFee_lt,omitempty"`
	MyCoinAskMakerFeeLte   *float64              `json:"myCoinAskMakerFee_lte,omitempty"`
	MyCoinAskMakerFeeGt    *float64              `json:"myCoinAskMakerFee_gt,omitempty"`
	MyCoinAskMakerFeeGte   *float64              `json:"myCoinAskMakerFee_gte,omitempty"`
	MyCoinBidTakerFee      *float64              `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidTakerFeeNot   *float64              `json:"myCoinBidTakerFee_not,omitempty"`
	MyCoinBidTakerFeeIn    []float64             `json:"myCoinBidTakerFee_in,omitempty"`
	MyCoinBidTakerFeeNotIn []float64             `json:"myCoinBidTakerFee_not_in,omitempty"`
	MyCoinBidTakerFeeLt    *float64              `json:"myCoinBidTakerFee_lt,omitempty"`
	MyCoinBidTakerFeeLte   *float64              `json:"myCoinBidTakerFee_lte,omitempty"`
	MyCoinBidTakerFeeGt    *float64              `json:"myCoinBidTakerFee_gt,omitempty"`
	MyCoinBidTakerFeeGte   *float64              `json:"myCoinBidTakerFee_gte,omitempty"`
	MyCoinBidMakerFee      *float64              `json:"myCoinBidMakerFee,omitempty"`
	MyCoinBidMakerFeeNot   *float64              `json:"myCoinBidMakerFee_not,omitempty"`
	MyCoinBidMakerFeeIn    []float64             `json:"myCoinBidMakerFee_in,omitempty"`
	MyCoinBidMakerFeeNotIn []float64             `json:"myCoinBidMakerFee_not_in,omitempty"`
	MyCoinBidMakerFeeLt    *float64              `json:"myCoinBidMakerFee_lt,omitempty"`
	MyCoinBidMakerFeeLte   *float64              `json:"myCoinBidMakerFee_lte,omitempty"`
	MyCoinBidMakerFeeGt    *float64              `json:"myCoinBidMakerFee_gt,omitempty"`
	MyCoinBidMakerFeeGte   *float64              `json:"myCoinBidMakerFee_gte,omitempty"`
	CreatedAt              *string               `json:"createdAt,omitempty"`
	CreatedAtNot           *string               `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string               `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string               `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string               `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string               `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string               `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string               `json:"updatedAt_gte,omitempty"`
	And                    []FeeScalarWhereInput `json:"AND,omitempty"`
	Or                     []FeeScalarWhereInput `json:"OR,omitempty"`
	Not                    []FeeScalarWhereInput `json:"NOT,omitempty"`
}

type FeeUpdateManyWithWhereNestedInput struct {
	Where FeeScalarWhereInput    `json:"where"`
	Data  FeeUpdateManyDataInput `json:"data"`
}

type FeeUpdateManyDataInput struct {
	Type              *int32   `json:"type,omitempty"`
	Key               *int32   `json:"key,omitempty"`
	Memo              *string  `json:"memo,omitempty"`
	Rank              *int32   `json:"rank,omitempty"`
	AskTakerFee       *float64 `json:"askTakerFee,omitempty"`
	AskMakerFee       *float64 `json:"askMakerFee,omitempty"`
	BidTakerFee       *float64 `json:"bidTakerFee,omitempty"`
	BidMakerFee       *float64 `json:"bidMakerFee,omitempty"`
	MyCoinAskTakerFee *float64 `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskMakerFee *float64 `json:"myCoinAskMakerFee,omitempty"`
	MyCoinBidTakerFee *float64 `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidMakerFee *float64 `json:"myCoinBidMakerFee,omitempty"`
}

type UserUpsertWithoutPageInput struct {
	Update UserUpdateWithoutPageDataInput `json:"update"`
	Create UserCreateWithoutPageInput     `json:"create"`
}

type PageCommentUpdateManyWithoutPageInput struct {
	Create     []PageCommentCreateWithoutPageInput                `json:"create,omitempty"`
	Delete     []PageCommentWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []PageCommentWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []PageCommentWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []PageCommentWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []PageCommentUpdateWithWhereUniqueWithoutPageInput `json:"update,omitempty"`
	Upsert     []PageCommentUpsertWithWhereUniqueWithoutPageInput `json:"upsert,omitempty"`
	DeleteMany []PageCommentScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []PageCommentUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type PageCommentUpdateWithWhereUniqueWithoutPageInput struct {
	Where PageCommentWhereUniqueInput           `json:"where"`
	Data  PageCommentUpdateWithoutPageDataInput `json:"data"`
}

type PageCommentUpdateWithoutPageDataInput struct {
	Content                  *string                                            `json:"content,omitempty"`
	Comments                 *PageCommentReplyUpdateManyWithoutPageCommentInput `json:"comments,omitempty"`
	IpAddress                *string                                            `json:"ipAddress,omitempty"`
	ImageUrl                 *string                                            `json:"imageUrl,omitempty"`
	ThumbnailImageUrl        *string                                            `json:"thumbnailImageUrl,omitempty"`
	Owner                    *UserUpdateOneInput                                `json:"owner,omitempty"`
	RelatedReviewContentPage *ReviewContentPageUpdateOneWithoutCommentsInput    `json:"relatedReviewContentPage,omitempty"`
	IsDel                    *bool                                              `json:"isDel,omitempty"`
}

type PageCommentReplyUpdateManyWithoutPageCommentInput struct {
	Create     []PageCommentReplyCreateWithoutPageCommentInput                `json:"create,omitempty"`
	Delete     []PageCommentReplyWhereUniqueInput                             `json:"delete,omitempty"`
	Connect    []PageCommentReplyWhereUniqueInput                             `json:"connect,omitempty"`
	Set        []PageCommentReplyWhereUniqueInput                             `json:"set,omitempty"`
	Disconnect []PageCommentReplyWhereUniqueInput                             `json:"disconnect,omitempty"`
	Update     []PageCommentReplyUpdateWithWhereUniqueWithoutPageCommentInput `json:"update,omitempty"`
	Upsert     []PageCommentReplyUpsertWithWhereUniqueWithoutPageCommentInput `json:"upsert,omitempty"`
	DeleteMany []PageCommentReplyScalarWhereInput                             `json:"deleteMany,omitempty"`
	UpdateMany []PageCommentReplyUpdateManyWithWhereNestedInput               `json:"updateMany,omitempty"`
}

type PageCommentReplyUpdateWithWhereUniqueWithoutPageCommentInput struct {
	Where PageCommentReplyWhereUniqueInput                  `json:"where"`
	Data  PageCommentReplyUpdateWithoutPageCommentDataInput `json:"data"`
}

type PageCommentReplyUpdateWithoutPageCommentDataInput struct {
	Content           *string             `json:"content,omitempty"`
	IpAddress         *string             `json:"ipAddress,omitempty"`
	ImageUrl          *string             `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string             `json:"thumbnailImageUrl,omitempty"`
	Owner             *UserUpdateOneInput `json:"owner,omitempty"`
	IsDel             *bool               `json:"isDel,omitempty"`
}

type PageCommentReplyUpsertWithWhereUniqueWithoutPageCommentInput struct {
	Where  PageCommentReplyWhereUniqueInput                  `json:"where"`
	Update PageCommentReplyUpdateWithoutPageCommentDataInput `json:"update"`
	Create PageCommentReplyCreateWithoutPageCommentInput     `json:"create"`
}

type PageCommentReplyScalarWhereInput struct {
	ID                             *string                            `json:"id,omitempty"`
	IDNot                          *string                            `json:"id_not,omitempty"`
	IDIn                           []string                           `json:"id_in,omitempty"`
	IDNotIn                        []string                           `json:"id_not_in,omitempty"`
	IDLt                           *string                            `json:"id_lt,omitempty"`
	IDLte                          *string                            `json:"id_lte,omitempty"`
	IDGt                           *string                            `json:"id_gt,omitempty"`
	IDGte                          *string                            `json:"id_gte,omitempty"`
	IDContains                     *string                            `json:"id_contains,omitempty"`
	IDNotContains                  *string                            `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                            `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                            `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                            `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                            `json:"id_not_ends_with,omitempty"`
	Content                        *string                            `json:"content,omitempty"`
	ContentNot                     *string                            `json:"content_not,omitempty"`
	ContentIn                      []string                           `json:"content_in,omitempty"`
	ContentNotIn                   []string                           `json:"content_not_in,omitempty"`
	ContentLt                      *string                            `json:"content_lt,omitempty"`
	ContentLte                     *string                            `json:"content_lte,omitempty"`
	ContentGt                      *string                            `json:"content_gt,omitempty"`
	ContentGte                     *string                            `json:"content_gte,omitempty"`
	ContentContains                *string                            `json:"content_contains,omitempty"`
	ContentNotContains             *string                            `json:"content_not_contains,omitempty"`
	ContentStartsWith              *string                            `json:"content_starts_with,omitempty"`
	ContentNotStartsWith           *string                            `json:"content_not_starts_with,omitempty"`
	ContentEndsWith                *string                            `json:"content_ends_with,omitempty"`
	ContentNotEndsWith             *string                            `json:"content_not_ends_with,omitempty"`
	IpAddress                      *string                            `json:"ipAddress,omitempty"`
	IpAddressNot                   *string                            `json:"ipAddress_not,omitempty"`
	IpAddressIn                    []string                           `json:"ipAddress_in,omitempty"`
	IpAddressNotIn                 []string                           `json:"ipAddress_not_in,omitempty"`
	IpAddressLt                    *string                            `json:"ipAddress_lt,omitempty"`
	IpAddressLte                   *string                            `json:"ipAddress_lte,omitempty"`
	IpAddressGt                    *string                            `json:"ipAddress_gt,omitempty"`
	IpAddressGte                   *string                            `json:"ipAddress_gte,omitempty"`
	IpAddressContains              *string                            `json:"ipAddress_contains,omitempty"`
	IpAddressNotContains           *string                            `json:"ipAddress_not_contains,omitempty"`
	IpAddressStartsWith            *string                            `json:"ipAddress_starts_with,omitempty"`
	IpAddressNotStartsWith         *string                            `json:"ipAddress_not_starts_with,omitempty"`
	IpAddressEndsWith              *string                            `json:"ipAddress_ends_with,omitempty"`
	IpAddressNotEndsWith           *string                            `json:"ipAddress_not_ends_with,omitempty"`
	ImageUrl                       *string                            `json:"imageUrl,omitempty"`
	ImageUrlNot                    *string                            `json:"imageUrl_not,omitempty"`
	ImageUrlIn                     []string                           `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn                  []string                           `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt                     *string                            `json:"imageUrl_lt,omitempty"`
	ImageUrlLte                    *string                            `json:"imageUrl_lte,omitempty"`
	ImageUrlGt                     *string                            `json:"imageUrl_gt,omitempty"`
	ImageUrlGte                    *string                            `json:"imageUrl_gte,omitempty"`
	ImageUrlContains               *string                            `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains            *string                            `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith             *string                            `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith          *string                            `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith               *string                            `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith            *string                            `json:"imageUrl_not_ends_with,omitempty"`
	ThumbnailImageUrl              *string                            `json:"thumbnailImageUrl,omitempty"`
	ThumbnailImageUrlNot           *string                            `json:"thumbnailImageUrl_not,omitempty"`
	ThumbnailImageUrlIn            []string                           `json:"thumbnailImageUrl_in,omitempty"`
	ThumbnailImageUrlNotIn         []string                           `json:"thumbnailImageUrl_not_in,omitempty"`
	ThumbnailImageUrlLt            *string                            `json:"thumbnailImageUrl_lt,omitempty"`
	ThumbnailImageUrlLte           *string                            `json:"thumbnailImageUrl_lte,omitempty"`
	ThumbnailImageUrlGt            *string                            `json:"thumbnailImageUrl_gt,omitempty"`
	ThumbnailImageUrlGte           *string                            `json:"thumbnailImageUrl_gte,omitempty"`
	ThumbnailImageUrlContains      *string                            `json:"thumbnailImageUrl_contains,omitempty"`
	ThumbnailImageUrlNotContains   *string                            `json:"thumbnailImageUrl_not_contains,omitempty"`
	ThumbnailImageUrlStartsWith    *string                            `json:"thumbnailImageUrl_starts_with,omitempty"`
	ThumbnailImageUrlNotStartsWith *string                            `json:"thumbnailImageUrl_not_starts_with,omitempty"`
	ThumbnailImageUrlEndsWith      *string                            `json:"thumbnailImageUrl_ends_with,omitempty"`
	ThumbnailImageUrlNotEndsWith   *string                            `json:"thumbnailImageUrl_not_ends_with,omitempty"`
	CreatedAt                      *string                            `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                            `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string                           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string                           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                            `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                            `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                            `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                            `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                            `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string                           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string                           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                            `json:"updatedAt_gte,omitempty"`
	IsDel                          *bool                              `json:"isDel,omitempty"`
	IsDelNot                       *bool                              `json:"isDel_not,omitempty"`
	And                            []PageCommentReplyScalarWhereInput `json:"AND,omitempty"`
	Or                             []PageCommentReplyScalarWhereInput `json:"OR,omitempty"`
	Not                            []PageCommentReplyScalarWhereInput `json:"NOT,omitempty"`
}

type PageCommentReplyUpdateManyWithWhereNestedInput struct {
	Where PageCommentReplyScalarWhereInput    `json:"where"`
	Data  PageCommentReplyUpdateManyDataInput `json:"data"`
}

type PageCommentReplyUpdateManyDataInput struct {
	Content           *string `json:"content,omitempty"`
	IpAddress         *string `json:"ipAddress,omitempty"`
	ImageUrl          *string `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string `json:"thumbnailImageUrl,omitempty"`
	IsDel             *bool   `json:"isDel,omitempty"`
}

type ReviewContentPageUpdateOneWithoutCommentsInput struct {
	Create     *ReviewContentPageCreateWithoutCommentsInput     `json:"create,omitempty"`
	Update     *ReviewContentPageUpdateWithoutCommentsDataInput `json:"update,omitempty"`
	Upsert     *ReviewContentPageUpsertWithoutCommentsInput     `json:"upsert,omitempty"`
	Delete     *bool                                            `json:"delete,omitempty"`
	Disconnect *bool                                            `json:"disconnect,omitempty"`
	Connect    *ReviewContentPageWhereUniqueInput               `json:"connect,omitempty"`
}

type ReviewContentPageUpdateWithoutCommentsDataInput struct {
	Page       *PageUpdateOneRequiredWithoutReviewsInput                         `json:"page,omitempty"`
	Categories *ReviewContentCategoryUpdateManyInput                             `json:"categories,omitempty"`
	Title      *string                                                           `json:"title,omitempty"`
	SubTitle   *string                                                           `json:"subTitle,omitempty"`
	Message    *string                                                           `json:"message,omitempty"`
	Viewers    *ReviewContentPageViewerUpdateManyWithoutReviewContentPageInput   `json:"viewers,omitempty"`
	Reviews    *ReviewContentUpdateManyWithoutReviewContentPageInput             `json:"reviews,omitempty"`
	Owner      *UserUpdateOneRequiredInput                                       `json:"owner,omitempty"`
	FeedBacks  *ReviewContentPageFeedBackUpdateManyWithoutReviewContentPageInput `json:"feedBacks,omitempty"`
	ReleasedAt *string                                                           `json:"releasedAt,omitempty"`
	IsDrafts   *bool                                                             `json:"isDrafts,omitempty"`
	IsDel      *bool                                                             `json:"isDel,omitempty"`
}

type ReviewContentCategoryUpdateManyInput struct {
	Create     []ReviewContentCategoryCreateInput                      `json:"create,omitempty"`
	Update     []ReviewContentCategoryUpdateWithWhereUniqueNestedInput `json:"update,omitempty"`
	Upsert     []ReviewContentCategoryUpsertWithWhereUniqueNestedInput `json:"upsert,omitempty"`
	Delete     []ReviewContentCategoryWhereUniqueInput                 `json:"delete,omitempty"`
	Connect    []ReviewContentCategoryWhereUniqueInput                 `json:"connect,omitempty"`
	Set        []ReviewContentCategoryWhereUniqueInput                 `json:"set,omitempty"`
	Disconnect []ReviewContentCategoryWhereUniqueInput                 `json:"disconnect,omitempty"`
	DeleteMany []ReviewContentCategoryScalarWhereInput                 `json:"deleteMany,omitempty"`
	UpdateMany []ReviewContentCategoryUpdateManyWithWhereNestedInput   `json:"updateMany,omitempty"`
}

type ReviewContentCategoryUpdateWithWhereUniqueNestedInput struct {
	Where ReviewContentCategoryWhereUniqueInput `json:"where"`
	Data  ReviewContentCategoryUpdateDataInput  `json:"data"`
}

type ReviewContentCategoryUpdateDataInput struct {
	Name     *string `json:"name,omitempty"`
	ImageUrl *string `json:"imageUrl,omitempty"`
}

type ReviewContentCategoryUpsertWithWhereUniqueNestedInput struct {
	Where  ReviewContentCategoryWhereUniqueInput `json:"where"`
	Update ReviewContentCategoryUpdateDataInput  `json:"update"`
	Create ReviewContentCategoryCreateInput      `json:"create"`
}

type ReviewContentCategoryScalarWhereInput struct {
	ID                    *string                                 `json:"id,omitempty"`
	IDNot                 *string                                 `json:"id_not,omitempty"`
	IDIn                  []string                                `json:"id_in,omitempty"`
	IDNotIn               []string                                `json:"id_not_in,omitempty"`
	IDLt                  *string                                 `json:"id_lt,omitempty"`
	IDLte                 *string                                 `json:"id_lte,omitempty"`
	IDGt                  *string                                 `json:"id_gt,omitempty"`
	IDGte                 *string                                 `json:"id_gte,omitempty"`
	IDContains            *string                                 `json:"id_contains,omitempty"`
	IDNotContains         *string                                 `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                                 `json:"id_not_ends_with,omitempty"`
	Name                  *string                                 `json:"name,omitempty"`
	NameNot               *string                                 `json:"name_not,omitempty"`
	NameIn                []string                                `json:"name_in,omitempty"`
	NameNotIn             []string                                `json:"name_not_in,omitempty"`
	NameLt                *string                                 `json:"name_lt,omitempty"`
	NameLte               *string                                 `json:"name_lte,omitempty"`
	NameGt                *string                                 `json:"name_gt,omitempty"`
	NameGte               *string                                 `json:"name_gte,omitempty"`
	NameContains          *string                                 `json:"name_contains,omitempty"`
	NameNotContains       *string                                 `json:"name_not_contains,omitempty"`
	NameStartsWith        *string                                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith     *string                                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith          *string                                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith       *string                                 `json:"name_not_ends_with,omitempty"`
	ImageUrl              *string                                 `json:"imageUrl,omitempty"`
	ImageUrlNot           *string                                 `json:"imageUrl_not,omitempty"`
	ImageUrlIn            []string                                `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn         []string                                `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt            *string                                 `json:"imageUrl_lt,omitempty"`
	ImageUrlLte           *string                                 `json:"imageUrl_lte,omitempty"`
	ImageUrlGt            *string                                 `json:"imageUrl_gt,omitempty"`
	ImageUrlGte           *string                                 `json:"imageUrl_gte,omitempty"`
	ImageUrlContains      *string                                 `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains   *string                                 `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith    *string                                 `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith *string                                 `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith      *string                                 `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith   *string                                 `json:"imageUrl_not_ends_with,omitempty"`
	CreatedAt             *string                                 `json:"createdAt,omitempty"`
	CreatedAtNot          *string                                 `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                                 `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                                 `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                                 `json:"updatedAt_gte,omitempty"`
	And                   []ReviewContentCategoryScalarWhereInput `json:"AND,omitempty"`
	Or                    []ReviewContentCategoryScalarWhereInput `json:"OR,omitempty"`
	Not                   []ReviewContentCategoryScalarWhereInput `json:"NOT,omitempty"`
}

type ReviewContentCategoryUpdateManyWithWhereNestedInput struct {
	Where ReviewContentCategoryScalarWhereInput    `json:"where"`
	Data  ReviewContentCategoryUpdateManyDataInput `json:"data"`
}

type ReviewContentCategoryUpdateManyDataInput struct {
	Name     *string `json:"name,omitempty"`
	ImageUrl *string `json:"imageUrl,omitempty"`
}

type ReviewContentPageViewerUpdateManyWithoutReviewContentPageInput struct {
	Create     []ReviewContentPageViewerCreateWithoutReviewContentPageInput                `json:"create,omitempty"`
	Delete     []ReviewContentPageViewerWhereUniqueInput                                   `json:"delete,omitempty"`
	Connect    []ReviewContentPageViewerWhereUniqueInput                                   `json:"connect,omitempty"`
	Set        []ReviewContentPageViewerWhereUniqueInput                                   `json:"set,omitempty"`
	Disconnect []ReviewContentPageViewerWhereUniqueInput                                   `json:"disconnect,omitempty"`
	Update     []ReviewContentPageViewerUpdateWithWhereUniqueWithoutReviewContentPageInput `json:"update,omitempty"`
	Upsert     []ReviewContentPageViewerUpsertWithWhereUniqueWithoutReviewContentPageInput `json:"upsert,omitempty"`
	DeleteMany []ReviewContentPageViewerScalarWhereInput                                   `json:"deleteMany,omitempty"`
	UpdateMany []ReviewContentPageViewerUpdateManyWithWhereNestedInput                     `json:"updateMany,omitempty"`
}

type ReviewContentPageViewerUpdateWithWhereUniqueWithoutReviewContentPageInput struct {
	Where ReviewContentPageViewerWhereUniqueInput                        `json:"where"`
	Data  ReviewContentPageViewerUpdateWithoutReviewContentPageDataInput `json:"data"`
}

type ReviewContentPageViewerUpdateWithoutReviewContentPageDataInput struct {
	User *UserUpdateOneInput `json:"user,omitempty"`
	Ip   *string             `json:"ip,omitempty"`
}

type ReviewContentPageViewerUpsertWithWhereUniqueWithoutReviewContentPageInput struct {
	Where  ReviewContentPageViewerWhereUniqueInput                        `json:"where"`
	Update ReviewContentPageViewerUpdateWithoutReviewContentPageDataInput `json:"update"`
	Create ReviewContentPageViewerCreateWithoutReviewContentPageInput     `json:"create"`
}

type ReviewContentPageViewerScalarWhereInput struct {
	ID              *string                                   `json:"id,omitempty"`
	IDNot           *string                                   `json:"id_not,omitempty"`
	IDIn            []string                                  `json:"id_in,omitempty"`
	IDNotIn         []string                                  `json:"id_not_in,omitempty"`
	IDLt            *string                                   `json:"id_lt,omitempty"`
	IDLte           *string                                   `json:"id_lte,omitempty"`
	IDGt            *string                                   `json:"id_gt,omitempty"`
	IDGte           *string                                   `json:"id_gte,omitempty"`
	IDContains      *string                                   `json:"id_contains,omitempty"`
	IDNotContains   *string                                   `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                                   `json:"id_not_ends_with,omitempty"`
	Ip              *string                                   `json:"ip,omitempty"`
	IpNot           *string                                   `json:"ip_not,omitempty"`
	IpIn            []string                                  `json:"ip_in,omitempty"`
	IpNotIn         []string                                  `json:"ip_not_in,omitempty"`
	IpLt            *string                                   `json:"ip_lt,omitempty"`
	IpLte           *string                                   `json:"ip_lte,omitempty"`
	IpGt            *string                                   `json:"ip_gt,omitempty"`
	IpGte           *string                                   `json:"ip_gte,omitempty"`
	IpContains      *string                                   `json:"ip_contains,omitempty"`
	IpNotContains   *string                                   `json:"ip_not_contains,omitempty"`
	IpStartsWith    *string                                   `json:"ip_starts_with,omitempty"`
	IpNotStartsWith *string                                   `json:"ip_not_starts_with,omitempty"`
	IpEndsWith      *string                                   `json:"ip_ends_with,omitempty"`
	IpNotEndsWith   *string                                   `json:"ip_not_ends_with,omitempty"`
	CreatedAt       *string                                   `json:"createdAt,omitempty"`
	CreatedAtNot    *string                                   `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                                   `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                                   `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                                   `json:"updatedAt_gte,omitempty"`
	And             []ReviewContentPageViewerScalarWhereInput `json:"AND,omitempty"`
	Or              []ReviewContentPageViewerScalarWhereInput `json:"OR,omitempty"`
	Not             []ReviewContentPageViewerScalarWhereInput `json:"NOT,omitempty"`
}

type ReviewContentPageViewerUpdateManyWithWhereNestedInput struct {
	Where ReviewContentPageViewerScalarWhereInput    `json:"where"`
	Data  ReviewContentPageViewerUpdateManyDataInput `json:"data"`
}

type ReviewContentPageViewerUpdateManyDataInput struct {
	Ip *string `json:"ip,omitempty"`
}

type ReviewContentUpdateManyWithoutReviewContentPageInput struct {
	Create     []ReviewContentCreateWithoutReviewContentPageInput                `json:"create,omitempty"`
	Delete     []ReviewContentWhereUniqueInput                                   `json:"delete,omitempty"`
	Connect    []ReviewContentWhereUniqueInput                                   `json:"connect,omitempty"`
	Set        []ReviewContentWhereUniqueInput                                   `json:"set,omitempty"`
	Disconnect []ReviewContentWhereUniqueInput                                   `json:"disconnect,omitempty"`
	Update     []ReviewContentUpdateWithWhereUniqueWithoutReviewContentPageInput `json:"update,omitempty"`
	Upsert     []ReviewContentUpsertWithWhereUniqueWithoutReviewContentPageInput `json:"upsert,omitempty"`
	DeleteMany []ReviewContentScalarWhereInput                                   `json:"deleteMany,omitempty"`
	UpdateMany []ReviewContentUpdateManyWithWhereNestedInput                     `json:"updateMany,omitempty"`
}

type ReviewContentUpdateWithWhereUniqueWithoutReviewContentPageInput struct {
	Where ReviewContentWhereUniqueInput                        `json:"where"`
	Data  ReviewContentUpdateWithoutReviewContentPageDataInput `json:"data"`
}

type ReviewContentUpdateWithoutReviewContentPageDataInput struct {
	PreviewImageUrl *string                                                   `json:"previewImageUrl,omitempty"`
	Title           *string                                                   `json:"title,omitempty"`
	Type            *string                                                   `json:"type,omitempty"`
	Url             *string                                                   `json:"url,omitempty"`
	Review          *string                                                   `json:"review,omitempty"`
	VideoId         *string                                                   `json:"videoId,omitempty"`
	ContentId       *string                                                   `json:"contentId,omitempty"`
	Viewers         *ReviewContentViewerUpdateManyWithoutReviewContentInput   `json:"viewers,omitempty"`
	Reviewers       *ReviewContentReviewerUpdateManyWithoutReviewContentInput `json:"reviewers,omitempty"`
	RelatedPage     *PageUpdateOneRequiredWithoutRelatedReviewsInput          `json:"relatedPage,omitempty"`
	Owner           *UserUpdateOneRequiredInput                               `json:"owner,omitempty"`
}

type ReviewContentViewerUpdateManyWithoutReviewContentInput struct {
	Create     []ReviewContentViewerCreateWithoutReviewContentInput                `json:"create,omitempty"`
	Delete     []ReviewContentViewerWhereUniqueInput                               `json:"delete,omitempty"`
	Connect    []ReviewContentViewerWhereUniqueInput                               `json:"connect,omitempty"`
	Set        []ReviewContentViewerWhereUniqueInput                               `json:"set,omitempty"`
	Disconnect []ReviewContentViewerWhereUniqueInput                               `json:"disconnect,omitempty"`
	Update     []ReviewContentViewerUpdateWithWhereUniqueWithoutReviewContentInput `json:"update,omitempty"`
	Upsert     []ReviewContentViewerUpsertWithWhereUniqueWithoutReviewContentInput `json:"upsert,omitempty"`
	DeleteMany []ReviewContentViewerScalarWhereInput                               `json:"deleteMany,omitempty"`
	UpdateMany []ReviewContentViewerUpdateManyWithWhereNestedInput                 `json:"updateMany,omitempty"`
}

type ReviewContentViewerUpdateWithWhereUniqueWithoutReviewContentInput struct {
	Where ReviewContentViewerWhereUniqueInput                    `json:"where"`
	Data  ReviewContentViewerUpdateWithoutReviewContentDataInput `json:"data"`
}

type ReviewContentViewerUpdateWithoutReviewContentDataInput struct {
	User *UserUpdateOneInput `json:"user,omitempty"`
	Ip   *string             `json:"ip,omitempty"`
}

type ReviewContentViewerUpsertWithWhereUniqueWithoutReviewContentInput struct {
	Where  ReviewContentViewerWhereUniqueInput                    `json:"where"`
	Update ReviewContentViewerUpdateWithoutReviewContentDataInput `json:"update"`
	Create ReviewContentViewerCreateWithoutReviewContentInput     `json:"create"`
}

type ReviewContentViewerScalarWhereInput struct {
	ID              *string                               `json:"id,omitempty"`
	IDNot           *string                               `json:"id_not,omitempty"`
	IDIn            []string                              `json:"id_in,omitempty"`
	IDNotIn         []string                              `json:"id_not_in,omitempty"`
	IDLt            *string                               `json:"id_lt,omitempty"`
	IDLte           *string                               `json:"id_lte,omitempty"`
	IDGt            *string                               `json:"id_gt,omitempty"`
	IDGte           *string                               `json:"id_gte,omitempty"`
	IDContains      *string                               `json:"id_contains,omitempty"`
	IDNotContains   *string                               `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                               `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                               `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                               `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                               `json:"id_not_ends_with,omitempty"`
	Ip              *string                               `json:"ip,omitempty"`
	IpNot           *string                               `json:"ip_not,omitempty"`
	IpIn            []string                              `json:"ip_in,omitempty"`
	IpNotIn         []string                              `json:"ip_not_in,omitempty"`
	IpLt            *string                               `json:"ip_lt,omitempty"`
	IpLte           *string                               `json:"ip_lte,omitempty"`
	IpGt            *string                               `json:"ip_gt,omitempty"`
	IpGte           *string                               `json:"ip_gte,omitempty"`
	IpContains      *string                               `json:"ip_contains,omitempty"`
	IpNotContains   *string                               `json:"ip_not_contains,omitempty"`
	IpStartsWith    *string                               `json:"ip_starts_with,omitempty"`
	IpNotStartsWith *string                               `json:"ip_not_starts_with,omitempty"`
	IpEndsWith      *string                               `json:"ip_ends_with,omitempty"`
	IpNotEndsWith   *string                               `json:"ip_not_ends_with,omitempty"`
	CreatedAt       *string                               `json:"createdAt,omitempty"`
	CreatedAtNot    *string                               `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                              `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                              `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                               `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                               `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                               `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                               `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                               `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                               `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                              `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                              `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                               `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                               `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                               `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                               `json:"updatedAt_gte,omitempty"`
	And             []ReviewContentViewerScalarWhereInput `json:"AND,omitempty"`
	Or              []ReviewContentViewerScalarWhereInput `json:"OR,omitempty"`
	Not             []ReviewContentViewerScalarWhereInput `json:"NOT,omitempty"`
}

type ReviewContentViewerUpdateManyWithWhereNestedInput struct {
	Where ReviewContentViewerScalarWhereInput    `json:"where"`
	Data  ReviewContentViewerUpdateManyDataInput `json:"data"`
}

type ReviewContentViewerUpdateManyDataInput struct {
	Ip *string `json:"ip,omitempty"`
}

type ReviewContentReviewerUpdateManyWithoutReviewContentInput struct {
	Create     []ReviewContentReviewerCreateWithoutReviewContentInput                `json:"create,omitempty"`
	Delete     []ReviewContentReviewerWhereUniqueInput                               `json:"delete,omitempty"`
	Connect    []ReviewContentReviewerWhereUniqueInput                               `json:"connect,omitempty"`
	Set        []ReviewContentReviewerWhereUniqueInput                               `json:"set,omitempty"`
	Disconnect []ReviewContentReviewerWhereUniqueInput                               `json:"disconnect,omitempty"`
	Update     []ReviewContentReviewerUpdateWithWhereUniqueWithoutReviewContentInput `json:"update,omitempty"`
	Upsert     []ReviewContentReviewerUpsertWithWhereUniqueWithoutReviewContentInput `json:"upsert,omitempty"`
	DeleteMany []ReviewContentReviewerScalarWhereInput                               `json:"deleteMany,omitempty"`
	UpdateMany []ReviewContentReviewerUpdateManyWithWhereNestedInput                 `json:"updateMany,omitempty"`
}

type ReviewContentReviewerUpdateWithWhereUniqueWithoutReviewContentInput struct {
	Where ReviewContentReviewerWhereUniqueInput                    `json:"where"`
	Data  ReviewContentReviewerUpdateWithoutReviewContentDataInput `json:"data"`
}

type ReviewContentReviewerUpdateWithoutReviewContentDataInput struct {
	Review *string                     `json:"review,omitempty"`
	Owner  *UserUpdateOneRequiredInput `json:"owner,omitempty"`
}

type ReviewContentReviewerUpsertWithWhereUniqueWithoutReviewContentInput struct {
	Where  ReviewContentReviewerWhereUniqueInput                    `json:"where"`
	Update ReviewContentReviewerUpdateWithoutReviewContentDataInput `json:"update"`
	Create ReviewContentReviewerCreateWithoutReviewContentInput     `json:"create"`
}

type ReviewContentReviewerScalarWhereInput struct {
	ID                  *string                                 `json:"id,omitempty"`
	IDNot               *string                                 `json:"id_not,omitempty"`
	IDIn                []string                                `json:"id_in,omitempty"`
	IDNotIn             []string                                `json:"id_not_in,omitempty"`
	IDLt                *string                                 `json:"id_lt,omitempty"`
	IDLte               *string                                 `json:"id_lte,omitempty"`
	IDGt                *string                                 `json:"id_gt,omitempty"`
	IDGte               *string                                 `json:"id_gte,omitempty"`
	IDContains          *string                                 `json:"id_contains,omitempty"`
	IDNotContains       *string                                 `json:"id_not_contains,omitempty"`
	IDStartsWith        *string                                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith     *string                                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith          *string                                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith       *string                                 `json:"id_not_ends_with,omitempty"`
	Review              *string                                 `json:"review,omitempty"`
	ReviewNot           *string                                 `json:"review_not,omitempty"`
	ReviewIn            []string                                `json:"review_in,omitempty"`
	ReviewNotIn         []string                                `json:"review_not_in,omitempty"`
	ReviewLt            *string                                 `json:"review_lt,omitempty"`
	ReviewLte           *string                                 `json:"review_lte,omitempty"`
	ReviewGt            *string                                 `json:"review_gt,omitempty"`
	ReviewGte           *string                                 `json:"review_gte,omitempty"`
	ReviewContains      *string                                 `json:"review_contains,omitempty"`
	ReviewNotContains   *string                                 `json:"review_not_contains,omitempty"`
	ReviewStartsWith    *string                                 `json:"review_starts_with,omitempty"`
	ReviewNotStartsWith *string                                 `json:"review_not_starts_with,omitempty"`
	ReviewEndsWith      *string                                 `json:"review_ends_with,omitempty"`
	ReviewNotEndsWith   *string                                 `json:"review_not_ends_with,omitempty"`
	CreatedAt           *string                                 `json:"createdAt,omitempty"`
	CreatedAtNot        *string                                 `json:"createdAt_not,omitempty"`
	CreatedAtIn         []string                                `json:"createdAt_in,omitempty"`
	CreatedAtNotIn      []string                                `json:"createdAt_not_in,omitempty"`
	CreatedAtLt         *string                                 `json:"createdAt_lt,omitempty"`
	CreatedAtLte        *string                                 `json:"createdAt_lte,omitempty"`
	CreatedAtGt         *string                                 `json:"createdAt_gt,omitempty"`
	CreatedAtGte        *string                                 `json:"createdAt_gte,omitempty"`
	UpdatedAt           *string                                 `json:"updatedAt,omitempty"`
	UpdatedAtNot        *string                                 `json:"updatedAt_not,omitempty"`
	UpdatedAtIn         []string                                `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn      []string                                `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt         *string                                 `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte        *string                                 `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt         *string                                 `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte        *string                                 `json:"updatedAt_gte,omitempty"`
	And                 []ReviewContentReviewerScalarWhereInput `json:"AND,omitempty"`
	Or                  []ReviewContentReviewerScalarWhereInput `json:"OR,omitempty"`
	Not                 []ReviewContentReviewerScalarWhereInput `json:"NOT,omitempty"`
}

type ReviewContentReviewerUpdateManyWithWhereNestedInput struct {
	Where ReviewContentReviewerScalarWhereInput    `json:"where"`
	Data  ReviewContentReviewerUpdateManyDataInput `json:"data"`
}

type ReviewContentReviewerUpdateManyDataInput struct {
	Review *string `json:"review,omitempty"`
}

type PageUpdateOneRequiredWithoutRelatedReviewsInput struct {
	Create  *PageCreateWithoutRelatedReviewsInput     `json:"create,omitempty"`
	Update  *PageUpdateWithoutRelatedReviewsDataInput `json:"update,omitempty"`
	Upsert  *PageUpsertWithoutRelatedReviewsInput     `json:"upsert,omitempty"`
	Connect *PageWhereUniqueInput                     `json:"connect,omitempty"`
}

type PageUpdateWithoutRelatedReviewsDataInput struct {
	PageId           *string                                      `json:"pageId,omitempty"`
	NickName         *string                                      `json:"nickName,omitempty"`
	AvatarUrl        *string                                      `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                      `json:"coverUrl,omitempty"`
	Description      *string                                      `json:"description,omitempty"`
	Badges           *PageBadgeUpdateManyWithoutPageInput         `json:"badges,omitempty"`
	Youtube          *YoutubeUpdateOneWithoutPageInput            `json:"youtube,omitempty"`
	Twitch           *TwitchUpdateOneWithoutPageInput             `json:"twitch,omitempty"`
	Instagram        *InstagramUpdateOneWithoutPageInput          `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvUpdateOneWithoutPageInput          `json:"afreecaTV,omitempty"`
	Fans             *PageFanUpdateManyInput                      `json:"fans,omitempty"`
	Owner            *UserUpdateOneWithoutPageInput               `json:"owner,omitempty"`
	Comments         *PageCommentUpdateManyWithoutPageInput       `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemUpdateManyWithoutPageInput   `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageUpdateManyWithoutPageInput `json:"reviews,omitempty"`
}

type RequestPageItemUpdateManyWithoutPageInput struct {
	Create     []RequestPageItemCreateWithoutPageInput                `json:"create,omitempty"`
	Delete     []RequestPageItemWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []RequestPageItemWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []RequestPageItemWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []RequestPageItemWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []RequestPageItemUpdateWithWhereUniqueWithoutPageInput `json:"update,omitempty"`
	Upsert     []RequestPageItemUpsertWithWhereUniqueWithoutPageInput `json:"upsert,omitempty"`
	DeleteMany []RequestPageItemScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []RequestPageItemUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type RequestPageItemUpdateWithWhereUniqueWithoutPageInput struct {
	Where RequestPageItemWhereUniqueInput           `json:"where"`
	Data  RequestPageItemUpdateWithoutPageDataInput `json:"data"`
}

type RequestPageItemUpdateWithoutPageDataInput struct {
	Type      *int32              `json:"type,omitempty"`
	Note      *string             `json:"note,omitempty"`
	IpAddress *string             `json:"ipAddress,omitempty"`
	Owner     *UserUpdateOneInput `json:"owner,omitempty"`
}

type RequestPageItemUpsertWithWhereUniqueWithoutPageInput struct {
	Where  RequestPageItemWhereUniqueInput           `json:"where"`
	Update RequestPageItemUpdateWithoutPageDataInput `json:"update"`
	Create RequestPageItemCreateWithoutPageInput     `json:"create"`
}

type RequestPageItemScalarWhereInput struct {
	ID                     *string                           `json:"id,omitempty"`
	IDNot                  *string                           `json:"id_not,omitempty"`
	IDIn                   []string                          `json:"id_in,omitempty"`
	IDNotIn                []string                          `json:"id_not_in,omitempty"`
	IDLt                   *string                           `json:"id_lt,omitempty"`
	IDLte                  *string                           `json:"id_lte,omitempty"`
	IDGt                   *string                           `json:"id_gt,omitempty"`
	IDGte                  *string                           `json:"id_gte,omitempty"`
	IDContains             *string                           `json:"id_contains,omitempty"`
	IDNotContains          *string                           `json:"id_not_contains,omitempty"`
	IDStartsWith           *string                           `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string                           `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string                           `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string                           `json:"id_not_ends_with,omitempty"`
	Type                   *int32                            `json:"type,omitempty"`
	TypeNot                *int32                            `json:"type_not,omitempty"`
	TypeIn                 []int32                           `json:"type_in,omitempty"`
	TypeNotIn              []int32                           `json:"type_not_in,omitempty"`
	TypeLt                 *int32                            `json:"type_lt,omitempty"`
	TypeLte                *int32                            `json:"type_lte,omitempty"`
	TypeGt                 *int32                            `json:"type_gt,omitempty"`
	TypeGte                *int32                            `json:"type_gte,omitempty"`
	Note                   *string                           `json:"note,omitempty"`
	NoteNot                *string                           `json:"note_not,omitempty"`
	NoteIn                 []string                          `json:"note_in,omitempty"`
	NoteNotIn              []string                          `json:"note_not_in,omitempty"`
	NoteLt                 *string                           `json:"note_lt,omitempty"`
	NoteLte                *string                           `json:"note_lte,omitempty"`
	NoteGt                 *string                           `json:"note_gt,omitempty"`
	NoteGte                *string                           `json:"note_gte,omitempty"`
	NoteContains           *string                           `json:"note_contains,omitempty"`
	NoteNotContains        *string                           `json:"note_not_contains,omitempty"`
	NoteStartsWith         *string                           `json:"note_starts_with,omitempty"`
	NoteNotStartsWith      *string                           `json:"note_not_starts_with,omitempty"`
	NoteEndsWith           *string                           `json:"note_ends_with,omitempty"`
	NoteNotEndsWith        *string                           `json:"note_not_ends_with,omitempty"`
	IpAddress              *string                           `json:"ipAddress,omitempty"`
	IpAddressNot           *string                           `json:"ipAddress_not,omitempty"`
	IpAddressIn            []string                          `json:"ipAddress_in,omitempty"`
	IpAddressNotIn         []string                          `json:"ipAddress_not_in,omitempty"`
	IpAddressLt            *string                           `json:"ipAddress_lt,omitempty"`
	IpAddressLte           *string                           `json:"ipAddress_lte,omitempty"`
	IpAddressGt            *string                           `json:"ipAddress_gt,omitempty"`
	IpAddressGte           *string                           `json:"ipAddress_gte,omitempty"`
	IpAddressContains      *string                           `json:"ipAddress_contains,omitempty"`
	IpAddressNotContains   *string                           `json:"ipAddress_not_contains,omitempty"`
	IpAddressStartsWith    *string                           `json:"ipAddress_starts_with,omitempty"`
	IpAddressNotStartsWith *string                           `json:"ipAddress_not_starts_with,omitempty"`
	IpAddressEndsWith      *string                           `json:"ipAddress_ends_with,omitempty"`
	IpAddressNotEndsWith   *string                           `json:"ipAddress_not_ends_with,omitempty"`
	CreatedAt              *string                           `json:"createdAt,omitempty"`
	CreatedAtNot           *string                           `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string                          `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string                          `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                           `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                           `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                           `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                           `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                           `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                           `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string                          `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string                          `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                           `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                           `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                           `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                           `json:"updatedAt_gte,omitempty"`
	And                    []RequestPageItemScalarWhereInput `json:"AND,omitempty"`
	Or                     []RequestPageItemScalarWhereInput `json:"OR,omitempty"`
	Not                    []RequestPageItemScalarWhereInput `json:"NOT,omitempty"`
}

type RequestPageItemUpdateManyWithWhereNestedInput struct {
	Where RequestPageItemScalarWhereInput    `json:"where"`
	Data  RequestPageItemUpdateManyDataInput `json:"data"`
}

type RequestPageItemUpdateManyDataInput struct {
	Type      *int32  `json:"type,omitempty"`
	Note      *string `json:"note,omitempty"`
	IpAddress *string `json:"ipAddress,omitempty"`
}

type ReviewContentPageUpdateManyWithoutPageInput struct {
	Create     []ReviewContentPageCreateWithoutPageInput                `json:"create,omitempty"`
	Delete     []ReviewContentPageWhereUniqueInput                      `json:"delete,omitempty"`
	Connect    []ReviewContentPageWhereUniqueInput                      `json:"connect,omitempty"`
	Set        []ReviewContentPageWhereUniqueInput                      `json:"set,omitempty"`
	Disconnect []ReviewContentPageWhereUniqueInput                      `json:"disconnect,omitempty"`
	Update     []ReviewContentPageUpdateWithWhereUniqueWithoutPageInput `json:"update,omitempty"`
	Upsert     []ReviewContentPageUpsertWithWhereUniqueWithoutPageInput `json:"upsert,omitempty"`
	DeleteMany []ReviewContentPageScalarWhereInput                      `json:"deleteMany,omitempty"`
	UpdateMany []ReviewContentPageUpdateManyWithWhereNestedInput        `json:"updateMany,omitempty"`
}

type ReviewContentPageUpdateWithWhereUniqueWithoutPageInput struct {
	Where ReviewContentPageWhereUniqueInput           `json:"where"`
	Data  ReviewContentPageUpdateWithoutPageDataInput `json:"data"`
}

type ReviewContentPageUpdateWithoutPageDataInput struct {
	Categories *ReviewContentCategoryUpdateManyInput                             `json:"categories,omitempty"`
	Title      *string                                                           `json:"title,omitempty"`
	SubTitle   *string                                                           `json:"subTitle,omitempty"`
	Message    *string                                                           `json:"message,omitempty"`
	Viewers    *ReviewContentPageViewerUpdateManyWithoutReviewContentPageInput   `json:"viewers,omitempty"`
	Reviews    *ReviewContentUpdateManyWithoutReviewContentPageInput             `json:"reviews,omitempty"`
	Comments   *PageCommentUpdateManyWithoutRelatedReviewContentPageInput        `json:"comments,omitempty"`
	Owner      *UserUpdateOneRequiredInput                                       `json:"owner,omitempty"`
	FeedBacks  *ReviewContentPageFeedBackUpdateManyWithoutReviewContentPageInput `json:"feedBacks,omitempty"`
	ReleasedAt *string                                                           `json:"releasedAt,omitempty"`
	IsDrafts   *bool                                                             `json:"isDrafts,omitempty"`
	IsDel      *bool                                                             `json:"isDel,omitempty"`
}

type PageCommentUpdateManyWithoutRelatedReviewContentPageInput struct {
	Create     []PageCommentCreateWithoutRelatedReviewContentPageInput                `json:"create,omitempty"`
	Delete     []PageCommentWhereUniqueInput                                          `json:"delete,omitempty"`
	Connect    []PageCommentWhereUniqueInput                                          `json:"connect,omitempty"`
	Set        []PageCommentWhereUniqueInput                                          `json:"set,omitempty"`
	Disconnect []PageCommentWhereUniqueInput                                          `json:"disconnect,omitempty"`
	Update     []PageCommentUpdateWithWhereUniqueWithoutRelatedReviewContentPageInput `json:"update,omitempty"`
	Upsert     []PageCommentUpsertWithWhereUniqueWithoutRelatedReviewContentPageInput `json:"upsert,omitempty"`
	DeleteMany []PageCommentScalarWhereInput                                          `json:"deleteMany,omitempty"`
	UpdateMany []PageCommentUpdateManyWithWhereNestedInput                            `json:"updateMany,omitempty"`
}

type PageCommentUpdateWithWhereUniqueWithoutRelatedReviewContentPageInput struct {
	Where PageCommentWhereUniqueInput                               `json:"where"`
	Data  PageCommentUpdateWithoutRelatedReviewContentPageDataInput `json:"data"`
}

type PageCommentUpdateWithoutRelatedReviewContentPageDataInput struct {
	Page              *PageUpdateOneRequiredWithoutCommentsInput         `json:"page,omitempty"`
	Content           *string                                            `json:"content,omitempty"`
	Comments          *PageCommentReplyUpdateManyWithoutPageCommentInput `json:"comments,omitempty"`
	IpAddress         *string                                            `json:"ipAddress,omitempty"`
	ImageUrl          *string                                            `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string                                            `json:"thumbnailImageUrl,omitempty"`
	Owner             *UserUpdateOneInput                                `json:"owner,omitempty"`
	IsDel             *bool                                              `json:"isDel,omitempty"`
}

type PageUpdateOneRequiredWithoutCommentsInput struct {
	Create  *PageCreateWithoutCommentsInput     `json:"create,omitempty"`
	Update  *PageUpdateWithoutCommentsDataInput `json:"update,omitempty"`
	Upsert  *PageUpsertWithoutCommentsInput     `json:"upsert,omitempty"`
	Connect *PageWhereUniqueInput               `json:"connect,omitempty"`
}

type PageUpdateWithoutCommentsDataInput struct {
	PageId           *string                                         `json:"pageId,omitempty"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeUpdateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeUpdateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchUpdateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramUpdateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvUpdateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanUpdateManyInput                         `json:"fans,omitempty"`
	Owner            *UserUpdateOneWithoutPageInput                  `json:"owner,omitempty"`
	RequestPageItems *RequestPageItemUpdateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageUpdateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentUpdateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type ReviewContentUpdateManyWithoutRelatedPageInput struct {
	Create     []ReviewContentCreateWithoutRelatedPageInput                `json:"create,omitempty"`
	Delete     []ReviewContentWhereUniqueInput                             `json:"delete,omitempty"`
	Connect    []ReviewContentWhereUniqueInput                             `json:"connect,omitempty"`
	Set        []ReviewContentWhereUniqueInput                             `json:"set,omitempty"`
	Disconnect []ReviewContentWhereUniqueInput                             `json:"disconnect,omitempty"`
	Update     []ReviewContentUpdateWithWhereUniqueWithoutRelatedPageInput `json:"update,omitempty"`
	Upsert     []ReviewContentUpsertWithWhereUniqueWithoutRelatedPageInput `json:"upsert,omitempty"`
	DeleteMany []ReviewContentScalarWhereInput                             `json:"deleteMany,omitempty"`
	UpdateMany []ReviewContentUpdateManyWithWhereNestedInput               `json:"updateMany,omitempty"`
}

type ReviewContentUpdateWithWhereUniqueWithoutRelatedPageInput struct {
	Where ReviewContentWhereUniqueInput                  `json:"where"`
	Data  ReviewContentUpdateWithoutRelatedPageDataInput `json:"data"`
}

type ReviewContentUpdateWithoutRelatedPageDataInput struct {
	ReviewContentPage *ReviewContentPageUpdateOneWithoutReviewsInput            `json:"reviewContentPage,omitempty"`
	PreviewImageUrl   *string                                                   `json:"previewImageUrl,omitempty"`
	Title             *string                                                   `json:"title,omitempty"`
	Type              *string                                                   `json:"type,omitempty"`
	Url               *string                                                   `json:"url,omitempty"`
	Review            *string                                                   `json:"review,omitempty"`
	VideoId           *string                                                   `json:"videoId,omitempty"`
	ContentId         *string                                                   `json:"contentId,omitempty"`
	Viewers           *ReviewContentViewerUpdateManyWithoutReviewContentInput   `json:"viewers,omitempty"`
	Reviewers         *ReviewContentReviewerUpdateManyWithoutReviewContentInput `json:"reviewers,omitempty"`
	Owner             *UserUpdateOneRequiredInput                               `json:"owner,omitempty"`
}

type ReviewContentUpsertWithWhereUniqueWithoutRelatedPageInput struct {
	Where  ReviewContentWhereUniqueInput                  `json:"where"`
	Update ReviewContentUpdateWithoutRelatedPageDataInput `json:"update"`
	Create ReviewContentCreateWithoutRelatedPageInput     `json:"create"`
}

type ReviewContentScalarWhereInput struct {
	ID                           *string                         `json:"id,omitempty"`
	IDNot                        *string                         `json:"id_not,omitempty"`
	IDIn                         []string                        `json:"id_in,omitempty"`
	IDNotIn                      []string                        `json:"id_not_in,omitempty"`
	IDLt                         *string                         `json:"id_lt,omitempty"`
	IDLte                        *string                         `json:"id_lte,omitempty"`
	IDGt                         *string                         `json:"id_gt,omitempty"`
	IDGte                        *string                         `json:"id_gte,omitempty"`
	IDContains                   *string                         `json:"id_contains,omitempty"`
	IDNotContains                *string                         `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                         `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                         `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                         `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                         `json:"id_not_ends_with,omitempty"`
	PreviewImageUrl              *string                         `json:"previewImageUrl,omitempty"`
	PreviewImageUrlNot           *string                         `json:"previewImageUrl_not,omitempty"`
	PreviewImageUrlIn            []string                        `json:"previewImageUrl_in,omitempty"`
	PreviewImageUrlNotIn         []string                        `json:"previewImageUrl_not_in,omitempty"`
	PreviewImageUrlLt            *string                         `json:"previewImageUrl_lt,omitempty"`
	PreviewImageUrlLte           *string                         `json:"previewImageUrl_lte,omitempty"`
	PreviewImageUrlGt            *string                         `json:"previewImageUrl_gt,omitempty"`
	PreviewImageUrlGte           *string                         `json:"previewImageUrl_gte,omitempty"`
	PreviewImageUrlContains      *string                         `json:"previewImageUrl_contains,omitempty"`
	PreviewImageUrlNotContains   *string                         `json:"previewImageUrl_not_contains,omitempty"`
	PreviewImageUrlStartsWith    *string                         `json:"previewImageUrl_starts_with,omitempty"`
	PreviewImageUrlNotStartsWith *string                         `json:"previewImageUrl_not_starts_with,omitempty"`
	PreviewImageUrlEndsWith      *string                         `json:"previewImageUrl_ends_with,omitempty"`
	PreviewImageUrlNotEndsWith   *string                         `json:"previewImageUrl_not_ends_with,omitempty"`
	Title                        *string                         `json:"title,omitempty"`
	TitleNot                     *string                         `json:"title_not,omitempty"`
	TitleIn                      []string                        `json:"title_in,omitempty"`
	TitleNotIn                   []string                        `json:"title_not_in,omitempty"`
	TitleLt                      *string                         `json:"title_lt,omitempty"`
	TitleLte                     *string                         `json:"title_lte,omitempty"`
	TitleGt                      *string                         `json:"title_gt,omitempty"`
	TitleGte                     *string                         `json:"title_gte,omitempty"`
	TitleContains                *string                         `json:"title_contains,omitempty"`
	TitleNotContains             *string                         `json:"title_not_contains,omitempty"`
	TitleStartsWith              *string                         `json:"title_starts_with,omitempty"`
	TitleNotStartsWith           *string                         `json:"title_not_starts_with,omitempty"`
	TitleEndsWith                *string                         `json:"title_ends_with,omitempty"`
	TitleNotEndsWith             *string                         `json:"title_not_ends_with,omitempty"`
	Type                         *string                         `json:"type,omitempty"`
	TypeNot                      *string                         `json:"type_not,omitempty"`
	TypeIn                       []string                        `json:"type_in,omitempty"`
	TypeNotIn                    []string                        `json:"type_not_in,omitempty"`
	TypeLt                       *string                         `json:"type_lt,omitempty"`
	TypeLte                      *string                         `json:"type_lte,omitempty"`
	TypeGt                       *string                         `json:"type_gt,omitempty"`
	TypeGte                      *string                         `json:"type_gte,omitempty"`
	TypeContains                 *string                         `json:"type_contains,omitempty"`
	TypeNotContains              *string                         `json:"type_not_contains,omitempty"`
	TypeStartsWith               *string                         `json:"type_starts_with,omitempty"`
	TypeNotStartsWith            *string                         `json:"type_not_starts_with,omitempty"`
	TypeEndsWith                 *string                         `json:"type_ends_with,omitempty"`
	TypeNotEndsWith              *string                         `json:"type_not_ends_with,omitempty"`
	Url                          *string                         `json:"url,omitempty"`
	UrlNot                       *string                         `json:"url_not,omitempty"`
	UrlIn                        []string                        `json:"url_in,omitempty"`
	UrlNotIn                     []string                        `json:"url_not_in,omitempty"`
	UrlLt                        *string                         `json:"url_lt,omitempty"`
	UrlLte                       *string                         `json:"url_lte,omitempty"`
	UrlGt                        *string                         `json:"url_gt,omitempty"`
	UrlGte                       *string                         `json:"url_gte,omitempty"`
	UrlContains                  *string                         `json:"url_contains,omitempty"`
	UrlNotContains               *string                         `json:"url_not_contains,omitempty"`
	UrlStartsWith                *string                         `json:"url_starts_with,omitempty"`
	UrlNotStartsWith             *string                         `json:"url_not_starts_with,omitempty"`
	UrlEndsWith                  *string                         `json:"url_ends_with,omitempty"`
	UrlNotEndsWith               *string                         `json:"url_not_ends_with,omitempty"`
	Review                       *string                         `json:"review,omitempty"`
	ReviewNot                    *string                         `json:"review_not,omitempty"`
	ReviewIn                     []string                        `json:"review_in,omitempty"`
	ReviewNotIn                  []string                        `json:"review_not_in,omitempty"`
	ReviewLt                     *string                         `json:"review_lt,omitempty"`
	ReviewLte                    *string                         `json:"review_lte,omitempty"`
	ReviewGt                     *string                         `json:"review_gt,omitempty"`
	ReviewGte                    *string                         `json:"review_gte,omitempty"`
	ReviewContains               *string                         `json:"review_contains,omitempty"`
	ReviewNotContains            *string                         `json:"review_not_contains,omitempty"`
	ReviewStartsWith             *string                         `json:"review_starts_with,omitempty"`
	ReviewNotStartsWith          *string                         `json:"review_not_starts_with,omitempty"`
	ReviewEndsWith               *string                         `json:"review_ends_with,omitempty"`
	ReviewNotEndsWith            *string                         `json:"review_not_ends_with,omitempty"`
	VideoId                      *string                         `json:"videoId,omitempty"`
	VideoIdNot                   *string                         `json:"videoId_not,omitempty"`
	VideoIdIn                    []string                        `json:"videoId_in,omitempty"`
	VideoIdNotIn                 []string                        `json:"videoId_not_in,omitempty"`
	VideoIdLt                    *string                         `json:"videoId_lt,omitempty"`
	VideoIdLte                   *string                         `json:"videoId_lte,omitempty"`
	VideoIdGt                    *string                         `json:"videoId_gt,omitempty"`
	VideoIdGte                   *string                         `json:"videoId_gte,omitempty"`
	VideoIdContains              *string                         `json:"videoId_contains,omitempty"`
	VideoIdNotContains           *string                         `json:"videoId_not_contains,omitempty"`
	VideoIdStartsWith            *string                         `json:"videoId_starts_with,omitempty"`
	VideoIdNotStartsWith         *string                         `json:"videoId_not_starts_with,omitempty"`
	VideoIdEndsWith              *string                         `json:"videoId_ends_with,omitempty"`
	VideoIdNotEndsWith           *string                         `json:"videoId_not_ends_with,omitempty"`
	ContentId                    *string                         `json:"contentId,omitempty"`
	ContentIdNot                 *string                         `json:"contentId_not,omitempty"`
	ContentIdIn                  []string                        `json:"contentId_in,omitempty"`
	ContentIdNotIn               []string                        `json:"contentId_not_in,omitempty"`
	ContentIdLt                  *string                         `json:"contentId_lt,omitempty"`
	ContentIdLte                 *string                         `json:"contentId_lte,omitempty"`
	ContentIdGt                  *string                         `json:"contentId_gt,omitempty"`
	ContentIdGte                 *string                         `json:"contentId_gte,omitempty"`
	ContentIdContains            *string                         `json:"contentId_contains,omitempty"`
	ContentIdNotContains         *string                         `json:"contentId_not_contains,omitempty"`
	ContentIdStartsWith          *string                         `json:"contentId_starts_with,omitempty"`
	ContentIdNotStartsWith       *string                         `json:"contentId_not_starts_with,omitempty"`
	ContentIdEndsWith            *string                         `json:"contentId_ends_with,omitempty"`
	ContentIdNotEndsWith         *string                         `json:"contentId_not_ends_with,omitempty"`
	CreatedAt                    *string                         `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                         `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string                        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string                        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                         `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                         `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                         `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                         `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                         `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string                        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string                        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                         `json:"updatedAt_gte,omitempty"`
	And                          []ReviewContentScalarWhereInput `json:"AND,omitempty"`
	Or                           []ReviewContentScalarWhereInput `json:"OR,omitempty"`
	Not                          []ReviewContentScalarWhereInput `json:"NOT,omitempty"`
}

type ReviewContentUpdateManyWithWhereNestedInput struct {
	Where ReviewContentScalarWhereInput    `json:"where"`
	Data  ReviewContentUpdateManyDataInput `json:"data"`
}

type ReviewContentUpdateManyDataInput struct {
	PreviewImageUrl *string `json:"previewImageUrl,omitempty"`
	Title           *string `json:"title,omitempty"`
	Type            *string `json:"type,omitempty"`
	Url             *string `json:"url,omitempty"`
	Review          *string `json:"review,omitempty"`
	VideoId         *string `json:"videoId,omitempty"`
	ContentId       *string `json:"contentId,omitempty"`
}

type PageUpsertWithoutCommentsInput struct {
	Update PageUpdateWithoutCommentsDataInput `json:"update"`
	Create PageCreateWithoutCommentsInput     `json:"create"`
}

type PageCommentUpsertWithWhereUniqueWithoutRelatedReviewContentPageInput struct {
	Where  PageCommentWhereUniqueInput                               `json:"where"`
	Update PageCommentUpdateWithoutRelatedReviewContentPageDataInput `json:"update"`
	Create PageCommentCreateWithoutRelatedReviewContentPageInput     `json:"create"`
}

type PageCommentScalarWhereInput struct {
	ID                             *string                       `json:"id,omitempty"`
	IDNot                          *string                       `json:"id_not,omitempty"`
	IDIn                           []string                      `json:"id_in,omitempty"`
	IDNotIn                        []string                      `json:"id_not_in,omitempty"`
	IDLt                           *string                       `json:"id_lt,omitempty"`
	IDLte                          *string                       `json:"id_lte,omitempty"`
	IDGt                           *string                       `json:"id_gt,omitempty"`
	IDGte                          *string                       `json:"id_gte,omitempty"`
	IDContains                     *string                       `json:"id_contains,omitempty"`
	IDNotContains                  *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith                   *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith                *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith                     *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith                  *string                       `json:"id_not_ends_with,omitempty"`
	Content                        *string                       `json:"content,omitempty"`
	ContentNot                     *string                       `json:"content_not,omitempty"`
	ContentIn                      []string                      `json:"content_in,omitempty"`
	ContentNotIn                   []string                      `json:"content_not_in,omitempty"`
	ContentLt                      *string                       `json:"content_lt,omitempty"`
	ContentLte                     *string                       `json:"content_lte,omitempty"`
	ContentGt                      *string                       `json:"content_gt,omitempty"`
	ContentGte                     *string                       `json:"content_gte,omitempty"`
	ContentContains                *string                       `json:"content_contains,omitempty"`
	ContentNotContains             *string                       `json:"content_not_contains,omitempty"`
	ContentStartsWith              *string                       `json:"content_starts_with,omitempty"`
	ContentNotStartsWith           *string                       `json:"content_not_starts_with,omitempty"`
	ContentEndsWith                *string                       `json:"content_ends_with,omitempty"`
	ContentNotEndsWith             *string                       `json:"content_not_ends_with,omitempty"`
	IpAddress                      *string                       `json:"ipAddress,omitempty"`
	IpAddressNot                   *string                       `json:"ipAddress_not,omitempty"`
	IpAddressIn                    []string                      `json:"ipAddress_in,omitempty"`
	IpAddressNotIn                 []string                      `json:"ipAddress_not_in,omitempty"`
	IpAddressLt                    *string                       `json:"ipAddress_lt,omitempty"`
	IpAddressLte                   *string                       `json:"ipAddress_lte,omitempty"`
	IpAddressGt                    *string                       `json:"ipAddress_gt,omitempty"`
	IpAddressGte                   *string                       `json:"ipAddress_gte,omitempty"`
	IpAddressContains              *string                       `json:"ipAddress_contains,omitempty"`
	IpAddressNotContains           *string                       `json:"ipAddress_not_contains,omitempty"`
	IpAddressStartsWith            *string                       `json:"ipAddress_starts_with,omitempty"`
	IpAddressNotStartsWith         *string                       `json:"ipAddress_not_starts_with,omitempty"`
	IpAddressEndsWith              *string                       `json:"ipAddress_ends_with,omitempty"`
	IpAddressNotEndsWith           *string                       `json:"ipAddress_not_ends_with,omitempty"`
	ImageUrl                       *string                       `json:"imageUrl,omitempty"`
	ImageUrlNot                    *string                       `json:"imageUrl_not,omitempty"`
	ImageUrlIn                     []string                      `json:"imageUrl_in,omitempty"`
	ImageUrlNotIn                  []string                      `json:"imageUrl_not_in,omitempty"`
	ImageUrlLt                     *string                       `json:"imageUrl_lt,omitempty"`
	ImageUrlLte                    *string                       `json:"imageUrl_lte,omitempty"`
	ImageUrlGt                     *string                       `json:"imageUrl_gt,omitempty"`
	ImageUrlGte                    *string                       `json:"imageUrl_gte,omitempty"`
	ImageUrlContains               *string                       `json:"imageUrl_contains,omitempty"`
	ImageUrlNotContains            *string                       `json:"imageUrl_not_contains,omitempty"`
	ImageUrlStartsWith             *string                       `json:"imageUrl_starts_with,omitempty"`
	ImageUrlNotStartsWith          *string                       `json:"imageUrl_not_starts_with,omitempty"`
	ImageUrlEndsWith               *string                       `json:"imageUrl_ends_with,omitempty"`
	ImageUrlNotEndsWith            *string                       `json:"imageUrl_not_ends_with,omitempty"`
	ThumbnailImageUrl              *string                       `json:"thumbnailImageUrl,omitempty"`
	ThumbnailImageUrlNot           *string                       `json:"thumbnailImageUrl_not,omitempty"`
	ThumbnailImageUrlIn            []string                      `json:"thumbnailImageUrl_in,omitempty"`
	ThumbnailImageUrlNotIn         []string                      `json:"thumbnailImageUrl_not_in,omitempty"`
	ThumbnailImageUrlLt            *string                       `json:"thumbnailImageUrl_lt,omitempty"`
	ThumbnailImageUrlLte           *string                       `json:"thumbnailImageUrl_lte,omitempty"`
	ThumbnailImageUrlGt            *string                       `json:"thumbnailImageUrl_gt,omitempty"`
	ThumbnailImageUrlGte           *string                       `json:"thumbnailImageUrl_gte,omitempty"`
	ThumbnailImageUrlContains      *string                       `json:"thumbnailImageUrl_contains,omitempty"`
	ThumbnailImageUrlNotContains   *string                       `json:"thumbnailImageUrl_not_contains,omitempty"`
	ThumbnailImageUrlStartsWith    *string                       `json:"thumbnailImageUrl_starts_with,omitempty"`
	ThumbnailImageUrlNotStartsWith *string                       `json:"thumbnailImageUrl_not_starts_with,omitempty"`
	ThumbnailImageUrlEndsWith      *string                       `json:"thumbnailImageUrl_ends_with,omitempty"`
	ThumbnailImageUrlNotEndsWith   *string                       `json:"thumbnailImageUrl_not_ends_with,omitempty"`
	CreatedAt                      *string                       `json:"createdAt,omitempty"`
	CreatedAtNot                   *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn                    []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                 []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                    *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte                   *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt                    *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte                   *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt                      *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot                   *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                    []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn                 []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                    *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                   *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                    *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                   *string                       `json:"updatedAt_gte,omitempty"`
	IsDel                          *bool                         `json:"isDel,omitempty"`
	IsDelNot                       *bool                         `json:"isDel_not,omitempty"`
	And                            []PageCommentScalarWhereInput `json:"AND,omitempty"`
	Or                             []PageCommentScalarWhereInput `json:"OR,omitempty"`
	Not                            []PageCommentScalarWhereInput `json:"NOT,omitempty"`
}

type PageCommentUpdateManyWithWhereNestedInput struct {
	Where PageCommentScalarWhereInput    `json:"where"`
	Data  PageCommentUpdateManyDataInput `json:"data"`
}

type PageCommentUpdateManyDataInput struct {
	Content           *string `json:"content,omitempty"`
	IpAddress         *string `json:"ipAddress,omitempty"`
	ImageUrl          *string `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string `json:"thumbnailImageUrl,omitempty"`
	IsDel             *bool   `json:"isDel,omitempty"`
}

type ReviewContentPageFeedBackUpdateManyWithoutReviewContentPageInput struct {
	Create     []ReviewContentPageFeedBackCreateWithoutReviewContentPageInput                `json:"create,omitempty"`
	Delete     []ReviewContentPageFeedBackWhereUniqueInput                                   `json:"delete,omitempty"`
	Connect    []ReviewContentPageFeedBackWhereUniqueInput                                   `json:"connect,omitempty"`
	Set        []ReviewContentPageFeedBackWhereUniqueInput                                   `json:"set,omitempty"`
	Disconnect []ReviewContentPageFeedBackWhereUniqueInput                                   `json:"disconnect,omitempty"`
	Update     []ReviewContentPageFeedBackUpdateWithWhereUniqueWithoutReviewContentPageInput `json:"update,omitempty"`
	Upsert     []ReviewContentPageFeedBackUpsertWithWhereUniqueWithoutReviewContentPageInput `json:"upsert,omitempty"`
	DeleteMany []ReviewContentPageFeedBackScalarWhereInput                                   `json:"deleteMany,omitempty"`
	UpdateMany []ReviewContentPageFeedBackUpdateManyWithWhereNestedInput                     `json:"updateMany,omitempty"`
}

type ReviewContentPageFeedBackUpdateWithWhereUniqueWithoutReviewContentPageInput struct {
	Where ReviewContentPageFeedBackWhereUniqueInput                        `json:"where"`
	Data  ReviewContentPageFeedBackUpdateWithoutReviewContentPageDataInput `json:"data"`
}

type ReviewContentPageFeedBackUpdateWithoutReviewContentPageDataInput struct {
	IsLike    *bool               `json:"isLike,omitempty"`
	Message   *string             `json:"message,omitempty"`
	Owner     *UserUpdateOneInput `json:"owner,omitempty"`
	IpAddress *string             `json:"ipAddress,omitempty"`
}

type ReviewContentPageFeedBackUpsertWithWhereUniqueWithoutReviewContentPageInput struct {
	Where  ReviewContentPageFeedBackWhereUniqueInput                        `json:"where"`
	Update ReviewContentPageFeedBackUpdateWithoutReviewContentPageDataInput `json:"update"`
	Create ReviewContentPageFeedBackCreateWithoutReviewContentPageInput     `json:"create"`
}

type ReviewContentPageFeedBackScalarWhereInput struct {
	ID                     *string                                     `json:"id,omitempty"`
	IDNot                  *string                                     `json:"id_not,omitempty"`
	IDIn                   []string                                    `json:"id_in,omitempty"`
	IDNotIn                []string                                    `json:"id_not_in,omitempty"`
	IDLt                   *string                                     `json:"id_lt,omitempty"`
	IDLte                  *string                                     `json:"id_lte,omitempty"`
	IDGt                   *string                                     `json:"id_gt,omitempty"`
	IDGte                  *string                                     `json:"id_gte,omitempty"`
	IDContains             *string                                     `json:"id_contains,omitempty"`
	IDNotContains          *string                                     `json:"id_not_contains,omitempty"`
	IDStartsWith           *string                                     `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string                                     `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string                                     `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string                                     `json:"id_not_ends_with,omitempty"`
	IsLike                 *bool                                       `json:"isLike,omitempty"`
	IsLikeNot              *bool                                       `json:"isLike_not,omitempty"`
	Message                *string                                     `json:"message,omitempty"`
	MessageNot             *string                                     `json:"message_not,omitempty"`
	MessageIn              []string                                    `json:"message_in,omitempty"`
	MessageNotIn           []string                                    `json:"message_not_in,omitempty"`
	MessageLt              *string                                     `json:"message_lt,omitempty"`
	MessageLte             *string                                     `json:"message_lte,omitempty"`
	MessageGt              *string                                     `json:"message_gt,omitempty"`
	MessageGte             *string                                     `json:"message_gte,omitempty"`
	MessageContains        *string                                     `json:"message_contains,omitempty"`
	MessageNotContains     *string                                     `json:"message_not_contains,omitempty"`
	MessageStartsWith      *string                                     `json:"message_starts_with,omitempty"`
	MessageNotStartsWith   *string                                     `json:"message_not_starts_with,omitempty"`
	MessageEndsWith        *string                                     `json:"message_ends_with,omitempty"`
	MessageNotEndsWith     *string                                     `json:"message_not_ends_with,omitempty"`
	IpAddress              *string                                     `json:"ipAddress,omitempty"`
	IpAddressNot           *string                                     `json:"ipAddress_not,omitempty"`
	IpAddressIn            []string                                    `json:"ipAddress_in,omitempty"`
	IpAddressNotIn         []string                                    `json:"ipAddress_not_in,omitempty"`
	IpAddressLt            *string                                     `json:"ipAddress_lt,omitempty"`
	IpAddressLte           *string                                     `json:"ipAddress_lte,omitempty"`
	IpAddressGt            *string                                     `json:"ipAddress_gt,omitempty"`
	IpAddressGte           *string                                     `json:"ipAddress_gte,omitempty"`
	IpAddressContains      *string                                     `json:"ipAddress_contains,omitempty"`
	IpAddressNotContains   *string                                     `json:"ipAddress_not_contains,omitempty"`
	IpAddressStartsWith    *string                                     `json:"ipAddress_starts_with,omitempty"`
	IpAddressNotStartsWith *string                                     `json:"ipAddress_not_starts_with,omitempty"`
	IpAddressEndsWith      *string                                     `json:"ipAddress_ends_with,omitempty"`
	IpAddressNotEndsWith   *string                                     `json:"ipAddress_not_ends_with,omitempty"`
	CreatedAt              *string                                     `json:"createdAt,omitempty"`
	CreatedAtNot           *string                                     `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string                                    `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string                                    `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string                                     `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string                                     `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string                                     `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string                                     `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string                                     `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string                                     `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string                                    `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string                                    `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string                                     `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string                                     `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string                                     `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string                                     `json:"updatedAt_gte,omitempty"`
	And                    []ReviewContentPageFeedBackScalarWhereInput `json:"AND,omitempty"`
	Or                     []ReviewContentPageFeedBackScalarWhereInput `json:"OR,omitempty"`
	Not                    []ReviewContentPageFeedBackScalarWhereInput `json:"NOT,omitempty"`
}

type ReviewContentPageFeedBackUpdateManyWithWhereNestedInput struct {
	Where ReviewContentPageFeedBackScalarWhereInput    `json:"where"`
	Data  ReviewContentPageFeedBackUpdateManyDataInput `json:"data"`
}

type ReviewContentPageFeedBackUpdateManyDataInput struct {
	IsLike    *bool   `json:"isLike,omitempty"`
	Message   *string `json:"message,omitempty"`
	IpAddress *string `json:"ipAddress,omitempty"`
}

type ReviewContentPageUpsertWithWhereUniqueWithoutPageInput struct {
	Where  ReviewContentPageWhereUniqueInput           `json:"where"`
	Update ReviewContentPageUpdateWithoutPageDataInput `json:"update"`
	Create ReviewContentPageCreateWithoutPageInput     `json:"create"`
}

type ReviewContentPageScalarWhereInput struct {
	ID                    *string                             `json:"id,omitempty"`
	IDNot                 *string                             `json:"id_not,omitempty"`
	IDIn                  []string                            `json:"id_in,omitempty"`
	IDNotIn               []string                            `json:"id_not_in,omitempty"`
	IDLt                  *string                             `json:"id_lt,omitempty"`
	IDLte                 *string                             `json:"id_lte,omitempty"`
	IDGt                  *string                             `json:"id_gt,omitempty"`
	IDGte                 *string                             `json:"id_gte,omitempty"`
	IDContains            *string                             `json:"id_contains,omitempty"`
	IDNotContains         *string                             `json:"id_not_contains,omitempty"`
	IDStartsWith          *string                             `json:"id_starts_with,omitempty"`
	IDNotStartsWith       *string                             `json:"id_not_starts_with,omitempty"`
	IDEndsWith            *string                             `json:"id_ends_with,omitempty"`
	IDNotEndsWith         *string                             `json:"id_not_ends_with,omitempty"`
	Title                 *string                             `json:"title,omitempty"`
	TitleNot              *string                             `json:"title_not,omitempty"`
	TitleIn               []string                            `json:"title_in,omitempty"`
	TitleNotIn            []string                            `json:"title_not_in,omitempty"`
	TitleLt               *string                             `json:"title_lt,omitempty"`
	TitleLte              *string                             `json:"title_lte,omitempty"`
	TitleGt               *string                             `json:"title_gt,omitempty"`
	TitleGte              *string                             `json:"title_gte,omitempty"`
	TitleContains         *string                             `json:"title_contains,omitempty"`
	TitleNotContains      *string                             `json:"title_not_contains,omitempty"`
	TitleStartsWith       *string                             `json:"title_starts_with,omitempty"`
	TitleNotStartsWith    *string                             `json:"title_not_starts_with,omitempty"`
	TitleEndsWith         *string                             `json:"title_ends_with,omitempty"`
	TitleNotEndsWith      *string                             `json:"title_not_ends_with,omitempty"`
	SubTitle              *string                             `json:"subTitle,omitempty"`
	SubTitleNot           *string                             `json:"subTitle_not,omitempty"`
	SubTitleIn            []string                            `json:"subTitle_in,omitempty"`
	SubTitleNotIn         []string                            `json:"subTitle_not_in,omitempty"`
	SubTitleLt            *string                             `json:"subTitle_lt,omitempty"`
	SubTitleLte           *string                             `json:"subTitle_lte,omitempty"`
	SubTitleGt            *string                             `json:"subTitle_gt,omitempty"`
	SubTitleGte           *string                             `json:"subTitle_gte,omitempty"`
	SubTitleContains      *string                             `json:"subTitle_contains,omitempty"`
	SubTitleNotContains   *string                             `json:"subTitle_not_contains,omitempty"`
	SubTitleStartsWith    *string                             `json:"subTitle_starts_with,omitempty"`
	SubTitleNotStartsWith *string                             `json:"subTitle_not_starts_with,omitempty"`
	SubTitleEndsWith      *string                             `json:"subTitle_ends_with,omitempty"`
	SubTitleNotEndsWith   *string                             `json:"subTitle_not_ends_with,omitempty"`
	Message               *string                             `json:"message,omitempty"`
	MessageNot            *string                             `json:"message_not,omitempty"`
	MessageIn             []string                            `json:"message_in,omitempty"`
	MessageNotIn          []string                            `json:"message_not_in,omitempty"`
	MessageLt             *string                             `json:"message_lt,omitempty"`
	MessageLte            *string                             `json:"message_lte,omitempty"`
	MessageGt             *string                             `json:"message_gt,omitempty"`
	MessageGte            *string                             `json:"message_gte,omitempty"`
	MessageContains       *string                             `json:"message_contains,omitempty"`
	MessageNotContains    *string                             `json:"message_not_contains,omitempty"`
	MessageStartsWith     *string                             `json:"message_starts_with,omitempty"`
	MessageNotStartsWith  *string                             `json:"message_not_starts_with,omitempty"`
	MessageEndsWith       *string                             `json:"message_ends_with,omitempty"`
	MessageNotEndsWith    *string                             `json:"message_not_ends_with,omitempty"`
	ReleasedAt            *string                             `json:"releasedAt,omitempty"`
	ReleasedAtNot         *string                             `json:"releasedAt_not,omitempty"`
	ReleasedAtIn          []string                            `json:"releasedAt_in,omitempty"`
	ReleasedAtNotIn       []string                            `json:"releasedAt_not_in,omitempty"`
	ReleasedAtLt          *string                             `json:"releasedAt_lt,omitempty"`
	ReleasedAtLte         *string                             `json:"releasedAt_lte,omitempty"`
	ReleasedAtGt          *string                             `json:"releasedAt_gt,omitempty"`
	ReleasedAtGte         *string                             `json:"releasedAt_gte,omitempty"`
	IsDrafts              *bool                               `json:"isDrafts,omitempty"`
	IsDraftsNot           *bool                               `json:"isDrafts_not,omitempty"`
	IsDel                 *bool                               `json:"isDel,omitempty"`
	IsDelNot              *bool                               `json:"isDel_not,omitempty"`
	CreatedAt             *string                             `json:"createdAt,omitempty"`
	CreatedAtNot          *string                             `json:"createdAt_not,omitempty"`
	CreatedAtIn           []string                            `json:"createdAt_in,omitempty"`
	CreatedAtNotIn        []string                            `json:"createdAt_not_in,omitempty"`
	CreatedAtLt           *string                             `json:"createdAt_lt,omitempty"`
	CreatedAtLte          *string                             `json:"createdAt_lte,omitempty"`
	CreatedAtGt           *string                             `json:"createdAt_gt,omitempty"`
	CreatedAtGte          *string                             `json:"createdAt_gte,omitempty"`
	UpdatedAt             *string                             `json:"updatedAt,omitempty"`
	UpdatedAtNot          *string                             `json:"updatedAt_not,omitempty"`
	UpdatedAtIn           []string                            `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn        []string                            `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt           *string                             `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte          *string                             `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt           *string                             `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte          *string                             `json:"updatedAt_gte,omitempty"`
	And                   []ReviewContentPageScalarWhereInput `json:"AND,omitempty"`
	Or                    []ReviewContentPageScalarWhereInput `json:"OR,omitempty"`
	Not                   []ReviewContentPageScalarWhereInput `json:"NOT,omitempty"`
}

type ReviewContentPageUpdateManyWithWhereNestedInput struct {
	Where ReviewContentPageScalarWhereInput    `json:"where"`
	Data  ReviewContentPageUpdateManyDataInput `json:"data"`
}

type ReviewContentPageUpdateManyDataInput struct {
	Title      *string `json:"title,omitempty"`
	SubTitle   *string `json:"subTitle,omitempty"`
	Message    *string `json:"message,omitempty"`
	ReleasedAt *string `json:"releasedAt,omitempty"`
	IsDrafts   *bool   `json:"isDrafts,omitempty"`
	IsDel      *bool   `json:"isDel,omitempty"`
}

type PageUpsertWithoutRelatedReviewsInput struct {
	Update PageUpdateWithoutRelatedReviewsDataInput `json:"update"`
	Create PageCreateWithoutRelatedReviewsInput     `json:"create"`
}

type ReviewContentUpsertWithWhereUniqueWithoutReviewContentPageInput struct {
	Where  ReviewContentWhereUniqueInput                        `json:"where"`
	Update ReviewContentUpdateWithoutReviewContentPageDataInput `json:"update"`
	Create ReviewContentCreateWithoutReviewContentPageInput     `json:"create"`
}

type ReviewContentPageUpsertWithoutCommentsInput struct {
	Update ReviewContentPageUpdateWithoutCommentsDataInput `json:"update"`
	Create ReviewContentPageCreateWithoutCommentsInput     `json:"create"`
}

type PageCommentUpsertWithWhereUniqueWithoutPageInput struct {
	Where  PageCommentWhereUniqueInput           `json:"where"`
	Update PageCommentUpdateWithoutPageDataInput `json:"update"`
	Create PageCommentCreateWithoutPageInput     `json:"create"`
}

type PageUpsertWithoutReviewsInput struct {
	Update PageUpdateWithoutReviewsDataInput `json:"update"`
	Create PageCreateWithoutReviewsInput     `json:"create"`
}

type ReviewContentPageUpsertWithoutReviewsInput struct {
	Update ReviewContentPageUpdateWithoutReviewsDataInput `json:"update"`
	Create ReviewContentPageCreateWithoutReviewsInput     `json:"create"`
}

type ReviewContentUpsertNestedInput struct {
	Update ReviewContentUpdateDataInput `json:"update"`
	Create ReviewContentCreateInput     `json:"create"`
}

type BadgeVoterUpsertWithWhereUniqueWithoutPageBadgeInput struct {
	Where  BadgeVoterWhereUniqueInput                `json:"where"`
	Update BadgeVoterUpdateWithoutPageBadgeDataInput `json:"update"`
	Create BadgeVoterCreateWithoutPageBadgeInput     `json:"create"`
}

type BadgeVoterScalarWhereInput struct {
	ID              *string                      `json:"id,omitempty"`
	IDNot           *string                      `json:"id_not,omitempty"`
	IDIn            []string                     `json:"id_in,omitempty"`
	IDNotIn         []string                     `json:"id_not_in,omitempty"`
	IDLt            *string                      `json:"id_lt,omitempty"`
	IDLte           *string                      `json:"id_lte,omitempty"`
	IDGt            *string                      `json:"id_gt,omitempty"`
	IDGte           *string                      `json:"id_gte,omitempty"`
	IDContains      *string                      `json:"id_contains,omitempty"`
	IDNotContains   *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                      `json:"id_not_ends_with,omitempty"`
	Ip              *string                      `json:"ip,omitempty"`
	IpNot           *string                      `json:"ip_not,omitempty"`
	IpIn            []string                     `json:"ip_in,omitempty"`
	IpNotIn         []string                     `json:"ip_not_in,omitempty"`
	IpLt            *string                      `json:"ip_lt,omitempty"`
	IpLte           *string                      `json:"ip_lte,omitempty"`
	IpGt            *string                      `json:"ip_gt,omitempty"`
	IpGte           *string                      `json:"ip_gte,omitempty"`
	IpContains      *string                      `json:"ip_contains,omitempty"`
	IpNotContains   *string                      `json:"ip_not_contains,omitempty"`
	IpStartsWith    *string                      `json:"ip_starts_with,omitempty"`
	IpNotStartsWith *string                      `json:"ip_not_starts_with,omitempty"`
	IpEndsWith      *string                      `json:"ip_ends_with,omitempty"`
	IpNotEndsWith   *string                      `json:"ip_not_ends_with,omitempty"`
	CreatedAt       *string                      `json:"createdAt,omitempty"`
	CreatedAtNot    *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                      `json:"updatedAt_gte,omitempty"`
	And             []BadgeVoterScalarWhereInput `json:"AND,omitempty"`
	Or              []BadgeVoterScalarWhereInput `json:"OR,omitempty"`
	Not             []BadgeVoterScalarWhereInput `json:"NOT,omitempty"`
}

type BadgeVoterUpdateManyWithWhereNestedInput struct {
	Where BadgeVoterScalarWhereInput    `json:"where"`
	Data  BadgeVoterUpdateManyDataInput `json:"data"`
}

type BadgeVoterUpdateManyDataInput struct {
	Ip *string `json:"ip,omitempty"`
}

type PageBadgeUpsertWithWhereUniqueWithoutPageInput struct {
	Where  PageBadgeWhereUniqueInput           `json:"where"`
	Update PageBadgeUpdateWithoutPageDataInput `json:"update"`
	Create PageBadgeCreateWithoutPageInput     `json:"create"`
}

type PageBadgeScalarWhereInput struct {
	ID              *string                     `json:"id,omitempty"`
	IDNot           *string                     `json:"id_not,omitempty"`
	IDIn            []string                    `json:"id_in,omitempty"`
	IDNotIn         []string                    `json:"id_not_in,omitempty"`
	IDLt            *string                     `json:"id_lt,omitempty"`
	IDLte           *string                     `json:"id_lte,omitempty"`
	IDGt            *string                     `json:"id_gt,omitempty"`
	IDGte           *string                     `json:"id_gte,omitempty"`
	IDContains      *string                     `json:"id_contains,omitempty"`
	IDNotContains   *string                     `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                     `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                     `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                     `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                     `json:"id_not_ends_with,omitempty"`
	Vote            *int32                      `json:"vote,omitempty"`
	VoteNot         *int32                      `json:"vote_not,omitempty"`
	VoteIn          []int32                     `json:"vote_in,omitempty"`
	VoteNotIn       []int32                     `json:"vote_not_in,omitempty"`
	VoteLt          *int32                      `json:"vote_lt,omitempty"`
	VoteLte         *int32                      `json:"vote_lte,omitempty"`
	VoteGt          *int32                      `json:"vote_gt,omitempty"`
	VoteGte         *int32                      `json:"vote_gte,omitempty"`
	CreatedAt       *string                     `json:"createdAt,omitempty"`
	CreatedAtNot    *string                     `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                    `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                    `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                     `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                     `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                     `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                     `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                     `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                     `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                    `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                    `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                     `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                     `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                     `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                     `json:"updatedAt_gte,omitempty"`
	And             []PageBadgeScalarWhereInput `json:"AND,omitempty"`
	Or              []PageBadgeScalarWhereInput `json:"OR,omitempty"`
	Not             []PageBadgeScalarWhereInput `json:"NOT,omitempty"`
}

type PageBadgeUpdateManyWithWhereNestedInput struct {
	Where PageBadgeScalarWhereInput    `json:"where"`
	Data  PageBadgeUpdateManyDataInput `json:"data"`
}

type PageBadgeUpdateManyDataInput struct {
	Vote *int32 `json:"vote,omitempty"`
}

type PageUpsertWithoutOwnerInput struct {
	Update PageUpdateWithoutOwnerDataInput `json:"update"`
	Create PageCreateWithoutOwnerInput     `json:"create"`
}

type UserUpsertWithWhereUniqueWithoutEventFeeInput struct {
	Where  UserWhereUniqueInput               `json:"where"`
	Update UserUpdateWithoutEventFeeDataInput `json:"update"`
	Create UserCreateWithoutEventFeeInput     `json:"create"`
}

type FeeUpsertWithoutRankRelationInput struct {
	Update FeeUpdateWithoutRankRelationDataInput `json:"update"`
	Create FeeCreateWithoutRankRelationInput     `json:"create"`
}

type UserUpsertWithWhereUniqueWithoutViewsInput struct {
	Where  UserWhereUniqueInput            `json:"where"`
	Update UserUpdateWithoutViewsDataInput `json:"update"`
	Create UserCreateWithoutViewsInput     `json:"create"`
}

type PostUpsertWithoutAirDropInput struct {
	Update PostUpdateWithoutAirDropDataInput `json:"update"`
	Create PostCreateWithoutAirDropInput     `json:"create"`
}

type AirDropHistoryUpdateManyWithoutAirDropInput struct {
	Create     []AirDropHistoryCreateWithoutAirDropInput                `json:"create,omitempty"`
	Delete     []AirDropHistoryWhereUniqueInput                         `json:"delete,omitempty"`
	Connect    []AirDropHistoryWhereUniqueInput                         `json:"connect,omitempty"`
	Set        []AirDropHistoryWhereUniqueInput                         `json:"set,omitempty"`
	Disconnect []AirDropHistoryWhereUniqueInput                         `json:"disconnect,omitempty"`
	Update     []AirDropHistoryUpdateWithWhereUniqueWithoutAirDropInput `json:"update,omitempty"`
	Upsert     []AirDropHistoryUpsertWithWhereUniqueWithoutAirDropInput `json:"upsert,omitempty"`
	DeleteMany []AirDropHistoryScalarWhereInput                         `json:"deleteMany,omitempty"`
	UpdateMany []AirDropHistoryUpdateManyWithWhereNestedInput           `json:"updateMany,omitempty"`
}

type AirDropHistoryUpdateWithWhereUniqueWithoutAirDropInput struct {
	Where AirDropHistoryWhereUniqueInput              `json:"where"`
	Data  AirDropHistoryUpdateWithoutAirDropDataInput `json:"data"`
}

type AirDropHistoryUpdateWithoutAirDropDataInput struct {
	Type          *int32                                            `json:"type,omitempty"`
	Description   *string                                           `json:"description,omitempty"`
	User          *UserUpdateOneWithoutAirDropHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutAirDropHistoryInput `json:"motherHistory,omitempty"`
	AirDropMember *AirDropMemberUpdateOneWithoutAirDropHistoryInput `json:"airDropMember,omitempty"`
	Qty           *float64                                          `json:"qty,omitempty"`
	CurrentPrice  *float64                                          `json:"currentPrice,omitempty"`
	Memo          *string                                           `json:"memo,omitempty"`
}

type AirDropMemberUpdateOneWithoutAirDropHistoryInput struct {
	Create     *AirDropMemberCreateWithoutAirDropHistoryInput     `json:"create,omitempty"`
	Update     *AirDropMemberUpdateWithoutAirDropHistoryDataInput `json:"update,omitempty"`
	Upsert     *AirDropMemberUpsertWithoutAirDropHistoryInput     `json:"upsert,omitempty"`
	Delete     *bool                                              `json:"delete,omitempty"`
	Disconnect *bool                                              `json:"disconnect,omitempty"`
	Connect    *AirDropMemberWhereUniqueInput                     `json:"connect,omitempty"`
}

type AirDropMemberUpdateWithoutAirDropHistoryDataInput struct {
	AirDrop *AirDropUpdateOneRequiredWithoutMembersInput     `json:"airDrop,omitempty"`
	User    *UserUpdateOneRequiredWithoutAirDropMembersInput `json:"user,omitempty"`
	DropNum *int32                                           `json:"dropNum,omitempty"`
	Qty     *float64                                         `json:"qty,omitempty"`
	IsDel   *bool                                            `json:"isDel,omitempty"`
}

type AirDropMemberUpsertWithoutAirDropHistoryInput struct {
	Update AirDropMemberUpdateWithoutAirDropHistoryDataInput `json:"update"`
	Create AirDropMemberCreateWithoutAirDropHistoryInput     `json:"create"`
}

type AirDropHistoryUpsertWithWhereUniqueWithoutAirDropInput struct {
	Where  AirDropHistoryWhereUniqueInput              `json:"where"`
	Update AirDropHistoryUpdateWithoutAirDropDataInput `json:"update"`
	Create AirDropHistoryCreateWithoutAirDropInput     `json:"create"`
}

type AirDropHistoryScalarWhereInput struct {
	ID                       *string                          `json:"id,omitempty"`
	IDNot                    *string                          `json:"id_not,omitempty"`
	IDIn                     []string                         `json:"id_in,omitempty"`
	IDNotIn                  []string                         `json:"id_not_in,omitempty"`
	IDLt                     *string                          `json:"id_lt,omitempty"`
	IDLte                    *string                          `json:"id_lte,omitempty"`
	IDGt                     *string                          `json:"id_gt,omitempty"`
	IDGte                    *string                          `json:"id_gte,omitempty"`
	IDContains               *string                          `json:"id_contains,omitempty"`
	IDNotContains            *string                          `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                          `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                          `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                          `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                          `json:"id_not_ends_with,omitempty"`
	Type                     *int32                           `json:"type,omitempty"`
	TypeNot                  *int32                           `json:"type_not,omitempty"`
	TypeIn                   []int32                          `json:"type_in,omitempty"`
	TypeNotIn                []int32                          `json:"type_not_in,omitempty"`
	TypeLt                   *int32                           `json:"type_lt,omitempty"`
	TypeLte                  *int32                           `json:"type_lte,omitempty"`
	TypeGt                   *int32                           `json:"type_gt,omitempty"`
	TypeGte                  *int32                           `json:"type_gte,omitempty"`
	Description              *string                          `json:"description,omitempty"`
	DescriptionNot           *string                          `json:"description_not,omitempty"`
	DescriptionIn            []string                         `json:"description_in,omitempty"`
	DescriptionNotIn         []string                         `json:"description_not_in,omitempty"`
	DescriptionLt            *string                          `json:"description_lt,omitempty"`
	DescriptionLte           *string                          `json:"description_lte,omitempty"`
	DescriptionGt            *string                          `json:"description_gt,omitempty"`
	DescriptionGte           *string                          `json:"description_gte,omitempty"`
	DescriptionContains      *string                          `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                          `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                          `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                          `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                          `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                          `json:"description_not_ends_with,omitempty"`
	Qty                      *float64                         `json:"qty,omitempty"`
	QtyNot                   *float64                         `json:"qty_not,omitempty"`
	QtyIn                    []float64                        `json:"qty_in,omitempty"`
	QtyNotIn                 []float64                        `json:"qty_not_in,omitempty"`
	QtyLt                    *float64                         `json:"qty_lt,omitempty"`
	QtyLte                   *float64                         `json:"qty_lte,omitempty"`
	QtyGt                    *float64                         `json:"qty_gt,omitempty"`
	QtyGte                   *float64                         `json:"qty_gte,omitempty"`
	CurrentPrice             *float64                         `json:"currentPrice,omitempty"`
	CurrentPriceNot          *float64                         `json:"currentPrice_not,omitempty"`
	CurrentPriceIn           []float64                        `json:"currentPrice_in,omitempty"`
	CurrentPriceNotIn        []float64                        `json:"currentPrice_not_in,omitempty"`
	CurrentPriceLt           *float64                         `json:"currentPrice_lt,omitempty"`
	CurrentPriceLte          *float64                         `json:"currentPrice_lte,omitempty"`
	CurrentPriceGt           *float64                         `json:"currentPrice_gt,omitempty"`
	CurrentPriceGte          *float64                         `json:"currentPrice_gte,omitempty"`
	Memo                     *string                          `json:"memo,omitempty"`
	MemoNot                  *string                          `json:"memo_not,omitempty"`
	MemoIn                   []string                         `json:"memo_in,omitempty"`
	MemoNotIn                []string                         `json:"memo_not_in,omitempty"`
	MemoLt                   *string                          `json:"memo_lt,omitempty"`
	MemoLte                  *string                          `json:"memo_lte,omitempty"`
	MemoGt                   *string                          `json:"memo_gt,omitempty"`
	MemoGte                  *string                          `json:"memo_gte,omitempty"`
	MemoContains             *string                          `json:"memo_contains,omitempty"`
	MemoNotContains          *string                          `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                          `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                          `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                          `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                          `json:"memo_not_ends_with,omitempty"`
	CreatedAt                *string                          `json:"createdAt,omitempty"`
	CreatedAtNot             *string                          `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                         `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                         `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                          `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                          `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                          `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                          `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                          `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                          `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                         `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                         `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                          `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                          `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                          `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                          `json:"updatedAt_gte,omitempty"`
	And                      []AirDropHistoryScalarWhereInput `json:"AND,omitempty"`
	Or                       []AirDropHistoryScalarWhereInput `json:"OR,omitempty"`
	Not                      []AirDropHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type AirDropHistoryUpdateManyWithWhereNestedInput struct {
	Where AirDropHistoryScalarWhereInput    `json:"where"`
	Data  AirDropHistoryUpdateManyDataInput `json:"data"`
}

type AirDropHistoryUpdateManyDataInput struct {
	Type         *int32   `json:"type,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
}

type AirDropUpsertWithoutMembersInput struct {
	Update AirDropUpdateWithoutMembersDataInput `json:"update"`
	Create AirDropCreateWithoutMembersInput     `json:"create"`
}

type AirDropHistoryUpdateOneWithoutAirDropMemberInput struct {
	Create     *AirDropHistoryCreateWithoutAirDropMemberInput     `json:"create,omitempty"`
	Update     *AirDropHistoryUpdateWithoutAirDropMemberDataInput `json:"update,omitempty"`
	Upsert     *AirDropHistoryUpsertWithoutAirDropMemberInput     `json:"upsert,omitempty"`
	Delete     *bool                                              `json:"delete,omitempty"`
	Disconnect *bool                                              `json:"disconnect,omitempty"`
	Connect    *AirDropHistoryWhereUniqueInput                    `json:"connect,omitempty"`
}

type AirDropHistoryUpdateWithoutAirDropMemberDataInput struct {
	Type          *int32                                            `json:"type,omitempty"`
	Description   *string                                           `json:"description,omitempty"`
	User          *UserUpdateOneWithoutAirDropHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutAirDropHistoryInput `json:"motherHistory,omitempty"`
	AirDrop       *AirDropUpdateOneWithoutAirDropHistoriesInput     `json:"airDrop,omitempty"`
	Qty           *float64                                          `json:"qty,omitempty"`
	CurrentPrice  *float64                                          `json:"currentPrice,omitempty"`
	Memo          *string                                           `json:"memo,omitempty"`
}

type AirDropUpdateOneWithoutAirDropHistoriesInput struct {
	Create     *AirDropCreateWithoutAirDropHistoriesInput     `json:"create,omitempty"`
	Update     *AirDropUpdateWithoutAirDropHistoriesDataInput `json:"update,omitempty"`
	Upsert     *AirDropUpsertWithoutAirDropHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                          `json:"delete,omitempty"`
	Disconnect *bool                                          `json:"disconnect,omitempty"`
	Connect    *AirDropWhereUniqueInput                       `json:"connect,omitempty"`
}

type AirDropUpdateWithoutAirDropHistoriesDataInput struct {
	Status            *int32                                      `json:"status,omitempty"`
	Post              *PostUpdateOneRequiredWithoutAirDropInput   `json:"post,omitempty"`
	DeployTxhash      *string                                     `json:"deployTxhash,omitempty"`
	ContractAddress   *string                                     `json:"contractAddress,omitempty"`
	RandomArrayString *string                                     `json:"randomArrayString,omitempty"`
	Amount            *float64                                    `json:"amount,omitempty"`
	Left              *float64                                    `json:"left,omitempty"`
	Members           *AirDropMemberUpdateManyWithoutAirDropInput `json:"members,omitempty"`
	ToDate            *string                                     `json:"toDate,omitempty"`
	IsDel             *bool                                       `json:"isDel,omitempty"`
}

type AirDropUpsertWithoutAirDropHistoriesInput struct {
	Update AirDropUpdateWithoutAirDropHistoriesDataInput `json:"update"`
	Create AirDropCreateWithoutAirDropHistoriesInput     `json:"create"`
}

type AirDropHistoryUpsertWithoutAirDropMemberInput struct {
	Update AirDropHistoryUpdateWithoutAirDropMemberDataInput `json:"update"`
	Create AirDropHistoryCreateWithoutAirDropMemberInput     `json:"create"`
}

type AirDropMemberUpsertWithWhereUniqueWithoutUserInput struct {
	Where  AirDropMemberWhereUniqueInput           `json:"where"`
	Update AirDropMemberUpdateWithoutUserDataInput `json:"update"`
	Create AirDropMemberCreateWithoutUserInput     `json:"create"`
}

type AirDropMemberScalarWhereInput struct {
	ID              *string                         `json:"id,omitempty"`
	IDNot           *string                         `json:"id_not,omitempty"`
	IDIn            []string                        `json:"id_in,omitempty"`
	IDNotIn         []string                        `json:"id_not_in,omitempty"`
	IDLt            *string                         `json:"id_lt,omitempty"`
	IDLte           *string                         `json:"id_lte,omitempty"`
	IDGt            *string                         `json:"id_gt,omitempty"`
	IDGte           *string                         `json:"id_gte,omitempty"`
	IDContains      *string                         `json:"id_contains,omitempty"`
	IDNotContains   *string                         `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                         `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                         `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                         `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                         `json:"id_not_ends_with,omitempty"`
	DropNum         *int32                          `json:"dropNum,omitempty"`
	DropNumNot      *int32                          `json:"dropNum_not,omitempty"`
	DropNumIn       []int32                         `json:"dropNum_in,omitempty"`
	DropNumNotIn    []int32                         `json:"dropNum_not_in,omitempty"`
	DropNumLt       *int32                          `json:"dropNum_lt,omitempty"`
	DropNumLte      *int32                          `json:"dropNum_lte,omitempty"`
	DropNumGt       *int32                          `json:"dropNum_gt,omitempty"`
	DropNumGte      *int32                          `json:"dropNum_gte,omitempty"`
	Qty             *float64                        `json:"qty,omitempty"`
	QtyNot          *float64                        `json:"qty_not,omitempty"`
	QtyIn           []float64                       `json:"qty_in,omitempty"`
	QtyNotIn        []float64                       `json:"qty_not_in,omitempty"`
	QtyLt           *float64                        `json:"qty_lt,omitempty"`
	QtyLte          *float64                        `json:"qty_lte,omitempty"`
	QtyGt           *float64                        `json:"qty_gt,omitempty"`
	QtyGte          *float64                        `json:"qty_gte,omitempty"`
	CreatedAt       *string                         `json:"createdAt,omitempty"`
	CreatedAtNot    *string                         `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                         `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                         `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                         `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                         `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                         `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                         `json:"updatedAt_gte,omitempty"`
	IsDel           *bool                           `json:"isDel,omitempty"`
	IsDelNot        *bool                           `json:"isDel_not,omitempty"`
	And             []AirDropMemberScalarWhereInput `json:"AND,omitempty"`
	Or              []AirDropMemberScalarWhereInput `json:"OR,omitempty"`
	Not             []AirDropMemberScalarWhereInput `json:"NOT,omitempty"`
}

type AirDropMemberUpdateManyWithWhereNestedInput struct {
	Where AirDropMemberScalarWhereInput    `json:"where"`
	Data  AirDropMemberUpdateManyDataInput `json:"data"`
}

type AirDropMemberUpdateManyDataInput struct {
	DropNum *int32   `json:"dropNum,omitempty"`
	Qty     *float64 `json:"qty,omitempty"`
	IsDel   *bool    `json:"isDel,omitempty"`
}

type UserUpsertWithoutAirDropHistoriesInput struct {
	Update UserUpdateWithoutAirDropHistoriesDataInput `json:"update"`
	Create UserCreateWithoutAirDropHistoriesInput     `json:"create"`
}

type AirDropHistoryUpsertWithoutMotherHistoryInput struct {
	Update AirDropHistoryUpdateWithoutMotherHistoryDataInput `json:"update"`
	Create AirDropHistoryCreateWithoutMotherHistoryInput     `json:"create"`
}

type MotherHistoryUpsertWithoutAergoAccountHistoryInput struct {
	Update MotherHistoryUpdateWithoutAergoAccountHistoryDataInput `json:"update"`
	Create MotherHistoryCreateWithoutAergoAccountHistoryInput     `json:"create"`
}

type AergoAccountHistoryUpsertWithoutCashHistoryInput struct {
	Update AergoAccountHistoryUpdateWithoutCashHistoryDataInput `json:"update"`
	Create AergoAccountHistoryCreateWithoutCashHistoryInput     `json:"create"`
}

type CashHistoryUpsertWithoutQehInput struct {
	Update CashHistoryUpdateWithoutQehDataInput `json:"update"`
	Create CashHistoryCreateWithoutQehInput     `json:"create"`
}

type QuestExpenditureHistoryUpsertWithoutMotherHistoryInput struct {
	Update QuestExpenditureHistoryUpdateWithoutMotherHistoryDataInput `json:"update"`
	Create QuestExpenditureHistoryCreateWithoutMotherHistoryInput     `json:"create"`
}

type MotherHistoryUpsertWithoutAirDropHistoryInput struct {
	Update MotherHistoryUpdateWithoutAirDropHistoryDataInput `json:"update"`
	Create MotherHistoryCreateWithoutAirDropHistoryInput     `json:"create"`
}

type AirDropHistoryUpsertWithWhereUniqueWithoutUserInput struct {
	Where  AirDropHistoryWhereUniqueInput           `json:"where"`
	Update AirDropHistoryUpdateWithoutUserDataInput `json:"update"`
	Create AirDropHistoryCreateWithoutUserInput     `json:"create"`
}

type UserUpsertWithoutAergoAccountInput struct {
	Update UserUpdateWithoutAergoAccountDataInput `json:"update"`
	Create UserCreateWithoutAergoAccountInput     `json:"create"`
}

type AergoAccountUpsertWithoutHistoriesInput struct {
	Update AergoAccountUpdateWithoutHistoriesDataInput `json:"update"`
	Create AergoAccountCreateWithoutHistoriesInput     `json:"create"`
}

type AergoAccountHistoryUpsertWithoutMotherHistoryInput struct {
	Update AergoAccountHistoryUpdateWithoutMotherHistoryDataInput `json:"update"`
	Create AergoAccountHistoryCreateWithoutMotherHistoryInput     `json:"create"`
}

type MotherHistoryUpsertWithoutOrderHistoryInput struct {
	Update MotherHistoryUpdateWithoutOrderHistoryDataInput `json:"update"`
	Create MotherHistoryCreateWithoutOrderHistoryInput     `json:"create"`
}

type OrderHistoryUpsertWithoutOrderUserDealsHistoriesInput struct {
	Update OrderHistoryUpdateWithoutOrderUserDealsHistoriesDataInput `json:"update"`
	Create OrderHistoryCreateWithoutOrderUserDealsHistoriesInput     `json:"create"`
}

type OrderUserDealsHistoryUpsertWithoutMotherHistoryInput struct {
	Update OrderUserDealsHistoryUpdateWithoutMotherHistoryDataInput `json:"update"`
	Create OrderUserDealsHistoryCreateWithoutMotherHistoryInput     `json:"create"`
}

type MotherHistoryUpsertWithoutCashHistoryInput struct {
	Update MotherHistoryUpdateWithoutCashHistoryDataInput `json:"update"`
	Create MotherHistoryCreateWithoutCashHistoryInput     `json:"create"`
}

type CashHistoryUpsertWithWhereUniqueWithoutUserInput struct {
	Where  CashHistoryWhereUniqueInput           `json:"where"`
	Update CashHistoryUpdateWithoutUserDataInput `json:"update"`
	Create CashHistoryCreateWithoutUserInput     `json:"create"`
}

type CashHistoryScalarWhereInput struct {
	ID                       *string                       `json:"id,omitempty"`
	IDNot                    *string                       `json:"id_not,omitempty"`
	IDIn                     []string                      `json:"id_in,omitempty"`
	IDNotIn                  []string                      `json:"id_not_in,omitempty"`
	IDLt                     *string                       `json:"id_lt,omitempty"`
	IDLte                    *string                       `json:"id_lte,omitempty"`
	IDGt                     *string                       `json:"id_gt,omitempty"`
	IDGte                    *string                       `json:"id_gte,omitempty"`
	IDContains               *string                       `json:"id_contains,omitempty"`
	IDNotContains            *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                       `json:"id_not_ends_with,omitempty"`
	Type                     *int32                        `json:"type,omitempty"`
	TypeNot                  *int32                        `json:"type_not,omitempty"`
	TypeIn                   []int32                       `json:"type_in,omitempty"`
	TypeNotIn                []int32                       `json:"type_not_in,omitempty"`
	TypeLt                   *int32                        `json:"type_lt,omitempty"`
	TypeLte                  *int32                        `json:"type_lte,omitempty"`
	TypeGt                   *int32                        `json:"type_gt,omitempty"`
	TypeGte                  *int32                        `json:"type_gte,omitempty"`
	Property                 *int32                        `json:"property,omitempty"`
	PropertyNot              *int32                        `json:"property_not,omitempty"`
	PropertyIn               []int32                       `json:"property_in,omitempty"`
	PropertyNotIn            []int32                       `json:"property_not_in,omitempty"`
	PropertyLt               *int32                        `json:"property_lt,omitempty"`
	PropertyLte              *int32                        `json:"property_lte,omitempty"`
	PropertyGt               *int32                        `json:"property_gt,omitempty"`
	PropertyGte              *int32                        `json:"property_gte,omitempty"`
	OrderNum                 *int32                        `json:"orderNum,omitempty"`
	OrderNumNot              *int32                        `json:"orderNum_not,omitempty"`
	OrderNumIn               []int32                       `json:"orderNum_in,omitempty"`
	OrderNumNotIn            []int32                       `json:"orderNum_not_in,omitempty"`
	OrderNumLt               *int32                        `json:"orderNum_lt,omitempty"`
	OrderNumLte              *int32                        `json:"orderNum_lte,omitempty"`
	OrderNumGt               *int32                        `json:"orderNum_gt,omitempty"`
	OrderNumGte              *int32                        `json:"orderNum_gte,omitempty"`
	Description              *string                       `json:"description,omitempty"`
	DescriptionNot           *string                       `json:"description_not,omitempty"`
	DescriptionIn            []string                      `json:"description_in,omitempty"`
	DescriptionNotIn         []string                      `json:"description_not_in,omitempty"`
	DescriptionLt            *string                       `json:"description_lt,omitempty"`
	DescriptionLte           *string                       `json:"description_lte,omitempty"`
	DescriptionGt            *string                       `json:"description_gt,omitempty"`
	DescriptionGte           *string                       `json:"description_gte,omitempty"`
	DescriptionContains      *string                       `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                       `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                       `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                       `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                       `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                       `json:"description_not_ends_with,omitempty"`
	Price                    *int32                        `json:"price,omitempty"`
	PriceNot                 *int32                        `json:"price_not,omitempty"`
	PriceIn                  []int32                       `json:"price_in,omitempty"`
	PriceNotIn               []int32                       `json:"price_not_in,omitempty"`
	PriceLt                  *int32                        `json:"price_lt,omitempty"`
	PriceLte                 *int32                        `json:"price_lte,omitempty"`
	PriceGt                  *int32                        `json:"price_gt,omitempty"`
	PriceGte                 *int32                        `json:"price_gte,omitempty"`
	OPrice                   *float64                      `json:"oPrice,omitempty"`
	OPriceNot                *float64                      `json:"oPrice_not,omitempty"`
	OPriceIn                 []float64                     `json:"oPrice_in,omitempty"`
	OPriceNotIn              []float64                     `json:"oPrice_not_in,omitempty"`
	OPriceLt                 *float64                      `json:"oPrice_lt,omitempty"`
	OPriceLte                *float64                      `json:"oPrice_lte,omitempty"`
	OPriceGt                 *float64                      `json:"oPrice_gt,omitempty"`
	OPriceGte                *float64                      `json:"oPrice_gte,omitempty"`
	OPriceBack               *float64                      `json:"oPriceBack,omitempty"`
	OPriceBackNot            *float64                      `json:"oPriceBack_not,omitempty"`
	OPriceBackIn             []float64                     `json:"oPriceBack_in,omitempty"`
	OPriceBackNotIn          []float64                     `json:"oPriceBack_not_in,omitempty"`
	OPriceBackLt             *float64                      `json:"oPriceBack_lt,omitempty"`
	OPriceBackLte            *float64                      `json:"oPriceBack_lte,omitempty"`
	OPriceBackGt             *float64                      `json:"oPriceBack_gt,omitempty"`
	OPriceBackGte            *float64                      `json:"oPriceBack_gte,omitempty"`
	Qty                      *float64                      `json:"qty,omitempty"`
	QtyNot                   *float64                      `json:"qty_not,omitempty"`
	QtyIn                    []float64                     `json:"qty_in,omitempty"`
	QtyNotIn                 []float64                     `json:"qty_not_in,omitempty"`
	QtyLt                    *float64                      `json:"qty_lt,omitempty"`
	QtyLte                   *float64                      `json:"qty_lte,omitempty"`
	QtyGt                    *float64                      `json:"qty_gt,omitempty"`
	QtyGte                   *float64                      `json:"qty_gte,omitempty"`
	Memo                     *string                       `json:"memo,omitempty"`
	MemoNot                  *string                       `json:"memo_not,omitempty"`
	MemoIn                   []string                      `json:"memo_in,omitempty"`
	MemoNotIn                []string                      `json:"memo_not_in,omitempty"`
	MemoLt                   *string                       `json:"memo_lt,omitempty"`
	MemoLte                  *string                       `json:"memo_lte,omitempty"`
	MemoGt                   *string                       `json:"memo_gt,omitempty"`
	MemoGte                  *string                       `json:"memo_gte,omitempty"`
	MemoContains             *string                       `json:"memo_contains,omitempty"`
	MemoNotContains          *string                       `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                       `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                       `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                       `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                       `json:"memo_not_ends_with,omitempty"`
	CreatedAt                *string                       `json:"createdAt,omitempty"`
	CreatedAtNot             *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                       `json:"updatedAt_gte,omitempty"`
	And                      []CashHistoryScalarWhereInput `json:"AND,omitempty"`
	Or                       []CashHistoryScalarWhereInput `json:"OR,omitempty"`
	Not                      []CashHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type CashHistoryUpdateManyWithWhereNestedInput struct {
	Where CashHistoryScalarWhereInput    `json:"where"`
	Data  CashHistoryUpdateManyDataInput `json:"data"`
}

type CashHistoryUpdateManyDataInput struct {
	Type        *int32   `json:"type,omitempty"`
	Property    *int32   `json:"property,omitempty"`
	OrderNum    *int32   `json:"orderNum,omitempty"`
	Description *string  `json:"description,omitempty"`
	Price       *int32   `json:"price,omitempty"`
	OPrice      *float64 `json:"oPrice,omitempty"`
	OPriceBack  *float64 `json:"oPriceBack,omitempty"`
	Qty         *float64 `json:"qty,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
}

type UserUpsertWithWhereUniqueWithoutLikesInput struct {
	Where  UserWhereUniqueInput            `json:"where"`
	Update UserUpdateWithoutLikesDataInput `json:"update"`
	Create UserCreateWithoutLikesInput     `json:"create"`
}

type PostUpsertWithoutQuestExpenditureHistoriesInput struct {
	Update PostUpdateWithoutQuestExpenditureHistoriesDataInput `json:"update"`
	Create PostCreateWithoutQuestExpenditureHistoriesInput     `json:"create"`
}

type QuestExpenditureHistoryUpsertWithWhereUniqueWithoutUserInput struct {
	Where  QuestExpenditureHistoryWhereUniqueInput           `json:"where"`
	Update QuestExpenditureHistoryUpdateWithoutUserDataInput `json:"update"`
	Create QuestExpenditureHistoryCreateWithoutUserInput     `json:"create"`
}

type QuestExpenditureHistoryScalarWhereInput struct {
	ID                       *string                                   `json:"id,omitempty"`
	IDNot                    *string                                   `json:"id_not,omitempty"`
	IDIn                     []string                                  `json:"id_in,omitempty"`
	IDNotIn                  []string                                  `json:"id_not_in,omitempty"`
	IDLt                     *string                                   `json:"id_lt,omitempty"`
	IDLte                    *string                                   `json:"id_lte,omitempty"`
	IDGt                     *string                                   `json:"id_gt,omitempty"`
	IDGte                    *string                                   `json:"id_gte,omitempty"`
	IDContains               *string                                   `json:"id_contains,omitempty"`
	IDNotContains            *string                                   `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                                   `json:"id_not_ends_with,omitempty"`
	Type                     *int32                                    `json:"type,omitempty"`
	TypeNot                  *int32                                    `json:"type_not,omitempty"`
	TypeIn                   []int32                                   `json:"type_in,omitempty"`
	TypeNotIn                []int32                                   `json:"type_not_in,omitempty"`
	TypeLt                   *int32                                    `json:"type_lt,omitempty"`
	TypeLte                  *int32                                    `json:"type_lte,omitempty"`
	TypeGt                   *int32                                    `json:"type_gt,omitempty"`
	TypeGte                  *int32                                    `json:"type_gte,omitempty"`
	PayType                  *int32                                    `json:"payType,omitempty"`
	PayTypeNot               *int32                                    `json:"payType_not,omitempty"`
	PayTypeIn                []int32                                   `json:"payType_in,omitempty"`
	PayTypeNotIn             []int32                                   `json:"payType_not_in,omitempty"`
	PayTypeLt                *int32                                    `json:"payType_lt,omitempty"`
	PayTypeLte               *int32                                    `json:"payType_lte,omitempty"`
	PayTypeGt                *int32                                    `json:"payType_gt,omitempty"`
	PayTypeGte               *int32                                    `json:"payType_gte,omitempty"`
	OrderNum                 *int32                                    `json:"orderNum,omitempty"`
	OrderNumNot              *int32                                    `json:"orderNum_not,omitempty"`
	OrderNumIn               []int32                                   `json:"orderNum_in,omitempty"`
	OrderNumNotIn            []int32                                   `json:"orderNum_not_in,omitempty"`
	OrderNumLt               *int32                                    `json:"orderNum_lt,omitempty"`
	OrderNumLte              *int32                                    `json:"orderNum_lte,omitempty"`
	OrderNumGt               *int32                                    `json:"orderNum_gt,omitempty"`
	OrderNumGte              *int32                                    `json:"orderNum_gte,omitempty"`
	Description              *string                                   `json:"description,omitempty"`
	DescriptionNot           *string                                   `json:"description_not,omitempty"`
	DescriptionIn            []string                                  `json:"description_in,omitempty"`
	DescriptionNotIn         []string                                  `json:"description_not_in,omitempty"`
	DescriptionLt            *string                                   `json:"description_lt,omitempty"`
	DescriptionLte           *string                                   `json:"description_lte,omitempty"`
	DescriptionGt            *string                                   `json:"description_gt,omitempty"`
	DescriptionGte           *string                                   `json:"description_gte,omitempty"`
	DescriptionContains      *string                                   `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                                   `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                                   `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                                   `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                                   `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                                   `json:"description_not_ends_with,omitempty"`
	Price                    *int32                                    `json:"price,omitempty"`
	PriceNot                 *int32                                    `json:"price_not,omitempty"`
	PriceIn                  []int32                                   `json:"price_in,omitempty"`
	PriceNotIn               []int32                                   `json:"price_not_in,omitempty"`
	PriceLt                  *int32                                    `json:"price_lt,omitempty"`
	PriceLte                 *int32                                    `json:"price_lte,omitempty"`
	PriceGt                  *int32                                    `json:"price_gt,omitempty"`
	PriceGte                 *int32                                    `json:"price_gte,omitempty"`
	Qty                      *float64                                  `json:"qty,omitempty"`
	QtyNot                   *float64                                  `json:"qty_not,omitempty"`
	QtyIn                    []float64                                 `json:"qty_in,omitempty"`
	QtyNotIn                 []float64                                 `json:"qty_not_in,omitempty"`
	QtyLt                    *float64                                  `json:"qty_lt,omitempty"`
	QtyLte                   *float64                                  `json:"qty_lte,omitempty"`
	QtyGt                    *float64                                  `json:"qty_gt,omitempty"`
	QtyGte                   *float64                                  `json:"qty_gte,omitempty"`
	OPrice                   *int32                                    `json:"oPrice,omitempty"`
	OPriceNot                *int32                                    `json:"oPrice_not,omitempty"`
	OPriceIn                 []int32                                   `json:"oPrice_in,omitempty"`
	OPriceNotIn              []int32                                   `json:"oPrice_not_in,omitempty"`
	OPriceLt                 *int32                                    `json:"oPrice_lt,omitempty"`
	OPriceLte                *int32                                    `json:"oPrice_lte,omitempty"`
	OPriceGt                 *int32                                    `json:"oPrice_gt,omitempty"`
	OPriceGte                *int32                                    `json:"oPrice_gte,omitempty"`
	CurrentPrice             *float64                                  `json:"currentPrice,omitempty"`
	CurrentPriceNot          *float64                                  `json:"currentPrice_not,omitempty"`
	CurrentPriceIn           []float64                                 `json:"currentPrice_in,omitempty"`
	CurrentPriceNotIn        []float64                                 `json:"currentPrice_not_in,omitempty"`
	CurrentPriceLt           *float64                                  `json:"currentPrice_lt,omitempty"`
	CurrentPriceLte          *float64                                  `json:"currentPrice_lte,omitempty"`
	CurrentPriceGt           *float64                                  `json:"currentPrice_gt,omitempty"`
	CurrentPriceGte          *float64                                  `json:"currentPrice_gte,omitempty"`
	Memo                     *string                                   `json:"memo,omitempty"`
	MemoNot                  *string                                   `json:"memo_not,omitempty"`
	MemoIn                   []string                                  `json:"memo_in,omitempty"`
	MemoNotIn                []string                                  `json:"memo_not_in,omitempty"`
	MemoLt                   *string                                   `json:"memo_lt,omitempty"`
	MemoLte                  *string                                   `json:"memo_lte,omitempty"`
	MemoGt                   *string                                   `json:"memo_gt,omitempty"`
	MemoGte                  *string                                   `json:"memo_gte,omitempty"`
	MemoContains             *string                                   `json:"memo_contains,omitempty"`
	MemoNotContains          *string                                   `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                                   `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                                   `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                                   `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                                   `json:"memo_not_ends_with,omitempty"`
	CreatedAt                *string                                   `json:"createdAt,omitempty"`
	CreatedAtNot             *string                                   `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                                   `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                                   `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                                   `json:"updatedAt_gte,omitempty"`
	And                      []QuestExpenditureHistoryScalarWhereInput `json:"AND,omitempty"`
	Or                       []QuestExpenditureHistoryScalarWhereInput `json:"OR,omitempty"`
	Not                      []QuestExpenditureHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type QuestExpenditureHistoryUpdateManyWithWhereNestedInput struct {
	Where QuestExpenditureHistoryScalarWhereInput    `json:"where"`
	Data  QuestExpenditureHistoryUpdateManyDataInput `json:"data"`
}

type QuestExpenditureHistoryUpdateManyDataInput struct {
	Type         *int32   `json:"type,omitempty"`
	PayType      *int32   `json:"payType,omitempty"`
	OrderNum     *int32   `json:"orderNum,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Price        *int32   `json:"price,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	OPrice       *int32   `json:"oPrice,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
}

type UserUpsertWithoutCashHistoriesInput struct {
	Update UserUpdateWithoutCashHistoriesDataInput `json:"update"`
	Create UserCreateWithoutCashHistoriesInput     `json:"create"`
}

type CashHistoryUpsertWithoutMotherHistoryInput struct {
	Update CashHistoryUpdateWithoutMotherHistoryDataInput `json:"update"`
	Create CashHistoryCreateWithoutMotherHistoryInput     `json:"create"`
}

type MotherHistoryUpsertWithoutOrderUserDealsHistoryInput struct {
	Update MotherHistoryUpdateWithoutOrderUserDealsHistoryDataInput `json:"update"`
	Create MotherHistoryCreateWithoutOrderUserDealsHistoryInput     `json:"create"`
}

type OrderUserDealsHistoryUpsertWithWhereUniqueWithoutUserInput struct {
	Where  OrderUserDealsHistoryWhereUniqueInput           `json:"where"`
	Update OrderUserDealsHistoryUpdateWithoutUserDataInput `json:"update"`
	Create OrderUserDealsHistoryCreateWithoutUserInput     `json:"create"`
}

type UserUpsertWithoutMotherHistoriesInput struct {
	Update UserUpdateWithoutMotherHistoriesDataInput `json:"update"`
	Create UserCreateWithoutMotherHistoriesInput     `json:"create"`
}

type MotherHistoryUpsertWithWhereUniqueWithoutCoinInput struct {
	Where  MotherHistoryWhereUniqueInput           `json:"where"`
	Update MotherHistoryUpdateWithoutCoinDataInput `json:"update"`
	Create MotherHistoryCreateWithoutCoinInput     `json:"create"`
}

type MotherHistoryScalarWhereInput struct {
	ID              *string                         `json:"id,omitempty"`
	IDNot           *string                         `json:"id_not,omitempty"`
	IDIn            []string                        `json:"id_in,omitempty"`
	IDNotIn         []string                        `json:"id_not_in,omitempty"`
	IDLt            *string                         `json:"id_lt,omitempty"`
	IDLte           *string                         `json:"id_lte,omitempty"`
	IDGt            *string                         `json:"id_gt,omitempty"`
	IDGte           *string                         `json:"id_gte,omitempty"`
	IDContains      *string                         `json:"id_contains,omitempty"`
	IDNotContains   *string                         `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                         `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                         `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                         `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                         `json:"id_not_ends_with,omitempty"`
	Type            *int32                          `json:"type,omitempty"`
	TypeNot         *int32                          `json:"type_not,omitempty"`
	TypeIn          []int32                         `json:"type_in,omitempty"`
	TypeNotIn       []int32                         `json:"type_not_in,omitempty"`
	TypeLt          *int32                          `json:"type_lt,omitempty"`
	TypeLte         *int32                          `json:"type_lte,omitempty"`
	TypeGt          *int32                          `json:"type_gt,omitempty"`
	TypeGte         *int32                          `json:"type_gte,omitempty"`
	RoleTime        *string                         `json:"roleTime,omitempty"`
	RoleTimeNot     *string                         `json:"roleTime_not,omitempty"`
	RoleTimeIn      []string                        `json:"roleTime_in,omitempty"`
	RoleTimeNotIn   []string                        `json:"roleTime_not_in,omitempty"`
	RoleTimeLt      *string                         `json:"roleTime_lt,omitempty"`
	RoleTimeLte     *string                         `json:"roleTime_lte,omitempty"`
	RoleTimeGt      *string                         `json:"roleTime_gt,omitempty"`
	RoleTimeGte     *string                         `json:"roleTime_gte,omitempty"`
	CreatedAt       *string                         `json:"createdAt,omitempty"`
	CreatedAtNot    *string                         `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                        `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                        `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                         `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                         `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                         `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                         `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                         `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                         `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                        `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                        `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                         `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                         `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                         `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                         `json:"updatedAt_gte,omitempty"`
	And             []MotherHistoryScalarWhereInput `json:"AND,omitempty"`
	Or              []MotherHistoryScalarWhereInput `json:"OR,omitempty"`
	Not             []MotherHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type MotherHistoryUpdateManyWithWhereNestedInput struct {
	Where MotherHistoryScalarWhereInput    `json:"where"`
	Data  MotherHistoryUpdateManyDataInput `json:"data"`
}

type MotherHistoryUpdateManyDataInput struct {
	Type     *int32  `json:"type,omitempty"`
	RoleTime *string `json:"roleTime,omitempty"`
}

type CoinUpsertWithoutOrderHistoriesInput struct {
	Update CoinUpdateWithoutOrderHistoriesDataInput `json:"update"`
	Create CoinCreateWithoutOrderHistoriesInput     `json:"create"`
}

type OrderHistoryUpsertWithWhereUniqueWithoutUserInput struct {
	Where  OrderHistoryWhereUniqueInput           `json:"where"`
	Update OrderHistoryUpdateWithoutUserDataInput `json:"update"`
	Create OrderHistoryCreateWithoutUserInput     `json:"create"`
}

type OrderHistoryScalarWhereInput struct {
	ID                       *string                        `json:"id,omitempty"`
	IDNot                    *string                        `json:"id_not,omitempty"`
	IDIn                     []string                       `json:"id_in,omitempty"`
	IDNotIn                  []string                       `json:"id_not_in,omitempty"`
	IDLt                     *string                        `json:"id_lt,omitempty"`
	IDLte                    *string                        `json:"id_lte,omitempty"`
	IDGt                     *string                        `json:"id_gt,omitempty"`
	IDGte                    *string                        `json:"id_gte,omitempty"`
	IDContains               *string                        `json:"id_contains,omitempty"`
	IDNotContains            *string                        `json:"id_not_contains,omitempty"`
	IDStartsWith             *string                        `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string                        `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string                        `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string                        `json:"id_not_ends_with,omitempty"`
	Type                     *int32                         `json:"type,omitempty"`
	TypeNot                  *int32                         `json:"type_not,omitempty"`
	TypeIn                   []int32                        `json:"type_in,omitempty"`
	TypeNotIn                []int32                        `json:"type_not_in,omitempty"`
	TypeLt                   *int32                         `json:"type_lt,omitempty"`
	TypeLte                  *int32                         `json:"type_lte,omitempty"`
	TypeGt                   *int32                         `json:"type_gt,omitempty"`
	TypeGte                  *int32                         `json:"type_gte,omitempty"`
	OrderNum                 *int32                         `json:"orderNum,omitempty"`
	OrderNumNot              *int32                         `json:"orderNum_not,omitempty"`
	OrderNumIn               []int32                        `json:"orderNum_in,omitempty"`
	OrderNumNotIn            []int32                        `json:"orderNum_not_in,omitempty"`
	OrderNumLt               *int32                         `json:"orderNum_lt,omitempty"`
	OrderNumLte              *int32                         `json:"orderNum_lte,omitempty"`
	OrderNumGt               *int32                         `json:"orderNum_gt,omitempty"`
	OrderNumGte              *int32                         `json:"orderNum_gte,omitempty"`
	OrderPrice               *float64                       `json:"orderPrice,omitempty"`
	OrderPriceNot            *float64                       `json:"orderPrice_not,omitempty"`
	OrderPriceIn             []float64                      `json:"orderPrice_in,omitempty"`
	OrderPriceNotIn          []float64                      `json:"orderPrice_not_in,omitempty"`
	OrderPriceLt             *float64                       `json:"orderPrice_lt,omitempty"`
	OrderPriceLte            *float64                       `json:"orderPrice_lte,omitempty"`
	OrderPriceGt             *float64                       `json:"orderPrice_gt,omitempty"`
	OrderPriceGte            *float64                       `json:"orderPrice_gte,omitempty"`
	DealPrice                *float64                       `json:"dealPrice,omitempty"`
	DealPriceNot             *float64                       `json:"dealPrice_not,omitempty"`
	DealPriceIn              []float64                      `json:"dealPrice_in,omitempty"`
	DealPriceNotIn           []float64                      `json:"dealPrice_not_in,omitempty"`
	DealPriceLt              *float64                       `json:"dealPrice_lt,omitempty"`
	DealPriceLte             *float64                       `json:"dealPrice_lte,omitempty"`
	DealPriceGt              *float64                       `json:"dealPrice_gt,omitempty"`
	DealPriceGte             *float64                       `json:"dealPrice_gte,omitempty"`
	OrderQty                 *float64                       `json:"orderQty,omitempty"`
	OrderQtyNot              *float64                       `json:"orderQty_not,omitempty"`
	OrderQtyIn               []float64                      `json:"orderQty_in,omitempty"`
	OrderQtyNotIn            []float64                      `json:"orderQty_not_in,omitempty"`
	OrderQtyLt               *float64                       `json:"orderQty_lt,omitempty"`
	OrderQtyLte              *float64                       `json:"orderQty_lte,omitempty"`
	OrderQtyGt               *float64                       `json:"orderQty_gt,omitempty"`
	OrderQtyGte              *float64                       `json:"orderQty_gte,omitempty"`
	DealQty                  *float64                       `json:"dealQty,omitempty"`
	DealQtyNot               *float64                       `json:"dealQty_not,omitempty"`
	DealQtyIn                []float64                      `json:"dealQty_in,omitempty"`
	DealQtyNotIn             []float64                      `json:"dealQty_not_in,omitempty"`
	DealQtyLt                *float64                       `json:"dealQty_lt,omitempty"`
	DealQtyLte               *float64                       `json:"dealQty_lte,omitempty"`
	DealQtyGt                *float64                       `json:"dealQty_gt,omitempty"`
	DealQtyGte               *float64                       `json:"dealQty_gte,omitempty"`
	LeftQty                  *float64                       `json:"leftQty,omitempty"`
	LeftQtyNot               *float64                       `json:"leftQty_not,omitempty"`
	LeftQtyIn                []float64                      `json:"leftQty_in,omitempty"`
	LeftQtyNotIn             []float64                      `json:"leftQty_not_in,omitempty"`
	LeftQtyLt                *float64                       `json:"leftQty_lt,omitempty"`
	LeftQtyLte               *float64                       `json:"leftQty_lte,omitempty"`
	LeftQtyGt                *float64                       `json:"leftQty_gt,omitempty"`
	LeftQtyGte               *float64                       `json:"leftQty_gte,omitempty"`
	DealFee                  *float64                       `json:"dealFee,omitempty"`
	DealFeeNot               *float64                       `json:"dealFee_not,omitempty"`
	DealFeeIn                []float64                      `json:"dealFee_in,omitempty"`
	DealFeeNotIn             []float64                      `json:"dealFee_not_in,omitempty"`
	DealFeeLt                *float64                       `json:"dealFee_lt,omitempty"`
	DealFeeLte               *float64                       `json:"dealFee_lte,omitempty"`
	DealFeeGt                *float64                       `json:"dealFee_gt,omitempty"`
	DealFeeGte               *float64                       `json:"dealFee_gte,omitempty"`
	TakerFee                 *float64                       `json:"takerFee,omitempty"`
	TakerFeeNot              *float64                       `json:"takerFee_not,omitempty"`
	TakerFeeIn               []float64                      `json:"takerFee_in,omitempty"`
	TakerFeeNotIn            []float64                      `json:"takerFee_not_in,omitempty"`
	TakerFeeLt               *float64                       `json:"takerFee_lt,omitempty"`
	TakerFeeLte              *float64                       `json:"takerFee_lte,omitempty"`
	TakerFeeGt               *float64                       `json:"takerFee_gt,omitempty"`
	TakerFeeGte              *float64                       `json:"takerFee_gte,omitempty"`
	MakerFee                 *float64                       `json:"makerFee,omitempty"`
	MakerFeeNot              *float64                       `json:"makerFee_not,omitempty"`
	MakerFeeIn               []float64                      `json:"makerFee_in,omitempty"`
	MakerFeeNotIn            []float64                      `json:"makerFee_not_in,omitempty"`
	MakerFeeLt               *float64                       `json:"makerFee_lt,omitempty"`
	MakerFeeLte              *float64                       `json:"makerFee_lte,omitempty"`
	MakerFeeGt               *float64                       `json:"makerFee_gt,omitempty"`
	MakerFeeGte              *float64                       `json:"makerFee_gte,omitempty"`
	Memo                     *string                        `json:"memo,omitempty"`
	MemoNot                  *string                        `json:"memo_not,omitempty"`
	MemoIn                   []string                       `json:"memo_in,omitempty"`
	MemoNotIn                []string                       `json:"memo_not_in,omitempty"`
	MemoLt                   *string                        `json:"memo_lt,omitempty"`
	MemoLte                  *string                        `json:"memo_lte,omitempty"`
	MemoGt                   *string                        `json:"memo_gt,omitempty"`
	MemoGte                  *string                        `json:"memo_gte,omitempty"`
	MemoContains             *string                        `json:"memo_contains,omitempty"`
	MemoNotContains          *string                        `json:"memo_not_contains,omitempty"`
	MemoStartsWith           *string                        `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith        *string                        `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith             *string                        `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith          *string                        `json:"memo_not_ends_with,omitempty"`
	Description              *string                        `json:"description,omitempty"`
	DescriptionNot           *string                        `json:"description_not,omitempty"`
	DescriptionIn            []string                       `json:"description_in,omitempty"`
	DescriptionNotIn         []string                       `json:"description_not_in,omitempty"`
	DescriptionLt            *string                        `json:"description_lt,omitempty"`
	DescriptionLte           *string                        `json:"description_lte,omitempty"`
	DescriptionGt            *string                        `json:"description_gt,omitempty"`
	DescriptionGte           *string                        `json:"description_gte,omitempty"`
	DescriptionContains      *string                        `json:"description_contains,omitempty"`
	DescriptionNotContains   *string                        `json:"description_not_contains,omitempty"`
	DescriptionStartsWith    *string                        `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith *string                        `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith      *string                        `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith   *string                        `json:"description_not_ends_with,omitempty"`
	Offset                   *int32                         `json:"offset,omitempty"`
	OffsetNot                *int32                         `json:"offset_not,omitempty"`
	OffsetIn                 []int32                        `json:"offset_in,omitempty"`
	OffsetNotIn              []int32                        `json:"offset_not_in,omitempty"`
	OffsetLt                 *int32                         `json:"offset_lt,omitempty"`
	OffsetLte                *int32                         `json:"offset_lte,omitempty"`
	OffsetGt                 *int32                         `json:"offset_gt,omitempty"`
	OffsetGte                *int32                         `json:"offset_gte,omitempty"`
	IsCancel                 *bool                          `json:"isCancel,omitempty"`
	IsCancelNot              *bool                          `json:"isCancel_not,omitempty"`
	CreatedAt                *string                        `json:"createdAt,omitempty"`
	CreatedAtNot             *string                        `json:"createdAt_not,omitempty"`
	CreatedAtIn              []string                       `json:"createdAt_in,omitempty"`
	CreatedAtNotIn           []string                       `json:"createdAt_not_in,omitempty"`
	CreatedAtLt              *string                        `json:"createdAt_lt,omitempty"`
	CreatedAtLte             *string                        `json:"createdAt_lte,omitempty"`
	CreatedAtGt              *string                        `json:"createdAt_gt,omitempty"`
	CreatedAtGte             *string                        `json:"createdAt_gte,omitempty"`
	UpdatedAt                *string                        `json:"updatedAt,omitempty"`
	UpdatedAtNot             *string                        `json:"updatedAt_not,omitempty"`
	UpdatedAtIn              []string                       `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn           []string                       `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt              *string                        `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte             *string                        `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt              *string                        `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte             *string                        `json:"updatedAt_gte,omitempty"`
	And                      []OrderHistoryScalarWhereInput `json:"AND,omitempty"`
	Or                       []OrderHistoryScalarWhereInput `json:"OR,omitempty"`
	Not                      []OrderHistoryScalarWhereInput `json:"NOT,omitempty"`
}

type OrderHistoryUpdateManyWithWhereNestedInput struct {
	Where OrderHistoryScalarWhereInput    `json:"where"`
	Data  OrderHistoryUpdateManyDataInput `json:"data"`
}

type OrderHistoryUpdateManyDataInput struct {
	Type        *int32   `json:"type,omitempty"`
	OrderNum    *int32   `json:"orderNum,omitempty"`
	OrderPrice  *float64 `json:"orderPrice,omitempty"`
	DealPrice   *float64 `json:"dealPrice,omitempty"`
	OrderQty    *float64 `json:"orderQty,omitempty"`
	DealQty     *float64 `json:"dealQty,omitempty"`
	LeftQty     *float64 `json:"leftQty,omitempty"`
	DealFee     *float64 `json:"dealFee,omitempty"`
	TakerFee    *float64 `json:"takerFee,omitempty"`
	MakerFee    *float64 `json:"makerFee,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
	Description *string  `json:"description,omitempty"`
	Offset      *int32   `json:"offset,omitempty"`
	IsCancel    *bool    `json:"isCancel,omitempty"`
}

type UserUpsertWithoutCommentsInput struct {
	Update UserUpdateWithoutCommentsDataInput `json:"update"`
	Create UserCreateWithoutCommentsInput     `json:"create"`
}

type PostRewardHistoryUpdateOneWithoutCommentInput struct {
	Create     *PostRewardHistoryCreateWithoutCommentInput     `json:"create,omitempty"`
	Update     *PostRewardHistoryUpdateWithoutCommentDataInput `json:"update,omitempty"`
	Upsert     *PostRewardHistoryUpsertWithoutCommentInput     `json:"upsert,omitempty"`
	Delete     *bool                                           `json:"delete,omitempty"`
	Disconnect *bool                                           `json:"disconnect,omitempty"`
	Connect    *PostRewardHistoryWhereUniqueInput              `json:"connect,omitempty"`
}

type PostRewardHistoryUpdateWithoutCommentDataInput struct {
	Type          *int32                                               `json:"type,omitempty"`
	Description   *string                                              `json:"description,omitempty"`
	User          *UserUpdateOneWithoutPostRewardHistoriesInput        `json:"user,omitempty"`
	Post          *PostUpdateOneWithoutPostRewardHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutPostRewardHistoryInput `json:"motherHistory,omitempty"`
	Qty           *float64                                             `json:"qty,omitempty"`
	CurrentPrice  *float64                                             `json:"currentPrice,omitempty"`
	Memo          *string                                              `json:"memo,omitempty"`
}

type PostRewardHistoryUpsertWithoutCommentInput struct {
	Update PostRewardHistoryUpdateWithoutCommentDataInput `json:"update"`
	Create PostRewardHistoryCreateWithoutCommentInput     `json:"create"`
}

type CommentUpsertWithWhereUniqueWithoutPostInput struct {
	Where  CommentWhereUniqueInput           `json:"where"`
	Update CommentUpdateWithoutPostDataInput `json:"update"`
	Create CommentCreateWithoutPostInput     `json:"create"`
}

type CommentScalarWhereInput struct {
	ID                   *string                   `json:"id,omitempty"`
	IDNot                *string                   `json:"id_not,omitempty"`
	IDIn                 []string                  `json:"id_in,omitempty"`
	IDNotIn              []string                  `json:"id_not_in,omitempty"`
	IDLt                 *string                   `json:"id_lt,omitempty"`
	IDLte                *string                   `json:"id_lte,omitempty"`
	IDGt                 *string                   `json:"id_gt,omitempty"`
	IDGte                *string                   `json:"id_gte,omitempty"`
	IDContains           *string                   `json:"id_contains,omitempty"`
	IDNotContains        *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                   `json:"id_not_ends_with,omitempty"`
	Type                 *int32                    `json:"type,omitempty"`
	TypeNot              *int32                    `json:"type_not,omitempty"`
	TypeIn               []int32                   `json:"type_in,omitempty"`
	TypeNotIn            []int32                   `json:"type_not_in,omitempty"`
	TypeLt               *int32                    `json:"type_lt,omitempty"`
	TypeLte              *int32                    `json:"type_lte,omitempty"`
	TypeGt               *int32                    `json:"type_gt,omitempty"`
	TypeGte              *int32                    `json:"type_gte,omitempty"`
	Content              *string                   `json:"content,omitempty"`
	ContentNot           *string                   `json:"content_not,omitempty"`
	ContentIn            []string                  `json:"content_in,omitempty"`
	ContentNotIn         []string                  `json:"content_not_in,omitempty"`
	ContentLt            *string                   `json:"content_lt,omitempty"`
	ContentLte           *string                   `json:"content_lte,omitempty"`
	ContentGt            *string                   `json:"content_gt,omitempty"`
	ContentGte           *string                   `json:"content_gte,omitempty"`
	ContentContains      *string                   `json:"content_contains,omitempty"`
	ContentNotContains   *string                   `json:"content_not_contains,omitempty"`
	ContentStartsWith    *string                   `json:"content_starts_with,omitempty"`
	ContentNotStartsWith *string                   `json:"content_not_starts_with,omitempty"`
	ContentEndsWith      *string                   `json:"content_ends_with,omitempty"`
	ContentNotEndsWith   *string                   `json:"content_not_ends_with,omitempty"`
	Url                  *string                   `json:"url,omitempty"`
	UrlNot               *string                   `json:"url_not,omitempty"`
	UrlIn                []string                  `json:"url_in,omitempty"`
	UrlNotIn             []string                  `json:"url_not_in,omitempty"`
	UrlLt                *string                   `json:"url_lt,omitempty"`
	UrlLte               *string                   `json:"url_lte,omitempty"`
	UrlGt                *string                   `json:"url_gt,omitempty"`
	UrlGte               *string                   `json:"url_gte,omitempty"`
	UrlContains          *string                   `json:"url_contains,omitempty"`
	UrlNotContains       *string                   `json:"url_not_contains,omitempty"`
	UrlStartsWith        *string                   `json:"url_starts_with,omitempty"`
	UrlNotStartsWith     *string                   `json:"url_not_starts_with,omitempty"`
	UrlEndsWith          *string                   `json:"url_ends_with,omitempty"`
	UrlNotEndsWith       *string                   `json:"url_not_ends_with,omitempty"`
	CreatedAt            *string                   `json:"createdAt,omitempty"`
	CreatedAtNot         *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                   `json:"updatedAt_gte,omitempty"`
	IsDel                *bool                     `json:"isDel,omitempty"`
	IsDelNot             *bool                     `json:"isDel_not,omitempty"`
	And                  []CommentScalarWhereInput `json:"AND,omitempty"`
	Or                   []CommentScalarWhereInput `json:"OR,omitempty"`
	Not                  []CommentScalarWhereInput `json:"NOT,omitempty"`
}

type CommentUpdateManyWithWhereNestedInput struct {
	Where CommentScalarWhereInput    `json:"where"`
	Data  CommentUpdateManyDataInput `json:"data"`
}

type CommentUpdateManyDataInput struct {
	Type    *int32  `json:"type,omitempty"`
	Content *string `json:"content,omitempty"`
	Url     *string `json:"url,omitempty"`
	IsDel   *bool   `json:"isDel,omitempty"`
}

type PostUpsertWithoutMotherHistoriesInput struct {
	Update PostUpdateWithoutMotherHistoriesDataInput `json:"update"`
	Create PostCreateWithoutMotherHistoriesInput     `json:"create"`
}

type MotherHistoryUpsertWithWhereUniqueWithoutUserInput struct {
	Where  MotherHistoryWhereUniqueInput           `json:"where"`
	Update MotherHistoryUpdateWithoutUserDataInput `json:"update"`
	Create MotherHistoryCreateWithoutUserInput     `json:"create"`
}

type UserUpsertWithoutOrderUserDealsHistoriesInput struct {
	Update UserUpdateWithoutOrderUserDealsHistoriesDataInput `json:"update"`
	Create UserCreateWithoutOrderUserDealsHistoriesInput     `json:"create"`
}

type OrderUserDealsHistoryUpsertWithWhereUniqueWithoutCoinInput struct {
	Where  OrderUserDealsHistoryWhereUniqueInput           `json:"where"`
	Update OrderUserDealsHistoryUpdateWithoutCoinDataInput `json:"update"`
	Create OrderUserDealsHistoryCreateWithoutCoinInput     `json:"create"`
}

type CoinUpsertNestedInput struct {
	Update CoinUpdateDataInput `json:"update"`
	Create CoinCreateInput     `json:"create"`
}

type RewardDropEventUpsertWithoutAttendingUsersInput struct {
	Update RewardDropEventUpdateWithoutAttendingUsersDataInput `json:"update"`
	Create RewardDropEventCreateWithoutAttendingUsersInput     `json:"create"`
}

type RewardDropAttendingUserUpsertWithWhereUniqueWithoutUserInput struct {
	Where  RewardDropAttendingUserWhereUniqueInput           `json:"where"`
	Update RewardDropAttendingUserUpdateWithoutUserDataInput `json:"update"`
	Create RewardDropAttendingUserCreateWithoutUserInput     `json:"create"`
}

type RewardDropAttendingUserScalarWhereInput struct {
	ID                *string                                   `json:"id,omitempty"`
	IDNot             *string                                   `json:"id_not,omitempty"`
	IDIn              []string                                  `json:"id_in,omitempty"`
	IDNotIn           []string                                  `json:"id_not_in,omitempty"`
	IDLt              *string                                   `json:"id_lt,omitempty"`
	IDLte             *string                                   `json:"id_lte,omitempty"`
	IDGt              *string                                   `json:"id_gt,omitempty"`
	IDGte             *string                                   `json:"id_gte,omitempty"`
	IDContains        *string                                   `json:"id_contains,omitempty"`
	IDNotContains     *string                                   `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                                   `json:"id_not_ends_with,omitempty"`
	Memo              *string                                   `json:"memo,omitempty"`
	MemoNot           *string                                   `json:"memo_not,omitempty"`
	MemoIn            []string                                  `json:"memo_in,omitempty"`
	MemoNotIn         []string                                  `json:"memo_not_in,omitempty"`
	MemoLt            *string                                   `json:"memo_lt,omitempty"`
	MemoLte           *string                                   `json:"memo_lte,omitempty"`
	MemoGt            *string                                   `json:"memo_gt,omitempty"`
	MemoGte           *string                                   `json:"memo_gte,omitempty"`
	MemoContains      *string                                   `json:"memo_contains,omitempty"`
	MemoNotContains   *string                                   `json:"memo_not_contains,omitempty"`
	MemoStartsWith    *string                                   `json:"memo_starts_with,omitempty"`
	MemoNotStartsWith *string                                   `json:"memo_not_starts_with,omitempty"`
	MemoEndsWith      *string                                   `json:"memo_ends_with,omitempty"`
	MemoNotEndsWith   *string                                   `json:"memo_not_ends_with,omitempty"`
	IsDel             *bool                                     `json:"isDel,omitempty"`
	IsDelNot          *bool                                     `json:"isDel_not,omitempty"`
	CreatedAt         *string                                   `json:"createdAt,omitempty"`
	CreatedAtNot      *string                                   `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                                   `json:"createdAt_gte,omitempty"`
	And               []RewardDropAttendingUserScalarWhereInput `json:"AND,omitempty"`
	Or                []RewardDropAttendingUserScalarWhereInput `json:"OR,omitempty"`
	Not               []RewardDropAttendingUserScalarWhereInput `json:"NOT,omitempty"`
}

type RewardDropAttendingUserUpdateManyWithWhereNestedInput struct {
	Where RewardDropAttendingUserScalarWhereInput    `json:"where"`
	Data  RewardDropAttendingUserUpdateManyDataInput `json:"data"`
}

type RewardDropAttendingUserUpdateManyDataInput struct {
	Memo  *string `json:"memo,omitempty"`
	IsDel *bool   `json:"isDel,omitempty"`
}

type UserUpsertWithWhereUniqueNestedInput struct {
	Where  UserWhereUniqueInput `json:"where"`
	Update UserUpdateDataInput  `json:"update"`
	Create UserCreateInput      `json:"create"`
}

type AdminUserUpdateOneWithoutUpdateNotificationInput struct {
	Create     *AdminUserCreateWithoutUpdateNotificationInput     `json:"create,omitempty"`
	Update     *AdminUserUpdateWithoutUpdateNotificationDataInput `json:"update,omitempty"`
	Upsert     *AdminUserUpsertWithoutUpdateNotificationInput     `json:"upsert,omitempty"`
	Delete     *bool                                              `json:"delete,omitempty"`
	Disconnect *bool                                              `json:"disconnect,omitempty"`
	Connect    *AdminUserWhereUniqueInput                         `json:"connect,omitempty"`
}

type AdminUserUpdateWithoutUpdateNotificationDataInput struct {
	Role               *Role                                        `json:"role,omitempty"`
	Email              *string                                      `json:"email,omitempty"`
	Password           *string                                      `json:"password,omitempty"`
	NickName           *string                                      `json:"nickName,omitempty"`
	OtpKey             *string                                      `json:"otpKey,omitempty"`
	Level              *string                                      `json:"level,omitempty"`
	Members            *UserUpdateManyWithoutAdminUserInput         `json:"members,omitempty"`
	CreateNotification *NotificationUpdateOneWithoutCreateUserInput `json:"createNotification,omitempty"`
}

type AdminUserUpsertWithoutUpdateNotificationInput struct {
	Update AdminUserUpdateWithoutUpdateNotificationDataInput `json:"update"`
	Create AdminUserCreateWithoutUpdateNotificationInput     `json:"create"`
}

type NotificationUpsertWithoutCreateUserInput struct {
	Update NotificationUpdateWithoutCreateUserDataInput `json:"update"`
	Create NotificationCreateWithoutCreateUserInput     `json:"create"`
}

type AdminUserUpsertWithoutMembersInput struct {
	Update AdminUserUpdateWithoutMembersDataInput `json:"update"`
	Create AdminUserCreateWithoutMembersInput     `json:"create"`
}

type UserUpsertWithoutPostRewardHistoriesInput struct {
	Update UserUpdateWithoutPostRewardHistoriesDataInput `json:"update"`
	Create UserCreateWithoutPostRewardHistoriesInput     `json:"create"`
}

type PostRewardHistoryUpsertWithWhereUniqueWithoutPostInput struct {
	Where  PostRewardHistoryWhereUniqueInput           `json:"where"`
	Update PostRewardHistoryUpdateWithoutPostDataInput `json:"update"`
	Create PostRewardHistoryCreateWithoutPostInput     `json:"create"`
}

type PostUpsertWithoutQuestMembersInput struct {
	Update PostUpdateWithoutQuestMembersDataInput `json:"update"`
	Create PostCreateWithoutQuestMembersInput     `json:"create"`
}

type QuestMemberUpsertWithWhereUniqueWithoutUserInput struct {
	Where  QuestMemberWhereUniqueInput           `json:"where"`
	Update QuestMemberUpdateWithoutUserDataInput `json:"update"`
	Create QuestMemberCreateWithoutUserInput     `json:"create"`
}

type QuestMemberScalarWhereInput struct {
	ID                *string                       `json:"id,omitempty"`
	IDNot             *string                       `json:"id_not,omitempty"`
	IDIn              []string                      `json:"id_in,omitempty"`
	IDNotIn           []string                      `json:"id_not_in,omitempty"`
	IDLt              *string                       `json:"id_lt,omitempty"`
	IDLte             *string                       `json:"id_lte,omitempty"`
	IDGt              *string                       `json:"id_gt,omitempty"`
	IDGte             *string                       `json:"id_gte,omitempty"`
	IDContains        *string                       `json:"id_contains,omitempty"`
	IDNotContains     *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                       `json:"id_not_ends_with,omitempty"`
	Note              *string                       `json:"note,omitempty"`
	NoteNot           *string                       `json:"note_not,omitempty"`
	NoteIn            []string                      `json:"note_in,omitempty"`
	NoteNotIn         []string                      `json:"note_not_in,omitempty"`
	NoteLt            *string                       `json:"note_lt,omitempty"`
	NoteLte           *string                       `json:"note_lte,omitempty"`
	NoteGt            *string                       `json:"note_gt,omitempty"`
	NoteGte           *string                       `json:"note_gte,omitempty"`
	NoteContains      *string                       `json:"note_contains,omitempty"`
	NoteNotContains   *string                       `json:"note_not_contains,omitempty"`
	NoteStartsWith    *string                       `json:"note_starts_with,omitempty"`
	NoteNotStartsWith *string                       `json:"note_not_starts_with,omitempty"`
	NoteEndsWith      *string                       `json:"note_ends_with,omitempty"`
	NoteNotEndsWith   *string                       `json:"note_not_ends_with,omitempty"`
	CreatedAt         *string                       `json:"createdAt,omitempty"`
	CreatedAtNot      *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                       `json:"createdAt_gte,omitempty"`
	IsDel             *bool                         `json:"isDel,omitempty"`
	IsDelNot          *bool                         `json:"isDel_not,omitempty"`
	And               []QuestMemberScalarWhereInput `json:"AND,omitempty"`
	Or                []QuestMemberScalarWhereInput `json:"OR,omitempty"`
	Not               []QuestMemberScalarWhereInput `json:"NOT,omitempty"`
}

type QuestMemberUpdateManyWithWhereNestedInput struct {
	Where QuestMemberScalarWhereInput    `json:"where"`
	Data  QuestMemberUpdateManyDataInput `json:"data"`
}

type QuestMemberUpdateManyDataInput struct {
	Note  *string `json:"note,omitempty"`
	IsDel *bool   `json:"isDel,omitempty"`
}

type UserUpsertWithoutMyReportInput struct {
	Update UserUpdateWithoutMyReportDataInput `json:"update"`
	Create UserCreateWithoutMyReportInput     `json:"create"`
}

type ReportUpsertWithWhereUniqueWithoutTargetUserInput struct {
	Where  ReportWhereUniqueInput                 `json:"where"`
	Update ReportUpdateWithoutTargetUserDataInput `json:"update"`
	Create ReportCreateWithoutTargetUserInput     `json:"create"`
}

type ReportScalarWhereInput struct {
	ID              *string                  `json:"id,omitempty"`
	IDNot           *string                  `json:"id_not,omitempty"`
	IDIn            []string                 `json:"id_in,omitempty"`
	IDNotIn         []string                 `json:"id_not_in,omitempty"`
	IDLt            *string                  `json:"id_lt,omitempty"`
	IDLte           *string                  `json:"id_lte,omitempty"`
	IDGt            *string                  `json:"id_gt,omitempty"`
	IDGte           *string                  `json:"id_gte,omitempty"`
	IDContains      *string                  `json:"id_contains,omitempty"`
	IDNotContains   *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                  `json:"id_not_ends_with,omitempty"`
	Type            *int32                   `json:"type,omitempty"`
	TypeNot         *int32                   `json:"type_not,omitempty"`
	TypeIn          []int32                  `json:"type_in,omitempty"`
	TypeNotIn       []int32                  `json:"type_not_in,omitempty"`
	TypeLt          *int32                   `json:"type_lt,omitempty"`
	TypeLte         *int32                   `json:"type_lte,omitempty"`
	TypeGt          *int32                   `json:"type_gt,omitempty"`
	TypeGte         *int32                   `json:"type_gte,omitempty"`
	ReportType      *int32                   `json:"reportType,omitempty"`
	ReportTypeNot   *int32                   `json:"reportType_not,omitempty"`
	ReportTypeIn    []int32                  `json:"reportType_in,omitempty"`
	ReportTypeNotIn []int32                  `json:"reportType_not_in,omitempty"`
	ReportTypeLt    *int32                   `json:"reportType_lt,omitempty"`
	ReportTypeLte   *int32                   `json:"reportType_lte,omitempty"`
	ReportTypeGt    *int32                   `json:"reportType_gt,omitempty"`
	ReportTypeGte   *int32                   `json:"reportType_gte,omitempty"`
	CreatedAt       *string                  `json:"createdAt,omitempty"`
	CreatedAtNot    *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                  `json:"createdAt_gte,omitempty"`
	And             []ReportScalarWhereInput `json:"AND,omitempty"`
	Or              []ReportScalarWhereInput `json:"OR,omitempty"`
	Not             []ReportScalarWhereInput `json:"NOT,omitempty"`
}

type ReportUpdateManyWithWhereNestedInput struct {
	Where ReportScalarWhereInput    `json:"where"`
	Data  ReportUpdateManyDataInput `json:"data"`
}

type ReportUpdateManyDataInput struct {
	Type       *int32 `json:"type,omitempty"`
	ReportType *int32 `json:"reportType,omitempty"`
}

type UserUpsertWithoutOrderHistoriesInput struct {
	Update UserUpdateWithoutOrderHistoriesDataInput `json:"update"`
	Create UserCreateWithoutOrderHistoriesInput     `json:"create"`
}

type OrderHistoryUpsertWithWhereUniqueWithoutCoinInput struct {
	Where  OrderHistoryWhereUniqueInput           `json:"where"`
	Update OrderHistoryUpdateWithoutCoinDataInput `json:"update"`
	Create OrderHistoryCreateWithoutCoinInput     `json:"create"`
}

type CoinUpsertWithoutOfferInput struct {
	Update CoinUpdateWithoutOfferDataInput `json:"update"`
	Create CoinCreateWithoutOfferInput     `json:"create"`
}

type OfferUpsertWithoutOfferorInput struct {
	Update OfferUpdateWithoutOfferorDataInput `json:"update"`
	Create OfferCreateWithoutOfferorInput     `json:"create"`
}

type OfferorUpsertWithWhereUniqueWithoutUserInput struct {
	Where  OfferorWhereUniqueInput           `json:"where"`
	Update OfferorUpdateWithoutUserDataInput `json:"update"`
	Create OfferorCreateWithoutUserInput     `json:"create"`
}

type OfferorScalarWhereInput struct {
	ID              *string                   `json:"id,omitempty"`
	IDNot           *string                   `json:"id_not,omitempty"`
	IDIn            []string                  `json:"id_in,omitempty"`
	IDNotIn         []string                  `json:"id_not_in,omitempty"`
	IDLt            *string                   `json:"id_lt,omitempty"`
	IDLte           *string                   `json:"id_lte,omitempty"`
	IDGt            *string                   `json:"id_gt,omitempty"`
	IDGte           *string                   `json:"id_gte,omitempty"`
	IDContains      *string                   `json:"id_contains,omitempty"`
	IDNotContains   *string                   `json:"id_not_contains,omitempty"`
	IDStartsWith    *string                   `json:"id_starts_with,omitempty"`
	IDNotStartsWith *string                   `json:"id_not_starts_with,omitempty"`
	IDEndsWith      *string                   `json:"id_ends_with,omitempty"`
	IDNotEndsWith   *string                   `json:"id_not_ends_with,omitempty"`
	Price           *int32                    `json:"price,omitempty"`
	PriceNot        *int32                    `json:"price_not,omitempty"`
	PriceIn         []int32                   `json:"price_in,omitempty"`
	PriceNotIn      []int32                   `json:"price_not_in,omitempty"`
	PriceLt         *int32                    `json:"price_lt,omitempty"`
	PriceLte        *int32                    `json:"price_lte,omitempty"`
	PriceGt         *int32                    `json:"price_gt,omitempty"`
	PriceGte        *int32                    `json:"price_gte,omitempty"`
	CreatedAt       *string                   `json:"createdAt,omitempty"`
	CreatedAtNot    *string                   `json:"createdAt_not,omitempty"`
	CreatedAtIn     []string                  `json:"createdAt_in,omitempty"`
	CreatedAtNotIn  []string                  `json:"createdAt_not_in,omitempty"`
	CreatedAtLt     *string                   `json:"createdAt_lt,omitempty"`
	CreatedAtLte    *string                   `json:"createdAt_lte,omitempty"`
	CreatedAtGt     *string                   `json:"createdAt_gt,omitempty"`
	CreatedAtGte    *string                   `json:"createdAt_gte,omitempty"`
	UpdatedAt       *string                   `json:"updatedAt,omitempty"`
	UpdatedAtNot    *string                   `json:"updatedAt_not,omitempty"`
	UpdatedAtIn     []string                  `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn  []string                  `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt     *string                   `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte    *string                   `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt     *string                   `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte    *string                   `json:"updatedAt_gte,omitempty"`
	And             []OfferorScalarWhereInput `json:"AND,omitempty"`
	Or              []OfferorScalarWhereInput `json:"OR,omitempty"`
	Not             []OfferorScalarWhereInput `json:"NOT,omitempty"`
}

type OfferorUpdateManyWithWhereNestedInput struct {
	Where OfferorScalarWhereInput    `json:"where"`
	Data  OfferorUpdateManyDataInput `json:"data"`
}

type OfferorUpdateManyDataInput struct {
	Price *int32 `json:"price,omitempty"`
}

type UserUpsertWithoutQuestExpenditureHistoriesInput struct {
	Update UserUpdateWithoutQuestExpenditureHistoriesDataInput `json:"update"`
	Create UserCreateWithoutQuestExpenditureHistoriesInput     `json:"create"`
}

type QuestExpenditureHistoryUpsertWithWhereUniqueWithoutPostInput struct {
	Where  QuestExpenditureHistoryWhereUniqueInput           `json:"where"`
	Update QuestExpenditureHistoryUpdateWithoutPostDataInput `json:"update"`
	Create QuestExpenditureHistoryCreateWithoutPostInput     `json:"create"`
}

type PostUpsertNestedInput struct {
	Update PostUpdateDataInput `json:"update"`
	Create PostCreateInput     `json:"create"`
}

type UserUpdateOneWithoutTargetReportInput struct {
	Create     *UserCreateWithoutTargetReportInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutTargetReportDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutTargetReportInput     `json:"upsert,omitempty"`
	Delete     *bool                                   `json:"delete,omitempty"`
	Disconnect *bool                                   `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                   `json:"connect,omitempty"`
}

type UserUpdateWithoutTargetReportDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type UserUpsertWithoutTargetReportInput struct {
	Update UserUpdateWithoutTargetReportDataInput `json:"update"`
	Create UserCreateWithoutTargetReportInput     `json:"create"`
}

type ReportUpsertWithWhereUniqueWithoutReportUserInput struct {
	Where  ReportWhereUniqueInput                 `json:"where"`
	Update ReportUpdateWithoutReportUserDataInput `json:"update"`
	Create ReportCreateWithoutReportUserInput     `json:"create"`
}

type UserUpsertWithoutJoinOfferInput struct {
	Update UserUpdateWithoutJoinOfferDataInput `json:"update"`
	Create UserCreateWithoutJoinOfferInput     `json:"create"`
}

type OfferorUpsertWithWhereUniqueWithoutOfferInput struct {
	Where  OfferorWhereUniqueInput            `json:"where"`
	Update OfferorUpdateWithoutOfferDataInput `json:"update"`
	Create OfferorCreateWithoutOfferInput     `json:"create"`
}

type OfferUpsertWithoutCoinInput struct {
	Update OfferUpdateWithoutCoinDataInput `json:"update"`
	Create OfferCreateWithoutCoinInput     `json:"create"`
}

type CoinUpsertWithoutMotherHistoriesInput struct {
	Update CoinUpdateWithoutMotherHistoriesDataInput `json:"update"`
	Create CoinCreateWithoutMotherHistoriesInput     `json:"create"`
}

type MotherHistoryUpsertWithWhereUniqueWithoutPostInput struct {
	Where  MotherHistoryWhereUniqueInput           `json:"where"`
	Update MotherHistoryUpdateWithoutPostDataInput `json:"update"`
	Create MotherHistoryCreateWithoutPostInput     `json:"create"`
}

type PostUpsertWithWhereUniqueWithoutViewsInput struct {
	Where  PostWhereUniqueInput            `json:"where"`
	Update PostUpdateWithoutViewsDataInput `json:"update"`
	Create PostCreateWithoutViewsInput     `json:"create"`
}

type PostScalarWhereInput struct {
	ID                         *string                `json:"id,omitempty"`
	IDNot                      *string                `json:"id_not,omitempty"`
	IDIn                       []string               `json:"id_in,omitempty"`
	IDNotIn                    []string               `json:"id_not_in,omitempty"`
	IDLt                       *string                `json:"id_lt,omitempty"`
	IDLte                      *string                `json:"id_lte,omitempty"`
	IDGt                       *string                `json:"id_gt,omitempty"`
	IDGte                      *string                `json:"id_gte,omitempty"`
	IDContains                 *string                `json:"id_contains,omitempty"`
	IDNotContains              *string                `json:"id_not_contains,omitempty"`
	IDStartsWith               *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith            *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith                 *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith              *string                `json:"id_not_ends_with,omitempty"`
	Type                       *int32                 `json:"type,omitempty"`
	TypeNot                    *int32                 `json:"type_not,omitempty"`
	TypeIn                     []int32                `json:"type_in,omitempty"`
	TypeNotIn                  []int32                `json:"type_not_in,omitempty"`
	TypeLt                     *int32                 `json:"type_lt,omitempty"`
	TypeLte                    *int32                 `json:"type_lte,omitempty"`
	TypeGt                     *int32                 `json:"type_gt,omitempty"`
	TypeGte                    *int32                 `json:"type_gte,omitempty"`
	PayType                    *int32                 `json:"payType,omitempty"`
	PayTypeNot                 *int32                 `json:"payType_not,omitempty"`
	PayTypeIn                  []int32                `json:"payType_in,omitempty"`
	PayTypeNotIn               []int32                `json:"payType_not_in,omitempty"`
	PayTypeLt                  *int32                 `json:"payType_lt,omitempty"`
	PayTypeLte                 *int32                 `json:"payType_lte,omitempty"`
	PayTypeGt                  *int32                 `json:"payType_gt,omitempty"`
	PayTypeGte                 *int32                 `json:"payType_gte,omitempty"`
	Content                    *string                `json:"content,omitempty"`
	ContentNot                 *string                `json:"content_not,omitempty"`
	ContentIn                  []string               `json:"content_in,omitempty"`
	ContentNotIn               []string               `json:"content_not_in,omitempty"`
	ContentLt                  *string                `json:"content_lt,omitempty"`
	ContentLte                 *string                `json:"content_lte,omitempty"`
	ContentGt                  *string                `json:"content_gt,omitempty"`
	ContentGte                 *string                `json:"content_gte,omitempty"`
	ContentContains            *string                `json:"content_contains,omitempty"`
	ContentNotContains         *string                `json:"content_not_contains,omitempty"`
	ContentStartsWith          *string                `json:"content_starts_with,omitempty"`
	ContentNotStartsWith       *string                `json:"content_not_starts_with,omitempty"`
	ContentEndsWith            *string                `json:"content_ends_with,omitempty"`
	ContentNotEndsWith         *string                `json:"content_not_ends_with,omitempty"`
	QuestTitle                 *string                `json:"questTitle,omitempty"`
	QuestTitleNot              *string                `json:"questTitle_not,omitempty"`
	QuestTitleIn               []string               `json:"questTitle_in,omitempty"`
	QuestTitleNotIn            []string               `json:"questTitle_not_in,omitempty"`
	QuestTitleLt               *string                `json:"questTitle_lt,omitempty"`
	QuestTitleLte              *string                `json:"questTitle_lte,omitempty"`
	QuestTitleGt               *string                `json:"questTitle_gt,omitempty"`
	QuestTitleGte              *string                `json:"questTitle_gte,omitempty"`
	QuestTitleContains         *string                `json:"questTitle_contains,omitempty"`
	QuestTitleNotContains      *string                `json:"questTitle_not_contains,omitempty"`
	QuestTitleStartsWith       *string                `json:"questTitle_starts_with,omitempty"`
	QuestTitleNotStartsWith    *string                `json:"questTitle_not_starts_with,omitempty"`
	QuestTitleEndsWith         *string                `json:"questTitle_ends_with,omitempty"`
	QuestTitleNotEndsWith      *string                `json:"questTitle_not_ends_with,omitempty"`
	QuestCost                  *float64               `json:"questCost,omitempty"`
	QuestCostNot               *float64               `json:"questCost_not,omitempty"`
	QuestCostIn                []float64              `json:"questCost_in,omitempty"`
	QuestCostNotIn             []float64              `json:"questCost_not_in,omitempty"`
	QuestCostLt                *float64               `json:"questCost_lt,omitempty"`
	QuestCostLte               *float64               `json:"questCost_lte,omitempty"`
	QuestCostGt                *float64               `json:"questCost_gt,omitempty"`
	QuestCostGte               *float64               `json:"questCost_gte,omitempty"`
	QuestMinMemberCount        *int32                 `json:"questMinMemberCount,omitempty"`
	QuestMinMemberCountNot     *int32                 `json:"questMinMemberCount_not,omitempty"`
	QuestMinMemberCountIn      []int32                `json:"questMinMemberCount_in,omitempty"`
	QuestMinMemberCountNotIn   []int32                `json:"questMinMemberCount_not_in,omitempty"`
	QuestMinMemberCountLt      *int32                 `json:"questMinMemberCount_lt,omitempty"`
	QuestMinMemberCountLte     *int32                 `json:"questMinMemberCount_lte,omitempty"`
	QuestMinMemberCountGt      *int32                 `json:"questMinMemberCount_gt,omitempty"`
	QuestMinMemberCountGte     *int32                 `json:"questMinMemberCount_gte,omitempty"`
	QuestLimitMemberCount      *int32                 `json:"questLimitMemberCount,omitempty"`
	QuestLimitMemberCountNot   *int32                 `json:"questLimitMemberCount_not,omitempty"`
	QuestLimitMemberCountIn    []int32                `json:"questLimitMemberCount_in,omitempty"`
	QuestLimitMemberCountNotIn []int32                `json:"questLimitMemberCount_not_in,omitempty"`
	QuestLimitMemberCountLt    *int32                 `json:"questLimitMemberCount_lt,omitempty"`
	QuestLimitMemberCountLte   *int32                 `json:"questLimitMemberCount_lte,omitempty"`
	QuestLimitMemberCountGt    *int32                 `json:"questLimitMemberCount_gt,omitempty"`
	QuestLimitMemberCountGte   *int32                 `json:"questLimitMemberCount_gte,omitempty"`
	QuestToDate                *string                `json:"questToDate,omitempty"`
	QuestToDateNot             *string                `json:"questToDate_not,omitempty"`
	QuestToDateIn              []string               `json:"questToDate_in,omitempty"`
	QuestToDateNotIn           []string               `json:"questToDate_not_in,omitempty"`
	QuestToDateLt              *string                `json:"questToDate_lt,omitempty"`
	QuestToDateLte             *string                `json:"questToDate_lte,omitempty"`
	QuestToDateGt              *string                `json:"questToDate_gt,omitempty"`
	QuestToDateGte             *string                `json:"questToDate_gte,omitempty"`
	QuestStatus                *int32                 `json:"questStatus,omitempty"`
	QuestStatusNot             *int32                 `json:"questStatus_not,omitempty"`
	QuestStatusIn              []int32                `json:"questStatus_in,omitempty"`
	QuestStatusNotIn           []int32                `json:"questStatus_not_in,omitempty"`
	QuestStatusLt              *int32                 `json:"questStatus_lt,omitempty"`
	QuestStatusLte             *int32                 `json:"questStatus_lte,omitempty"`
	QuestStatusGt              *int32                 `json:"questStatus_gt,omitempty"`
	QuestStatusGte             *int32                 `json:"questStatus_gte,omitempty"`
	CreatedAt                  *string                `json:"createdAt,omitempty"`
	CreatedAtNot               *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn                []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn             []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte               *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt                *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte               *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt                  *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot               *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn             []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte               *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte               *string                `json:"updatedAt_gte,omitempty"`
	IsBanner                   *bool                  `json:"isBanner,omitempty"`
	IsBannerNot                *bool                  `json:"isBanner_not,omitempty"`
	IsDel                      *bool                  `json:"isDel,omitempty"`
	IsDelNot                   *bool                  `json:"isDel_not,omitempty"`
	EnableEarlyAccess          *bool                  `json:"enableEarlyAccess,omitempty"`
	EnableEarlyAccessNot       *bool                  `json:"enableEarlyAccess_not,omitempty"`
	PublicAccessAt             *string                `json:"publicAccessAt,omitempty"`
	PublicAccessAtNot          *string                `json:"publicAccessAt_not,omitempty"`
	PublicAccessAtIn           []string               `json:"publicAccessAt_in,omitempty"`
	PublicAccessAtNotIn        []string               `json:"publicAccessAt_not_in,omitempty"`
	PublicAccessAtLt           *string                `json:"publicAccessAt_lt,omitempty"`
	PublicAccessAtLte          *string                `json:"publicAccessAt_lte,omitempty"`
	PublicAccessAtGt           *string                `json:"publicAccessAt_gt,omitempty"`
	PublicAccessAtGte          *string                `json:"publicAccessAt_gte,omitempty"`
	OrderIndex                 *float64               `json:"order_index,omitempty"`
	OrderIndexNot              *float64               `json:"order_index_not,omitempty"`
	OrderIndexIn               []float64              `json:"order_index_in,omitempty"`
	OrderIndexNotIn            []float64              `json:"order_index_not_in,omitempty"`
	OrderIndexLt               *float64               `json:"order_index_lt,omitempty"`
	OrderIndexLte              *float64               `json:"order_index_lte,omitempty"`
	OrderIndexGt               *float64               `json:"order_index_gt,omitempty"`
	OrderIndexGte              *float64               `json:"order_index_gte,omitempty"`
	And                        []PostScalarWhereInput `json:"AND,omitempty"`
	Or                         []PostScalarWhereInput `json:"OR,omitempty"`
	Not                        []PostScalarWhereInput `json:"NOT,omitempty"`
}

type PostUpdateManyWithWhereNestedInput struct {
	Where PostScalarWhereInput    `json:"where"`
	Data  PostUpdateManyDataInput `json:"data"`
}

type PostUpdateManyDataInput struct {
	Type                  *int32   `json:"type,omitempty"`
	PayType               *int32   `json:"payType,omitempty"`
	Content               *string  `json:"content,omitempty"`
	QuestTitle            *string  `json:"questTitle,omitempty"`
	QuestCost             *float64 `json:"questCost,omitempty"`
	QuestMinMemberCount   *int32   `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount *int32   `json:"questLimitMemberCount,omitempty"`
	QuestToDate           *string  `json:"questToDate,omitempty"`
	QuestStatus           *int32   `json:"questStatus,omitempty"`
	IsBanner              *bool    `json:"isBanner,omitempty"`
	IsDel                 *bool    `json:"isDel,omitempty"`
	EnableEarlyAccess     *bool    `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt        *string  `json:"publicAccessAt,omitempty"`
	OrderIndex            *float64 `json:"order_index,omitempty"`
}

type UserUpsertWithoutJoinedQuestsInput struct {
	Update UserUpdateWithoutJoinedQuestsDataInput `json:"update"`
	Create UserCreateWithoutJoinedQuestsInput     `json:"create"`
}

type QuestMemberUpsertWithWhereUniqueWithoutPostInput struct {
	Where  QuestMemberWhereUniqueInput           `json:"where"`
	Update QuestMemberUpdateWithoutPostDataInput `json:"update"`
	Create QuestMemberCreateWithoutPostInput     `json:"create"`
}

type PostUpsertWithWhereUniqueWithoutLikesInput struct {
	Where  PostWhereUniqueInput            `json:"where"`
	Update PostUpdateWithoutLikesDataInput `json:"update"`
	Create PostCreateWithoutLikesInput     `json:"create"`
}

type UserUpsertWithoutFileListInput struct {
	Update UserUpdateWithoutFileListDataInput `json:"update"`
	Create UserCreateWithoutFileListInput     `json:"create"`
}

type FileInfoUpsertWithWhereUniqueWithoutPostInput struct {
	Where  FileInfoWhereUniqueInput           `json:"where"`
	Update FileInfoUpdateWithoutPostDataInput `json:"update"`
	Create FileInfoCreateWithoutPostInput     `json:"create"`
}

type FileInfoScalarWhereInput struct {
	ID                        *string                    `json:"id,omitempty"`
	IDNot                     *string                    `json:"id_not,omitempty"`
	IDIn                      []string                   `json:"id_in,omitempty"`
	IDNotIn                   []string                   `json:"id_not_in,omitempty"`
	IDLt                      *string                    `json:"id_lt,omitempty"`
	IDLte                     *string                    `json:"id_lte,omitempty"`
	IDGt                      *string                    `json:"id_gt,omitempty"`
	IDGte                     *string                    `json:"id_gte,omitempty"`
	IDContains                *string                    `json:"id_contains,omitempty"`
	IDNotContains             *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith              *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith           *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith                *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith             *string                    `json:"id_not_ends_with,omitempty"`
	TempFileId                *string                    `json:"tempFileId,omitempty"`
	TempFileIdNot             *string                    `json:"tempFileId_not,omitempty"`
	TempFileIdIn              []string                   `json:"tempFileId_in,omitempty"`
	TempFileIdNotIn           []string                   `json:"tempFileId_not_in,omitempty"`
	TempFileIdLt              *string                    `json:"tempFileId_lt,omitempty"`
	TempFileIdLte             *string                    `json:"tempFileId_lte,omitempty"`
	TempFileIdGt              *string                    `json:"tempFileId_gt,omitempty"`
	TempFileIdGte             *string                    `json:"tempFileId_gte,omitempty"`
	TempFileIdContains        *string                    `json:"tempFileId_contains,omitempty"`
	TempFileIdNotContains     *string                    `json:"tempFileId_not_contains,omitempty"`
	TempFileIdStartsWith      *string                    `json:"tempFileId_starts_with,omitempty"`
	TempFileIdNotStartsWith   *string                    `json:"tempFileId_not_starts_with,omitempty"`
	TempFileIdEndsWith        *string                    `json:"tempFileId_ends_with,omitempty"`
	TempFileIdNotEndsWith     *string                    `json:"tempFileId_not_ends_with,omitempty"`
	LocationPath              *string                    `json:"locationPath,omitempty"`
	LocationPathNot           *string                    `json:"locationPath_not,omitempty"`
	LocationPathIn            []string                   `json:"locationPath_in,omitempty"`
	LocationPathNotIn         []string                   `json:"locationPath_not_in,omitempty"`
	LocationPathLt            *string                    `json:"locationPath_lt,omitempty"`
	LocationPathLte           *string                    `json:"locationPath_lte,omitempty"`
	LocationPathGt            *string                    `json:"locationPath_gt,omitempty"`
	LocationPathGte           *string                    `json:"locationPath_gte,omitempty"`
	LocationPathContains      *string                    `json:"locationPath_contains,omitempty"`
	LocationPathNotContains   *string                    `json:"locationPath_not_contains,omitempty"`
	LocationPathStartsWith    *string                    `json:"locationPath_starts_with,omitempty"`
	LocationPathNotStartsWith *string                    `json:"locationPath_not_starts_with,omitempty"`
	LocationPathEndsWith      *string                    `json:"locationPath_ends_with,omitempty"`
	LocationPathNotEndsWith   *string                    `json:"locationPath_not_ends_with,omitempty"`
	Name                      *string                    `json:"name,omitempty"`
	NameNot                   *string                    `json:"name_not,omitempty"`
	NameIn                    []string                   `json:"name_in,omitempty"`
	NameNotIn                 []string                   `json:"name_not_in,omitempty"`
	NameLt                    *string                    `json:"name_lt,omitempty"`
	NameLte                   *string                    `json:"name_lte,omitempty"`
	NameGt                    *string                    `json:"name_gt,omitempty"`
	NameGte                   *string                    `json:"name_gte,omitempty"`
	NameContains              *string                    `json:"name_contains,omitempty"`
	NameNotContains           *string                    `json:"name_not_contains,omitempty"`
	NameStartsWith            *string                    `json:"name_starts_with,omitempty"`
	NameNotStartsWith         *string                    `json:"name_not_starts_with,omitempty"`
	NameEndsWith              *string                    `json:"name_ends_with,omitempty"`
	NameNotEndsWith           *string                    `json:"name_not_ends_with,omitempty"`
	ContentType               *string                    `json:"contentType,omitempty"`
	ContentTypeNot            *string                    `json:"contentType_not,omitempty"`
	ContentTypeIn             []string                   `json:"contentType_in,omitempty"`
	ContentTypeNotIn          []string                   `json:"contentType_not_in,omitempty"`
	ContentTypeLt             *string                    `json:"contentType_lt,omitempty"`
	ContentTypeLte            *string                    `json:"contentType_lte,omitempty"`
	ContentTypeGt             *string                    `json:"contentType_gt,omitempty"`
	ContentTypeGte            *string                    `json:"contentType_gte,omitempty"`
	ContentTypeContains       *string                    `json:"contentType_contains,omitempty"`
	ContentTypeNotContains    *string                    `json:"contentType_not_contains,omitempty"`
	ContentTypeStartsWith     *string                    `json:"contentType_starts_with,omitempty"`
	ContentTypeNotStartsWith  *string                    `json:"contentType_not_starts_with,omitempty"`
	ContentTypeEndsWith       *string                    `json:"contentType_ends_with,omitempty"`
	ContentTypeNotEndsWith    *string                    `json:"contentType_not_ends_with,omitempty"`
	Url                       *string                    `json:"url,omitempty"`
	UrlNot                    *string                    `json:"url_not,omitempty"`
	UrlIn                     []string                   `json:"url_in,omitempty"`
	UrlNotIn                  []string                   `json:"url_not_in,omitempty"`
	UrlLt                     *string                    `json:"url_lt,omitempty"`
	UrlLte                    *string                    `json:"url_lte,omitempty"`
	UrlGt                     *string                    `json:"url_gt,omitempty"`
	UrlGte                    *string                    `json:"url_gte,omitempty"`
	UrlContains               *string                    `json:"url_contains,omitempty"`
	UrlNotContains            *string                    `json:"url_not_contains,omitempty"`
	UrlStartsWith             *string                    `json:"url_starts_with,omitempty"`
	UrlNotStartsWith          *string                    `json:"url_not_starts_with,omitempty"`
	UrlEndsWith               *string                    `json:"url_ends_with,omitempty"`
	UrlNotEndsWith            *string                    `json:"url_not_ends_with,omitempty"`
	IsVideo                   *bool                      `json:"isVideo,omitempty"`
	IsVideoNot                *bool                      `json:"isVideo_not,omitempty"`
	IsDel                     *bool                      `json:"isDel,omitempty"`
	IsDelNot                  *bool                      `json:"isDel_not,omitempty"`
	CreatedAt                 *string                    `json:"createdAt,omitempty"`
	CreatedAtNot              *string                    `json:"createdAt_not,omitempty"`
	CreatedAtIn               []string                   `json:"createdAt_in,omitempty"`
	CreatedAtNotIn            []string                   `json:"createdAt_not_in,omitempty"`
	CreatedAtLt               *string                    `json:"createdAt_lt,omitempty"`
	CreatedAtLte              *string                    `json:"createdAt_lte,omitempty"`
	CreatedAtGt               *string                    `json:"createdAt_gt,omitempty"`
	CreatedAtGte              *string                    `json:"createdAt_gte,omitempty"`
	And                       []FileInfoScalarWhereInput `json:"AND,omitempty"`
	Or                        []FileInfoScalarWhereInput `json:"OR,omitempty"`
	Not                       []FileInfoScalarWhereInput `json:"NOT,omitempty"`
}

type FileInfoUpdateManyWithWhereNestedInput struct {
	Where FileInfoScalarWhereInput    `json:"where"`
	Data  FileInfoUpdateManyDataInput `json:"data"`
}

type FileInfoUpdateManyDataInput struct {
	TempFileId   *string `json:"tempFileId,omitempty"`
	LocationPath *string `json:"locationPath,omitempty"`
	Name         *string `json:"name,omitempty"`
	ContentType  *string `json:"contentType,omitempty"`
	Url          *string `json:"url,omitempty"`
	IsVideo      *bool   `json:"isVideo,omitempty"`
	IsDel        *bool   `json:"isDel,omitempty"`
}

type PostUpsertWithWhereUniqueWithoutCoinInput struct {
	Where  PostWhereUniqueInput           `json:"where"`
	Update PostUpdateWithoutCoinDataInput `json:"update"`
	Create PostCreateWithoutCoinInput     `json:"create"`
}

type CoinUpsertWithoutPictureInput struct {
	Update CoinUpdateWithoutPictureDataInput `json:"update"`
	Create CoinCreateWithoutPictureInput     `json:"create"`
}

type FileInfoUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  FileInfoWhereUniqueInput            `json:"where"`
	Update FileInfoUpdateWithoutOwnerDataInput `json:"update"`
	Create FileInfoCreateWithoutOwnerInput     `json:"create"`
}

type UserUpsertWithoutCoinInput struct {
	Update UserUpdateWithoutCoinDataInput `json:"update"`
	Create UserCreateWithoutCoinInput     `json:"create"`
}

type CoinUpsertWithoutImageInput struct {
	Update CoinUpdateWithoutImageDataInput `json:"update"`
	Create CoinCreateWithoutImageInput     `json:"create"`
}

type UserUpdateOneWithoutFilesInput struct {
	Create     *UserCreateWithoutFilesInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutFilesDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutFilesInput     `json:"upsert,omitempty"`
	Delete     *bool                            `json:"delete,omitempty"`
	Disconnect *bool                            `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput            `json:"connect,omitempty"`
}

type UserUpdateWithoutFilesDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type UserUpsertWithoutFilesInput struct {
	Update UserUpdateWithoutFilesDataInput `json:"update"`
	Create UserCreateWithoutFilesInput     `json:"create"`
}

type FileUpsertWithoutPostInput struct {
	Update FileUpdateWithoutPostDataInput `json:"update"`
	Create FileCreateWithoutPostInput     `json:"create"`
}

type PostUpsertWithoutCommentsInput struct {
	Update PostUpdateWithoutCommentsDataInput `json:"update"`
	Create PostCreateWithoutCommentsInput     `json:"create"`
}

type CommentUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  CommentWhereUniqueInput            `json:"where"`
	Update CommentUpdateWithoutOwnerDataInput `json:"update"`
	Create CommentCreateWithoutOwnerInput     `json:"create"`
}

type UserUpsertWithoutAirDropMembersInput struct {
	Update UserUpdateWithoutAirDropMembersDataInput `json:"update"`
	Create UserCreateWithoutAirDropMembersInput     `json:"create"`
}

type AirDropMemberUpsertWithWhereUniqueWithoutAirDropInput struct {
	Where  AirDropMemberWhereUniqueInput              `json:"where"`
	Update AirDropMemberUpdateWithoutAirDropDataInput `json:"update"`
	Create AirDropMemberCreateWithoutAirDropInput     `json:"create"`
}

type AirDropUpsertWithoutPostInput struct {
	Update AirDropUpdateWithoutPostDataInput `json:"update"`
	Create AirDropCreateWithoutPostInput     `json:"create"`
}

type PostUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  PostWhereUniqueInput            `json:"where"`
	Update PostUpdateWithoutOwnerDataInput `json:"update"`
	Create PostCreateWithoutOwnerInput     `json:"create"`
}

type UserUpsertWithoutWalletsInput struct {
	Update UserUpdateWithoutWalletsDataInput `json:"update"`
	Create UserCreateWithoutWalletsInput     `json:"create"`
}

type WalletUpsertWithWhereUniqueWithoutCoinInput struct {
	Where  WalletWhereUniqueInput           `json:"where"`
	Update WalletUpdateWithoutCoinDataInput `json:"update"`
	Create WalletCreateWithoutCoinInput     `json:"create"`
}

type WalletScalarWhereInput struct {
	ID                              *string                  `json:"id,omitempty"`
	IDNot                           *string                  `json:"id_not,omitempty"`
	IDIn                            []string                 `json:"id_in,omitempty"`
	IDNotIn                         []string                 `json:"id_not_in,omitempty"`
	IDLt                            *string                  `json:"id_lt,omitempty"`
	IDLte                           *string                  `json:"id_lte,omitempty"`
	IDGt                            *string                  `json:"id_gt,omitempty"`
	IDGte                           *string                  `json:"id_gte,omitempty"`
	IDContains                      *string                  `json:"id_contains,omitempty"`
	IDNotContains                   *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith                    *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith                 *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith                      *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith                   *string                  `json:"id_not_ends_with,omitempty"`
	NumIdCoinName                   *string                  `json:"numIdCoinName,omitempty"`
	NumIdCoinNameNot                *string                  `json:"numIdCoinName_not,omitempty"`
	NumIdCoinNameIn                 []string                 `json:"numIdCoinName_in,omitempty"`
	NumIdCoinNameNotIn              []string                 `json:"numIdCoinName_not_in,omitempty"`
	NumIdCoinNameLt                 *string                  `json:"numIdCoinName_lt,omitempty"`
	NumIdCoinNameLte                *string                  `json:"numIdCoinName_lte,omitempty"`
	NumIdCoinNameGt                 *string                  `json:"numIdCoinName_gt,omitempty"`
	NumIdCoinNameGte                *string                  `json:"numIdCoinName_gte,omitempty"`
	NumIdCoinNameContains           *string                  `json:"numIdCoinName_contains,omitempty"`
	NumIdCoinNameNotContains        *string                  `json:"numIdCoinName_not_contains,omitempty"`
	NumIdCoinNameStartsWith         *string                  `json:"numIdCoinName_starts_with,omitempty"`
	NumIdCoinNameNotStartsWith      *string                  `json:"numIdCoinName_not_starts_with,omitempty"`
	NumIdCoinNameEndsWith           *string                  `json:"numIdCoinName_ends_with,omitempty"`
	NumIdCoinNameNotEndsWith        *string                  `json:"numIdCoinName_not_ends_with,omitempty"`
	CumulativePurchaseQuantity      *float64                 `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseQuantityNot   *float64                 `json:"cumulativePurchaseQuantity_not,omitempty"`
	CumulativePurchaseQuantityIn    []float64                `json:"cumulativePurchaseQuantity_in,omitempty"`
	CumulativePurchaseQuantityNotIn []float64                `json:"cumulativePurchaseQuantity_not_in,omitempty"`
	CumulativePurchaseQuantityLt    *float64                 `json:"cumulativePurchaseQuantity_lt,omitempty"`
	CumulativePurchaseQuantityLte   *float64                 `json:"cumulativePurchaseQuantity_lte,omitempty"`
	CumulativePurchaseQuantityGt    *float64                 `json:"cumulativePurchaseQuantity_gt,omitempty"`
	CumulativePurchaseQuantityGte   *float64                 `json:"cumulativePurchaseQuantity_gte,omitempty"`
	CumulativePurchaseValue         *float64                 `json:"cumulativePurchaseValue,omitempty"`
	CumulativePurchaseValueNot      *float64                 `json:"cumulativePurchaseValue_not,omitempty"`
	CumulativePurchaseValueIn       []float64                `json:"cumulativePurchaseValue_in,omitempty"`
	CumulativePurchaseValueNotIn    []float64                `json:"cumulativePurchaseValue_not_in,omitempty"`
	CumulativePurchaseValueLt       *float64                 `json:"cumulativePurchaseValue_lt,omitempty"`
	CumulativePurchaseValueLte      *float64                 `json:"cumulativePurchaseValue_lte,omitempty"`
	CumulativePurchaseValueGt       *float64                 `json:"cumulativePurchaseValue_gt,omitempty"`
	CumulativePurchaseValueGte      *float64                 `json:"cumulativePurchaseValue_gte,omitempty"`
	CreatedAt                       *string                  `json:"createdAt,omitempty"`
	CreatedAtNot                    *string                  `json:"createdAt_not,omitempty"`
	CreatedAtIn                     []string                 `json:"createdAt_in,omitempty"`
	CreatedAtNotIn                  []string                 `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                     *string                  `json:"createdAt_lt,omitempty"`
	CreatedAtLte                    *string                  `json:"createdAt_lte,omitempty"`
	CreatedAtGt                     *string                  `json:"createdAt_gt,omitempty"`
	CreatedAtGte                    *string                  `json:"createdAt_gte,omitempty"`
	And                             []WalletScalarWhereInput `json:"AND,omitempty"`
	Or                              []WalletScalarWhereInput `json:"OR,omitempty"`
	Not                             []WalletScalarWhereInput `json:"NOT,omitempty"`
}

type WalletUpdateManyWithWhereNestedInput struct {
	Where WalletScalarWhereInput    `json:"where"`
	Data  WalletUpdateManyDataInput `json:"data"`
}

type WalletUpdateManyDataInput struct {
	NumIdCoinName              *string  `json:"numIdCoinName,omitempty"`
	CumulativePurchaseQuantity *float64 `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseValue    *float64 `json:"cumulativePurchaseValue,omitempty"`
}

type CoinUpsertWithoutPostsInput struct {
	Update CoinUpdateWithoutPostsDataInput `json:"update"`
	Create CoinCreateWithoutPostsInput     `json:"create"`
}

type PostUpsertWithWhereUniqueWithoutToUserInput struct {
	Where  PostWhereUniqueInput             `json:"where"`
	Update PostUpdateWithoutToUserDataInput `json:"update"`
	Create PostCreateWithoutToUserInput     `json:"create"`
}

type UserUpsertWithoutPostsInput struct {
	Update UserUpdateWithoutPostsDataInput `json:"update"`
	Create UserCreateWithoutPostsInput     `json:"create"`
}

type PostUpsertWithoutFileListInput struct {
	Update PostUpdateWithoutFileListDataInput `json:"update"`
	Create PostCreateWithoutFileListInput     `json:"create"`
}

type FileInfoUpsertWithoutCoinInput struct {
	Update FileInfoUpdateWithoutCoinDataInput `json:"update"`
	Create FileInfoCreateWithoutCoinInput     `json:"create"`
}

type CoinUpsertWithWhereUniqueWithoutCategoriesInput struct {
	Where  CoinWhereUniqueInput                 `json:"where"`
	Update CoinUpdateWithoutCategoriesDataInput `json:"update"`
	Create CoinCreateWithoutCategoriesInput     `json:"create"`
}

type CoinScalarWhereInput struct {
	ID                           *string                `json:"id,omitempty"`
	IDNot                        *string                `json:"id_not,omitempty"`
	IDIn                         []string               `json:"id_in,omitempty"`
	IDNotIn                      []string               `json:"id_not_in,omitempty"`
	IDLt                         *string                `json:"id_lt,omitempty"`
	IDLte                        *string                `json:"id_lte,omitempty"`
	IDGt                         *string                `json:"id_gt,omitempty"`
	IDGte                        *string                `json:"id_gte,omitempty"`
	IDContains                   *string                `json:"id_contains,omitempty"`
	IDNotContains                *string                `json:"id_not_contains,omitempty"`
	IDStartsWith                 *string                `json:"id_starts_with,omitempty"`
	IDNotStartsWith              *string                `json:"id_not_starts_with,omitempty"`
	IDEndsWith                   *string                `json:"id_ends_with,omitempty"`
	IDNotEndsWith                *string                `json:"id_not_ends_with,omitempty"`
	Name                         *string                `json:"name,omitempty"`
	NameNot                      *string                `json:"name_not,omitempty"`
	NameIn                       []string               `json:"name_in,omitempty"`
	NameNotIn                    []string               `json:"name_not_in,omitempty"`
	NameLt                       *string                `json:"name_lt,omitempty"`
	NameLte                      *string                `json:"name_lte,omitempty"`
	NameGt                       *string                `json:"name_gt,omitempty"`
	NameGte                      *string                `json:"name_gte,omitempty"`
	NameContains                 *string                `json:"name_contains,omitempty"`
	NameNotContains              *string                `json:"name_not_contains,omitempty"`
	NameStartsWith               *string                `json:"name_starts_with,omitempty"`
	NameNotStartsWith            *string                `json:"name_not_starts_with,omitempty"`
	NameEndsWith                 *string                `json:"name_ends_with,omitempty"`
	NameNotEndsWith              *string                `json:"name_not_ends_with,omitempty"`
	Qty                          *float64               `json:"qty,omitempty"`
	QtyNot                       *float64               `json:"qty_not,omitempty"`
	QtyIn                        []float64              `json:"qty_in,omitempty"`
	QtyNotIn                     []float64              `json:"qty_not_in,omitempty"`
	QtyLt                        *float64               `json:"qty_lt,omitempty"`
	QtyLte                       *float64               `json:"qty_lte,omitempty"`
	QtyGt                        *float64               `json:"qty_gt,omitempty"`
	QtyGte                       *float64               `json:"qty_gte,omitempty"`
	StandardPrice                *float64               `json:"standardPrice,omitempty"`
	StandardPriceNot             *float64               `json:"standardPrice_not,omitempty"`
	StandardPriceIn              []float64              `json:"standardPrice_in,omitempty"`
	StandardPriceNotIn           []float64              `json:"standardPrice_not_in,omitempty"`
	StandardPriceLt              *float64               `json:"standardPrice_lt,omitempty"`
	StandardPriceLte             *float64               `json:"standardPrice_lte,omitempty"`
	StandardPriceGt              *float64               `json:"standardPrice_gt,omitempty"`
	StandardPriceGte             *float64               `json:"standardPrice_gte,omitempty"`
	CurrentPrice                 *float64               `json:"currentPrice,omitempty"`
	CurrentPriceNot              *float64               `json:"currentPrice_not,omitempty"`
	CurrentPriceIn               []float64              `json:"currentPrice_in,omitempty"`
	CurrentPriceNotIn            []float64              `json:"currentPrice_not_in,omitempty"`
	CurrentPriceLt               *float64               `json:"currentPrice_lt,omitempty"`
	CurrentPriceLte              *float64               `json:"currentPrice_lte,omitempty"`
	CurrentPriceGt               *float64               `json:"currentPrice_gt,omitempty"`
	CurrentPriceGte              *float64               `json:"currentPrice_gte,omitempty"`
	Description                  *string                `json:"description,omitempty"`
	DescriptionNot               *string                `json:"description_not,omitempty"`
	DescriptionIn                []string               `json:"description_in,omitempty"`
	DescriptionNotIn             []string               `json:"description_not_in,omitempty"`
	DescriptionLt                *string                `json:"description_lt,omitempty"`
	DescriptionLte               *string                `json:"description_lte,omitempty"`
	DescriptionGt                *string                `json:"description_gt,omitempty"`
	DescriptionGte               *string                `json:"description_gte,omitempty"`
	DescriptionContains          *string                `json:"description_contains,omitempty"`
	DescriptionNotContains       *string                `json:"description_not_contains,omitempty"`
	DescriptionStartsWith        *string                `json:"description_starts_with,omitempty"`
	DescriptionNotStartsWith     *string                `json:"description_not_starts_with,omitempty"`
	DescriptionEndsWith          *string                `json:"description_ends_with,omitempty"`
	DescriptionNotEndsWith       *string                `json:"description_not_ends_with,omitempty"`
	Status                       *int32                 `json:"status,omitempty"`
	StatusNot                    *int32                 `json:"status_not,omitempty"`
	StatusIn                     []int32                `json:"status_in,omitempty"`
	StatusNotIn                  []int32                `json:"status_not_in,omitempty"`
	StatusLt                     *int32                 `json:"status_lt,omitempty"`
	StatusLte                    *int32                 `json:"status_lte,omitempty"`
	StatusGt                     *int32                 `json:"status_gt,omitempty"`
	StatusGte                    *int32                 `json:"status_gte,omitempty"`
	Weight                       *string                `json:"weight,omitempty"`
	WeightNot                    *string                `json:"weight_not,omitempty"`
	WeightIn                     []string               `json:"weight_in,omitempty"`
	WeightNotIn                  []string               `json:"weight_not_in,omitempty"`
	WeightLt                     *string                `json:"weight_lt,omitempty"`
	WeightLte                    *string                `json:"weight_lte,omitempty"`
	WeightGt                     *string                `json:"weight_gt,omitempty"`
	WeightGte                    *string                `json:"weight_gte,omitempty"`
	WeightContains               *string                `json:"weight_contains,omitempty"`
	WeightNotContains            *string                `json:"weight_not_contains,omitempty"`
	WeightStartsWith             *string                `json:"weight_starts_with,omitempty"`
	WeightNotStartsWith          *string                `json:"weight_not_starts_with,omitempty"`
	WeightEndsWith               *string                `json:"weight_ends_with,omitempty"`
	WeightNotEndsWith            *string                `json:"weight_not_ends_with,omitempty"`
	DeployTxhash                 *string                `json:"deployTxhash,omitempty"`
	DeployTxhashNot              *string                `json:"deployTxhash_not,omitempty"`
	DeployTxhashIn               []string               `json:"deployTxhash_in,omitempty"`
	DeployTxhashNotIn            []string               `json:"deployTxhash_not_in,omitempty"`
	DeployTxhashLt               *string                `json:"deployTxhash_lt,omitempty"`
	DeployTxhashLte              *string                `json:"deployTxhash_lte,omitempty"`
	DeployTxhashGt               *string                `json:"deployTxhash_gt,omitempty"`
	DeployTxhashGte              *string                `json:"deployTxhash_gte,omitempty"`
	DeployTxhashContains         *string                `json:"deployTxhash_contains,omitempty"`
	DeployTxhashNotContains      *string                `json:"deployTxhash_not_contains,omitempty"`
	DeployTxhashStartsWith       *string                `json:"deployTxhash_starts_with,omitempty"`
	DeployTxhashNotStartsWith    *string                `json:"deployTxhash_not_starts_with,omitempty"`
	DeployTxhashEndsWith         *string                `json:"deployTxhash_ends_with,omitempty"`
	DeployTxhashNotEndsWith      *string                `json:"deployTxhash_not_ends_with,omitempty"`
	ContractAddress              *string                `json:"contractAddress,omitempty"`
	ContractAddressNot           *string                `json:"contractAddress_not,omitempty"`
	ContractAddressIn            []string               `json:"contractAddress_in,omitempty"`
	ContractAddressNotIn         []string               `json:"contractAddress_not_in,omitempty"`
	ContractAddressLt            *string                `json:"contractAddress_lt,omitempty"`
	ContractAddressLte           *string                `json:"contractAddress_lte,omitempty"`
	ContractAddressGt            *string                `json:"contractAddress_gt,omitempty"`
	ContractAddressGte           *string                `json:"contractAddress_gte,omitempty"`
	ContractAddressContains      *string                `json:"contractAddress_contains,omitempty"`
	ContractAddressNotContains   *string                `json:"contractAddress_not_contains,omitempty"`
	ContractAddressStartsWith    *string                `json:"contractAddress_starts_with,omitempty"`
	ContractAddressNotStartsWith *string                `json:"contractAddress_not_starts_with,omitempty"`
	ContractAddressEndsWith      *string                `json:"contractAddress_ends_with,omitempty"`
	ContractAddressNotEndsWith   *string                `json:"contractAddress_not_ends_with,omitempty"`
	ODda                         *float64               `json:"oDDA,omitempty"`
	ODdaNot                      *float64               `json:"oDDA_not,omitempty"`
	ODdaIn                       []float64              `json:"oDDA_in,omitempty"`
	ODdaNotIn                    []float64              `json:"oDDA_not_in,omitempty"`
	ODdaLt                       *float64               `json:"oDDA_lt,omitempty"`
	ODdaLte                      *float64               `json:"oDDA_lte,omitempty"`
	ODdaGt                       *float64               `json:"oDDA_gt,omitempty"`
	ODdaGte                      *float64               `json:"oDDA_gte,omitempty"`
	CreatedAt                    *string                `json:"createdAt,omitempty"`
	CreatedAtNot                 *string                `json:"createdAt_not,omitempty"`
	CreatedAtIn                  []string               `json:"createdAt_in,omitempty"`
	CreatedAtNotIn               []string               `json:"createdAt_not_in,omitempty"`
	CreatedAtLt                  *string                `json:"createdAt_lt,omitempty"`
	CreatedAtLte                 *string                `json:"createdAt_lte,omitempty"`
	CreatedAtGt                  *string                `json:"createdAt_gt,omitempty"`
	CreatedAtGte                 *string                `json:"createdAt_gte,omitempty"`
	UpdatedAt                    *string                `json:"updatedAt,omitempty"`
	UpdatedAtNot                 *string                `json:"updatedAt_not,omitempty"`
	UpdatedAtIn                  []string               `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn               []string               `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt                  *string                `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte                 *string                `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt                  *string                `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte                 *string                `json:"updatedAt_gte,omitempty"`
	And                          []CoinScalarWhereInput `json:"AND,omitempty"`
	Or                           []CoinScalarWhereInput `json:"OR,omitempty"`
	Not                          []CoinScalarWhereInput `json:"NOT,omitempty"`
}

type CoinUpdateManyWithWhereNestedInput struct {
	Where CoinScalarWhereInput    `json:"where"`
	Data  CoinUpdateManyDataInput `json:"data"`
}

type CoinUpdateManyDataInput struct {
	Name            *string  `json:"name,omitempty"`
	Qty             *float64 `json:"qty,omitempty"`
	StandardPrice   *float64 `json:"standardPrice,omitempty"`
	CurrentPrice    *float64 `json:"currentPrice,omitempty"`
	Description     *string  `json:"description,omitempty"`
	Status          *int32   `json:"status,omitempty"`
	Weight          *string  `json:"weight,omitempty"`
	DeployTxhash    *string  `json:"deployTxhash,omitempty"`
	ContractAddress *string  `json:"contractAddress,omitempty"`
	ODda            *float64 `json:"oDDA,omitempty"`
}

type CategoryUpsertWithWhereUniqueWithoutPostsInput struct {
	Where  CategoryWhereUniqueInput            `json:"where"`
	Update CategoryUpdateWithoutPostsDataInput `json:"update"`
	Create CategoryCreateWithoutPostsInput     `json:"create"`
}

type CategoryScalarWhereInput struct {
	ID                *string                    `json:"id,omitempty"`
	IDNot             *string                    `json:"id_not,omitempty"`
	IDIn              []string                   `json:"id_in,omitempty"`
	IDNotIn           []string                   `json:"id_not_in,omitempty"`
	IDLt              *string                    `json:"id_lt,omitempty"`
	IDLte             *string                    `json:"id_lte,omitempty"`
	IDGt              *string                    `json:"id_gt,omitempty"`
	IDGte             *string                    `json:"id_gte,omitempty"`
	IDContains        *string                    `json:"id_contains,omitempty"`
	IDNotContains     *string                    `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                    `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                    `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                    `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                    `json:"id_not_ends_with,omitempty"`
	Name              *string                    `json:"name,omitempty"`
	NameNot           *string                    `json:"name_not,omitempty"`
	NameIn            []string                   `json:"name_in,omitempty"`
	NameNotIn         []string                   `json:"name_not_in,omitempty"`
	NameLt            *string                    `json:"name_lt,omitempty"`
	NameLte           *string                    `json:"name_lte,omitempty"`
	NameGt            *string                    `json:"name_gt,omitempty"`
	NameGte           *string                    `json:"name_gte,omitempty"`
	NameContains      *string                    `json:"name_contains,omitempty"`
	NameNotContains   *string                    `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                    `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                    `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                    `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                    `json:"name_not_ends_with,omitempty"`
	OrderIndex        *float64                   `json:"order_index,omitempty"`
	OrderIndexNot     *float64                   `json:"order_index_not,omitempty"`
	OrderIndexIn      []float64                  `json:"order_index_in,omitempty"`
	OrderIndexNotIn   []float64                  `json:"order_index_not_in,omitempty"`
	OrderIndexLt      *float64                   `json:"order_index_lt,omitempty"`
	OrderIndexLte     *float64                   `json:"order_index_lte,omitempty"`
	OrderIndexGt      *float64                   `json:"order_index_gt,omitempty"`
	OrderIndexGte     *float64                   `json:"order_index_gte,omitempty"`
	And               []CategoryScalarWhereInput `json:"AND,omitempty"`
	Or                []CategoryScalarWhereInput `json:"OR,omitempty"`
	Not               []CategoryScalarWhereInput `json:"NOT,omitempty"`
}

type CategoryUpdateManyWithWhereNestedInput struct {
	Where CategoryScalarWhereInput    `json:"where"`
	Data  CategoryUpdateManyDataInput `json:"data"`
}

type CategoryUpdateManyDataInput struct {
	Name       *string  `json:"name,omitempty"`
	OrderIndex *float64 `json:"order_index,omitempty"`
}

type PostUpsertWithoutImageInput struct {
	Update PostUpdateWithoutImageDataInput `json:"update"`
	Create PostCreateWithoutImageInput     `json:"create"`
}

type FileUpsertWithoutCoinInput struct {
	Update FileUpdateWithoutCoinDataInput `json:"update"`
	Create FileCreateWithoutCoinInput     `json:"create"`
}

type CoinUpsertWithoutWalletsInput struct {
	Update CoinUpdateWithoutWalletsDataInput `json:"update"`
	Create CoinCreateWithoutWalletsInput     `json:"create"`
}

type WalletUpsertWithWhereUniqueWithoutOwnerInput struct {
	Where  WalletWhereUniqueInput            `json:"where"`
	Update WalletUpdateWithoutOwnerDataInput `json:"update"`
	Create WalletCreateWithoutOwnerInput     `json:"create"`
}

type UserUpsertWithWhereUniqueWithoutFeedCategoriesInput struct {
	Where  UserWhereUniqueInput                     `json:"where"`
	Update UserUpdateWithoutFeedCategoriesDataInput `json:"update"`
	Create UserCreateWithoutFeedCategoriesInput     `json:"create"`
}

type CategoryUpsertWithWhereUniqueWithoutCoinsInput struct {
	Where  CategoryWhereUniqueInput            `json:"where"`
	Update CategoryUpdateWithoutCoinsDataInput `json:"update"`
	Create CategoryCreateWithoutCoinsInput     `json:"create"`
}

type CoinUpsertWithoutOwnerInput struct {
	Update CoinUpdateWithoutOwnerDataInput `json:"update"`
	Create CoinCreateWithoutOwnerInput     `json:"create"`
}

type UserUpsertWithoutRequestPostsInput struct {
	Update UserUpdateWithoutRequestPostsDataInput `json:"update"`
	Create UserCreateWithoutRequestPostsInput     `json:"create"`
}

type PostUpsertWithWhereUniqueWithoutCategoriesInput struct {
	Where  PostWhereUniqueInput                 `json:"where"`
	Update PostUpdateWithoutCategoriesDataInput `json:"update"`
	Create PostCreateWithoutCategoriesInput     `json:"create"`
}

type CategoryUpsertWithWhereUniqueWithoutFeedUsersInput struct {
	Where  CategoryWhereUniqueInput                `json:"where"`
	Update CategoryUpdateWithoutFeedUsersDataInput `json:"update"`
	Create CategoryCreateWithoutFeedUsersInput     `json:"create"`
}

type UserUpsertWithWhereUniqueWithoutAdminUserInput struct {
	Where  UserWhereUniqueInput                `json:"where"`
	Update UserUpdateWithoutAdminUserDataInput `json:"update"`
	Create UserCreateWithoutAdminUserInput     `json:"create"`
}

type AdminUserUpdateManyMutationInput struct {
	Role     *Role   `json:"role,omitempty"`
	Email    *string `json:"email,omitempty"`
	Password *string `json:"password,omitempty"`
	NickName *string `json:"nickName,omitempty"`
	OtpKey   *string `json:"otpKey,omitempty"`
	Level    *string `json:"level,omitempty"`
}

type AergoAccountCreateInput struct {
	ContractAddress string                                                 `json:"contractAddress"`
	Amount          *float64                                               `json:"amount,omitempty"`
	Owner           *UserCreateOneWithoutAergoAccountInput                 `json:"owner,omitempty"`
	LatestBlock     *int32                                                 `json:"latestBlock,omitempty"`
	Histories       *AergoAccountHistoryCreateManyWithoutAergoAccountInput `json:"histories,omitempty"`
}

type AergoAccountUpdateInput struct {
	ContractAddress *string                                                `json:"contractAddress,omitempty"`
	Amount          *float64                                               `json:"amount,omitempty"`
	Owner           *UserUpdateOneWithoutAergoAccountInput                 `json:"owner,omitempty"`
	LatestBlock     *int32                                                 `json:"latestBlock,omitempty"`
	Histories       *AergoAccountHistoryUpdateManyWithoutAergoAccountInput `json:"histories,omitempty"`
}

type AergoAccountUpdateManyMutationInput struct {
	ContractAddress *string  `json:"contractAddress,omitempty"`
	Amount          *float64 `json:"amount,omitempty"`
	LatestBlock     *int32   `json:"latestBlock,omitempty"`
}

type AergoAccountHistoryCreateInput struct {
	Type          int32                                                  `json:"type"`
	MotherHistory *MotherHistoryCreateOneWithoutAergoAccountHistoryInput `json:"motherHistory,omitempty"`
	AergoAccount  AergoAccountCreateOneWithoutHistoriesInput             `json:"aergoAccount"`
	CashHistory   *CashHistoryCreateOneWithoutAergoAccountHistoryInput   `json:"cashHistory,omitempty"`
	AergoAmount   *string                                                `json:"aergoAmount,omitempty"`
	AmountFee     *float64                                               `json:"amount_fee,omitempty"`
	Amount        *float64                                               `json:"amount,omitempty"`
	MarketPrice   *string                                                `json:"marketPrice,omitempty"`
	TxHash        *string                                                `json:"txHash,omitempty"`
	Memo          *string                                                `json:"memo,omitempty"`
	Description   *string                                                `json:"description,omitempty"`
	BlockNo       *int32                                                 `json:"blockNo,omitempty"`
	Status        *int32                                                 `json:"status,omitempty"`
}

type AergoAccountHistoryUpdateInput struct {
	Type          *int32                                                 `json:"type,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutAergoAccountHistoryInput `json:"motherHistory,omitempty"`
	AergoAccount  *AergoAccountUpdateOneRequiredWithoutHistoriesInput    `json:"aergoAccount,omitempty"`
	CashHistory   *CashHistoryUpdateOneWithoutAergoAccountHistoryInput   `json:"cashHistory,omitempty"`
	AergoAmount   *string                                                `json:"aergoAmount,omitempty"`
	AmountFee     *float64                                               `json:"amount_fee,omitempty"`
	Amount        *float64                                               `json:"amount,omitempty"`
	MarketPrice   *string                                                `json:"marketPrice,omitempty"`
	TxHash        *string                                                `json:"txHash,omitempty"`
	Memo          *string                                                `json:"memo,omitempty"`
	Description   *string                                                `json:"description,omitempty"`
	BlockNo       *int32                                                 `json:"blockNo,omitempty"`
	Status        *int32                                                 `json:"status,omitempty"`
}

type AergoAccountHistoryUpdateManyMutationInput struct {
	Type        *int32   `json:"type,omitempty"`
	AergoAmount *string  `json:"aergoAmount,omitempty"`
	AmountFee   *float64 `json:"amount_fee,omitempty"`
	Amount      *float64 `json:"amount,omitempty"`
	MarketPrice *string  `json:"marketPrice,omitempty"`
	TxHash      *string  `json:"txHash,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
	Description *string  `json:"description,omitempty"`
	BlockNo     *int32   `json:"blockNo,omitempty"`
	Status      *int32   `json:"status,omitempty"`
}

type AfreecaTvCreateInput struct {
	StationNo     string                                                   `json:"stationNo"`
	StationName   *string                                                  `json:"stationName,omitempty"`
	StationTitle  *string                                                  `json:"stationTitle,omitempty"`
	UserId        string                                                   `json:"userId"`
	UserName      *string                                                  `json:"userName,omitempty"`
	AvatarUrl     *string                                                  `json:"avatarUrl,omitempty"`
	Description   *string                                                  `json:"description,omitempty"`
	PageUrl       *string                                                  `json:"pageUrl,omitempty"`
	Page          PageCreateOneWithoutAfreecaTvInput                       `json:"page"`
	Statistics    *AfreecaTvDailyStatisticsCreateManyWithoutAfreecaTvInput `json:"statistics,omitempty"`
	FollowerCount *string                                                  `json:"followerCount,omitempty"`
	ViewCount     *string                                                  `json:"viewCount,omitempty"`
	VisitCount    *string                                                  `json:"visitCount,omitempty"`
	FanCount      *string                                                  `json:"fanCount,omitempty"`
}

type PageCreateOneWithoutAfreecaTvInput struct {
	Create  *PageCreateWithoutAfreecaTvInput `json:"create,omitempty"`
	Connect *PageWhereUniqueInput            `json:"connect,omitempty"`
}

type PageCreateWithoutAfreecaTvInput struct {
	PageId           string                                          `json:"pageId"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeCreateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeCreateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchCreateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramCreateOneWithoutPageInput             `json:"instagram,omitempty"`
	Fans             *PageFanCreateManyInput                         `json:"fans,omitempty"`
	Owner            *UserCreateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentCreateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemCreateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageCreateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentCreateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type AfreecaTvUpdateInput struct {
	StationNo     *string                                                  `json:"stationNo,omitempty"`
	StationName   *string                                                  `json:"stationName,omitempty"`
	StationTitle  *string                                                  `json:"stationTitle,omitempty"`
	UserId        *string                                                  `json:"userId,omitempty"`
	UserName      *string                                                  `json:"userName,omitempty"`
	AvatarUrl     *string                                                  `json:"avatarUrl,omitempty"`
	Description   *string                                                  `json:"description,omitempty"`
	PageUrl       *string                                                  `json:"pageUrl,omitempty"`
	Page          *PageUpdateOneRequiredWithoutAfreecaTvInput              `json:"page,omitempty"`
	Statistics    *AfreecaTvDailyStatisticsUpdateManyWithoutAfreecaTvInput `json:"statistics,omitempty"`
	FollowerCount *string                                                  `json:"followerCount,omitempty"`
	ViewCount     *string                                                  `json:"viewCount,omitempty"`
	VisitCount    *string                                                  `json:"visitCount,omitempty"`
	FanCount      *string                                                  `json:"fanCount,omitempty"`
}

type PageUpdateOneRequiredWithoutAfreecaTvInput struct {
	Create  *PageCreateWithoutAfreecaTvInput     `json:"create,omitempty"`
	Update  *PageUpdateWithoutAfreecaTvDataInput `json:"update,omitempty"`
	Upsert  *PageUpsertWithoutAfreecaTvInput     `json:"upsert,omitempty"`
	Connect *PageWhereUniqueInput                `json:"connect,omitempty"`
}

type PageUpdateWithoutAfreecaTvDataInput struct {
	PageId           *string                                         `json:"pageId,omitempty"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeUpdateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeUpdateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchUpdateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramUpdateOneWithoutPageInput             `json:"instagram,omitempty"`
	Fans             *PageFanUpdateManyInput                         `json:"fans,omitempty"`
	Owner            *UserUpdateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentUpdateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemUpdateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageUpdateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentUpdateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type PageUpsertWithoutAfreecaTvInput struct {
	Update PageUpdateWithoutAfreecaTvDataInput `json:"update"`
	Create PageCreateWithoutAfreecaTvInput     `json:"create"`
}

type AfreecaTvUpdateManyMutationInput struct {
	StationNo     *string `json:"stationNo,omitempty"`
	StationName   *string `json:"stationName,omitempty"`
	StationTitle  *string `json:"stationTitle,omitempty"`
	UserId        *string `json:"userId,omitempty"`
	UserName      *string `json:"userName,omitempty"`
	AvatarUrl     *string `json:"avatarUrl,omitempty"`
	Description   *string `json:"description,omitempty"`
	PageUrl       *string `json:"pageUrl,omitempty"`
	FollowerCount *string `json:"followerCount,omitempty"`
	ViewCount     *string `json:"viewCount,omitempty"`
	VisitCount    *string `json:"visitCount,omitempty"`
	FanCount      *string `json:"fanCount,omitempty"`
}

type AfreecaTvDailyStatisticsCreateInput struct {
	Date          string                                   `json:"date"`
	FollowerCount string                                   `json:"followerCount"`
	ViewCount     string                                   `json:"viewCount"`
	VisitCount    string                                   `json:"visitCount"`
	FanCount      string                                   `json:"fanCount"`
	AfreecaTv     AfreecaTvCreateOneWithoutStatisticsInput `json:"afreecaTV"`
}

type AfreecaTvCreateOneWithoutStatisticsInput struct {
	Create  *AfreecaTvCreateWithoutStatisticsInput `json:"create,omitempty"`
	Connect *AfreecaTvWhereUniqueInput             `json:"connect,omitempty"`
}

type AfreecaTvCreateWithoutStatisticsInput struct {
	StationNo     string                             `json:"stationNo"`
	StationName   *string                            `json:"stationName,omitempty"`
	StationTitle  *string                            `json:"stationTitle,omitempty"`
	UserId        string                             `json:"userId"`
	UserName      *string                            `json:"userName,omitempty"`
	AvatarUrl     *string                            `json:"avatarUrl,omitempty"`
	Description   *string                            `json:"description,omitempty"`
	PageUrl       *string                            `json:"pageUrl,omitempty"`
	Page          PageCreateOneWithoutAfreecaTvInput `json:"page"`
	FollowerCount *string                            `json:"followerCount,omitempty"`
	ViewCount     *string                            `json:"viewCount,omitempty"`
	VisitCount    *string                            `json:"visitCount,omitempty"`
	FanCount      *string                            `json:"fanCount,omitempty"`
}

type AfreecaTvDailyStatisticsUpdateInput struct {
	Date          *string                                           `json:"date,omitempty"`
	FollowerCount *string                                           `json:"followerCount,omitempty"`
	ViewCount     *string                                           `json:"viewCount,omitempty"`
	VisitCount    *string                                           `json:"visitCount,omitempty"`
	FanCount      *string                                           `json:"fanCount,omitempty"`
	AfreecaTv     *AfreecaTvUpdateOneRequiredWithoutStatisticsInput `json:"afreecaTV,omitempty"`
}

type AfreecaTvUpdateOneRequiredWithoutStatisticsInput struct {
	Create  *AfreecaTvCreateWithoutStatisticsInput     `json:"create,omitempty"`
	Update  *AfreecaTvUpdateWithoutStatisticsDataInput `json:"update,omitempty"`
	Upsert  *AfreecaTvUpsertWithoutStatisticsInput     `json:"upsert,omitempty"`
	Connect *AfreecaTvWhereUniqueInput                 `json:"connect,omitempty"`
}

type AfreecaTvUpdateWithoutStatisticsDataInput struct {
	StationNo     *string                                     `json:"stationNo,omitempty"`
	StationName   *string                                     `json:"stationName,omitempty"`
	StationTitle  *string                                     `json:"stationTitle,omitempty"`
	UserId        *string                                     `json:"userId,omitempty"`
	UserName      *string                                     `json:"userName,omitempty"`
	AvatarUrl     *string                                     `json:"avatarUrl,omitempty"`
	Description   *string                                     `json:"description,omitempty"`
	PageUrl       *string                                     `json:"pageUrl,omitempty"`
	Page          *PageUpdateOneRequiredWithoutAfreecaTvInput `json:"page,omitempty"`
	FollowerCount *string                                     `json:"followerCount,omitempty"`
	ViewCount     *string                                     `json:"viewCount,omitempty"`
	VisitCount    *string                                     `json:"visitCount,omitempty"`
	FanCount      *string                                     `json:"fanCount,omitempty"`
}

type AfreecaTvUpsertWithoutStatisticsInput struct {
	Update AfreecaTvUpdateWithoutStatisticsDataInput `json:"update"`
	Create AfreecaTvCreateWithoutStatisticsInput     `json:"create"`
}

type AfreecaTvDailyStatisticsUpdateManyMutationInput struct {
	Date          *string `json:"date,omitempty"`
	FollowerCount *string `json:"followerCount,omitempty"`
	ViewCount     *string `json:"viewCount,omitempty"`
	VisitCount    *string `json:"visitCount,omitempty"`
	FanCount      *string `json:"fanCount,omitempty"`
}

type AirDropCreateInput struct {
	Status            *int32                                       `json:"status,omitempty"`
	Post              PostCreateOneWithoutAirDropInput             `json:"post"`
	DeployTxhash      *string                                      `json:"deployTxhash,omitempty"`
	ContractAddress   *string                                      `json:"contractAddress,omitempty"`
	RandomArrayString *string                                      `json:"randomArrayString,omitempty"`
	Amount            float64                                      `json:"amount"`
	Left              float64                                      `json:"left"`
	Members           *AirDropMemberCreateManyWithoutAirDropInput  `json:"members,omitempty"`
	ToDate            *string                                      `json:"toDate,omitempty"`
	AirDropHistories  *AirDropHistoryCreateManyWithoutAirDropInput `json:"airDropHistories,omitempty"`
	IsDel             *bool                                        `json:"isDel,omitempty"`
}

type AirDropUpdateInput struct {
	Status            *int32                                       `json:"status,omitempty"`
	Post              *PostUpdateOneRequiredWithoutAirDropInput    `json:"post,omitempty"`
	DeployTxhash      *string                                      `json:"deployTxhash,omitempty"`
	ContractAddress   *string                                      `json:"contractAddress,omitempty"`
	RandomArrayString *string                                      `json:"randomArrayString,omitempty"`
	Amount            *float64                                     `json:"amount,omitempty"`
	Left              *float64                                     `json:"left,omitempty"`
	Members           *AirDropMemberUpdateManyWithoutAirDropInput  `json:"members,omitempty"`
	ToDate            *string                                      `json:"toDate,omitempty"`
	AirDropHistories  *AirDropHistoryUpdateManyWithoutAirDropInput `json:"airDropHistories,omitempty"`
	IsDel             *bool                                        `json:"isDel,omitempty"`
}

type AirDropUpdateManyMutationInput struct {
	Status            *int32   `json:"status,omitempty"`
	DeployTxhash      *string  `json:"deployTxhash,omitempty"`
	ContractAddress   *string  `json:"contractAddress,omitempty"`
	RandomArrayString *string  `json:"randomArrayString,omitempty"`
	Amount            *float64 `json:"amount,omitempty"`
	Left              *float64 `json:"left,omitempty"`
	ToDate            *string  `json:"toDate,omitempty"`
	IsDel             *bool    `json:"isDel,omitempty"`
}

type AirDropHistoryCreateInput struct {
	Type          int32                                             `json:"type"`
	Description   *string                                           `json:"description,omitempty"`
	User          *UserCreateOneWithoutAirDropHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutAirDropHistoryInput `json:"motherHistory,omitempty"`
	AirDrop       *AirDropCreateOneWithoutAirDropHistoriesInput     `json:"airDrop,omitempty"`
	AirDropMember *AirDropMemberCreateOneWithoutAirDropHistoryInput `json:"airDropMember,omitempty"`
	Qty           *float64                                          `json:"qty,omitempty"`
	CurrentPrice  *float64                                          `json:"currentPrice,omitempty"`
	Memo          *string                                           `json:"memo,omitempty"`
}

type AirDropHistoryUpdateInput struct {
	Type          *int32                                            `json:"type,omitempty"`
	Description   *string                                           `json:"description,omitempty"`
	User          *UserUpdateOneWithoutAirDropHistoriesInput        `json:"user,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutAirDropHistoryInput `json:"motherHistory,omitempty"`
	AirDrop       *AirDropUpdateOneWithoutAirDropHistoriesInput     `json:"airDrop,omitempty"`
	AirDropMember *AirDropMemberUpdateOneWithoutAirDropHistoryInput `json:"airDropMember,omitempty"`
	Qty           *float64                                          `json:"qty,omitempty"`
	CurrentPrice  *float64                                          `json:"currentPrice,omitempty"`
	Memo          *string                                           `json:"memo,omitempty"`
}

type AirDropHistoryUpdateManyMutationInput struct {
	Type         *int32   `json:"type,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
}

type AirDropMemberCreateInput struct {
	AirDrop        AirDropCreateOneWithoutMembersInput               `json:"airDrop"`
	User           UserCreateOneWithoutAirDropMembersInput           `json:"user"`
	DropNum        int32                                             `json:"dropNum"`
	Qty            float64                                           `json:"qty"`
	AirDropHistory *AirDropHistoryCreateOneWithoutAirDropMemberInput `json:"airDropHistory,omitempty"`
	IsDel          *bool                                             `json:"isDel,omitempty"`
}

type AirDropMemberUpdateInput struct {
	AirDrop        *AirDropUpdateOneRequiredWithoutMembersInput      `json:"airDrop,omitempty"`
	User           *UserUpdateOneRequiredWithoutAirDropMembersInput  `json:"user,omitempty"`
	DropNum        *int32                                            `json:"dropNum,omitempty"`
	Qty            *float64                                          `json:"qty,omitempty"`
	AirDropHistory *AirDropHistoryUpdateOneWithoutAirDropMemberInput `json:"airDropHistory,omitempty"`
	IsDel          *bool                                             `json:"isDel,omitempty"`
}

type AirDropMemberUpdateManyMutationInput struct {
	DropNum *int32   `json:"dropNum,omitempty"`
	Qty     *float64 `json:"qty,omitempty"`
	IsDel   *bool    `json:"isDel,omitempty"`
}

type AppVersionCreateInput struct {
	Version         string                                  `json:"version"`
	Type            int32                                   `json:"type"`
	AffectedDevices *DeviceCreateManyWithoutAppVersionInput `json:"affectedDevices,omitempty"`
	Note            string                                  `json:"note"`
	CreateUser      *AdminUserCreateOneInput                `json:"createUser,omitempty"`
	UpdateUser      *AdminUserCreateOneInput                `json:"updateUser,omitempty"`
	ReleasedAt      string                                  `json:"releasedAt"`
	IsDel           *bool                                   `json:"isDel,omitempty"`
}

type DeviceCreateManyWithoutAppVersionInput struct {
	Create  []DeviceCreateWithoutAppVersionInput `json:"create,omitempty"`
	Connect []DeviceWhereUniqueInput             `json:"connect,omitempty"`
}

type DeviceCreateWithoutAppVersionInput struct {
	Maintenance *MaintenanceCreateManyWithoutAffectedDevicesInput `json:"maintenance,omitempty"`
	Code        int32                                             `json:"code"`
	Name        string                                            `json:"name"`
}

type MaintenanceCreateManyWithoutAffectedDevicesInput struct {
	Create  []MaintenanceCreateWithoutAffectedDevicesInput `json:"create,omitempty"`
	Connect []MaintenanceWhereUniqueInput                  `json:"connect,omitempty"`
}

type MaintenanceCreateWithoutAffectedDevicesInput struct {
	Type       int32                    `json:"type"`
	Note       string                   `json:"note"`
	FromDate   string                   `json:"fromDate"`
	ToDate     string                   `json:"toDate"`
	CreateUser *AdminUserCreateOneInput `json:"createUser,omitempty"`
	UpdateUser *AdminUserCreateOneInput `json:"updateUser,omitempty"`
	IsDel      *bool                    `json:"isDel,omitempty"`
}

type AppVersionUpdateInput struct {
	Version         *string                                 `json:"version,omitempty"`
	Type            *int32                                  `json:"type,omitempty"`
	AffectedDevices *DeviceUpdateManyWithoutAppVersionInput `json:"affectedDevices,omitempty"`
	Note            *string                                 `json:"note,omitempty"`
	CreateUser      *AdminUserUpdateOneInput                `json:"createUser,omitempty"`
	UpdateUser      *AdminUserUpdateOneInput                `json:"updateUser,omitempty"`
	ReleasedAt      *string                                 `json:"releasedAt,omitempty"`
	IsDel           *bool                                   `json:"isDel,omitempty"`
}

type DeviceUpdateManyWithoutAppVersionInput struct {
	Create     []DeviceCreateWithoutAppVersionInput                `json:"create,omitempty"`
	Delete     []DeviceWhereUniqueInput                            `json:"delete,omitempty"`
	Connect    []DeviceWhereUniqueInput                            `json:"connect,omitempty"`
	Set        []DeviceWhereUniqueInput                            `json:"set,omitempty"`
	Disconnect []DeviceWhereUniqueInput                            `json:"disconnect,omitempty"`
	Update     []DeviceUpdateWithWhereUniqueWithoutAppVersionInput `json:"update,omitempty"`
	Upsert     []DeviceUpsertWithWhereUniqueWithoutAppVersionInput `json:"upsert,omitempty"`
	DeleteMany []DeviceScalarWhereInput                            `json:"deleteMany,omitempty"`
	UpdateMany []DeviceUpdateManyWithWhereNestedInput              `json:"updateMany,omitempty"`
}

type DeviceUpdateWithWhereUniqueWithoutAppVersionInput struct {
	Where DeviceWhereUniqueInput                 `json:"where"`
	Data  DeviceUpdateWithoutAppVersionDataInput `json:"data"`
}

type DeviceUpdateWithoutAppVersionDataInput struct {
	Maintenance *MaintenanceUpdateManyWithoutAffectedDevicesInput `json:"maintenance,omitempty"`
	Code        *int32                                            `json:"code,omitempty"`
	Name        *string                                           `json:"name,omitempty"`
}

type MaintenanceUpdateManyWithoutAffectedDevicesInput struct {
	Create     []MaintenanceCreateWithoutAffectedDevicesInput                `json:"create,omitempty"`
	Delete     []MaintenanceWhereUniqueInput                                 `json:"delete,omitempty"`
	Connect    []MaintenanceWhereUniqueInput                                 `json:"connect,omitempty"`
	Set        []MaintenanceWhereUniqueInput                                 `json:"set,omitempty"`
	Disconnect []MaintenanceWhereUniqueInput                                 `json:"disconnect,omitempty"`
	Update     []MaintenanceUpdateWithWhereUniqueWithoutAffectedDevicesInput `json:"update,omitempty"`
	Upsert     []MaintenanceUpsertWithWhereUniqueWithoutAffectedDevicesInput `json:"upsert,omitempty"`
	DeleteMany []MaintenanceScalarWhereInput                                 `json:"deleteMany,omitempty"`
	UpdateMany []MaintenanceUpdateManyWithWhereNestedInput                   `json:"updateMany,omitempty"`
}

type MaintenanceUpdateWithWhereUniqueWithoutAffectedDevicesInput struct {
	Where MaintenanceWhereUniqueInput                      `json:"where"`
	Data  MaintenanceUpdateWithoutAffectedDevicesDataInput `json:"data"`
}

type MaintenanceUpdateWithoutAffectedDevicesDataInput struct {
	Type       *int32                   `json:"type,omitempty"`
	Note       *string                  `json:"note,omitempty"`
	FromDate   *string                  `json:"fromDate,omitempty"`
	ToDate     *string                  `json:"toDate,omitempty"`
	CreateUser *AdminUserUpdateOneInput `json:"createUser,omitempty"`
	UpdateUser *AdminUserUpdateOneInput `json:"updateUser,omitempty"`
	IsDel      *bool                    `json:"isDel,omitempty"`
}

type MaintenanceUpsertWithWhereUniqueWithoutAffectedDevicesInput struct {
	Where  MaintenanceWhereUniqueInput                      `json:"where"`
	Update MaintenanceUpdateWithoutAffectedDevicesDataInput `json:"update"`
	Create MaintenanceCreateWithoutAffectedDevicesInput     `json:"create"`
}

type MaintenanceScalarWhereInput struct {
	ID                *string                       `json:"id,omitempty"`
	IDNot             *string                       `json:"id_not,omitempty"`
	IDIn              []string                      `json:"id_in,omitempty"`
	IDNotIn           []string                      `json:"id_not_in,omitempty"`
	IDLt              *string                       `json:"id_lt,omitempty"`
	IDLte             *string                       `json:"id_lte,omitempty"`
	IDGt              *string                       `json:"id_gt,omitempty"`
	IDGte             *string                       `json:"id_gte,omitempty"`
	IDContains        *string                       `json:"id_contains,omitempty"`
	IDNotContains     *string                       `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                       `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                       `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                       `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                       `json:"id_not_ends_with,omitempty"`
	Type              *int32                        `json:"type,omitempty"`
	TypeNot           *int32                        `json:"type_not,omitempty"`
	TypeIn            []int32                       `json:"type_in,omitempty"`
	TypeNotIn         []int32                       `json:"type_not_in,omitempty"`
	TypeLt            *int32                        `json:"type_lt,omitempty"`
	TypeLte           *int32                        `json:"type_lte,omitempty"`
	TypeGt            *int32                        `json:"type_gt,omitempty"`
	TypeGte           *int32                        `json:"type_gte,omitempty"`
	Note              *string                       `json:"note,omitempty"`
	NoteNot           *string                       `json:"note_not,omitempty"`
	NoteIn            []string                      `json:"note_in,omitempty"`
	NoteNotIn         []string                      `json:"note_not_in,omitempty"`
	NoteLt            *string                       `json:"note_lt,omitempty"`
	NoteLte           *string                       `json:"note_lte,omitempty"`
	NoteGt            *string                       `json:"note_gt,omitempty"`
	NoteGte           *string                       `json:"note_gte,omitempty"`
	NoteContains      *string                       `json:"note_contains,omitempty"`
	NoteNotContains   *string                       `json:"note_not_contains,omitempty"`
	NoteStartsWith    *string                       `json:"note_starts_with,omitempty"`
	NoteNotStartsWith *string                       `json:"note_not_starts_with,omitempty"`
	NoteEndsWith      *string                       `json:"note_ends_with,omitempty"`
	NoteNotEndsWith   *string                       `json:"note_not_ends_with,omitempty"`
	FromDate          *string                       `json:"fromDate,omitempty"`
	FromDateNot       *string                       `json:"fromDate_not,omitempty"`
	FromDateIn        []string                      `json:"fromDate_in,omitempty"`
	FromDateNotIn     []string                      `json:"fromDate_not_in,omitempty"`
	FromDateLt        *string                       `json:"fromDate_lt,omitempty"`
	FromDateLte       *string                       `json:"fromDate_lte,omitempty"`
	FromDateGt        *string                       `json:"fromDate_gt,omitempty"`
	FromDateGte       *string                       `json:"fromDate_gte,omitempty"`
	ToDate            *string                       `json:"toDate,omitempty"`
	ToDateNot         *string                       `json:"toDate_not,omitempty"`
	ToDateIn          []string                      `json:"toDate_in,omitempty"`
	ToDateNotIn       []string                      `json:"toDate_not_in,omitempty"`
	ToDateLt          *string                       `json:"toDate_lt,omitempty"`
	ToDateLte         *string                       `json:"toDate_lte,omitempty"`
	ToDateGt          *string                       `json:"toDate_gt,omitempty"`
	ToDateGte         *string                       `json:"toDate_gte,omitempty"`
	CreatedAt         *string                       `json:"createdAt,omitempty"`
	CreatedAtNot      *string                       `json:"createdAt_not,omitempty"`
	CreatedAtIn       []string                      `json:"createdAt_in,omitempty"`
	CreatedAtNotIn    []string                      `json:"createdAt_not_in,omitempty"`
	CreatedAtLt       *string                       `json:"createdAt_lt,omitempty"`
	CreatedAtLte      *string                       `json:"createdAt_lte,omitempty"`
	CreatedAtGt       *string                       `json:"createdAt_gt,omitempty"`
	CreatedAtGte      *string                       `json:"createdAt_gte,omitempty"`
	UpdatedAt         *string                       `json:"updatedAt,omitempty"`
	UpdatedAtNot      *string                       `json:"updatedAt_not,omitempty"`
	UpdatedAtIn       []string                      `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn    []string                      `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt       *string                       `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte      *string                       `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt       *string                       `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte      *string                       `json:"updatedAt_gte,omitempty"`
	IsDel             *bool                         `json:"isDel,omitempty"`
	IsDelNot          *bool                         `json:"isDel_not,omitempty"`
	And               []MaintenanceScalarWhereInput `json:"AND,omitempty"`
	Or                []MaintenanceScalarWhereInput `json:"OR,omitempty"`
	Not               []MaintenanceScalarWhereInput `json:"NOT,omitempty"`
}

type MaintenanceUpdateManyWithWhereNestedInput struct {
	Where MaintenanceScalarWhereInput    `json:"where"`
	Data  MaintenanceUpdateManyDataInput `json:"data"`
}

type MaintenanceUpdateManyDataInput struct {
	Type     *int32  `json:"type,omitempty"`
	Note     *string `json:"note,omitempty"`
	FromDate *string `json:"fromDate,omitempty"`
	ToDate   *string `json:"toDate,omitempty"`
	IsDel    *bool   `json:"isDel,omitempty"`
}

type DeviceUpsertWithWhereUniqueWithoutAppVersionInput struct {
	Where  DeviceWhereUniqueInput                 `json:"where"`
	Update DeviceUpdateWithoutAppVersionDataInput `json:"update"`
	Create DeviceCreateWithoutAppVersionInput     `json:"create"`
}

type DeviceScalarWhereInput struct {
	ID                *string                  `json:"id,omitempty"`
	IDNot             *string                  `json:"id_not,omitempty"`
	IDIn              []string                 `json:"id_in,omitempty"`
	IDNotIn           []string                 `json:"id_not_in,omitempty"`
	IDLt              *string                  `json:"id_lt,omitempty"`
	IDLte             *string                  `json:"id_lte,omitempty"`
	IDGt              *string                  `json:"id_gt,omitempty"`
	IDGte             *string                  `json:"id_gte,omitempty"`
	IDContains        *string                  `json:"id_contains,omitempty"`
	IDNotContains     *string                  `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                  `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                  `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                  `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                  `json:"id_not_ends_with,omitempty"`
	Code              *int32                   `json:"code,omitempty"`
	CodeNot           *int32                   `json:"code_not,omitempty"`
	CodeIn            []int32                  `json:"code_in,omitempty"`
	CodeNotIn         []int32                  `json:"code_not_in,omitempty"`
	CodeLt            *int32                   `json:"code_lt,omitempty"`
	CodeLte           *int32                   `json:"code_lte,omitempty"`
	CodeGt            *int32                   `json:"code_gt,omitempty"`
	CodeGte           *int32                   `json:"code_gte,omitempty"`
	Name              *string                  `json:"name,omitempty"`
	NameNot           *string                  `json:"name_not,omitempty"`
	NameIn            []string                 `json:"name_in,omitempty"`
	NameNotIn         []string                 `json:"name_not_in,omitempty"`
	NameLt            *string                  `json:"name_lt,omitempty"`
	NameLte           *string                  `json:"name_lte,omitempty"`
	NameGt            *string                  `json:"name_gt,omitempty"`
	NameGte           *string                  `json:"name_gte,omitempty"`
	NameContains      *string                  `json:"name_contains,omitempty"`
	NameNotContains   *string                  `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                  `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                  `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                  `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                  `json:"name_not_ends_with,omitempty"`
	And               []DeviceScalarWhereInput `json:"AND,omitempty"`
	Or                []DeviceScalarWhereInput `json:"OR,omitempty"`
	Not               []DeviceScalarWhereInput `json:"NOT,omitempty"`
}

type DeviceUpdateManyWithWhereNestedInput struct {
	Where DeviceScalarWhereInput    `json:"where"`
	Data  DeviceUpdateManyDataInput `json:"data"`
}

type DeviceUpdateManyDataInput struct {
	Code *int32  `json:"code,omitempty"`
	Name *string `json:"name,omitempty"`
}

type AppVersionUpdateManyMutationInput struct {
	Version    *string `json:"version,omitempty"`
	Type       *int32  `json:"type,omitempty"`
	Note       *string `json:"note,omitempty"`
	ReleasedAt *string `json:"releasedAt,omitempty"`
	IsDel      *bool   `json:"isDel,omitempty"`
}

type BadgeCreateInput struct {
	Name        string                                `json:"name"`
	ImageUrl    *string                               `json:"imageUrl,omitempty"`
	Description string                                `json:"description"`
	OrderIndex  int32                                 `json:"orderIndex"`
	Pages       *PageBadgeCreateManyWithoutBadgeInput `json:"pages,omitempty"`
}

type PageBadgeCreateManyWithoutBadgeInput struct {
	Create  []PageBadgeCreateWithoutBadgeInput `json:"create,omitempty"`
	Connect []PageBadgeWhereUniqueInput        `json:"connect,omitempty"`
}

type PageBadgeCreateWithoutBadgeInput struct {
	Vote  *int32                                     `json:"vote,omitempty"`
	Voter *BadgeVoterCreateManyWithoutPageBadgeInput `json:"voter,omitempty"`
	Page  PageCreateOneWithoutBadgesInput            `json:"page"`
}

type PageCreateOneWithoutBadgesInput struct {
	Create  *PageCreateWithoutBadgesInput `json:"create,omitempty"`
	Connect *PageWhereUniqueInput         `json:"connect,omitempty"`
}

type PageCreateWithoutBadgesInput struct {
	PageId           string                                          `json:"pageId"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Youtube          *YoutubeCreateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchCreateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramCreateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvCreateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanCreateManyInput                         `json:"fans,omitempty"`
	Owner            *UserCreateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentCreateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemCreateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageCreateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentCreateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type BadgeUpdateInput struct {
	Name        *string                               `json:"name,omitempty"`
	ImageUrl    *string                               `json:"imageUrl,omitempty"`
	Description *string                               `json:"description,omitempty"`
	OrderIndex  *int32                                `json:"orderIndex,omitempty"`
	Pages       *PageBadgeUpdateManyWithoutBadgeInput `json:"pages,omitempty"`
}

type PageBadgeUpdateManyWithoutBadgeInput struct {
	Create     []PageBadgeCreateWithoutBadgeInput                `json:"create,omitempty"`
	Delete     []PageBadgeWhereUniqueInput                       `json:"delete,omitempty"`
	Connect    []PageBadgeWhereUniqueInput                       `json:"connect,omitempty"`
	Set        []PageBadgeWhereUniqueInput                       `json:"set,omitempty"`
	Disconnect []PageBadgeWhereUniqueInput                       `json:"disconnect,omitempty"`
	Update     []PageBadgeUpdateWithWhereUniqueWithoutBadgeInput `json:"update,omitempty"`
	Upsert     []PageBadgeUpsertWithWhereUniqueWithoutBadgeInput `json:"upsert,omitempty"`
	DeleteMany []PageBadgeScalarWhereInput                       `json:"deleteMany,omitempty"`
	UpdateMany []PageBadgeUpdateManyWithWhereNestedInput         `json:"updateMany,omitempty"`
}

type PageBadgeUpdateWithWhereUniqueWithoutBadgeInput struct {
	Where PageBadgeWhereUniqueInput            `json:"where"`
	Data  PageBadgeUpdateWithoutBadgeDataInput `json:"data"`
}

type PageBadgeUpdateWithoutBadgeDataInput struct {
	Vote  *int32                                     `json:"vote,omitempty"`
	Voter *BadgeVoterUpdateManyWithoutPageBadgeInput `json:"voter,omitempty"`
	Page  *PageUpdateOneRequiredWithoutBadgesInput   `json:"page,omitempty"`
}

type PageUpdateOneRequiredWithoutBadgesInput struct {
	Create  *PageCreateWithoutBadgesInput     `json:"create,omitempty"`
	Update  *PageUpdateWithoutBadgesDataInput `json:"update,omitempty"`
	Upsert  *PageUpsertWithoutBadgesInput     `json:"upsert,omitempty"`
	Connect *PageWhereUniqueInput             `json:"connect,omitempty"`
}

type PageUpdateWithoutBadgesDataInput struct {
	PageId           *string                                         `json:"pageId,omitempty"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Youtube          *YoutubeUpdateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchUpdateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramUpdateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvUpdateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanUpdateManyInput                         `json:"fans,omitempty"`
	Owner            *UserUpdateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentUpdateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemUpdateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageUpdateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentUpdateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type PageUpsertWithoutBadgesInput struct {
	Update PageUpdateWithoutBadgesDataInput `json:"update"`
	Create PageCreateWithoutBadgesInput     `json:"create"`
}

type PageBadgeUpsertWithWhereUniqueWithoutBadgeInput struct {
	Where  PageBadgeWhereUniqueInput            `json:"where"`
	Update PageBadgeUpdateWithoutBadgeDataInput `json:"update"`
	Create PageBadgeCreateWithoutBadgeInput     `json:"create"`
}

type BadgeUpdateManyMutationInput struct {
	Name        *string `json:"name,omitempty"`
	ImageUrl    *string `json:"imageUrl,omitempty"`
	Description *string `json:"description,omitempty"`
	OrderIndex  *int32  `json:"orderIndex,omitempty"`
}

type BadgeVoterCreateInput struct {
	PageBadge     *PageBadgeCreateOneWithoutVoterInput `json:"pageBadge,omitempty"`
	ReviewContent *ReviewContentCreateOneInput         `json:"reviewContent,omitempty"`
	User          *UserCreateOneInput                  `json:"user,omitempty"`
	Ip            *string                              `json:"ip,omitempty"`
}

type PageBadgeCreateOneWithoutVoterInput struct {
	Create  *PageBadgeCreateWithoutVoterInput `json:"create,omitempty"`
	Connect *PageBadgeWhereUniqueInput        `json:"connect,omitempty"`
}

type PageBadgeCreateWithoutVoterInput struct {
	Badge BadgeCreateOneWithoutPagesInput `json:"badge"`
	Vote  *int32                          `json:"vote,omitempty"`
	Page  PageCreateOneWithoutBadgesInput `json:"page"`
}

type BadgeVoterUpdateInput struct {
	PageBadge     *PageBadgeUpdateOneWithoutVoterInput `json:"pageBadge,omitempty"`
	ReviewContent *ReviewContentUpdateOneInput         `json:"reviewContent,omitempty"`
	User          *UserUpdateOneInput                  `json:"user,omitempty"`
	Ip            *string                              `json:"ip,omitempty"`
}

type PageBadgeUpdateOneWithoutVoterInput struct {
	Create     *PageBadgeCreateWithoutVoterInput     `json:"create,omitempty"`
	Update     *PageBadgeUpdateWithoutVoterDataInput `json:"update,omitempty"`
	Upsert     *PageBadgeUpsertWithoutVoterInput     `json:"upsert,omitempty"`
	Delete     *bool                                 `json:"delete,omitempty"`
	Disconnect *bool                                 `json:"disconnect,omitempty"`
	Connect    *PageBadgeWhereUniqueInput            `json:"connect,omitempty"`
}

type PageBadgeUpdateWithoutVoterDataInput struct {
	Badge *BadgeUpdateOneRequiredWithoutPagesInput `json:"badge,omitempty"`
	Vote  *int32                                   `json:"vote,omitempty"`
	Page  *PageUpdateOneRequiredWithoutBadgesInput `json:"page,omitempty"`
}

type PageBadgeUpsertWithoutVoterInput struct {
	Update PageBadgeUpdateWithoutVoterDataInput `json:"update"`
	Create PageBadgeCreateWithoutVoterInput     `json:"create"`
}

type BadgeVoterUpdateManyMutationInput struct {
	Ip *string `json:"ip,omitempty"`
}

type BankUpdateInput struct {
	Code *string `json:"code,omitempty"`
	Name *string `json:"name,omitempty"`
}

type BankUpdateManyMutationInput struct {
	Code *string `json:"code,omitempty"`
	Name *string `json:"name,omitempty"`
}

type BankAccountVerificationCreateInput struct {
	Verification    *VerificationCreateOneWithoutBankAccountInput        `json:"verification,omitempty"`
	Bank            BankCreateOneInput                                   `json:"bank"`
	HolderName      string                                               `json:"holderName"`
	AccountNumber   string                                               `json:"accountNumber"`
	TransactionInfo BankAccountVerificationTransactionInfoCreateOneInput `json:"transactionInfo"`
	VerifyAt        *string                                              `json:"verifyAt,omitempty"`
}

type VerificationCreateOneWithoutBankAccountInput struct {
	Create  *VerificationCreateWithoutBankAccountInput `json:"create,omitempty"`
	Connect *VerificationWhereUniqueInput              `json:"connect,omitempty"`
}

type VerificationCreateWithoutBankAccountInput struct {
	Level          *int32                                              `json:"level,omitempty"`
	HasEmail       *bool                                               `json:"hasEmail,omitempty"`
	HasPin         *bool                                               `json:"hasPin,omitempty"`
	HasPhone       *bool                                               `json:"hasPhone,omitempty"`
	HasBankAccount *bool                                               `json:"hasBankAccount,omitempty"`
	HasInter       *bool                                               `json:"hasInter,omitempty"`
	PinNumber      *string                                             `json:"pinNumber,omitempty"`
	Phone          *PhoneVerificationCreateOneWithoutVerificationInput `json:"phone,omitempty"`
	User           UserCreateOneWithoutVerificationInput               `json:"user"`
}

type UserCreateOneWithoutVerificationInput struct {
	Create  *UserCreateWithoutVerificationInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput               `json:"connect,omitempty"`
}

type UserCreateWithoutVerificationInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type BankAccountVerificationUpdateInput struct {
	Verification    *VerificationUpdateOneWithoutBankAccountInput                 `json:"verification,omitempty"`
	Bank            *BankUpdateOneRequiredInput                                   `json:"bank,omitempty"`
	HolderName      *string                                                       `json:"holderName,omitempty"`
	AccountNumber   *string                                                       `json:"accountNumber,omitempty"`
	TransactionInfo *BankAccountVerificationTransactionInfoUpdateOneRequiredInput `json:"transactionInfo,omitempty"`
	VerifyAt        *string                                                       `json:"verifyAt,omitempty"`
}

type VerificationUpdateOneWithoutBankAccountInput struct {
	Create     *VerificationCreateWithoutBankAccountInput     `json:"create,omitempty"`
	Update     *VerificationUpdateWithoutBankAccountDataInput `json:"update,omitempty"`
	Upsert     *VerificationUpsertWithoutBankAccountInput     `json:"upsert,omitempty"`
	Delete     *bool                                          `json:"delete,omitempty"`
	Disconnect *bool                                          `json:"disconnect,omitempty"`
	Connect    *VerificationWhereUniqueInput                  `json:"connect,omitempty"`
}

type VerificationUpdateWithoutBankAccountDataInput struct {
	Level          *int32                                              `json:"level,omitempty"`
	HasEmail       *bool                                               `json:"hasEmail,omitempty"`
	HasPin         *bool                                               `json:"hasPin,omitempty"`
	HasPhone       *bool                                               `json:"hasPhone,omitempty"`
	HasBankAccount *bool                                               `json:"hasBankAccount,omitempty"`
	HasInter       *bool                                               `json:"hasInter,omitempty"`
	PinNumber      *string                                             `json:"pinNumber,omitempty"`
	Phone          *PhoneVerificationUpdateOneWithoutVerificationInput `json:"phone,omitempty"`
	User           *UserUpdateOneRequiredWithoutVerificationInput      `json:"user,omitempty"`
}

type UserUpdateOneRequiredWithoutVerificationInput struct {
	Create  *UserCreateWithoutVerificationInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutVerificationDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutVerificationInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput                   `json:"connect,omitempty"`
}

type UserUpdateWithoutVerificationDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type UserUpsertWithoutVerificationInput struct {
	Update UserUpdateWithoutVerificationDataInput `json:"update"`
	Create UserCreateWithoutVerificationInput     `json:"create"`
}

type VerificationUpsertWithoutBankAccountInput struct {
	Update VerificationUpdateWithoutBankAccountDataInput `json:"update"`
	Create VerificationCreateWithoutBankAccountInput     `json:"create"`
}

type BankAccountVerificationUpdateManyMutationInput struct {
	HolderName    *string `json:"holderName,omitempty"`
	AccountNumber *string `json:"accountNumber,omitempty"`
	VerifyAt      *string `json:"verifyAt,omitempty"`
}

type BankAccountVerificationTransactionInfoUpdateInput struct {
	TransactionDt *string `json:"transactionDt,omitempty"`
	TransactionNo *string `json:"transactionNo,omitempty"`
	ExpireAt      *string `json:"expireAt,omitempty"`
}

type BankAccountVerificationTransactionInfoUpdateManyMutationInput struct {
	TransactionDt *string `json:"transactionDt,omitempty"`
	TransactionNo *string `json:"transactionNo,omitempty"`
	ExpireAt      *string `json:"expireAt,omitempty"`
}

type BoardCreateInput struct {
	Type    *int32 `json:"type,omitempty"`
	Title   string `json:"title"`
	Content string `json:"content"`
	IsDel   *bool  `json:"isDel,omitempty"`
}

type BoardUpdateInput struct {
	Type    *int32  `json:"type,omitempty"`
	Title   *string `json:"title,omitempty"`
	Content *string `json:"content,omitempty"`
	IsDel   *bool   `json:"isDel,omitempty"`
}

type BoardUpdateManyMutationInput struct {
	Type    *int32  `json:"type,omitempty"`
	Title   *string `json:"title,omitempty"`
	Content *string `json:"content,omitempty"`
	IsDel   *bool   `json:"isDel,omitempty"`
}

type CashHistoryCreateInput struct {
	Type                int32                                                    `json:"type"`
	Property            *int32                                                   `json:"property,omitempty"`
	OrderNum            *int32                                                   `json:"orderNum,omitempty"`
	Description         *string                                                  `json:"description,omitempty"`
	User                *UserCreateOneWithoutCashHistoriesInput                  `json:"user,omitempty"`
	MotherHistory       *MotherHistoryCreateOneWithoutCashHistoryInput           `json:"motherHistory,omitempty"`
	Qeh                 *QuestExpenditureHistoryCreateOneWithoutCashHistoryInput `json:"qeh,omitempty"`
	AergoAccountHistory *AergoAccountHistoryCreateOneWithoutCashHistoryInput     `json:"aergoAccountHistory,omitempty"`
	Price               *int32                                                   `json:"price,omitempty"`
	OPrice              *float64                                                 `json:"oPrice,omitempty"`
	OPriceBack          *float64                                                 `json:"oPriceBack,omitempty"`
	Qty                 *float64                                                 `json:"qty,omitempty"`
	Memo                *string                                                  `json:"memo,omitempty"`
}

type CashHistoryUpdateInput struct {
	Type                *int32                                                   `json:"type,omitempty"`
	Property            *int32                                                   `json:"property,omitempty"`
	OrderNum            *int32                                                   `json:"orderNum,omitempty"`
	Description         *string                                                  `json:"description,omitempty"`
	User                *UserUpdateOneWithoutCashHistoriesInput                  `json:"user,omitempty"`
	MotherHistory       *MotherHistoryUpdateOneWithoutCashHistoryInput           `json:"motherHistory,omitempty"`
	Qeh                 *QuestExpenditureHistoryUpdateOneWithoutCashHistoryInput `json:"qeh,omitempty"`
	AergoAccountHistory *AergoAccountHistoryUpdateOneWithoutCashHistoryInput     `json:"aergoAccountHistory,omitempty"`
	Price               *int32                                                   `json:"price,omitempty"`
	OPrice              *float64                                                 `json:"oPrice,omitempty"`
	OPriceBack          *float64                                                 `json:"oPriceBack,omitempty"`
	Qty                 *float64                                                 `json:"qty,omitempty"`
	Memo                *string                                                  `json:"memo,omitempty"`
}

type CashHistoryUpdateManyMutationInput struct {
	Type        *int32   `json:"type,omitempty"`
	Property    *int32   `json:"property,omitempty"`
	OrderNum    *int32   `json:"orderNum,omitempty"`
	Description *string  `json:"description,omitempty"`
	Price       *int32   `json:"price,omitempty"`
	OPrice      *float64 `json:"oPrice,omitempty"`
	OPriceBack  *float64 `json:"oPriceBack,omitempty"`
	Qty         *float64 `json:"qty,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
}

type CategoryCreateInput struct {
	Name       string                                    `json:"name"`
	Posts      *PostCreateManyWithoutCategoriesInput     `json:"posts,omitempty"`
	FeedUsers  *UserCreateManyWithoutFeedCategoriesInput `json:"feedUsers,omitempty"`
	Coins      *CoinCreateManyWithoutCategoriesInput     `json:"coins,omitempty"`
	OrderIndex *float64                                  `json:"order_index,omitempty"`
}

type CategoryUpdateInput struct {
	Name       *string                                   `json:"name,omitempty"`
	Posts      *PostUpdateManyWithoutCategoriesInput     `json:"posts,omitempty"`
	FeedUsers  *UserUpdateManyWithoutFeedCategoriesInput `json:"feedUsers,omitempty"`
	Coins      *CoinUpdateManyWithoutCategoriesInput     `json:"coins,omitempty"`
	OrderIndex *float64                                  `json:"order_index,omitempty"`
}

type CategoryUpdateManyMutationInput struct {
	Name       *string  `json:"name,omitempty"`
	OrderIndex *float64 `json:"order_index,omitempty"`
}

type CoinUpdateInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type CoinUpdateManyMutationInput struct {
	Name            *string  `json:"name,omitempty"`
	Qty             *float64 `json:"qty,omitempty"`
	StandardPrice   *float64 `json:"standardPrice,omitempty"`
	CurrentPrice    *float64 `json:"currentPrice,omitempty"`
	Description     *string  `json:"description,omitempty"`
	Status          *int32   `json:"status,omitempty"`
	Weight          *string  `json:"weight,omitempty"`
	DeployTxhash    *string  `json:"deployTxhash,omitempty"`
	ContractAddress *string  `json:"contractAddress,omitempty"`
	ODda            *float64 `json:"oDDA,omitempty"`
}

type CoinKlineCreateInput struct {
	Open   float64                             `json:"open"`
	Close  float64                             `json:"close"`
	High   float64                             `json:"high"`
	Low    float64                             `json:"low"`
	Volume float64                             `json:"volume"`
	Deal   float64                             `json:"deal"`
	Coin   *CoinCreateOneWithoutCoinKlineInput `json:"coin,omitempty"`
}

type CoinCreateOneWithoutCoinKlineInput struct {
	Create  *CoinCreateWithoutCoinKlineInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput            `json:"connect,omitempty"`
}

type CoinCreateWithoutCoinKlineInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type CoinKlineUpdateInput struct {
	Open   *float64                            `json:"open,omitempty"`
	Close  *float64                            `json:"close,omitempty"`
	High   *float64                            `json:"high,omitempty"`
	Low    *float64                            `json:"low,omitempty"`
	Volume *float64                            `json:"volume,omitempty"`
	Deal   *float64                            `json:"deal,omitempty"`
	Coin   *CoinUpdateOneWithoutCoinKlineInput `json:"coin,omitempty"`
}

type CoinUpdateOneWithoutCoinKlineInput struct {
	Create     *CoinCreateWithoutCoinKlineInput     `json:"create,omitempty"`
	Update     *CoinUpdateWithoutCoinKlineDataInput `json:"update,omitempty"`
	Upsert     *CoinUpsertWithoutCoinKlineInput     `json:"upsert,omitempty"`
	Delete     *bool                                `json:"delete,omitempty"`
	Disconnect *bool                                `json:"disconnect,omitempty"`
	Connect    *CoinWhereUniqueInput                `json:"connect,omitempty"`
}

type CoinUpdateWithoutCoinKlineDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type CoinUpsertWithoutCoinKlineInput struct {
	Update CoinUpdateWithoutCoinKlineDataInput `json:"update"`
	Create CoinCreateWithoutCoinKlineInput     `json:"create"`
}

type CoinKlineUpdateManyMutationInput struct {
	Open   *float64 `json:"open,omitempty"`
	Close  *float64 `json:"close,omitempty"`
	High   *float64 `json:"high,omitempty"`
	Low    *float64 `json:"low,omitempty"`
	Volume *float64 `json:"volume,omitempty"`
	Deal   *float64 `json:"deal,omitempty"`
}

type CoinPriceTableCreateInput struct {
	Type      int32                                    `json:"type"`
	Coin      *CoinCreateOneWithoutCoinPriceTableInput `json:"coin,omitempty"`
	InfoValue *CoinPriceTableCreateinfoValueInput      `json:"infoValue,omitempty"`
}

type CoinCreateOneWithoutCoinPriceTableInput struct {
	Create  *CoinCreateWithoutCoinPriceTableInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput                 `json:"connect,omitempty"`
}

type CoinCreateWithoutCoinPriceTableInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryCreateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type CoinPriceTableUpdateInput struct {
	Type      *int32                                   `json:"type,omitempty"`
	Coin      *CoinUpdateOneWithoutCoinPriceTableInput `json:"coin,omitempty"`
	InfoValue *CoinPriceTableUpdateinfoValueInput      `json:"infoValue,omitempty"`
}

type CoinUpdateOneWithoutCoinPriceTableInput struct {
	Create     *CoinCreateWithoutCoinPriceTableInput     `json:"create,omitempty"`
	Update     *CoinUpdateWithoutCoinPriceTableDataInput `json:"update,omitempty"`
	Upsert     *CoinUpsertWithoutCoinPriceTableInput     `json:"upsert,omitempty"`
	Delete     *bool                                     `json:"delete,omitempty"`
	Disconnect *bool                                     `json:"disconnect,omitempty"`
	Connect    *CoinWhereUniqueInput                     `json:"connect,omitempty"`
}

type CoinUpdateWithoutCoinPriceTableDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderDealsHistories     *OrderDealsHistoryUpdateManyWithoutCoinInput     `json:"orderDealsHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type CoinUpsertWithoutCoinPriceTableInput struct {
	Update CoinUpdateWithoutCoinPriceTableDataInput `json:"update"`
	Create CoinCreateWithoutCoinPriceTableInput     `json:"create"`
}

type CoinPriceTableUpdateManyMutationInput struct {
	Type      *int32                              `json:"type,omitempty"`
	InfoValue *CoinPriceTableUpdateinfoValueInput `json:"infoValue,omitempty"`
}

type CommentCreateInput struct {
	Type              *int32                                         `json:"type,omitempty"`
	Post              PostCreateOneWithoutCommentsInput              `json:"post"`
	Content           string                                         `json:"content"`
	Image             *FileInfoCreateOneInput                        `json:"image,omitempty"`
	Url               *string                                        `json:"url,omitempty"`
	Reply             *CommentReplyCreateManyWithoutCommentInput     `json:"reply,omitempty"`
	Owner             UserCreateOneWithoutCommentsInput              `json:"owner"`
	PostRewardHistory *PostRewardHistoryCreateOneWithoutCommentInput `json:"postRewardHistory,omitempty"`
	IsDel             *bool                                          `json:"isDel,omitempty"`
}

type CommentUpdateInput struct {
	Type              *int32                                         `json:"type,omitempty"`
	Post              *PostUpdateOneRequiredWithoutCommentsInput     `json:"post,omitempty"`
	Content           *string                                        `json:"content,omitempty"`
	Image             *FileInfoUpdateOneInput                        `json:"image,omitempty"`
	Url               *string                                        `json:"url,omitempty"`
	Reply             *CommentReplyUpdateManyWithoutCommentInput     `json:"reply,omitempty"`
	Owner             *UserUpdateOneRequiredWithoutCommentsInput     `json:"owner,omitempty"`
	PostRewardHistory *PostRewardHistoryUpdateOneWithoutCommentInput `json:"postRewardHistory,omitempty"`
	IsDel             *bool                                          `json:"isDel,omitempty"`
}

type CommentUpdateManyMutationInput struct {
	Type    *int32  `json:"type,omitempty"`
	Content *string `json:"content,omitempty"`
	Url     *string `json:"url,omitempty"`
	IsDel   *bool   `json:"isDel,omitempty"`
}

type CommentReplyCreateInput struct {
	Comment CommentCreateOneWithoutReplyInput `json:"comment"`
	Content string                            `json:"content"`
	Owner   UserCreateOneInput                `json:"owner"`
	IsDel   *bool                             `json:"isDel,omitempty"`
}

type CommentCreateOneWithoutReplyInput struct {
	Create  *CommentCreateWithoutReplyInput `json:"create,omitempty"`
	Connect *CommentWhereUniqueInput        `json:"connect,omitempty"`
}

type CommentCreateWithoutReplyInput struct {
	Type              *int32                                         `json:"type,omitempty"`
	Post              PostCreateOneWithoutCommentsInput              `json:"post"`
	Content           string                                         `json:"content"`
	Image             *FileInfoCreateOneInput                        `json:"image,omitempty"`
	Url               *string                                        `json:"url,omitempty"`
	Owner             UserCreateOneWithoutCommentsInput              `json:"owner"`
	PostRewardHistory *PostRewardHistoryCreateOneWithoutCommentInput `json:"postRewardHistory,omitempty"`
	IsDel             *bool                                          `json:"isDel,omitempty"`
}

type CommentReplyUpdateInput struct {
	Comment *CommentUpdateOneRequiredWithoutReplyInput `json:"comment,omitempty"`
	Content *string                                    `json:"content,omitempty"`
	Owner   *UserUpdateOneRequiredInput                `json:"owner,omitempty"`
	IsDel   *bool                                      `json:"isDel,omitempty"`
}

type CommentUpdateOneRequiredWithoutReplyInput struct {
	Create  *CommentCreateWithoutReplyInput     `json:"create,omitempty"`
	Update  *CommentUpdateWithoutReplyDataInput `json:"update,omitempty"`
	Upsert  *CommentUpsertWithoutReplyInput     `json:"upsert,omitempty"`
	Connect *CommentWhereUniqueInput            `json:"connect,omitempty"`
}

type CommentUpdateWithoutReplyDataInput struct {
	Type              *int32                                         `json:"type,omitempty"`
	Post              *PostUpdateOneRequiredWithoutCommentsInput     `json:"post,omitempty"`
	Content           *string                                        `json:"content,omitempty"`
	Image             *FileInfoUpdateOneInput                        `json:"image,omitempty"`
	Url               *string                                        `json:"url,omitempty"`
	Owner             *UserUpdateOneRequiredWithoutCommentsInput     `json:"owner,omitempty"`
	PostRewardHistory *PostRewardHistoryUpdateOneWithoutCommentInput `json:"postRewardHistory,omitempty"`
	IsDel             *bool                                          `json:"isDel,omitempty"`
}

type CommentUpsertWithoutReplyInput struct {
	Update CommentUpdateWithoutReplyDataInput `json:"update"`
	Create CommentCreateWithoutReplyInput     `json:"create"`
}

type CommentReplyUpdateManyMutationInput struct {
	Content *string `json:"content,omitempty"`
	IsDel   *bool   `json:"isDel,omitempty"`
}

type DeviceCreateInput struct {
	Maintenance *MaintenanceCreateManyWithoutAffectedDevicesInput `json:"maintenance,omitempty"`
	AppVersion  *AppVersionCreateManyWithoutAffectedDevicesInput  `json:"appVersion,omitempty"`
	Code        int32                                             `json:"code"`
	Name        string                                            `json:"name"`
}

type AppVersionCreateManyWithoutAffectedDevicesInput struct {
	Create  []AppVersionCreateWithoutAffectedDevicesInput `json:"create,omitempty"`
	Connect []AppVersionWhereUniqueInput                  `json:"connect,omitempty"`
}

type AppVersionCreateWithoutAffectedDevicesInput struct {
	Version    string                   `json:"version"`
	Type       int32                    `json:"type"`
	Note       string                   `json:"note"`
	CreateUser *AdminUserCreateOneInput `json:"createUser,omitempty"`
	UpdateUser *AdminUserCreateOneInput `json:"updateUser,omitempty"`
	ReleasedAt string                   `json:"releasedAt"`
	IsDel      *bool                    `json:"isDel,omitempty"`
}

type DeviceUpdateInput struct {
	Maintenance *MaintenanceUpdateManyWithoutAffectedDevicesInput `json:"maintenance,omitempty"`
	AppVersion  *AppVersionUpdateManyWithoutAffectedDevicesInput  `json:"appVersion,omitempty"`
	Code        *int32                                            `json:"code,omitempty"`
	Name        *string                                           `json:"name,omitempty"`
}

type AppVersionUpdateManyWithoutAffectedDevicesInput struct {
	Create     []AppVersionCreateWithoutAffectedDevicesInput                `json:"create,omitempty"`
	Delete     []AppVersionWhereUniqueInput                                 `json:"delete,omitempty"`
	Connect    []AppVersionWhereUniqueInput                                 `json:"connect,omitempty"`
	Set        []AppVersionWhereUniqueInput                                 `json:"set,omitempty"`
	Disconnect []AppVersionWhereUniqueInput                                 `json:"disconnect,omitempty"`
	Update     []AppVersionUpdateWithWhereUniqueWithoutAffectedDevicesInput `json:"update,omitempty"`
	Upsert     []AppVersionUpsertWithWhereUniqueWithoutAffectedDevicesInput `json:"upsert,omitempty"`
	DeleteMany []AppVersionScalarWhereInput                                 `json:"deleteMany,omitempty"`
	UpdateMany []AppVersionUpdateManyWithWhereNestedInput                   `json:"updateMany,omitempty"`
}

type AppVersionUpdateWithWhereUniqueWithoutAffectedDevicesInput struct {
	Where AppVersionWhereUniqueInput                      `json:"where"`
	Data  AppVersionUpdateWithoutAffectedDevicesDataInput `json:"data"`
}

type AppVersionUpdateWithoutAffectedDevicesDataInput struct {
	Version    *string                  `json:"version,omitempty"`
	Type       *int32                   `json:"type,omitempty"`
	Note       *string                  `json:"note,omitempty"`
	CreateUser *AdminUserUpdateOneInput `json:"createUser,omitempty"`
	UpdateUser *AdminUserUpdateOneInput `json:"updateUser,omitempty"`
	ReleasedAt *string                  `json:"releasedAt,omitempty"`
	IsDel      *bool                    `json:"isDel,omitempty"`
}

type AppVersionUpsertWithWhereUniqueWithoutAffectedDevicesInput struct {
	Where  AppVersionWhereUniqueInput                      `json:"where"`
	Update AppVersionUpdateWithoutAffectedDevicesDataInput `json:"update"`
	Create AppVersionCreateWithoutAffectedDevicesInput     `json:"create"`
}

type AppVersionScalarWhereInput struct {
	ID                   *string                      `json:"id,omitempty"`
	IDNot                *string                      `json:"id_not,omitempty"`
	IDIn                 []string                     `json:"id_in,omitempty"`
	IDNotIn              []string                     `json:"id_not_in,omitempty"`
	IDLt                 *string                      `json:"id_lt,omitempty"`
	IDLte                *string                      `json:"id_lte,omitempty"`
	IDGt                 *string                      `json:"id_gt,omitempty"`
	IDGte                *string                      `json:"id_gte,omitempty"`
	IDContains           *string                      `json:"id_contains,omitempty"`
	IDNotContains        *string                      `json:"id_not_contains,omitempty"`
	IDStartsWith         *string                      `json:"id_starts_with,omitempty"`
	IDNotStartsWith      *string                      `json:"id_not_starts_with,omitempty"`
	IDEndsWith           *string                      `json:"id_ends_with,omitempty"`
	IDNotEndsWith        *string                      `json:"id_not_ends_with,omitempty"`
	Version              *string                      `json:"version,omitempty"`
	VersionNot           *string                      `json:"version_not,omitempty"`
	VersionIn            []string                     `json:"version_in,omitempty"`
	VersionNotIn         []string                     `json:"version_not_in,omitempty"`
	VersionLt            *string                      `json:"version_lt,omitempty"`
	VersionLte           *string                      `json:"version_lte,omitempty"`
	VersionGt            *string                      `json:"version_gt,omitempty"`
	VersionGte           *string                      `json:"version_gte,omitempty"`
	VersionContains      *string                      `json:"version_contains,omitempty"`
	VersionNotContains   *string                      `json:"version_not_contains,omitempty"`
	VersionStartsWith    *string                      `json:"version_starts_with,omitempty"`
	VersionNotStartsWith *string                      `json:"version_not_starts_with,omitempty"`
	VersionEndsWith      *string                      `json:"version_ends_with,omitempty"`
	VersionNotEndsWith   *string                      `json:"version_not_ends_with,omitempty"`
	Type                 *int32                       `json:"type,omitempty"`
	TypeNot              *int32                       `json:"type_not,omitempty"`
	TypeIn               []int32                      `json:"type_in,omitempty"`
	TypeNotIn            []int32                      `json:"type_not_in,omitempty"`
	TypeLt               *int32                       `json:"type_lt,omitempty"`
	TypeLte              *int32                       `json:"type_lte,omitempty"`
	TypeGt               *int32                       `json:"type_gt,omitempty"`
	TypeGte              *int32                       `json:"type_gte,omitempty"`
	Note                 *string                      `json:"note,omitempty"`
	NoteNot              *string                      `json:"note_not,omitempty"`
	NoteIn               []string                     `json:"note_in,omitempty"`
	NoteNotIn            []string                     `json:"note_not_in,omitempty"`
	NoteLt               *string                      `json:"note_lt,omitempty"`
	NoteLte              *string                      `json:"note_lte,omitempty"`
	NoteGt               *string                      `json:"note_gt,omitempty"`
	NoteGte              *string                      `json:"note_gte,omitempty"`
	NoteContains         *string                      `json:"note_contains,omitempty"`
	NoteNotContains      *string                      `json:"note_not_contains,omitempty"`
	NoteStartsWith       *string                      `json:"note_starts_with,omitempty"`
	NoteNotStartsWith    *string                      `json:"note_not_starts_with,omitempty"`
	NoteEndsWith         *string                      `json:"note_ends_with,omitempty"`
	NoteNotEndsWith      *string                      `json:"note_not_ends_with,omitempty"`
	ReleasedAt           *string                      `json:"releasedAt,omitempty"`
	ReleasedAtNot        *string                      `json:"releasedAt_not,omitempty"`
	ReleasedAtIn         []string                     `json:"releasedAt_in,omitempty"`
	ReleasedAtNotIn      []string                     `json:"releasedAt_not_in,omitempty"`
	ReleasedAtLt         *string                      `json:"releasedAt_lt,omitempty"`
	ReleasedAtLte        *string                      `json:"releasedAt_lte,omitempty"`
	ReleasedAtGt         *string                      `json:"releasedAt_gt,omitempty"`
	ReleasedAtGte        *string                      `json:"releasedAt_gte,omitempty"`
	CreatedAt            *string                      `json:"createdAt,omitempty"`
	CreatedAtNot         *string                      `json:"createdAt_not,omitempty"`
	CreatedAtIn          []string                     `json:"createdAt_in,omitempty"`
	CreatedAtNotIn       []string                     `json:"createdAt_not_in,omitempty"`
	CreatedAtLt          *string                      `json:"createdAt_lt,omitempty"`
	CreatedAtLte         *string                      `json:"createdAt_lte,omitempty"`
	CreatedAtGt          *string                      `json:"createdAt_gt,omitempty"`
	CreatedAtGte         *string                      `json:"createdAt_gte,omitempty"`
	UpdatedAt            *string                      `json:"updatedAt,omitempty"`
	UpdatedAtNot         *string                      `json:"updatedAt_not,omitempty"`
	UpdatedAtIn          []string                     `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn       []string                     `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt          *string                      `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte         *string                      `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt          *string                      `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte         *string                      `json:"updatedAt_gte,omitempty"`
	IsDel                *bool                        `json:"isDel,omitempty"`
	IsDelNot             *bool                        `json:"isDel_not,omitempty"`
	And                  []AppVersionScalarWhereInput `json:"AND,omitempty"`
	Or                   []AppVersionScalarWhereInput `json:"OR,omitempty"`
	Not                  []AppVersionScalarWhereInput `json:"NOT,omitempty"`
}

type AppVersionUpdateManyWithWhereNestedInput struct {
	Where AppVersionScalarWhereInput    `json:"where"`
	Data  AppVersionUpdateManyDataInput `json:"data"`
}

type AppVersionUpdateManyDataInput struct {
	Version    *string `json:"version,omitempty"`
	Type       *int32  `json:"type,omitempty"`
	Note       *string `json:"note,omitempty"`
	ReleasedAt *string `json:"releasedAt,omitempty"`
	IsDel      *bool   `json:"isDel,omitempty"`
}

type DeviceUpdateManyMutationInput struct {
	Code *int32  `json:"code,omitempty"`
	Name *string `json:"name,omitempty"`
}

type FeeCreateInput struct {
	Type              int32                                  `json:"type"`
	Key               int32                                  `json:"key"`
	Memo              *string                                `json:"memo,omitempty"`
	Rank              *int32                                 `json:"rank,omitempty"`
	AskTakerFee       *float64                               `json:"askTakerFee,omitempty"`
	AskMakerFee       *float64                               `json:"askMakerFee,omitempty"`
	BidTakerFee       *float64                               `json:"bidTakerFee,omitempty"`
	BidMakerFee       *float64                               `json:"bidMakerFee,omitempty"`
	MyCoinAskTakerFee *float64                               `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskMakerFee *float64                               `json:"myCoinAskMakerFee,omitempty"`
	MyCoinBidTakerFee *float64                               `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidMakerFee *float64                               `json:"myCoinBidMakerFee,omitempty"`
	RankRelation      *UserCreateManyWithoutUserRankFeeInput `json:"rankRelation,omitempty"`
	EventRelation     *UserCreateManyWithoutEventFeeInput    `json:"eventRelation,omitempty"`
}

type FeeUpdateInput struct {
	Type              *int32                                 `json:"type,omitempty"`
	Key               *int32                                 `json:"key,omitempty"`
	Memo              *string                                `json:"memo,omitempty"`
	Rank              *int32                                 `json:"rank,omitempty"`
	AskTakerFee       *float64                               `json:"askTakerFee,omitempty"`
	AskMakerFee       *float64                               `json:"askMakerFee,omitempty"`
	BidTakerFee       *float64                               `json:"bidTakerFee,omitempty"`
	BidMakerFee       *float64                               `json:"bidMakerFee,omitempty"`
	MyCoinAskTakerFee *float64                               `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskMakerFee *float64                               `json:"myCoinAskMakerFee,omitempty"`
	MyCoinBidTakerFee *float64                               `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidMakerFee *float64                               `json:"myCoinBidMakerFee,omitempty"`
	RankRelation      *UserUpdateManyWithoutUserRankFeeInput `json:"rankRelation,omitempty"`
	EventRelation     *UserUpdateManyWithoutEventFeeInput    `json:"eventRelation,omitempty"`
}

type FeeUpdateManyMutationInput struct {
	Type              *int32   `json:"type,omitempty"`
	Key               *int32   `json:"key,omitempty"`
	Memo              *string  `json:"memo,omitempty"`
	Rank              *int32   `json:"rank,omitempty"`
	AskTakerFee       *float64 `json:"askTakerFee,omitempty"`
	AskMakerFee       *float64 `json:"askMakerFee,omitempty"`
	BidTakerFee       *float64 `json:"bidTakerFee,omitempty"`
	BidMakerFee       *float64 `json:"bidMakerFee,omitempty"`
	MyCoinAskTakerFee *float64 `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskMakerFee *float64 `json:"myCoinAskMakerFee,omitempty"`
	MyCoinBidTakerFee *float64 `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidMakerFee *float64 `json:"myCoinBidMakerFee,omitempty"`
}

type FileCreateInput struct {
	Coin         *CoinCreateOneWithoutImageInput `json:"coin,omitempty"`
	Post         *PostCreateOneWithoutImageInput `json:"post,omitempty"`
	LocationPath *string                         `json:"locationPath,omitempty"`
	Name         *string                         `json:"name,omitempty"`
	ContentType  *string                         `json:"contentType,omitempty"`
	Url          string                          `json:"url"`
	Owner        *UserCreateOneWithoutFilesInput `json:"owner,omitempty"`
	IsDel        *bool                           `json:"isDel,omitempty"`
}

type FileUpdateInput struct {
	Coin         *CoinUpdateOneWithoutImageInput `json:"coin,omitempty"`
	Post         *PostUpdateOneWithoutImageInput `json:"post,omitempty"`
	LocationPath *string                         `json:"locationPath,omitempty"`
	Name         *string                         `json:"name,omitempty"`
	ContentType  *string                         `json:"contentType,omitempty"`
	Url          *string                         `json:"url,omitempty"`
	Owner        *UserUpdateOneWithoutFilesInput `json:"owner,omitempty"`
	IsDel        *bool                           `json:"isDel,omitempty"`
}

type FileUpdateManyMutationInput struct {
	LocationPath *string `json:"locationPath,omitempty"`
	Name         *string `json:"name,omitempty"`
	ContentType  *string `json:"contentType,omitempty"`
	Url          *string `json:"url,omitempty"`
	IsDel        *bool   `json:"isDel,omitempty"`
}

type FileInfoUpdateInput struct {
	Coin         *CoinUpdateOneWithoutPictureInput  `json:"coin,omitempty"`
	Post         *PostUpdateOneWithoutFileListInput `json:"post,omitempty"`
	TempFileId   *string                            `json:"tempFileId,omitempty"`
	LocationPath *string                            `json:"locationPath,omitempty"`
	Name         *string                            `json:"name,omitempty"`
	ContentType  *string                            `json:"contentType,omitempty"`
	Url          *string                            `json:"url,omitempty"`
	Owner        *UserUpdateOneWithoutFileListInput `json:"owner,omitempty"`
	IsVideo      *bool                              `json:"isVideo,omitempty"`
	IsDel        *bool                              `json:"isDel,omitempty"`
}

type FileInfoUpdateManyMutationInput struct {
	TempFileId   *string `json:"tempFileId,omitempty"`
	LocationPath *string `json:"locationPath,omitempty"`
	Name         *string `json:"name,omitempty"`
	ContentType  *string `json:"contentType,omitempty"`
	Url          *string `json:"url,omitempty"`
	IsVideo      *bool   `json:"isVideo,omitempty"`
	IsDel        *bool   `json:"isDel,omitempty"`
}

type InstagramCreateInput struct {
	UserId         string                                                   `json:"userId"`
	UserNo         string                                                   `json:"userNo"`
	UserName       *string                                                  `json:"userName,omitempty"`
	PostCount      *string                                                  `json:"postCount,omitempty"`
	FollowerCount  *string                                                  `json:"followerCount,omitempty"`
	FollowingCount *string                                                  `json:"followingCount,omitempty"`
	AvatarUrl      *string                                                  `json:"avatarUrl,omitempty"`
	Description    *string                                                  `json:"description,omitempty"`
	PageUrl        *string                                                  `json:"pageUrl,omitempty"`
	Page           PageCreateOneWithoutInstagramInput                       `json:"page"`
	Statistics     *InstagramDailyStatisticsCreateManyWithoutInstagramInput `json:"statistics,omitempty"`
}

type PageCreateOneWithoutInstagramInput struct {
	Create  *PageCreateWithoutInstagramInput `json:"create,omitempty"`
	Connect *PageWhereUniqueInput            `json:"connect,omitempty"`
}

type PageCreateWithoutInstagramInput struct {
	PageId           string                                          `json:"pageId"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeCreateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeCreateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchCreateOneWithoutPageInput                `json:"twitch,omitempty"`
	AfreecaTv        *AfreecaTvCreateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanCreateManyInput                         `json:"fans,omitempty"`
	Owner            *UserCreateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentCreateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemCreateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageCreateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentCreateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type InstagramUpdateInput struct {
	UserId         *string                                                  `json:"userId,omitempty"`
	UserNo         *string                                                  `json:"userNo,omitempty"`
	UserName       *string                                                  `json:"userName,omitempty"`
	PostCount      *string                                                  `json:"postCount,omitempty"`
	FollowerCount  *string                                                  `json:"followerCount,omitempty"`
	FollowingCount *string                                                  `json:"followingCount,omitempty"`
	AvatarUrl      *string                                                  `json:"avatarUrl,omitempty"`
	Description    *string                                                  `json:"description,omitempty"`
	PageUrl        *string                                                  `json:"pageUrl,omitempty"`
	Page           *PageUpdateOneRequiredWithoutInstagramInput              `json:"page,omitempty"`
	Statistics     *InstagramDailyStatisticsUpdateManyWithoutInstagramInput `json:"statistics,omitempty"`
}

type PageUpdateOneRequiredWithoutInstagramInput struct {
	Create  *PageCreateWithoutInstagramInput     `json:"create,omitempty"`
	Update  *PageUpdateWithoutInstagramDataInput `json:"update,omitempty"`
	Upsert  *PageUpsertWithoutInstagramInput     `json:"upsert,omitempty"`
	Connect *PageWhereUniqueInput                `json:"connect,omitempty"`
}

type PageUpdateWithoutInstagramDataInput struct {
	PageId           *string                                         `json:"pageId,omitempty"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeUpdateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeUpdateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchUpdateOneWithoutPageInput                `json:"twitch,omitempty"`
	AfreecaTv        *AfreecaTvUpdateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanUpdateManyInput                         `json:"fans,omitempty"`
	Owner            *UserUpdateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentUpdateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemUpdateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageUpdateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentUpdateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type PageUpsertWithoutInstagramInput struct {
	Update PageUpdateWithoutInstagramDataInput `json:"update"`
	Create PageCreateWithoutInstagramInput     `json:"create"`
}

type InstagramUpdateManyMutationInput struct {
	UserId         *string `json:"userId,omitempty"`
	UserNo         *string `json:"userNo,omitempty"`
	UserName       *string `json:"userName,omitempty"`
	PostCount      *string `json:"postCount,omitempty"`
	FollowerCount  *string `json:"followerCount,omitempty"`
	FollowingCount *string `json:"followingCount,omitempty"`
	AvatarUrl      *string `json:"avatarUrl,omitempty"`
	Description    *string `json:"description,omitempty"`
	PageUrl        *string `json:"pageUrl,omitempty"`
}

type InstagramDailyStatisticsCreateInput struct {
	Date           string                                   `json:"date"`
	PostCount      string                                   `json:"postCount"`
	FollowerCount  string                                   `json:"followerCount"`
	FollowingCount string                                   `json:"followingCount"`
	Instagram      InstagramCreateOneWithoutStatisticsInput `json:"instagram"`
}

type InstagramCreateOneWithoutStatisticsInput struct {
	Create  *InstagramCreateWithoutStatisticsInput `json:"create,omitempty"`
	Connect *InstagramWhereUniqueInput             `json:"connect,omitempty"`
}

type InstagramCreateWithoutStatisticsInput struct {
	UserId         string                             `json:"userId"`
	UserNo         string                             `json:"userNo"`
	UserName       *string                            `json:"userName,omitempty"`
	PostCount      *string                            `json:"postCount,omitempty"`
	FollowerCount  *string                            `json:"followerCount,omitempty"`
	FollowingCount *string                            `json:"followingCount,omitempty"`
	AvatarUrl      *string                            `json:"avatarUrl,omitempty"`
	Description    *string                            `json:"description,omitempty"`
	PageUrl        *string                            `json:"pageUrl,omitempty"`
	Page           PageCreateOneWithoutInstagramInput `json:"page"`
}

type InstagramDailyStatisticsUpdateInput struct {
	Date           *string                                           `json:"date,omitempty"`
	PostCount      *string                                           `json:"postCount,omitempty"`
	FollowerCount  *string                                           `json:"followerCount,omitempty"`
	FollowingCount *string                                           `json:"followingCount,omitempty"`
	Instagram      *InstagramUpdateOneRequiredWithoutStatisticsInput `json:"instagram,omitempty"`
}

type InstagramUpdateOneRequiredWithoutStatisticsInput struct {
	Create  *InstagramCreateWithoutStatisticsInput     `json:"create,omitempty"`
	Update  *InstagramUpdateWithoutStatisticsDataInput `json:"update,omitempty"`
	Upsert  *InstagramUpsertWithoutStatisticsInput     `json:"upsert,omitempty"`
	Connect *InstagramWhereUniqueInput                 `json:"connect,omitempty"`
}

type InstagramUpdateWithoutStatisticsDataInput struct {
	UserId         *string                                     `json:"userId,omitempty"`
	UserNo         *string                                     `json:"userNo,omitempty"`
	UserName       *string                                     `json:"userName,omitempty"`
	PostCount      *string                                     `json:"postCount,omitempty"`
	FollowerCount  *string                                     `json:"followerCount,omitempty"`
	FollowingCount *string                                     `json:"followingCount,omitempty"`
	AvatarUrl      *string                                     `json:"avatarUrl,omitempty"`
	Description    *string                                     `json:"description,omitempty"`
	PageUrl        *string                                     `json:"pageUrl,omitempty"`
	Page           *PageUpdateOneRequiredWithoutInstagramInput `json:"page,omitempty"`
}

type InstagramUpsertWithoutStatisticsInput struct {
	Update InstagramUpdateWithoutStatisticsDataInput `json:"update"`
	Create InstagramCreateWithoutStatisticsInput     `json:"create"`
}

type InstagramDailyStatisticsUpdateManyMutationInput struct {
	Date           *string `json:"date,omitempty"`
	PostCount      *string `json:"postCount,omitempty"`
	FollowerCount  *string `json:"followerCount,omitempty"`
	FollowingCount *string `json:"followingCount,omitempty"`
}

type InviteCodeCreateInput struct {
	NumId       *int32                                             `json:"numId,omitempty"`
	Code        string                                             `json:"code"`
	Owner       *UserCreateOneWithoutInviteCodeInput               `json:"owner,omitempty"`
	InviteUsers *InviteUserHistoryCreateManyWithoutInviteCodeInput `json:"inviteUsers,omitempty"`
}

type UserCreateOneWithoutInviteCodeInput struct {
	Create  *UserCreateWithoutInviteCodeInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput             `json:"connect,omitempty"`
}

type UserCreateWithoutInviteCodeInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserCreateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type InviteCodeUpdateInput struct {
	NumId       *int32                                             `json:"numId,omitempty"`
	Code        *string                                            `json:"code,omitempty"`
	Owner       *UserUpdateOneWithoutInviteCodeInput               `json:"owner,omitempty"`
	InviteUsers *InviteUserHistoryUpdateManyWithoutInviteCodeInput `json:"inviteUsers,omitempty"`
}

type UserUpdateOneWithoutInviteCodeInput struct {
	Create     *UserCreateWithoutInviteCodeInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutInviteCodeDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutInviteCodeInput     `json:"upsert,omitempty"`
	Delete     *bool                                 `json:"delete,omitempty"`
	Disconnect *bool                                 `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput                 `json:"connect,omitempty"`
}

type UserUpdateWithoutInviteCodeDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type UserUpsertWithoutInviteCodeInput struct {
	Update UserUpdateWithoutInviteCodeDataInput `json:"update"`
	Create UserCreateWithoutInviteCodeInput     `json:"create"`
}

type InviteCodeUpdateManyMutationInput struct {
	NumId *int32  `json:"numId,omitempty"`
	Code  *string `json:"code,omitempty"`
}

type InviteUserHistoryCreateInput struct {
	InviteCode InviteCodeCreateOneWithoutInviteUsersInput `json:"inviteCode"`
	User       UserCreateOneInput                         `json:"user"`
}

type InviteCodeCreateOneWithoutInviteUsersInput struct {
	Create  *InviteCodeCreateWithoutInviteUsersInput `json:"create,omitempty"`
	Connect *InviteCodeWhereUniqueInput              `json:"connect,omitempty"`
}

type InviteCodeCreateWithoutInviteUsersInput struct {
	NumId *int32                               `json:"numId,omitempty"`
	Code  string                               `json:"code"`
	Owner *UserCreateOneWithoutInviteCodeInput `json:"owner,omitempty"`
}

type InviteUserHistoryUpdateInput struct {
	InviteCode *InviteCodeUpdateOneRequiredWithoutInviteUsersInput `json:"inviteCode,omitempty"`
	User       *UserUpdateOneRequiredInput                         `json:"user,omitempty"`
}

type InviteCodeUpdateOneRequiredWithoutInviteUsersInput struct {
	Create  *InviteCodeCreateWithoutInviteUsersInput     `json:"create,omitempty"`
	Update  *InviteCodeUpdateWithoutInviteUsersDataInput `json:"update,omitempty"`
	Upsert  *InviteCodeUpsertWithoutInviteUsersInput     `json:"upsert,omitempty"`
	Connect *InviteCodeWhereUniqueInput                  `json:"connect,omitempty"`
}

type InviteCodeUpdateWithoutInviteUsersDataInput struct {
	NumId *int32                               `json:"numId,omitempty"`
	Code  *string                              `json:"code,omitempty"`
	Owner *UserUpdateOneWithoutInviteCodeInput `json:"owner,omitempty"`
}

type InviteCodeUpsertWithoutInviteUsersInput struct {
	Update InviteCodeUpdateWithoutInviteUsersDataInput `json:"update"`
	Create InviteCodeCreateWithoutInviteUsersInput     `json:"create"`
}

type MaintenanceCreateInput struct {
	Type            int32                                    `json:"type"`
	AffectedDevices *DeviceCreateManyWithoutMaintenanceInput `json:"affectedDevices,omitempty"`
	Note            string                                   `json:"note"`
	FromDate        string                                   `json:"fromDate"`
	ToDate          string                                   `json:"toDate"`
	CreateUser      *AdminUserCreateOneInput                 `json:"createUser,omitempty"`
	UpdateUser      *AdminUserCreateOneInput                 `json:"updateUser,omitempty"`
	IsDel           *bool                                    `json:"isDel,omitempty"`
}

type DeviceCreateManyWithoutMaintenanceInput struct {
	Create  []DeviceCreateWithoutMaintenanceInput `json:"create,omitempty"`
	Connect []DeviceWhereUniqueInput              `json:"connect,omitempty"`
}

type DeviceCreateWithoutMaintenanceInput struct {
	AppVersion *AppVersionCreateManyWithoutAffectedDevicesInput `json:"appVersion,omitempty"`
	Code       int32                                            `json:"code"`
	Name       string                                           `json:"name"`
}

type MaintenanceUpdateInput struct {
	Type            *int32                                   `json:"type,omitempty"`
	AffectedDevices *DeviceUpdateManyWithoutMaintenanceInput `json:"affectedDevices,omitempty"`
	Note            *string                                  `json:"note,omitempty"`
	FromDate        *string                                  `json:"fromDate,omitempty"`
	ToDate          *string                                  `json:"toDate,omitempty"`
	CreateUser      *AdminUserUpdateOneInput                 `json:"createUser,omitempty"`
	UpdateUser      *AdminUserUpdateOneInput                 `json:"updateUser,omitempty"`
	IsDel           *bool                                    `json:"isDel,omitempty"`
}

type DeviceUpdateManyWithoutMaintenanceInput struct {
	Create     []DeviceCreateWithoutMaintenanceInput                `json:"create,omitempty"`
	Delete     []DeviceWhereUniqueInput                             `json:"delete,omitempty"`
	Connect    []DeviceWhereUniqueInput                             `json:"connect,omitempty"`
	Set        []DeviceWhereUniqueInput                             `json:"set,omitempty"`
	Disconnect []DeviceWhereUniqueInput                             `json:"disconnect,omitempty"`
	Update     []DeviceUpdateWithWhereUniqueWithoutMaintenanceInput `json:"update,omitempty"`
	Upsert     []DeviceUpsertWithWhereUniqueWithoutMaintenanceInput `json:"upsert,omitempty"`
	DeleteMany []DeviceScalarWhereInput                             `json:"deleteMany,omitempty"`
	UpdateMany []DeviceUpdateManyWithWhereNestedInput               `json:"updateMany,omitempty"`
}

type DeviceUpdateWithWhereUniqueWithoutMaintenanceInput struct {
	Where DeviceWhereUniqueInput                  `json:"where"`
	Data  DeviceUpdateWithoutMaintenanceDataInput `json:"data"`
}

type DeviceUpdateWithoutMaintenanceDataInput struct {
	AppVersion *AppVersionUpdateManyWithoutAffectedDevicesInput `json:"appVersion,omitempty"`
	Code       *int32                                           `json:"code,omitempty"`
	Name       *string                                          `json:"name,omitempty"`
}

type DeviceUpsertWithWhereUniqueWithoutMaintenanceInput struct {
	Where  DeviceWhereUniqueInput                  `json:"where"`
	Update DeviceUpdateWithoutMaintenanceDataInput `json:"update"`
	Create DeviceCreateWithoutMaintenanceInput     `json:"create"`
}

type MaintenanceUpdateManyMutationInput struct {
	Type     *int32  `json:"type,omitempty"`
	Note     *string `json:"note,omitempty"`
	FromDate *string `json:"fromDate,omitempty"`
	ToDate   *string `json:"toDate,omitempty"`
	IsDel    *bool   `json:"isDel,omitempty"`
}

type MotherHistoryCreateInput struct {
	Type                    int32                                                      `json:"type"`
	RoleTime                string                                                     `json:"roleTime"`
	Coin                    *CoinCreateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserCreateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostCreateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryCreateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryCreateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryCreateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryCreateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryCreateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryCreateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryCreateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type MotherHistoryUpdateInput struct {
	Type                    *int32                                                     `json:"type,omitempty"`
	RoleTime                *string                                                    `json:"roleTime,omitempty"`
	Coin                    *CoinUpdateOneWithoutMotherHistoriesInput                  `json:"coin,omitempty"`
	User                    *UserUpdateOneWithoutMotherHistoriesInput                  `json:"user,omitempty"`
	Post                    *PostUpdateOneWithoutMotherHistoriesInput                  `json:"post,omitempty"`
	OrderUserDealsHistory   *OrderUserDealsHistoryUpdateOneWithoutMotherHistoryInput   `json:"orderUserDealsHistory,omitempty"`
	OrderHistory            *OrderHistoryUpdateOneWithoutMotherHistoryInput            `json:"orderHistory,omitempty"`
	CashHistory             *CashHistoryUpdateOneWithoutMotherHistoryInput             `json:"cashHistory,omitempty"`
	AergoAccountHistory     *AergoAccountHistoryUpdateOneWithoutMotherHistoryInput     `json:"aergoAccountHistory,omitempty"`
	QuestExpenditureHistory *QuestExpenditureHistoryUpdateOneWithoutMotherHistoryInput `json:"questExpenditureHistory,omitempty"`
	AirDropHistory          *AirDropHistoryUpdateOneWithoutMotherHistoryInput          `json:"airDropHistory,omitempty"`
	PostRewardHistory       *PostRewardHistoryUpdateOneWithoutMotherHistoryInput       `json:"postRewardHistory,omitempty"`
}

type MotherHistoryUpdateManyMutationInput struct {
	Type     *int32  `json:"type,omitempty"`
	RoleTime *string `json:"roleTime,omitempty"`
}

type NotificationCreateInput struct {
	NotiType     *int32                                            `json:"notiType,omitempty"`
	PushType     int32                                             `json:"pushType"`
	PushState    int32                                             `json:"pushState"`
	User         *UserCreateManyInput                              `json:"user,omitempty"`
	SendFailUser *UserCreateManyInput                              `json:"sendFailUser,omitempty"`
	ByUser       *UserCreateOneInput                               `json:"byUser,omitempty"`
	Post         *PostCreateOneInput                               `json:"post,omitempty"`
	Coin         *CoinCreateOneInput                               `json:"coin,omitempty"`
	Topic        *string                                           `json:"topic,omitempty"`
	LinkType     string                                            `json:"linkType"`
	LinkValue    string                                            `json:"linkValue"`
	Message      string                                            `json:"message"`
	Image        *string                                           `json:"image,omitempty"`
	PublishType  int32                                             `json:"publishType"`
	PublishDate  string                                            `json:"publishDate"`
	CreateUser   *AdminUserCreateOneWithoutCreateNotificationInput `json:"createUser,omitempty"`
	UpdateUser   *AdminUserCreateOneWithoutUpdateNotificationInput `json:"updateUser,omitempty"`
	IsDel        *bool                                             `json:"isDel,omitempty"`
}

type NotificationUpdateInput struct {
	NotiType     *int32                                            `json:"notiType,omitempty"`
	PushType     *int32                                            `json:"pushType,omitempty"`
	PushState    *int32                                            `json:"pushState,omitempty"`
	User         *UserUpdateManyInput                              `json:"user,omitempty"`
	SendFailUser *UserUpdateManyInput                              `json:"sendFailUser,omitempty"`
	ByUser       *UserUpdateOneInput                               `json:"byUser,omitempty"`
	Post         *PostUpdateOneInput                               `json:"post,omitempty"`
	Coin         *CoinUpdateOneInput                               `json:"coin,omitempty"`
	Topic        *string                                           `json:"topic,omitempty"`
	LinkType     *string                                           `json:"linkType,omitempty"`
	LinkValue    *string                                           `json:"linkValue,omitempty"`
	Message      *string                                           `json:"message,omitempty"`
	Image        *string                                           `json:"image,omitempty"`
	PublishType  *int32                                            `json:"publishType,omitempty"`
	PublishDate  *string                                           `json:"publishDate,omitempty"`
	CreateUser   *AdminUserUpdateOneWithoutCreateNotificationInput `json:"createUser,omitempty"`
	UpdateUser   *AdminUserUpdateOneWithoutUpdateNotificationInput `json:"updateUser,omitempty"`
	IsDel        *bool                                             `json:"isDel,omitempty"`
}

type NotificationUpdateManyMutationInput struct {
	NotiType    *int32  `json:"notiType,omitempty"`
	PushType    *int32  `json:"pushType,omitempty"`
	PushState   *int32  `json:"pushState,omitempty"`
	Topic       *string `json:"topic,omitempty"`
	LinkType    *string `json:"linkType,omitempty"`
	LinkValue   *string `json:"linkValue,omitempty"`
	Message     *string `json:"message,omitempty"`
	Image       *string `json:"image,omitempty"`
	PublishType *int32  `json:"publishType,omitempty"`
	PublishDate *string `json:"publishDate,omitempty"`
	IsDel       *bool   `json:"isDel,omitempty"`
}

type OfferCreateInput struct {
	Coin     CoinCreateOneWithoutOfferInput      `json:"coin"`
	Qty      int32                               `json:"qty"`
	Offeror  *OfferorCreateManyWithoutOfferInput `json:"offeror,omitempty"`
	FromDate string                              `json:"fromDate"`
	ToDate   string                              `json:"toDate"`
}

type OfferUpdateInput struct {
	Coin     *CoinUpdateOneRequiredWithoutOfferInput `json:"coin,omitempty"`
	Qty      *int32                                  `json:"qty,omitempty"`
	Offeror  *OfferorUpdateManyWithoutOfferInput     `json:"offeror,omitempty"`
	FromDate *string                                 `json:"fromDate,omitempty"`
	ToDate   *string                                 `json:"toDate,omitempty"`
}

type OfferUpdateManyMutationInput struct {
	Qty      *int32  `json:"qty,omitempty"`
	FromDate *string `json:"fromDate,omitempty"`
	ToDate   *string `json:"toDate,omitempty"`
}

type OfferorCreateInput struct {
	Price int32                              `json:"price"`
	Offer OfferCreateOneWithoutOfferorInput  `json:"offer"`
	User  UserCreateOneWithoutJoinOfferInput `json:"user"`
}

type OfferorUpdateInput struct {
	Price *int32                                      `json:"price,omitempty"`
	Offer *OfferUpdateOneRequiredWithoutOfferorInput  `json:"offer,omitempty"`
	User  *UserUpdateOneRequiredWithoutJoinOfferInput `json:"user,omitempty"`
}

type OfferorUpdateManyMutationInput struct {
	Price *int32 `json:"price,omitempty"`
}

type OrderDealsHistoryCreateInput struct {
	Type      int32                                         `json:"type"`
	DealId    int32                                         `json:"dealId"`
	Coin      *CoinCreateOneWithoutOrderDealsHistoriesInput `json:"coin,omitempty"`
	DealPrice float64                                       `json:"dealPrice"`
	DealQty   float64                                       `json:"dealQty"`
	Time      *float64                                      `json:"time,omitempty"`
}

type CoinCreateOneWithoutOrderDealsHistoriesInput struct {
	Create  *CoinCreateWithoutOrderDealsHistoriesInput `json:"create,omitempty"`
	Connect *CoinWhereUniqueInput                      `json:"connect,omitempty"`
}

type CoinCreateWithoutOrderDealsHistoriesInput struct {
	Categories              *CategoryCreateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    string                                           `json:"name"`
	Qty                     float64                                          `json:"qty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   FileCreateOneWithoutCoinInput                    `json:"image"`
	Picture                 *FileInfoCreateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             string                                           `json:"description"`
	Wallets                 *WalletCreateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   UserCreateOneWithoutCoinInput                    `json:"owner"`
	Posts                   *PostCreateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferCreateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  string                                           `json:"weight"`
	OrderHistories          *OrderHistoryCreateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryCreateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableCreateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineCreateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type OrderDealsHistoryUpdateInput struct {
	Type      *int32                                        `json:"type,omitempty"`
	DealId    *int32                                        `json:"dealId,omitempty"`
	Coin      *CoinUpdateOneWithoutOrderDealsHistoriesInput `json:"coin,omitempty"`
	DealPrice *float64                                      `json:"dealPrice,omitempty"`
	DealQty   *float64                                      `json:"dealQty,omitempty"`
	Time      *float64                                      `json:"time,omitempty"`
}

type CoinUpdateOneWithoutOrderDealsHistoriesInput struct {
	Create     *CoinCreateWithoutOrderDealsHistoriesInput     `json:"create,omitempty"`
	Update     *CoinUpdateWithoutOrderDealsHistoriesDataInput `json:"update,omitempty"`
	Upsert     *CoinUpsertWithoutOrderDealsHistoriesInput     `json:"upsert,omitempty"`
	Delete     *bool                                          `json:"delete,omitempty"`
	Disconnect *bool                                          `json:"disconnect,omitempty"`
	Connect    *CoinWhereUniqueInput                          `json:"connect,omitempty"`
}

type CoinUpdateWithoutOrderDealsHistoriesDataInput struct {
	Categories              *CategoryUpdateManyWithoutCoinsInput             `json:"categories,omitempty"`
	Name                    *string                                          `json:"name,omitempty"`
	Qty                     *float64                                         `json:"qty,omitempty"`
	StandardPrice           *float64                                         `json:"standardPrice,omitempty"`
	CurrentPrice            *float64                                         `json:"currentPrice,omitempty"`
	Image                   *FileUpdateOneRequiredWithoutCoinInput           `json:"image,omitempty"`
	Picture                 *FileInfoUpdateOneWithoutCoinInput               `json:"picture,omitempty"`
	Description             *string                                          `json:"description,omitempty"`
	Wallets                 *WalletUpdateManyWithoutCoinInput                `json:"wallets,omitempty"`
	Owner                   *UserUpdateOneRequiredWithoutCoinInput           `json:"owner,omitempty"`
	Posts                   *PostUpdateManyWithoutCoinInput                  `json:"posts,omitempty"`
	Offer                   *OfferUpdateOneWithoutCoinInput                  `json:"offer,omitempty"`
	Status                  *int32                                           `json:"status,omitempty"`
	Weight                  *string                                          `json:"weight,omitempty"`
	OrderHistories          *OrderHistoryUpdateManyWithoutCoinInput          `json:"orderHistories,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutCoinInput `json:"orderUserDealsHistories,omitempty"`
	MotherHistories         *MotherHistoryUpdateManyWithoutCoinInput         `json:"motherHistories,omitempty"`
	CoinPriceTable          *CoinPriceTableUpdateOneWithoutCoinInput         `json:"coinPriceTable,omitempty"`
	CoinKline               *CoinKlineUpdateManyWithoutCoinInput             `json:"coinKline,omitempty"`
	DeployTxhash            *string                                          `json:"deployTxhash,omitempty"`
	ContractAddress         *string                                          `json:"contractAddress,omitempty"`
	ODda                    *float64                                         `json:"oDDA,omitempty"`
}

type CoinUpsertWithoutOrderDealsHistoriesInput struct {
	Update CoinUpdateWithoutOrderDealsHistoriesDataInput `json:"update"`
	Create CoinCreateWithoutOrderDealsHistoriesInput     `json:"create"`
}

type OrderDealsHistoryUpdateManyMutationInput struct {
	Type      *int32   `json:"type,omitempty"`
	DealId    *int32   `json:"dealId,omitempty"`
	DealPrice *float64 `json:"dealPrice,omitempty"`
	DealQty   *float64 `json:"dealQty,omitempty"`
	Time      *float64 `json:"time,omitempty"`
}

type OrderHistoryCreateInput struct {
	Type                    int32                                                    `json:"type"`
	OrderNum                int32                                                    `json:"orderNum"`
	User                    *UserCreateOneWithoutOrderHistoriesInput                 `json:"user,omitempty"`
	Coin                    *CoinCreateOneWithoutOrderHistoriesInput                 `json:"coin,omitempty"`
	MotherHistory           *MotherHistoryCreateOneWithoutOrderHistoryInput          `json:"motherHistory,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryCreateManyWithoutOrderHistoryInput `json:"orderUserDealsHistories,omitempty"`
	OrderPrice              float64                                                  `json:"orderPrice"`
	DealPrice               *float64                                                 `json:"dealPrice,omitempty"`
	OrderQty                float64                                                  `json:"orderQty"`
	DealQty                 *float64                                                 `json:"dealQty,omitempty"`
	LeftQty                 float64                                                  `json:"leftQty"`
	DealFee                 *float64                                                 `json:"dealFee,omitempty"`
	TakerFee                *float64                                                 `json:"takerFee,omitempty"`
	MakerFee                *float64                                                 `json:"makerFee,omitempty"`
	Memo                    *string                                                  `json:"memo,omitempty"`
	Description             *string                                                  `json:"description,omitempty"`
	Offset                  *int32                                                   `json:"offset,omitempty"`
	IsCancel                *bool                                                    `json:"isCancel,omitempty"`
}

type OrderHistoryUpdateInput struct {
	Type                    *int32                                                   `json:"type,omitempty"`
	OrderNum                *int32                                                   `json:"orderNum,omitempty"`
	User                    *UserUpdateOneWithoutOrderHistoriesInput                 `json:"user,omitempty"`
	Coin                    *CoinUpdateOneWithoutOrderHistoriesInput                 `json:"coin,omitempty"`
	MotherHistory           *MotherHistoryUpdateOneWithoutOrderHistoryInput          `json:"motherHistory,omitempty"`
	OrderUserDealsHistories *OrderUserDealsHistoryUpdateManyWithoutOrderHistoryInput `json:"orderUserDealsHistories,omitempty"`
	OrderPrice              *float64                                                 `json:"orderPrice,omitempty"`
	DealPrice               *float64                                                 `json:"dealPrice,omitempty"`
	OrderQty                *float64                                                 `json:"orderQty,omitempty"`
	DealQty                 *float64                                                 `json:"dealQty,omitempty"`
	LeftQty                 *float64                                                 `json:"leftQty,omitempty"`
	DealFee                 *float64                                                 `json:"dealFee,omitempty"`
	TakerFee                *float64                                                 `json:"takerFee,omitempty"`
	MakerFee                *float64                                                 `json:"makerFee,omitempty"`
	Memo                    *string                                                  `json:"memo,omitempty"`
	Description             *string                                                  `json:"description,omitempty"`
	Offset                  *int32                                                   `json:"offset,omitempty"`
	IsCancel                *bool                                                    `json:"isCancel,omitempty"`
}

type OrderHistoryUpdateManyMutationInput struct {
	Type        *int32   `json:"type,omitempty"`
	OrderNum    *int32   `json:"orderNum,omitempty"`
	OrderPrice  *float64 `json:"orderPrice,omitempty"`
	DealPrice   *float64 `json:"dealPrice,omitempty"`
	OrderQty    *float64 `json:"orderQty,omitempty"`
	DealQty     *float64 `json:"dealQty,omitempty"`
	LeftQty     *float64 `json:"leftQty,omitempty"`
	DealFee     *float64 `json:"dealFee,omitempty"`
	TakerFee    *float64 `json:"takerFee,omitempty"`
	MakerFee    *float64 `json:"makerFee,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
	Description *string  `json:"description,omitempty"`
	Offset      *int32   `json:"offset,omitempty"`
	IsCancel    *bool    `json:"isCancel,omitempty"`
}

type OrderUserDealsHistoryCreateInput struct {
	Type          int32                                                     `json:"type"`
	Role          *int32                                                    `json:"role,omitempty"`
	DealId        int32                                                     `json:"dealId"`
	UniqueKey     string                                                    `json:"uniqueKey"`
	UniqueId      int32                                                     `json:"uniqueId"`
	Coin          *CoinCreateOneWithoutOrderUserDealsHistoriesInput         `json:"coin,omitempty"`
	User          *UserCreateOneWithoutOrderUserDealsHistoriesInput         `json:"user,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutOrderUserDealsHistoryInput  `json:"motherHistory,omitempty"`
	OrderHistory  *OrderHistoryCreateOneWithoutOrderUserDealsHistoriesInput `json:"orderHistory,omitempty"`
	DealPrice     float64                                                   `json:"dealPrice"`
	DealQty       float64                                                   `json:"dealQty"`
	Fee           float64                                                   `json:"fee"`
	DealOrderId   *int32                                                    `json:"dealOrderId,omitempty"`
	Time          *float64                                                  `json:"time,omitempty"`
}

type OrderUserDealsHistoryUpdateInput struct {
	Type          *int32                                                    `json:"type,omitempty"`
	Role          *int32                                                    `json:"role,omitempty"`
	DealId        *int32                                                    `json:"dealId,omitempty"`
	UniqueKey     *string                                                   `json:"uniqueKey,omitempty"`
	UniqueId      *int32                                                    `json:"uniqueId,omitempty"`
	Coin          *CoinUpdateOneWithoutOrderUserDealsHistoriesInput         `json:"coin,omitempty"`
	User          *UserUpdateOneWithoutOrderUserDealsHistoriesInput         `json:"user,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutOrderUserDealsHistoryInput  `json:"motherHistory,omitempty"`
	OrderHistory  *OrderHistoryUpdateOneWithoutOrderUserDealsHistoriesInput `json:"orderHistory,omitempty"`
	DealPrice     *float64                                                  `json:"dealPrice,omitempty"`
	DealQty       *float64                                                  `json:"dealQty,omitempty"`
	Fee           *float64                                                  `json:"fee,omitempty"`
	DealOrderId   *int32                                                    `json:"dealOrderId,omitempty"`
	Time          *float64                                                  `json:"time,omitempty"`
}

type OrderUserDealsHistoryUpdateManyMutationInput struct {
	Type        *int32   `json:"type,omitempty"`
	Role        *int32   `json:"role,omitempty"`
	DealId      *int32   `json:"dealId,omitempty"`
	UniqueKey   *string  `json:"uniqueKey,omitempty"`
	UniqueId    *int32   `json:"uniqueId,omitempty"`
	DealPrice   *float64 `json:"dealPrice,omitempty"`
	DealQty     *float64 `json:"dealQty,omitempty"`
	Fee         *float64 `json:"fee,omitempty"`
	DealOrderId *int32   `json:"dealOrderId,omitempty"`
	Time        *float64 `json:"time,omitempty"`
}

type PageCreateInput struct {
	PageId           string                                          `json:"pageId"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeCreateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeCreateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchCreateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramCreateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvCreateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanCreateManyInput                         `json:"fans,omitempty"`
	Owner            *UserCreateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentCreateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemCreateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageCreateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentCreateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type PageUpdateInput struct {
	PageId           *string                                         `json:"pageId,omitempty"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeUpdateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeUpdateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch           *TwitchUpdateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramUpdateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvUpdateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanUpdateManyInput                         `json:"fans,omitempty"`
	Owner            *UserUpdateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentUpdateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemUpdateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageUpdateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentUpdateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type PageUpdateManyMutationInput struct {
	PageId      *string `json:"pageId,omitempty"`
	NickName    *string `json:"nickName,omitempty"`
	AvatarUrl   *string `json:"avatarUrl,omitempty"`
	CoverUrl    *string `json:"coverUrl,omitempty"`
	Description *string `json:"description,omitempty"`
}

type PageBadgeCreateInput struct {
	Badge BadgeCreateOneWithoutPagesInput            `json:"badge"`
	Vote  *int32                                     `json:"vote,omitempty"`
	Voter *BadgeVoterCreateManyWithoutPageBadgeInput `json:"voter,omitempty"`
	Page  PageCreateOneWithoutBadgesInput            `json:"page"`
}

type PageBadgeUpdateInput struct {
	Badge *BadgeUpdateOneRequiredWithoutPagesInput   `json:"badge,omitempty"`
	Vote  *int32                                     `json:"vote,omitempty"`
	Voter *BadgeVoterUpdateManyWithoutPageBadgeInput `json:"voter,omitempty"`
	Page  *PageUpdateOneRequiredWithoutBadgesInput   `json:"page,omitempty"`
}

type PageBadgeUpdateManyMutationInput struct {
	Vote *int32 `json:"vote,omitempty"`
}

type PageCommentCreateInput struct {
	Page                     PageCreateOneWithoutCommentsInput                  `json:"page"`
	Content                  string                                             `json:"content"`
	Comments                 *PageCommentReplyCreateManyWithoutPageCommentInput `json:"comments,omitempty"`
	IpAddress                *string                                            `json:"ipAddress,omitempty"`
	ImageUrl                 *string                                            `json:"imageUrl,omitempty"`
	ThumbnailImageUrl        *string                                            `json:"thumbnailImageUrl,omitempty"`
	Owner                    *UserCreateOneInput                                `json:"owner,omitempty"`
	RelatedReviewContentPage *ReviewContentPageCreateOneWithoutCommentsInput    `json:"relatedReviewContentPage,omitempty"`
	IsDel                    *bool                                              `json:"isDel,omitempty"`
}

type PageCommentUpdateInput struct {
	Page                     *PageUpdateOneRequiredWithoutCommentsInput         `json:"page,omitempty"`
	Content                  *string                                            `json:"content,omitempty"`
	Comments                 *PageCommentReplyUpdateManyWithoutPageCommentInput `json:"comments,omitempty"`
	IpAddress                *string                                            `json:"ipAddress,omitempty"`
	ImageUrl                 *string                                            `json:"imageUrl,omitempty"`
	ThumbnailImageUrl        *string                                            `json:"thumbnailImageUrl,omitempty"`
	Owner                    *UserUpdateOneInput                                `json:"owner,omitempty"`
	RelatedReviewContentPage *ReviewContentPageUpdateOneWithoutCommentsInput    `json:"relatedReviewContentPage,omitempty"`
	IsDel                    *bool                                              `json:"isDel,omitempty"`
}

type PageCommentUpdateManyMutationInput struct {
	Content           *string `json:"content,omitempty"`
	IpAddress         *string `json:"ipAddress,omitempty"`
	ImageUrl          *string `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string `json:"thumbnailImageUrl,omitempty"`
	IsDel             *bool   `json:"isDel,omitempty"`
}

type PageCommentReplyCreateInput struct {
	PageComment       PageCommentCreateOneWithoutCommentsInput `json:"pageComment"`
	Content           string                                   `json:"content"`
	IpAddress         *string                                  `json:"ipAddress,omitempty"`
	ImageUrl          *string                                  `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string                                  `json:"thumbnailImageUrl,omitempty"`
	Owner             *UserCreateOneInput                      `json:"owner,omitempty"`
	IsDel             *bool                                    `json:"isDel,omitempty"`
}

type PageCommentCreateOneWithoutCommentsInput struct {
	Create  *PageCommentCreateWithoutCommentsInput `json:"create,omitempty"`
	Connect *PageCommentWhereUniqueInput           `json:"connect,omitempty"`
}

type PageCommentCreateWithoutCommentsInput struct {
	Page                     PageCreateOneWithoutCommentsInput               `json:"page"`
	Content                  string                                          `json:"content"`
	IpAddress                *string                                         `json:"ipAddress,omitempty"`
	ImageUrl                 *string                                         `json:"imageUrl,omitempty"`
	ThumbnailImageUrl        *string                                         `json:"thumbnailImageUrl,omitempty"`
	Owner                    *UserCreateOneInput                             `json:"owner,omitempty"`
	RelatedReviewContentPage *ReviewContentPageCreateOneWithoutCommentsInput `json:"relatedReviewContentPage,omitempty"`
	IsDel                    *bool                                           `json:"isDel,omitempty"`
}

type PageCommentReplyUpdateInput struct {
	PageComment       *PageCommentUpdateOneRequiredWithoutCommentsInput `json:"pageComment,omitempty"`
	Content           *string                                           `json:"content,omitempty"`
	IpAddress         *string                                           `json:"ipAddress,omitempty"`
	ImageUrl          *string                                           `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string                                           `json:"thumbnailImageUrl,omitempty"`
	Owner             *UserUpdateOneInput                               `json:"owner,omitempty"`
	IsDel             *bool                                             `json:"isDel,omitempty"`
}

type PageCommentUpdateOneRequiredWithoutCommentsInput struct {
	Create  *PageCommentCreateWithoutCommentsInput     `json:"create,omitempty"`
	Update  *PageCommentUpdateWithoutCommentsDataInput `json:"update,omitempty"`
	Upsert  *PageCommentUpsertWithoutCommentsInput     `json:"upsert,omitempty"`
	Connect *PageCommentWhereUniqueInput               `json:"connect,omitempty"`
}

type PageCommentUpdateWithoutCommentsDataInput struct {
	Page                     *PageUpdateOneRequiredWithoutCommentsInput      `json:"page,omitempty"`
	Content                  *string                                         `json:"content,omitempty"`
	IpAddress                *string                                         `json:"ipAddress,omitempty"`
	ImageUrl                 *string                                         `json:"imageUrl,omitempty"`
	ThumbnailImageUrl        *string                                         `json:"thumbnailImageUrl,omitempty"`
	Owner                    *UserUpdateOneInput                             `json:"owner,omitempty"`
	RelatedReviewContentPage *ReviewContentPageUpdateOneWithoutCommentsInput `json:"relatedReviewContentPage,omitempty"`
	IsDel                    *bool                                           `json:"isDel,omitempty"`
}

type PageCommentUpsertWithoutCommentsInput struct {
	Update PageCommentUpdateWithoutCommentsDataInput `json:"update"`
	Create PageCommentCreateWithoutCommentsInput     `json:"create"`
}

type PageCommentReplyUpdateManyMutationInput struct {
	Content           *string `json:"content,omitempty"`
	IpAddress         *string `json:"ipAddress,omitempty"`
	ImageUrl          *string `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string `json:"thumbnailImageUrl,omitempty"`
	IsDel             *bool   `json:"isDel,omitempty"`
}

type PageFanUpdateInput struct {
	User *UserUpdateOneRequiredInput `json:"user,omitempty"`
}

type PaymentHistoryCreateInput struct {
	Code             *string             `json:"code,omitempty"`
	Message          *string             `json:"message,omitempty"`
	User             *UserCreateOneInput `json:"user,omitempty"`
	OrderNo          *string             `json:"order_no,omitempty"`
	ServiceName      *string             `json:"service_name,omitempty"`
	ProductName      *string             `json:"product_name,omitempty"`
	CustomParameter  *string             `json:"custom_parameter,omitempty"`
	Tid              *string             `json:"tid,omitempty"`
	Cid              *string             `json:"cid,omitempty"`
	Amount           *int32              `json:"amount,omitempty"`
	AmountFee        *int32              `json:"amount_fee,omitempty"`
	AmountWithoutFee *int32              `json:"amount_without_fee,omitempty"`
	Pgcode           *string             `json:"pgcode,omitempty"`
	PayInfo          *string             `json:"pay_info,omitempty"`
	DomesticFlag     *string             `json:"domestic_flag,omitempty"`
	TransactionDate  *string             `json:"transaction_date,omitempty"`
	InstallMonth     *string             `json:"install_month,omitempty"`
	CardInfo         *string             `json:"card_info,omitempty"`
	Payhash          *string             `json:"payhash,omitempty"`
	AccountNo        *string             `json:"account_no,omitempty"`
	AccountName      *string             `json:"account_name,omitempty"`
	BankCode         *string             `json:"bank_code,omitempty"`
	BankName         *string             `json:"bank_name,omitempty"`
	ExpireDate       *string             `json:"expire_date,omitempty"`
	ExpireTime       *string             `json:"expire_time,omitempty"`
	IssueTid         *string             `json:"issue_tid,omitempty"`
}

type PaymentHistoryUpdateInput struct {
	Code             *string             `json:"code,omitempty"`
	Message          *string             `json:"message,omitempty"`
	User             *UserUpdateOneInput `json:"user,omitempty"`
	OrderNo          *string             `json:"order_no,omitempty"`
	ServiceName      *string             `json:"service_name,omitempty"`
	ProductName      *string             `json:"product_name,omitempty"`
	CustomParameter  *string             `json:"custom_parameter,omitempty"`
	Tid              *string             `json:"tid,omitempty"`
	Cid              *string             `json:"cid,omitempty"`
	Amount           *int32              `json:"amount,omitempty"`
	AmountFee        *int32              `json:"amount_fee,omitempty"`
	AmountWithoutFee *int32              `json:"amount_without_fee,omitempty"`
	Pgcode           *string             `json:"pgcode,omitempty"`
	PayInfo          *string             `json:"pay_info,omitempty"`
	DomesticFlag     *string             `json:"domestic_flag,omitempty"`
	TransactionDate  *string             `json:"transaction_date,omitempty"`
	InstallMonth     *string             `json:"install_month,omitempty"`
	CardInfo         *string             `json:"card_info,omitempty"`
	Payhash          *string             `json:"payhash,omitempty"`
	AccountNo        *string             `json:"account_no,omitempty"`
	AccountName      *string             `json:"account_name,omitempty"`
	BankCode         *string             `json:"bank_code,omitempty"`
	BankName         *string             `json:"bank_name,omitempty"`
	ExpireDate       *string             `json:"expire_date,omitempty"`
	ExpireTime       *string             `json:"expire_time,omitempty"`
	IssueTid         *string             `json:"issue_tid,omitempty"`
}

type PaymentHistoryUpdateManyMutationInput struct {
	Code             *string `json:"code,omitempty"`
	Message          *string `json:"message,omitempty"`
	OrderNo          *string `json:"order_no,omitempty"`
	ServiceName      *string `json:"service_name,omitempty"`
	ProductName      *string `json:"product_name,omitempty"`
	CustomParameter  *string `json:"custom_parameter,omitempty"`
	Tid              *string `json:"tid,omitempty"`
	Cid              *string `json:"cid,omitempty"`
	Amount           *int32  `json:"amount,omitempty"`
	AmountFee        *int32  `json:"amount_fee,omitempty"`
	AmountWithoutFee *int32  `json:"amount_without_fee,omitempty"`
	Pgcode           *string `json:"pgcode,omitempty"`
	PayInfo          *string `json:"pay_info,omitempty"`
	DomesticFlag     *string `json:"domestic_flag,omitempty"`
	TransactionDate  *string `json:"transaction_date,omitempty"`
	InstallMonth     *string `json:"install_month,omitempty"`
	CardInfo         *string `json:"card_info,omitempty"`
	Payhash          *string `json:"payhash,omitempty"`
	AccountNo        *string `json:"account_no,omitempty"`
	AccountName      *string `json:"account_name,omitempty"`
	BankCode         *string `json:"bank_code,omitempty"`
	BankName         *string `json:"bank_name,omitempty"`
	ExpireDate       *string `json:"expire_date,omitempty"`
	ExpireTime       *string `json:"expire_time,omitempty"`
	IssueTid         *string `json:"issue_tid,omitempty"`
}

type PhoneVerificationCreateInput struct {
	Verification *VerificationCreateOneWithoutPhoneInput `json:"verification,omitempty"`
	Name         string                                  `json:"name"`
	Birth        string                                  `json:"birth"`
	Foreigner    *bool                                   `json:"foreigner,omitempty"`
	Gender       string                                  `json:"gender"`
	PhoneNumber  *string                                 `json:"phoneNumber,omitempty"`
	Ci           string                                  `json:"CI"`
	Di           string                                  `json:"DI"`
	ImpUid       *string                                 `json:"imp_uid,omitempty"`
	MerchantUid  *string                                 `json:"merchant_uid,omitempty"`
}

type VerificationCreateOneWithoutPhoneInput struct {
	Create  *VerificationCreateWithoutPhoneInput `json:"create,omitempty"`
	Connect *VerificationWhereUniqueInput        `json:"connect,omitempty"`
}

type VerificationCreateWithoutPhoneInput struct {
	Level          *int32                                                    `json:"level,omitempty"`
	HasEmail       *bool                                                     `json:"hasEmail,omitempty"`
	HasPin         *bool                                                     `json:"hasPin,omitempty"`
	HasPhone       *bool                                                     `json:"hasPhone,omitempty"`
	HasBankAccount *bool                                                     `json:"hasBankAccount,omitempty"`
	HasInter       *bool                                                     `json:"hasInter,omitempty"`
	PinNumber      *string                                                   `json:"pinNumber,omitempty"`
	BankAccount    *BankAccountVerificationCreateOneWithoutVerificationInput `json:"bankAccount,omitempty"`
	User           UserCreateOneWithoutVerificationInput                     `json:"user"`
}

type PhoneVerificationUpdateInput struct {
	Verification *VerificationUpdateOneWithoutPhoneInput `json:"verification,omitempty"`
	Name         *string                                 `json:"name,omitempty"`
	Birth        *string                                 `json:"birth,omitempty"`
	Foreigner    *bool                                   `json:"foreigner,omitempty"`
	Gender       *string                                 `json:"gender,omitempty"`
	PhoneNumber  *string                                 `json:"phoneNumber,omitempty"`
	Ci           *string                                 `json:"CI,omitempty"`
	Di           *string                                 `json:"DI,omitempty"`
	ImpUid       *string                                 `json:"imp_uid,omitempty"`
	MerchantUid  *string                                 `json:"merchant_uid,omitempty"`
}

type VerificationUpdateOneWithoutPhoneInput struct {
	Create     *VerificationCreateWithoutPhoneInput     `json:"create,omitempty"`
	Update     *VerificationUpdateWithoutPhoneDataInput `json:"update,omitempty"`
	Upsert     *VerificationUpsertWithoutPhoneInput     `json:"upsert,omitempty"`
	Delete     *bool                                    `json:"delete,omitempty"`
	Disconnect *bool                                    `json:"disconnect,omitempty"`
	Connect    *VerificationWhereUniqueInput            `json:"connect,omitempty"`
}

type VerificationUpdateWithoutPhoneDataInput struct {
	Level          *int32                                                    `json:"level,omitempty"`
	HasEmail       *bool                                                     `json:"hasEmail,omitempty"`
	HasPin         *bool                                                     `json:"hasPin,omitempty"`
	HasPhone       *bool                                                     `json:"hasPhone,omitempty"`
	HasBankAccount *bool                                                     `json:"hasBankAccount,omitempty"`
	HasInter       *bool                                                     `json:"hasInter,omitempty"`
	PinNumber      *string                                                   `json:"pinNumber,omitempty"`
	BankAccount    *BankAccountVerificationUpdateOneWithoutVerificationInput `json:"bankAccount,omitempty"`
	User           *UserUpdateOneRequiredWithoutVerificationInput            `json:"user,omitempty"`
}

type VerificationUpsertWithoutPhoneInput struct {
	Update VerificationUpdateWithoutPhoneDataInput `json:"update"`
	Create VerificationCreateWithoutPhoneInput     `json:"create"`
}

type PhoneVerificationUpdateManyMutationInput struct {
	Name        *string `json:"name,omitempty"`
	Birth       *string `json:"birth,omitempty"`
	Foreigner   *bool   `json:"foreigner,omitempty"`
	Gender      *string `json:"gender,omitempty"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	Ci          *string `json:"CI,omitempty"`
	Di          *string `json:"DI,omitempty"`
	ImpUid      *string `json:"imp_uid,omitempty"`
	MerchantUid *string `json:"merchant_uid,omitempty"`
}

type PostUpdateInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	UpdateHistories           *UpdatePostHistoryUpdateManyWithoutPostInput       `json:"updateHistories,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type PostUpdateManyMutationInput struct {
	Type                  *int32   `json:"type,omitempty"`
	PayType               *int32   `json:"payType,omitempty"`
	Content               *string  `json:"content,omitempty"`
	QuestTitle            *string  `json:"questTitle,omitempty"`
	QuestCost             *float64 `json:"questCost,omitempty"`
	QuestMinMemberCount   *int32   `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount *int32   `json:"questLimitMemberCount,omitempty"`
	QuestToDate           *string  `json:"questToDate,omitempty"`
	QuestStatus           *int32   `json:"questStatus,omitempty"`
	IsBanner              *bool    `json:"isBanner,omitempty"`
	IsDel                 *bool    `json:"isDel,omitempty"`
	EnableEarlyAccess     *bool    `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt        *string  `json:"publicAccessAt,omitempty"`
	OrderIndex            *float64 `json:"order_index,omitempty"`
}

type PostRewardHistoryCreateInput struct {
	Type          int32                                                `json:"type"`
	Description   *string                                              `json:"description,omitempty"`
	User          *UserCreateOneWithoutPostRewardHistoriesInput        `json:"user,omitempty"`
	Post          *PostCreateOneWithoutPostRewardHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutPostRewardHistoryInput `json:"motherHistory,omitempty"`
	Comment       *CommentCreateOneWithoutPostRewardHistoryInput       `json:"comment,omitempty"`
	Qty           *float64                                             `json:"qty,omitempty"`
	CurrentPrice  *float64                                             `json:"currentPrice,omitempty"`
	Memo          *string                                              `json:"memo,omitempty"`
}

type PostRewardHistoryUpdateInput struct {
	Type          *int32                                               `json:"type,omitempty"`
	Description   *string                                              `json:"description,omitempty"`
	User          *UserUpdateOneWithoutPostRewardHistoriesInput        `json:"user,omitempty"`
	Post          *PostUpdateOneWithoutPostRewardHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutPostRewardHistoryInput `json:"motherHistory,omitempty"`
	Comment       *CommentUpdateOneWithoutPostRewardHistoryInput       `json:"comment,omitempty"`
	Qty           *float64                                             `json:"qty,omitempty"`
	CurrentPrice  *float64                                             `json:"currentPrice,omitempty"`
	Memo          *string                                              `json:"memo,omitempty"`
}

type PostRewardHistoryUpdateManyMutationInput struct {
	Type         *int32   `json:"type,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
}

type QuestExpenditureHistoryCreateInput struct {
	Type          int32                                                      `json:"type"`
	PayType       *int32                                                     `json:"payType,omitempty"`
	OrderNum      *int32                                                     `json:"orderNum,omitempty"`
	Description   *string                                                    `json:"description,omitempty"`
	User          *UserCreateOneWithoutQuestExpenditureHistoriesInput        `json:"user,omitempty"`
	Post          *PostCreateOneWithoutQuestExpenditureHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryCreateOneWithoutQuestExpenditureHistoryInput `json:"motherHistory,omitempty"`
	CashHistory   *CashHistoryCreateOneWithoutQehInput                       `json:"cashHistory,omitempty"`
	Price         *int32                                                     `json:"price,omitempty"`
	Qty           *float64                                                   `json:"qty,omitempty"`
	OPrice        *int32                                                     `json:"oPrice,omitempty"`
	CurrentPrice  *float64                                                   `json:"currentPrice,omitempty"`
	Memo          *string                                                    `json:"memo,omitempty"`
}

type QuestExpenditureHistoryUpdateInput struct {
	Type          *int32                                                     `json:"type,omitempty"`
	PayType       *int32                                                     `json:"payType,omitempty"`
	OrderNum      *int32                                                     `json:"orderNum,omitempty"`
	Description   *string                                                    `json:"description,omitempty"`
	User          *UserUpdateOneWithoutQuestExpenditureHistoriesInput        `json:"user,omitempty"`
	Post          *PostUpdateOneWithoutQuestExpenditureHistoriesInput        `json:"post,omitempty"`
	MotherHistory *MotherHistoryUpdateOneWithoutQuestExpenditureHistoryInput `json:"motherHistory,omitempty"`
	CashHistory   *CashHistoryUpdateOneWithoutQehInput                       `json:"cashHistory,omitempty"`
	Price         *int32                                                     `json:"price,omitempty"`
	Qty           *float64                                                   `json:"qty,omitempty"`
	OPrice        *int32                                                     `json:"oPrice,omitempty"`
	CurrentPrice  *float64                                                   `json:"currentPrice,omitempty"`
	Memo          *string                                                    `json:"memo,omitempty"`
}

type QuestExpenditureHistoryUpdateManyMutationInput struct {
	Type         *int32   `json:"type,omitempty"`
	PayType      *int32   `json:"payType,omitempty"`
	OrderNum     *int32   `json:"orderNum,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Price        *int32   `json:"price,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	OPrice       *int32   `json:"oPrice,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
}

type QuestMemberCreateInput struct {
	Post  PostCreateOneWithoutQuestMembersInput `json:"post"`
	User  UserCreateOneWithoutJoinedQuestsInput `json:"user"`
	Note  *string                               `json:"note,omitempty"`
	IsDel *bool                                 `json:"isDel,omitempty"`
}

type QuestMemberUpdateInput struct {
	Post  *PostUpdateOneRequiredWithoutQuestMembersInput `json:"post,omitempty"`
	User  *UserUpdateOneRequiredWithoutJoinedQuestsInput `json:"user,omitempty"`
	Note  *string                                        `json:"note,omitempty"`
	IsDel *bool                                          `json:"isDel,omitempty"`
}

type QuestMemberUpdateManyMutationInput struct {
	Note  *string `json:"note,omitempty"`
	IsDel *bool   `json:"isDel,omitempty"`
}

type ReportCreateInput struct {
	Type       int32                                  `json:"type"`
	ReportUser UserCreateOneWithoutMyReportInput      `json:"reportUser"`
	ReportType int32                                  `json:"reportType"`
	TargetPost *PostCreateOneInput                    `json:"targetPost,omitempty"`
	TargetUser *UserCreateOneWithoutTargetReportInput `json:"targetUser,omitempty"`
}

type ReportUpdateInput struct {
	Type       *int32                                     `json:"type,omitempty"`
	ReportUser *UserUpdateOneRequiredWithoutMyReportInput `json:"reportUser,omitempty"`
	ReportType *int32                                     `json:"reportType,omitempty"`
	TargetPost *PostUpdateOneInput                        `json:"targetPost,omitempty"`
	TargetUser *UserUpdateOneWithoutTargetReportInput     `json:"targetUser,omitempty"`
}

type ReportUpdateManyMutationInput struct {
	Type       *int32 `json:"type,omitempty"`
	ReportType *int32 `json:"reportType,omitempty"`
}

type RequestPageItemCreateInput struct {
	Type      int32                                     `json:"type"`
	Page      PageCreateOneWithoutRequestPageItemsInput `json:"page"`
	Note      *string                                   `json:"note,omitempty"`
	IpAddress *string                                   `json:"ipAddress,omitempty"`
	Owner     *UserCreateOneInput                       `json:"owner,omitempty"`
}

type PageCreateOneWithoutRequestPageItemsInput struct {
	Create  *PageCreateWithoutRequestPageItemsInput `json:"create,omitempty"`
	Connect *PageWhereUniqueInput                   `json:"connect,omitempty"`
}

type PageCreateWithoutRequestPageItemsInput struct {
	PageId         string                                          `json:"pageId"`
	NickName       *string                                         `json:"nickName,omitempty"`
	AvatarUrl      *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl       *string                                         `json:"coverUrl,omitempty"`
	Description    *string                                         `json:"description,omitempty"`
	Badges         *PageBadgeCreateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube        *YoutubeCreateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch         *TwitchCreateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram      *InstagramCreateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv      *AfreecaTvCreateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans           *PageFanCreateManyInput                         `json:"fans,omitempty"`
	Owner          *UserCreateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments       *PageCommentCreateManyWithoutPageInput          `json:"comments,omitempty"`
	Reviews        *ReviewContentPageCreateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews *ReviewContentCreateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type RequestPageItemUpdateInput struct {
	Type      *int32                                             `json:"type,omitempty"`
	Page      *PageUpdateOneRequiredWithoutRequestPageItemsInput `json:"page,omitempty"`
	Note      *string                                            `json:"note,omitempty"`
	IpAddress *string                                            `json:"ipAddress,omitempty"`
	Owner     *UserUpdateOneInput                                `json:"owner,omitempty"`
}

type PageUpdateOneRequiredWithoutRequestPageItemsInput struct {
	Create  *PageCreateWithoutRequestPageItemsInput     `json:"create,omitempty"`
	Update  *PageUpdateWithoutRequestPageItemsDataInput `json:"update,omitempty"`
	Upsert  *PageUpsertWithoutRequestPageItemsInput     `json:"upsert,omitempty"`
	Connect *PageWhereUniqueInput                       `json:"connect,omitempty"`
}

type PageUpdateWithoutRequestPageItemsDataInput struct {
	PageId         *string                                         `json:"pageId,omitempty"`
	NickName       *string                                         `json:"nickName,omitempty"`
	AvatarUrl      *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl       *string                                         `json:"coverUrl,omitempty"`
	Description    *string                                         `json:"description,omitempty"`
	Badges         *PageBadgeUpdateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube        *YoutubeUpdateOneWithoutPageInput               `json:"youtube,omitempty"`
	Twitch         *TwitchUpdateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram      *InstagramUpdateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv      *AfreecaTvUpdateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans           *PageFanUpdateManyInput                         `json:"fans,omitempty"`
	Owner          *UserUpdateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments       *PageCommentUpdateManyWithoutPageInput          `json:"comments,omitempty"`
	Reviews        *ReviewContentPageUpdateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews *ReviewContentUpdateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type PageUpsertWithoutRequestPageItemsInput struct {
	Update PageUpdateWithoutRequestPageItemsDataInput `json:"update"`
	Create PageCreateWithoutRequestPageItemsInput     `json:"create"`
}

type RequestPageItemUpdateManyMutationInput struct {
	Type      *int32  `json:"type,omitempty"`
	Note      *string `json:"note,omitempty"`
	IpAddress *string `json:"ipAddress,omitempty"`
}

type ReviewContentUpdateInput struct {
	ReviewContentPage *ReviewContentPageUpdateOneWithoutReviewsInput            `json:"reviewContentPage,omitempty"`
	PreviewImageUrl   *string                                                   `json:"previewImageUrl,omitempty"`
	Title             *string                                                   `json:"title,omitempty"`
	Type              *string                                                   `json:"type,omitempty"`
	Url               *string                                                   `json:"url,omitempty"`
	Review            *string                                                   `json:"review,omitempty"`
	VideoId           *string                                                   `json:"videoId,omitempty"`
	ContentId         *string                                                   `json:"contentId,omitempty"`
	Viewers           *ReviewContentViewerUpdateManyWithoutReviewContentInput   `json:"viewers,omitempty"`
	Reviewers         *ReviewContentReviewerUpdateManyWithoutReviewContentInput `json:"reviewers,omitempty"`
	RelatedPage       *PageUpdateOneRequiredWithoutRelatedReviewsInput          `json:"relatedPage,omitempty"`
	Owner             *UserUpdateOneRequiredInput                               `json:"owner,omitempty"`
}

type ReviewContentUpdateManyMutationInput struct {
	PreviewImageUrl *string `json:"previewImageUrl,omitempty"`
	Title           *string `json:"title,omitempty"`
	Type            *string `json:"type,omitempty"`
	Url             *string `json:"url,omitempty"`
	Review          *string `json:"review,omitempty"`
	VideoId         *string `json:"videoId,omitempty"`
	ContentId       *string `json:"contentId,omitempty"`
}

type ReviewContentCategoryUpdateInput struct {
	Name     *string `json:"name,omitempty"`
	ImageUrl *string `json:"imageUrl,omitempty"`
}

type ReviewContentCategoryUpdateManyMutationInput struct {
	Name     *string `json:"name,omitempty"`
	ImageUrl *string `json:"imageUrl,omitempty"`
}

type ReviewContentPageCreateInput struct {
	Page       PageCreateOneWithoutReviewsInput                                  `json:"page"`
	Categories *ReviewContentCategoryCreateManyInput                             `json:"categories,omitempty"`
	Title      string                                                            `json:"title"`
	SubTitle   *string                                                           `json:"subTitle,omitempty"`
	Message    *string                                                           `json:"message,omitempty"`
	Viewers    *ReviewContentPageViewerCreateManyWithoutReviewContentPageInput   `json:"viewers,omitempty"`
	Reviews    *ReviewContentCreateManyWithoutReviewContentPageInput             `json:"reviews,omitempty"`
	Comments   *PageCommentCreateManyWithoutRelatedReviewContentPageInput        `json:"comments,omitempty"`
	Owner      UserCreateOneInput                                                `json:"owner"`
	FeedBacks  *ReviewContentPageFeedBackCreateManyWithoutReviewContentPageInput `json:"feedBacks,omitempty"`
	ReleasedAt string                                                            `json:"releasedAt"`
	IsDrafts   *bool                                                             `json:"isDrafts,omitempty"`
	IsDel      *bool                                                             `json:"isDel,omitempty"`
}

type ReviewContentPageUpdateInput struct {
	Page       *PageUpdateOneRequiredWithoutReviewsInput                         `json:"page,omitempty"`
	Categories *ReviewContentCategoryUpdateManyInput                             `json:"categories,omitempty"`
	Title      *string                                                           `json:"title,omitempty"`
	SubTitle   *string                                                           `json:"subTitle,omitempty"`
	Message    *string                                                           `json:"message,omitempty"`
	Viewers    *ReviewContentPageViewerUpdateManyWithoutReviewContentPageInput   `json:"viewers,omitempty"`
	Reviews    *ReviewContentUpdateManyWithoutReviewContentPageInput             `json:"reviews,omitempty"`
	Comments   *PageCommentUpdateManyWithoutRelatedReviewContentPageInput        `json:"comments,omitempty"`
	Owner      *UserUpdateOneRequiredInput                                       `json:"owner,omitempty"`
	FeedBacks  *ReviewContentPageFeedBackUpdateManyWithoutReviewContentPageInput `json:"feedBacks,omitempty"`
	ReleasedAt *string                                                           `json:"releasedAt,omitempty"`
	IsDrafts   *bool                                                             `json:"isDrafts,omitempty"`
	IsDel      *bool                                                             `json:"isDel,omitempty"`
}

type ReviewContentPageUpdateManyMutationInput struct {
	Title      *string `json:"title,omitempty"`
	SubTitle   *string `json:"subTitle,omitempty"`
	Message    *string `json:"message,omitempty"`
	ReleasedAt *string `json:"releasedAt,omitempty"`
	IsDrafts   *bool   `json:"isDrafts,omitempty"`
	IsDel      *bool   `json:"isDel,omitempty"`
}

type ReviewContentPageFeedBackCreateInput struct {
	IsLike            bool                                            `json:"isLike"`
	ReviewContentPage ReviewContentPageCreateOneWithoutFeedBacksInput `json:"reviewContentPage"`
	Message           *string                                         `json:"message,omitempty"`
	Owner             *UserCreateOneInput                             `json:"owner,omitempty"`
	IpAddress         *string                                         `json:"ipAddress,omitempty"`
}

type ReviewContentPageCreateOneWithoutFeedBacksInput struct {
	Create  *ReviewContentPageCreateWithoutFeedBacksInput `json:"create,omitempty"`
	Connect *ReviewContentPageWhereUniqueInput            `json:"connect,omitempty"`
}

type ReviewContentPageCreateWithoutFeedBacksInput struct {
	Page       PageCreateOneWithoutReviewsInput                                `json:"page"`
	Categories *ReviewContentCategoryCreateManyInput                           `json:"categories,omitempty"`
	Title      string                                                          `json:"title"`
	SubTitle   *string                                                         `json:"subTitle,omitempty"`
	Message    *string                                                         `json:"message,omitempty"`
	Viewers    *ReviewContentPageViewerCreateManyWithoutReviewContentPageInput `json:"viewers,omitempty"`
	Reviews    *ReviewContentCreateManyWithoutReviewContentPageInput           `json:"reviews,omitempty"`
	Comments   *PageCommentCreateManyWithoutRelatedReviewContentPageInput      `json:"comments,omitempty"`
	Owner      UserCreateOneInput                                              `json:"owner"`
	ReleasedAt string                                                          `json:"releasedAt"`
	IsDrafts   *bool                                                           `json:"isDrafts,omitempty"`
	IsDel      *bool                                                           `json:"isDel,omitempty"`
}

type ReviewContentPageFeedBackUpdateInput struct {
	IsLike            *bool                                                    `json:"isLike,omitempty"`
	ReviewContentPage *ReviewContentPageUpdateOneRequiredWithoutFeedBacksInput `json:"reviewContentPage,omitempty"`
	Message           *string                                                  `json:"message,omitempty"`
	Owner             *UserUpdateOneInput                                      `json:"owner,omitempty"`
	IpAddress         *string                                                  `json:"ipAddress,omitempty"`
}

type ReviewContentPageUpdateOneRequiredWithoutFeedBacksInput struct {
	Create  *ReviewContentPageCreateWithoutFeedBacksInput     `json:"create,omitempty"`
	Update  *ReviewContentPageUpdateWithoutFeedBacksDataInput `json:"update,omitempty"`
	Upsert  *ReviewContentPageUpsertWithoutFeedBacksInput     `json:"upsert,omitempty"`
	Connect *ReviewContentPageWhereUniqueInput                `json:"connect,omitempty"`
}

type ReviewContentPageUpdateWithoutFeedBacksDataInput struct {
	Page       *PageUpdateOneRequiredWithoutReviewsInput                       `json:"page,omitempty"`
	Categories *ReviewContentCategoryUpdateManyInput                           `json:"categories,omitempty"`
	Title      *string                                                         `json:"title,omitempty"`
	SubTitle   *string                                                         `json:"subTitle,omitempty"`
	Message    *string                                                         `json:"message,omitempty"`
	Viewers    *ReviewContentPageViewerUpdateManyWithoutReviewContentPageInput `json:"viewers,omitempty"`
	Reviews    *ReviewContentUpdateManyWithoutReviewContentPageInput           `json:"reviews,omitempty"`
	Comments   *PageCommentUpdateManyWithoutRelatedReviewContentPageInput      `json:"comments,omitempty"`
	Owner      *UserUpdateOneRequiredInput                                     `json:"owner,omitempty"`
	ReleasedAt *string                                                         `json:"releasedAt,omitempty"`
	IsDrafts   *bool                                                           `json:"isDrafts,omitempty"`
	IsDel      *bool                                                           `json:"isDel,omitempty"`
}

type ReviewContentPageUpsertWithoutFeedBacksInput struct {
	Update ReviewContentPageUpdateWithoutFeedBacksDataInput `json:"update"`
	Create ReviewContentPageCreateWithoutFeedBacksInput     `json:"create"`
}

type ReviewContentPageFeedBackUpdateManyMutationInput struct {
	IsLike    *bool   `json:"isLike,omitempty"`
	Message   *string `json:"message,omitempty"`
	IpAddress *string `json:"ipAddress,omitempty"`
}

type ReviewContentPageViewerCreateInput struct {
	ReviewContentPage ReviewContentPageCreateOneWithoutViewersInput `json:"reviewContentPage"`
	User              *UserCreateOneInput                           `json:"user,omitempty"`
	Ip                *string                                       `json:"ip,omitempty"`
}

type ReviewContentPageCreateOneWithoutViewersInput struct {
	Create  *ReviewContentPageCreateWithoutViewersInput `json:"create,omitempty"`
	Connect *ReviewContentPageWhereUniqueInput          `json:"connect,omitempty"`
}

type ReviewContentPageCreateWithoutViewersInput struct {
	Page       PageCreateOneWithoutReviewsInput                                  `json:"page"`
	Categories *ReviewContentCategoryCreateManyInput                             `json:"categories,omitempty"`
	Title      string                                                            `json:"title"`
	SubTitle   *string                                                           `json:"subTitle,omitempty"`
	Message    *string                                                           `json:"message,omitempty"`
	Reviews    *ReviewContentCreateManyWithoutReviewContentPageInput             `json:"reviews,omitempty"`
	Comments   *PageCommentCreateManyWithoutRelatedReviewContentPageInput        `json:"comments,omitempty"`
	Owner      UserCreateOneInput                                                `json:"owner"`
	FeedBacks  *ReviewContentPageFeedBackCreateManyWithoutReviewContentPageInput `json:"feedBacks,omitempty"`
	ReleasedAt string                                                            `json:"releasedAt"`
	IsDrafts   *bool                                                             `json:"isDrafts,omitempty"`
	IsDel      *bool                                                             `json:"isDel,omitempty"`
}

type ReviewContentPageViewerUpdateInput struct {
	ReviewContentPage *ReviewContentPageUpdateOneRequiredWithoutViewersInput `json:"reviewContentPage,omitempty"`
	User              *UserUpdateOneInput                                    `json:"user,omitempty"`
	Ip                *string                                                `json:"ip,omitempty"`
}

type ReviewContentPageUpdateOneRequiredWithoutViewersInput struct {
	Create  *ReviewContentPageCreateWithoutViewersInput     `json:"create,omitempty"`
	Update  *ReviewContentPageUpdateWithoutViewersDataInput `json:"update,omitempty"`
	Upsert  *ReviewContentPageUpsertWithoutViewersInput     `json:"upsert,omitempty"`
	Connect *ReviewContentPageWhereUniqueInput              `json:"connect,omitempty"`
}

type ReviewContentPageUpdateWithoutViewersDataInput struct {
	Page       *PageUpdateOneRequiredWithoutReviewsInput                         `json:"page,omitempty"`
	Categories *ReviewContentCategoryUpdateManyInput                             `json:"categories,omitempty"`
	Title      *string                                                           `json:"title,omitempty"`
	SubTitle   *string                                                           `json:"subTitle,omitempty"`
	Message    *string                                                           `json:"message,omitempty"`
	Reviews    *ReviewContentUpdateManyWithoutReviewContentPageInput             `json:"reviews,omitempty"`
	Comments   *PageCommentUpdateManyWithoutRelatedReviewContentPageInput        `json:"comments,omitempty"`
	Owner      *UserUpdateOneRequiredInput                                       `json:"owner,omitempty"`
	FeedBacks  *ReviewContentPageFeedBackUpdateManyWithoutReviewContentPageInput `json:"feedBacks,omitempty"`
	ReleasedAt *string                                                           `json:"releasedAt,omitempty"`
	IsDrafts   *bool                                                             `json:"isDrafts,omitempty"`
	IsDel      *bool                                                             `json:"isDel,omitempty"`
}

type ReviewContentPageUpsertWithoutViewersInput struct {
	Update ReviewContentPageUpdateWithoutViewersDataInput `json:"update"`
	Create ReviewContentPageCreateWithoutViewersInput     `json:"create"`
}

type ReviewContentPageViewerUpdateManyMutationInput struct {
	Ip *string `json:"ip,omitempty"`
}

type ReviewContentReviewerCreateInput struct {
	ReviewContent ReviewContentCreateOneWithoutReviewersInput `json:"reviewContent"`
	Review        string                                      `json:"review"`
	Owner         UserCreateOneInput                          `json:"owner"`
}

type ReviewContentCreateOneWithoutReviewersInput struct {
	Create  *ReviewContentCreateWithoutReviewersInput `json:"create,omitempty"`
	Connect *ReviewContentWhereUniqueInput            `json:"connect,omitempty"`
}

type ReviewContentCreateWithoutReviewersInput struct {
	ReviewContentPage *ReviewContentPageCreateOneWithoutReviewsInput          `json:"reviewContentPage,omitempty"`
	PreviewImageUrl   string                                                  `json:"previewImageUrl"`
	Title             *string                                                 `json:"title,omitempty"`
	Type              string                                                  `json:"type"`
	Url               string                                                  `json:"url"`
	Review            *string                                                 `json:"review,omitempty"`
	VideoId           *string                                                 `json:"videoId,omitempty"`
	ContentId         *string                                                 `json:"contentId,omitempty"`
	Viewers           *ReviewContentViewerCreateManyWithoutReviewContentInput `json:"viewers,omitempty"`
	RelatedPage       PageCreateOneWithoutRelatedReviewsInput                 `json:"relatedPage"`
	Owner             UserCreateOneInput                                      `json:"owner"`
}

type ReviewContentReviewerUpdateInput struct {
	ReviewContent *ReviewContentUpdateOneRequiredWithoutReviewersInput `json:"reviewContent,omitempty"`
	Review        *string                                              `json:"review,omitempty"`
	Owner         *UserUpdateOneRequiredInput                          `json:"owner,omitempty"`
}

type ReviewContentUpdateOneRequiredWithoutReviewersInput struct {
	Create  *ReviewContentCreateWithoutReviewersInput     `json:"create,omitempty"`
	Update  *ReviewContentUpdateWithoutReviewersDataInput `json:"update,omitempty"`
	Upsert  *ReviewContentUpsertWithoutReviewersInput     `json:"upsert,omitempty"`
	Connect *ReviewContentWhereUniqueInput                `json:"connect,omitempty"`
}

type ReviewContentUpdateWithoutReviewersDataInput struct {
	ReviewContentPage *ReviewContentPageUpdateOneWithoutReviewsInput          `json:"reviewContentPage,omitempty"`
	PreviewImageUrl   *string                                                 `json:"previewImageUrl,omitempty"`
	Title             *string                                                 `json:"title,omitempty"`
	Type              *string                                                 `json:"type,omitempty"`
	Url               *string                                                 `json:"url,omitempty"`
	Review            *string                                                 `json:"review,omitempty"`
	VideoId           *string                                                 `json:"videoId,omitempty"`
	ContentId         *string                                                 `json:"contentId,omitempty"`
	Viewers           *ReviewContentViewerUpdateManyWithoutReviewContentInput `json:"viewers,omitempty"`
	RelatedPage       *PageUpdateOneRequiredWithoutRelatedReviewsInput        `json:"relatedPage,omitempty"`
	Owner             *UserUpdateOneRequiredInput                             `json:"owner,omitempty"`
}

type ReviewContentUpsertWithoutReviewersInput struct {
	Update ReviewContentUpdateWithoutReviewersDataInput `json:"update"`
	Create ReviewContentCreateWithoutReviewersInput     `json:"create"`
}

type ReviewContentReviewerUpdateManyMutationInput struct {
	Review *string `json:"review,omitempty"`
}

type ReviewContentViewerCreateInput struct {
	ReviewContent ReviewContentCreateOneWithoutViewersInput `json:"reviewContent"`
	User          *UserCreateOneInput                       `json:"user,omitempty"`
	Ip            *string                                   `json:"ip,omitempty"`
}

type ReviewContentCreateOneWithoutViewersInput struct {
	Create  *ReviewContentCreateWithoutViewersInput `json:"create,omitempty"`
	Connect *ReviewContentWhereUniqueInput          `json:"connect,omitempty"`
}

type ReviewContentCreateWithoutViewersInput struct {
	ReviewContentPage *ReviewContentPageCreateOneWithoutReviewsInput            `json:"reviewContentPage,omitempty"`
	PreviewImageUrl   string                                                    `json:"previewImageUrl"`
	Title             *string                                                   `json:"title,omitempty"`
	Type              string                                                    `json:"type"`
	Url               string                                                    `json:"url"`
	Review            *string                                                   `json:"review,omitempty"`
	VideoId           *string                                                   `json:"videoId,omitempty"`
	ContentId         *string                                                   `json:"contentId,omitempty"`
	Reviewers         *ReviewContentReviewerCreateManyWithoutReviewContentInput `json:"reviewers,omitempty"`
	RelatedPage       PageCreateOneWithoutRelatedReviewsInput                   `json:"relatedPage"`
	Owner             UserCreateOneInput                                        `json:"owner"`
}

type ReviewContentViewerUpdateInput struct {
	ReviewContent *ReviewContentUpdateOneRequiredWithoutViewersInput `json:"reviewContent,omitempty"`
	User          *UserUpdateOneInput                                `json:"user,omitempty"`
	Ip            *string                                            `json:"ip,omitempty"`
}

type ReviewContentUpdateOneRequiredWithoutViewersInput struct {
	Create  *ReviewContentCreateWithoutViewersInput     `json:"create,omitempty"`
	Update  *ReviewContentUpdateWithoutViewersDataInput `json:"update,omitempty"`
	Upsert  *ReviewContentUpsertWithoutViewersInput     `json:"upsert,omitempty"`
	Connect *ReviewContentWhereUniqueInput              `json:"connect,omitempty"`
}

type ReviewContentUpdateWithoutViewersDataInput struct {
	ReviewContentPage *ReviewContentPageUpdateOneWithoutReviewsInput            `json:"reviewContentPage,omitempty"`
	PreviewImageUrl   *string                                                   `json:"previewImageUrl,omitempty"`
	Title             *string                                                   `json:"title,omitempty"`
	Type              *string                                                   `json:"type,omitempty"`
	Url               *string                                                   `json:"url,omitempty"`
	Review            *string                                                   `json:"review,omitempty"`
	VideoId           *string                                                   `json:"videoId,omitempty"`
	ContentId         *string                                                   `json:"contentId,omitempty"`
	Reviewers         *ReviewContentReviewerUpdateManyWithoutReviewContentInput `json:"reviewers,omitempty"`
	RelatedPage       *PageUpdateOneRequiredWithoutRelatedReviewsInput          `json:"relatedPage,omitempty"`
	Owner             *UserUpdateOneRequiredInput                               `json:"owner,omitempty"`
}

type ReviewContentUpsertWithoutViewersInput struct {
	Update ReviewContentUpdateWithoutViewersDataInput `json:"update"`
	Create ReviewContentCreateWithoutViewersInput     `json:"create"`
}

type ReviewContentViewerUpdateManyMutationInput struct {
	Ip *string `json:"ip,omitempty"`
}

type RewardDropAttendingUserCreateInput struct {
	RewardDropEvent RewardDropEventCreateOneWithoutAttendingUsersInput `json:"rewardDropEvent"`
	User            UserCreateOneWithoutAttendingRewardDropInput       `json:"user"`
	Memo            string                                             `json:"memo"`
	IsDel           *bool                                              `json:"isDel,omitempty"`
}

type UserCreateOneWithoutAttendingRewardDropInput struct {
	Create  *UserCreateWithoutAttendingRewardDropInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput                      `json:"connect,omitempty"`
}

type UserCreateWithoutAttendingRewardDropInput struct {
	Role                      Role                                               `json:"role"`
	FirebaseUid               string                                             `json:"firebaseUID"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  string                                             `json:"nickName"`
	Email                     string                                             `json:"email"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryCreateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinCreateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationCreateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletCreateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostCreateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostCreateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentCreateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileCreateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoCreateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorCreateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportCreateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportCreateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberCreateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserCreateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryCreateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryCreateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryCreateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryCreateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberCreateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountCreateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeCreateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeCreateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeCreateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageCreateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type RewardDropAttendingUserUpdateInput struct {
	RewardDropEvent *RewardDropEventUpdateOneRequiredWithoutAttendingUsersInput `json:"rewardDropEvent,omitempty"`
	User            *UserUpdateOneRequiredWithoutAttendingRewardDropInput       `json:"user,omitempty"`
	Memo            *string                                                     `json:"memo,omitempty"`
	IsDel           *bool                                                       `json:"isDel,omitempty"`
}

type UserUpdateOneRequiredWithoutAttendingRewardDropInput struct {
	Create  *UserCreateWithoutAttendingRewardDropInput     `json:"create,omitempty"`
	Update  *UserUpdateWithoutAttendingRewardDropDataInput `json:"update,omitempty"`
	Upsert  *UserUpsertWithoutAttendingRewardDropInput     `json:"upsert,omitempty"`
	Connect *UserWhereUniqueInput                          `json:"connect,omitempty"`
}

type UserUpdateWithoutAttendingRewardDropDataInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type UserUpsertWithoutAttendingRewardDropInput struct {
	Update UserUpdateWithoutAttendingRewardDropDataInput `json:"update"`
	Create UserCreateWithoutAttendingRewardDropInput     `json:"create"`
}

type RewardDropAttendingUserUpdateManyMutationInput struct {
	Memo  *string `json:"memo,omitempty"`
	IsDel *bool   `json:"isDel,omitempty"`
}

type RewardDropEventCreateInput struct {
	EventId        string                                                        `json:"eventID"`
	Type           int32                                                         `json:"type"`
	Title          string                                                        `json:"title"`
	Cash           *int32                                                        `json:"cash,omitempty"`
	Coin           *CoinCreateOneInput                                           `json:"coin,omitempty"`
	Qty            *int32                                                        `json:"qty,omitempty"`
	LimitUserCount int32                                                         `json:"limitUserCount"`
	FromDate       string                                                        `json:"fromDate"`
	ToDate         string                                                        `json:"toDate"`
	AttendingUsers *RewardDropAttendingUserCreateManyWithoutRewardDropEventInput `json:"attendingUsers,omitempty"`
	IsDel          *bool                                                         `json:"isDel,omitempty"`
}

type RewardDropAttendingUserCreateManyWithoutRewardDropEventInput struct {
	Create  []RewardDropAttendingUserCreateWithoutRewardDropEventInput `json:"create,omitempty"`
	Connect []RewardDropAttendingUserWhereUniqueInput                  `json:"connect,omitempty"`
}

type RewardDropAttendingUserCreateWithoutRewardDropEventInput struct {
	User  UserCreateOneWithoutAttendingRewardDropInput `json:"user"`
	Memo  string                                       `json:"memo"`
	IsDel *bool                                        `json:"isDel,omitempty"`
}

type RewardDropEventUpdateInput struct {
	EventId        *string                                                       `json:"eventID,omitempty"`
	Type           *int32                                                        `json:"type,omitempty"`
	Title          *string                                                       `json:"title,omitempty"`
	Cash           *int32                                                        `json:"cash,omitempty"`
	Coin           *CoinUpdateOneInput                                           `json:"coin,omitempty"`
	Qty            *int32                                                        `json:"qty,omitempty"`
	LimitUserCount *int32                                                        `json:"limitUserCount,omitempty"`
	FromDate       *string                                                       `json:"fromDate,omitempty"`
	ToDate         *string                                                       `json:"toDate,omitempty"`
	AttendingUsers *RewardDropAttendingUserUpdateManyWithoutRewardDropEventInput `json:"attendingUsers,omitempty"`
	IsDel          *bool                                                         `json:"isDel,omitempty"`
}

type RewardDropAttendingUserUpdateManyWithoutRewardDropEventInput struct {
	Create     []RewardDropAttendingUserCreateWithoutRewardDropEventInput                `json:"create,omitempty"`
	Delete     []RewardDropAttendingUserWhereUniqueInput                                 `json:"delete,omitempty"`
	Connect    []RewardDropAttendingUserWhereUniqueInput                                 `json:"connect,omitempty"`
	Set        []RewardDropAttendingUserWhereUniqueInput                                 `json:"set,omitempty"`
	Disconnect []RewardDropAttendingUserWhereUniqueInput                                 `json:"disconnect,omitempty"`
	Update     []RewardDropAttendingUserUpdateWithWhereUniqueWithoutRewardDropEventInput `json:"update,omitempty"`
	Upsert     []RewardDropAttendingUserUpsertWithWhereUniqueWithoutRewardDropEventInput `json:"upsert,omitempty"`
	DeleteMany []RewardDropAttendingUserScalarWhereInput                                 `json:"deleteMany,omitempty"`
	UpdateMany []RewardDropAttendingUserUpdateManyWithWhereNestedInput                   `json:"updateMany,omitempty"`
}

type RewardDropAttendingUserUpdateWithWhereUniqueWithoutRewardDropEventInput struct {
	Where RewardDropAttendingUserWhereUniqueInput                      `json:"where"`
	Data  RewardDropAttendingUserUpdateWithoutRewardDropEventDataInput `json:"data"`
}

type RewardDropAttendingUserUpdateWithoutRewardDropEventDataInput struct {
	User  *UserUpdateOneRequiredWithoutAttendingRewardDropInput `json:"user,omitempty"`
	Memo  *string                                               `json:"memo,omitempty"`
	IsDel *bool                                                 `json:"isDel,omitempty"`
}

type RewardDropAttendingUserUpsertWithWhereUniqueWithoutRewardDropEventInput struct {
	Where  RewardDropAttendingUserWhereUniqueInput                      `json:"where"`
	Update RewardDropAttendingUserUpdateWithoutRewardDropEventDataInput `json:"update"`
	Create RewardDropAttendingUserCreateWithoutRewardDropEventInput     `json:"create"`
}

type RewardDropEventUpdateManyMutationInput struct {
	EventId        *string `json:"eventID,omitempty"`
	Type           *int32  `json:"type,omitempty"`
	Title          *string `json:"title,omitempty"`
	Cash           *int32  `json:"cash,omitempty"`
	Qty            *int32  `json:"qty,omitempty"`
	LimitUserCount *int32  `json:"limitUserCount,omitempty"`
	FromDate       *string `json:"fromDate,omitempty"`
	ToDate         *string `json:"toDate,omitempty"`
	IsDel          *bool   `json:"isDel,omitempty"`
}

type TwitchCreateInput struct {
	UserId           string                                             `json:"userId"`
	UserNo           string                                             `json:"userNo"`
	UserName         *string                                            `json:"userName,omitempty"`
	FollowerCount    *string                                            `json:"followerCount,omitempty"`
	FollowingCount   *string                                            `json:"followingCount,omitempty"`
	ChannelType      *string                                            `json:"channelType,omitempty"`
	ChannelViewCount *string                                            `json:"channelViewCount,omitempty"`
	AvatarUrl        *string                                            `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                            `json:"coverUrl,omitempty"`
	Description      *string                                            `json:"description,omitempty"`
	PageUrl          *string                                            `json:"pageUrl,omitempty"`
	Page             PageCreateOneWithoutTwitchInput                    `json:"page"`
	Statistics       *TwitchDailyStatisticsCreateManyWithoutTwitchInput `json:"statistics,omitempty"`
}

type PageCreateOneWithoutTwitchInput struct {
	Create  *PageCreateWithoutTwitchInput `json:"create,omitempty"`
	Connect *PageWhereUniqueInput         `json:"connect,omitempty"`
}

type PageCreateWithoutTwitchInput struct {
	PageId           string                                          `json:"pageId"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeCreateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeCreateOneWithoutPageInput               `json:"youtube,omitempty"`
	Instagram        *InstagramCreateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvCreateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanCreateManyInput                         `json:"fans,omitempty"`
	Owner            *UserCreateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentCreateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemCreateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageCreateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentCreateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type TwitchUpdateInput struct {
	UserId           *string                                            `json:"userId,omitempty"`
	UserNo           *string                                            `json:"userNo,omitempty"`
	UserName         *string                                            `json:"userName,omitempty"`
	FollowerCount    *string                                            `json:"followerCount,omitempty"`
	FollowingCount   *string                                            `json:"followingCount,omitempty"`
	ChannelType      *string                                            `json:"channelType,omitempty"`
	ChannelViewCount *string                                            `json:"channelViewCount,omitempty"`
	AvatarUrl        *string                                            `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                            `json:"coverUrl,omitempty"`
	Description      *string                                            `json:"description,omitempty"`
	PageUrl          *string                                            `json:"pageUrl,omitempty"`
	Page             *PageUpdateOneRequiredWithoutTwitchInput           `json:"page,omitempty"`
	Statistics       *TwitchDailyStatisticsUpdateManyWithoutTwitchInput `json:"statistics,omitempty"`
}

type PageUpdateOneRequiredWithoutTwitchInput struct {
	Create  *PageCreateWithoutTwitchInput     `json:"create,omitempty"`
	Update  *PageUpdateWithoutTwitchDataInput `json:"update,omitempty"`
	Upsert  *PageUpsertWithoutTwitchInput     `json:"upsert,omitempty"`
	Connect *PageWhereUniqueInput             `json:"connect,omitempty"`
}

type PageUpdateWithoutTwitchDataInput struct {
	PageId           *string                                         `json:"pageId,omitempty"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeUpdateManyWithoutPageInput            `json:"badges,omitempty"`
	Youtube          *YoutubeUpdateOneWithoutPageInput               `json:"youtube,omitempty"`
	Instagram        *InstagramUpdateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvUpdateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanUpdateManyInput                         `json:"fans,omitempty"`
	Owner            *UserUpdateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentUpdateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemUpdateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageUpdateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentUpdateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type PageUpsertWithoutTwitchInput struct {
	Update PageUpdateWithoutTwitchDataInput `json:"update"`
	Create PageCreateWithoutTwitchInput     `json:"create"`
}

type TwitchUpdateManyMutationInput struct {
	UserId           *string `json:"userId,omitempty"`
	UserNo           *string `json:"userNo,omitempty"`
	UserName         *string `json:"userName,omitempty"`
	FollowerCount    *string `json:"followerCount,omitempty"`
	FollowingCount   *string `json:"followingCount,omitempty"`
	ChannelType      *string `json:"channelType,omitempty"`
	ChannelViewCount *string `json:"channelViewCount,omitempty"`
	AvatarUrl        *string `json:"avatarUrl,omitempty"`
	CoverUrl         *string `json:"coverUrl,omitempty"`
	Description      *string `json:"description,omitempty"`
	PageUrl          *string `json:"pageUrl,omitempty"`
}

type TwitchDailyStatisticsCreateInput struct {
	Date             string                                `json:"date"`
	FollowerCount    string                                `json:"followerCount"`
	FollowingCount   string                                `json:"followingCount"`
	ChannelViewCount string                                `json:"channelViewCount"`
	Twitch           TwitchCreateOneWithoutStatisticsInput `json:"twitch"`
}

type TwitchCreateOneWithoutStatisticsInput struct {
	Create  *TwitchCreateWithoutStatisticsInput `json:"create,omitempty"`
	Connect *TwitchWhereUniqueInput             `json:"connect,omitempty"`
}

type TwitchCreateWithoutStatisticsInput struct {
	UserId           string                          `json:"userId"`
	UserNo           string                          `json:"userNo"`
	UserName         *string                         `json:"userName,omitempty"`
	FollowerCount    *string                         `json:"followerCount,omitempty"`
	FollowingCount   *string                         `json:"followingCount,omitempty"`
	ChannelType      *string                         `json:"channelType,omitempty"`
	ChannelViewCount *string                         `json:"channelViewCount,omitempty"`
	AvatarUrl        *string                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                         `json:"coverUrl,omitempty"`
	Description      *string                         `json:"description,omitempty"`
	PageUrl          *string                         `json:"pageUrl,omitempty"`
	Page             PageCreateOneWithoutTwitchInput `json:"page"`
}

type TwitchDailyStatisticsUpdateInput struct {
	Date             *string                                        `json:"date,omitempty"`
	FollowerCount    *string                                        `json:"followerCount,omitempty"`
	FollowingCount   *string                                        `json:"followingCount,omitempty"`
	ChannelViewCount *string                                        `json:"channelViewCount,omitempty"`
	Twitch           *TwitchUpdateOneRequiredWithoutStatisticsInput `json:"twitch,omitempty"`
}

type TwitchUpdateOneRequiredWithoutStatisticsInput struct {
	Create  *TwitchCreateWithoutStatisticsInput     `json:"create,omitempty"`
	Update  *TwitchUpdateWithoutStatisticsDataInput `json:"update,omitempty"`
	Upsert  *TwitchUpsertWithoutStatisticsInput     `json:"upsert,omitempty"`
	Connect *TwitchWhereUniqueInput                 `json:"connect,omitempty"`
}

type TwitchUpdateWithoutStatisticsDataInput struct {
	UserId           *string                                  `json:"userId,omitempty"`
	UserNo           *string                                  `json:"userNo,omitempty"`
	UserName         *string                                  `json:"userName,omitempty"`
	FollowerCount    *string                                  `json:"followerCount,omitempty"`
	FollowingCount   *string                                  `json:"followingCount,omitempty"`
	ChannelType      *string                                  `json:"channelType,omitempty"`
	ChannelViewCount *string                                  `json:"channelViewCount,omitempty"`
	AvatarUrl        *string                                  `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                  `json:"coverUrl,omitempty"`
	Description      *string                                  `json:"description,omitempty"`
	PageUrl          *string                                  `json:"pageUrl,omitempty"`
	Page             *PageUpdateOneRequiredWithoutTwitchInput `json:"page,omitempty"`
}

type TwitchUpsertWithoutStatisticsInput struct {
	Update TwitchUpdateWithoutStatisticsDataInput `json:"update"`
	Create TwitchCreateWithoutStatisticsInput     `json:"create"`
}

type TwitchDailyStatisticsUpdateManyMutationInput struct {
	Date             *string `json:"date,omitempty"`
	FollowerCount    *string `json:"followerCount,omitempty"`
	FollowingCount   *string `json:"followingCount,omitempty"`
	ChannelViewCount *string `json:"channelViewCount,omitempty"`
}

type UpdatePostHistoryCreateInput struct {
	Action         int32                                    `json:"action"`
	Post           PostCreateOneWithoutUpdateHistoriesInput `json:"post"`
	BeforeContent  *string                                  `json:"beforeContent,omitempty"`
	BeforeImageUrl *string                                  `json:"beforeImageUrl,omitempty"`
	User           *UserCreateOneInput                      `json:"user,omitempty"`
	Admin          *AdminUserCreateOneInput                 `json:"admin,omitempty"`
}

type PostCreateOneWithoutUpdateHistoriesInput struct {
	Create  *PostCreateWithoutUpdateHistoriesInput `json:"create,omitempty"`
	Connect *PostWhereUniqueInput                  `json:"connect,omitempty"`
}

type PostCreateWithoutUpdateHistoriesInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryCreateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   string                                             `json:"content"`
	ToUser                    *UserCreateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     UserCreateOneWithoutPostsInput                     `json:"owner"`
	Coin                      CoinCreateOneWithoutPostsInput                     `json:"coin"`
	AirDrop                   *AirDropCreateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileCreateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoCreateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberCreateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryCreateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryCreateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryCreateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentCreateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserCreateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserCreateManyWithoutViewsInput                   `json:"views,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type UpdatePostHistoryUpdateInput struct {
	Action         *int32                                            `json:"action,omitempty"`
	Post           *PostUpdateOneRequiredWithoutUpdateHistoriesInput `json:"post,omitempty"`
	BeforeContent  *string                                           `json:"beforeContent,omitempty"`
	BeforeImageUrl *string                                           `json:"beforeImageUrl,omitempty"`
	User           *UserUpdateOneInput                               `json:"user,omitempty"`
	Admin          *AdminUserUpdateOneInput                          `json:"admin,omitempty"`
}

type PostUpdateOneRequiredWithoutUpdateHistoriesInput struct {
	Create  *PostCreateWithoutUpdateHistoriesInput     `json:"create,omitempty"`
	Update  *PostUpdateWithoutUpdateHistoriesDataInput `json:"update,omitempty"`
	Upsert  *PostUpsertWithoutUpdateHistoriesInput     `json:"upsert,omitempty"`
	Connect *PostWhereUniqueInput                      `json:"connect,omitempty"`
}

type PostUpdateWithoutUpdateHistoriesDataInput struct {
	Type                      *int32                                             `json:"type,omitempty"`
	PayType                   *int32                                             `json:"payType,omitempty"`
	Categories                *CategoryUpdateManyWithoutPostsInput               `json:"categories,omitempty"`
	Content                   *string                                            `json:"content,omitempty"`
	ToUser                    *UserUpdateOneWithoutRequestPostsInput             `json:"toUser,omitempty"`
	Owner                     *UserUpdateOneRequiredWithoutPostsInput            `json:"owner,omitempty"`
	Coin                      *CoinUpdateOneRequiredWithoutPostsInput            `json:"coin,omitempty"`
	AirDrop                   *AirDropUpdateOneWithoutPostInput                  `json:"airDrop,omitempty"`
	Image                     *FileUpdateOneWithoutPostInput                     `json:"image,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutPostInput                `json:"fileList,omitempty"`
	QuestTitle                *string                                            `json:"questTitle,omitempty"`
	QuestCost                 *float64                                           `json:"questCost,omitempty"`
	QuestMinMemberCount       *int32                                             `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount     *int32                                             `json:"questLimitMemberCount,omitempty"`
	QuestToDate               *string                                            `json:"questToDate,omitempty"`
	QuestMembers              *QuestMemberUpdateManyWithoutPostInput             `json:"questMembers,omitempty"`
	QuestStatus               *int32                                             `json:"questStatus,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutPostInput           `json:"motherHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutPostInput `json:"questExpenditureHistories,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutPostInput       `json:"postRewardHistories,omitempty"`
	Comments                  *CommentUpdateManyWithoutPostInput                 `json:"comments,omitempty"`
	Likes                     *UserUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *UserUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	IsBanner                  *bool                                              `json:"isBanner,omitempty"`
	IsDel                     *bool                                              `json:"isDel,omitempty"`
	EnableEarlyAccess         *bool                                              `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt            *string                                            `json:"publicAccessAt,omitempty"`
	OrderIndex                *float64                                           `json:"order_index,omitempty"`
}

type PostUpsertWithoutUpdateHistoriesInput struct {
	Update PostUpdateWithoutUpdateHistoriesDataInput `json:"update"`
	Create PostCreateWithoutUpdateHistoriesInput     `json:"create"`
}

type UpdatePostHistoryUpdateManyMutationInput struct {
	Action         *int32  `json:"action,omitempty"`
	BeforeContent  *string `json:"beforeContent,omitempty"`
	BeforeImageUrl *string `json:"beforeImageUrl,omitempty"`
}

type UserUpdateInput struct {
	Role                      *Role                                              `json:"role,omitempty"`
	FirebaseUid               *string                                            `json:"firebaseUID,omitempty"`
	Provider                  *string                                            `json:"provider,omitempty"`
	NickName                  *string                                            `json:"nickName,omitempty"`
	Email                     *string                                            `json:"email,omitempty"`
	BackupEmail               *string                                            `json:"backupEmail,omitempty"`
	DeviceId                  *string                                            `json:"deviceId,omitempty"`
	Platform                  *string                                            `json:"platform,omitempty"`
	FcmToken                  *string                                            `json:"fcmToken,omitempty"`
	FeedCategories            *CategoryUpdateManyWithoutFeedUsersInput           `json:"feedCategories,omitempty"`
	LinkedFacebook            *string                                            `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string                                            `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string                                            `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string                                            `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string                                            `json:"linkedTwitch,omitempty"`
	ContentProvider           *string                                            `json:"contentProvider,omitempty"`
	ContentId                 *string                                            `json:"contentId,omitempty"`
	RevokeTokenKey            *string                                            `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool                                              `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool                                              `json:"subscribeEmail,omitempty"`
	Coin                      *CoinUpdateOneWithoutOwnerInput                    `json:"coin,omitempty"`
	Verification              *VerificationUpdateOneWithoutUserInput             `json:"verification,omitempty"`
	Wallets                   *WalletUpdateManyWithoutOwnerInput                 `json:"wallets,omitempty"`
	Posts                     *PostUpdateManyWithoutOwnerInput                   `json:"posts,omitempty"`
	RequestPosts              *PostUpdateManyWithoutToUserInput                  `json:"requestPosts,omitempty"`
	Comments                  *CommentUpdateManyWithoutOwnerInput                `json:"comments,omitempty"`
	Files                     *FileUpdateManyWithoutOwnerInput                   `json:"files,omitempty"`
	FileList                  *FileInfoUpdateManyWithoutOwnerInput               `json:"fileList,omitempty"`
	Likes                     *PostUpdateManyWithoutLikesInput                   `json:"likes,omitempty"`
	Views                     *PostUpdateManyWithoutViewsInput                   `json:"views,omitempty"`
	JoinOffer                 *OfferorUpdateManyWithoutUserInput                 `json:"joinOffer,omitempty"`
	MyReport                  *ReportUpdateManyWithoutReportUserInput            `json:"myReport,omitempty"`
	TargetReport              *ReportUpdateManyWithoutTargetUserInput            `json:"targetReport,omitempty"`
	JoinedQuests              *QuestMemberUpdateManyWithoutUserInput             `json:"joinedQuests,omitempty"`
	AdminUser                 *AdminUserUpdateOneWithoutMembersInput             `json:"adminUser,omitempty"`
	DeletedAt                 *string                                            `json:"deletedAt,omitempty"`
	Status                    *int32                                             `json:"status,omitempty"`
	NumId                     *int32                                             `json:"numId,omitempty"`
	AttendingRewardDrop       *RewardDropAttendingUserUpdateManyWithoutUserInput `json:"attendingRewardDrop,omitempty"`
	MotherHistories           *MotherHistoryUpdateManyWithoutUserInput           `json:"motherHistories,omitempty"`
	OrderHistories            *OrderHistoryUpdateManyWithoutUserInput            `json:"orderHistories,omitempty"`
	OrderUserDealsHistories   *OrderUserDealsHistoryUpdateManyWithoutUserInput   `json:"orderUserDealsHistories,omitempty"`
	CashHistories             *CashHistoryUpdateManyWithoutUserInput             `json:"cashHistories,omitempty"`
	QuestExpenditureHistories *QuestExpenditureHistoryUpdateManyWithoutUserInput `json:"questExpenditureHistories,omitempty"`
	AirDropHistories          *AirDropHistoryUpdateManyWithoutUserInput          `json:"airDropHistories,omitempty"`
	AirDropMembers            *AirDropMemberUpdateManyWithoutUserInput           `json:"airDropMembers,omitempty"`
	PostRewardHistories       *PostRewardHistoryUpdateManyWithoutUserInput       `json:"postRewardHistories,omitempty"`
	UserRank                  *int32                                             `json:"userRank,omitempty"`
	AergoAccount              *AergoAccountUpdateOneWithoutOwnerInput            `json:"aergoAccount,omitempty"`
	UserRankFee               *FeeUpdateOneWithoutRankRelationInput              `json:"userRankFee,omitempty"`
	EventFee                  *FeeUpdateManyWithoutEventRelationInput            `json:"eventFee,omitempty"`
	InviteCode                *InviteCodeUpdateOneWithoutOwnerInput              `json:"inviteCode,omitempty"`
	Page                      *PageUpdateOneWithoutOwnerInput                    `json:"page,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Role                      *Role   `json:"role,omitempty"`
	FirebaseUid               *string `json:"firebaseUID,omitempty"`
	Provider                  *string `json:"provider,omitempty"`
	NickName                  *string `json:"nickName,omitempty"`
	Email                     *string `json:"email,omitempty"`
	BackupEmail               *string `json:"backupEmail,omitempty"`
	DeviceId                  *string `json:"deviceId,omitempty"`
	Platform                  *string `json:"platform,omitempty"`
	FcmToken                  *string `json:"fcmToken,omitempty"`
	LinkedFacebook            *string `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string `json:"linkedTwitch,omitempty"`
	ContentProvider           *string `json:"contentProvider,omitempty"`
	ContentId                 *string `json:"contentId,omitempty"`
	RevokeTokenKey            *string `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool   `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool   `json:"subscribeEmail,omitempty"`
	DeletedAt                 *string `json:"deletedAt,omitempty"`
	Status                    *int32  `json:"status,omitempty"`
	NumId                     *int32  `json:"numId,omitempty"`
	UserRank                  *int32  `json:"userRank,omitempty"`
}

type VerificationCreateInput struct {
	Level          *int32                                                    `json:"level,omitempty"`
	HasEmail       *bool                                                     `json:"hasEmail,omitempty"`
	HasPin         *bool                                                     `json:"hasPin,omitempty"`
	HasPhone       *bool                                                     `json:"hasPhone,omitempty"`
	HasBankAccount *bool                                                     `json:"hasBankAccount,omitempty"`
	HasInter       *bool                                                     `json:"hasInter,omitempty"`
	PinNumber      *string                                                   `json:"pinNumber,omitempty"`
	Phone          *PhoneVerificationCreateOneWithoutVerificationInput       `json:"phone,omitempty"`
	BankAccount    *BankAccountVerificationCreateOneWithoutVerificationInput `json:"bankAccount,omitempty"`
	User           UserCreateOneWithoutVerificationInput                     `json:"user"`
}

type VerificationUpdateInput struct {
	Level          *int32                                                    `json:"level,omitempty"`
	HasEmail       *bool                                                     `json:"hasEmail,omitempty"`
	HasPin         *bool                                                     `json:"hasPin,omitempty"`
	HasPhone       *bool                                                     `json:"hasPhone,omitempty"`
	HasBankAccount *bool                                                     `json:"hasBankAccount,omitempty"`
	HasInter       *bool                                                     `json:"hasInter,omitempty"`
	PinNumber      *string                                                   `json:"pinNumber,omitempty"`
	Phone          *PhoneVerificationUpdateOneWithoutVerificationInput       `json:"phone,omitempty"`
	BankAccount    *BankAccountVerificationUpdateOneWithoutVerificationInput `json:"bankAccount,omitempty"`
	User           *UserUpdateOneRequiredWithoutVerificationInput            `json:"user,omitempty"`
}

type VerificationUpdateManyMutationInput struct {
	Level          *int32  `json:"level,omitempty"`
	HasEmail       *bool   `json:"hasEmail,omitempty"`
	HasPin         *bool   `json:"hasPin,omitempty"`
	HasPhone       *bool   `json:"hasPhone,omitempty"`
	HasBankAccount *bool   `json:"hasBankAccount,omitempty"`
	HasInter       *bool   `json:"hasInter,omitempty"`
	PinNumber      *string `json:"pinNumber,omitempty"`
}

type WalletCreateInput struct {
	Coin                       CoinCreateOneWithoutWalletsInput `json:"coin"`
	Owner                      UserCreateOneWithoutWalletsInput `json:"owner"`
	NumIdCoinName              *string                          `json:"numIdCoinName,omitempty"`
	CumulativePurchaseQuantity *float64                         `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseValue    *float64                         `json:"cumulativePurchaseValue,omitempty"`
}

type WalletUpdateInput struct {
	Coin                       *CoinUpdateOneRequiredWithoutWalletsInput `json:"coin,omitempty"`
	Owner                      *UserUpdateOneRequiredWithoutWalletsInput `json:"owner,omitempty"`
	NumIdCoinName              *string                                   `json:"numIdCoinName,omitempty"`
	CumulativePurchaseQuantity *float64                                  `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseValue    *float64                                  `json:"cumulativePurchaseValue,omitempty"`
}

type WalletUpdateManyMutationInput struct {
	NumIdCoinName              *string  `json:"numIdCoinName,omitempty"`
	CumulativePurchaseQuantity *float64 `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseValue    *float64 `json:"cumulativePurchaseValue,omitempty"`
}

type YoutubeCreateInput struct {
	ChannelId       string                                               `json:"channelId"`
	ChannelType     *string                                              `json:"channelType,omitempty"`
	ChannelName     *string                                              `json:"channelName,omitempty"`
	UserName        *string                                              `json:"userName,omitempty"`
	VideoCount      *string                                              `json:"videoCount,omitempty"`
	SubscriberCount *string                                              `json:"subscriberCount,omitempty"`
	VideoViewCount  *string                                              `json:"videoViewCount,omitempty"`
	ThumbnailUrl    *string                                              `json:"thumbnailUrl,omitempty"`
	BannerUrl       *string                                              `json:"bannerUrl,omitempty"`
	Description     *string                                              `json:"description,omitempty"`
	PublishedAt     *string                                              `json:"publishedAt,omitempty"`
	Country         *string                                              `json:"country,omitempty"`
	PageUrl         *string                                              `json:"pageUrl,omitempty"`
	Page            PageCreateOneWithoutYoutubeInput                     `json:"page"`
	Statistics      *YoutubeDailyStatisticsCreateManyWithoutYoutubeInput `json:"statistics,omitempty"`
}

type PageCreateOneWithoutYoutubeInput struct {
	Create  *PageCreateWithoutYoutubeInput `json:"create,omitempty"`
	Connect *PageWhereUniqueInput          `json:"connect,omitempty"`
}

type PageCreateWithoutYoutubeInput struct {
	PageId           string                                          `json:"pageId"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeCreateManyWithoutPageInput            `json:"badges,omitempty"`
	Twitch           *TwitchCreateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramCreateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvCreateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanCreateManyInput                         `json:"fans,omitempty"`
	Owner            *UserCreateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentCreateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemCreateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageCreateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentCreateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type YoutubeUpdateInput struct {
	ChannelId       *string                                              `json:"channelId,omitempty"`
	ChannelType     *string                                              `json:"channelType,omitempty"`
	ChannelName     *string                                              `json:"channelName,omitempty"`
	UserName        *string                                              `json:"userName,omitempty"`
	VideoCount      *string                                              `json:"videoCount,omitempty"`
	SubscriberCount *string                                              `json:"subscriberCount,omitempty"`
	VideoViewCount  *string                                              `json:"videoViewCount,omitempty"`
	ThumbnailUrl    *string                                              `json:"thumbnailUrl,omitempty"`
	BannerUrl       *string                                              `json:"bannerUrl,omitempty"`
	Description     *string                                              `json:"description,omitempty"`
	PublishedAt     *string                                              `json:"publishedAt,omitempty"`
	Country         *string                                              `json:"country,omitempty"`
	PageUrl         *string                                              `json:"pageUrl,omitempty"`
	Page            *PageUpdateOneRequiredWithoutYoutubeInput            `json:"page,omitempty"`
	Statistics      *YoutubeDailyStatisticsUpdateManyWithoutYoutubeInput `json:"statistics,omitempty"`
}

type PageUpdateOneRequiredWithoutYoutubeInput struct {
	Create  *PageCreateWithoutYoutubeInput     `json:"create,omitempty"`
	Update  *PageUpdateWithoutYoutubeDataInput `json:"update,omitempty"`
	Upsert  *PageUpsertWithoutYoutubeInput     `json:"upsert,omitempty"`
	Connect *PageWhereUniqueInput              `json:"connect,omitempty"`
}

type PageUpdateWithoutYoutubeDataInput struct {
	PageId           *string                                         `json:"pageId,omitempty"`
	NickName         *string                                         `json:"nickName,omitempty"`
	AvatarUrl        *string                                         `json:"avatarUrl,omitempty"`
	CoverUrl         *string                                         `json:"coverUrl,omitempty"`
	Description      *string                                         `json:"description,omitempty"`
	Badges           *PageBadgeUpdateManyWithoutPageInput            `json:"badges,omitempty"`
	Twitch           *TwitchUpdateOneWithoutPageInput                `json:"twitch,omitempty"`
	Instagram        *InstagramUpdateOneWithoutPageInput             `json:"instagram,omitempty"`
	AfreecaTv        *AfreecaTvUpdateOneWithoutPageInput             `json:"afreecaTV,omitempty"`
	Fans             *PageFanUpdateManyInput                         `json:"fans,omitempty"`
	Owner            *UserUpdateOneWithoutPageInput                  `json:"owner,omitempty"`
	Comments         *PageCommentUpdateManyWithoutPageInput          `json:"comments,omitempty"`
	RequestPageItems *RequestPageItemUpdateManyWithoutPageInput      `json:"requestPageItems,omitempty"`
	Reviews          *ReviewContentPageUpdateManyWithoutPageInput    `json:"reviews,omitempty"`
	RelatedReviews   *ReviewContentUpdateManyWithoutRelatedPageInput `json:"relatedReviews,omitempty"`
}

type PageUpsertWithoutYoutubeInput struct {
	Update PageUpdateWithoutYoutubeDataInput `json:"update"`
	Create PageCreateWithoutYoutubeInput     `json:"create"`
}

type YoutubeUpdateManyMutationInput struct {
	ChannelId       *string `json:"channelId,omitempty"`
	ChannelType     *string `json:"channelType,omitempty"`
	ChannelName     *string `json:"channelName,omitempty"`
	UserName        *string `json:"userName,omitempty"`
	VideoCount      *string `json:"videoCount,omitempty"`
	SubscriberCount *string `json:"subscriberCount,omitempty"`
	VideoViewCount  *string `json:"videoViewCount,omitempty"`
	ThumbnailUrl    *string `json:"thumbnailUrl,omitempty"`
	BannerUrl       *string `json:"bannerUrl,omitempty"`
	Description     *string `json:"description,omitempty"`
	PublishedAt     *string `json:"publishedAt,omitempty"`
	Country         *string `json:"country,omitempty"`
	PageUrl         *string `json:"pageUrl,omitempty"`
}

type YoutubeDailyStatisticsCreateInput struct {
	Date            string                                 `json:"date"`
	VideoCount      string                                 `json:"videoCount"`
	SubscriberCount string                                 `json:"subscriberCount"`
	VideoViewCount  string                                 `json:"videoViewCount"`
	Youtube         YoutubeCreateOneWithoutStatisticsInput `json:"youtube"`
}

type YoutubeCreateOneWithoutStatisticsInput struct {
	Create  *YoutubeCreateWithoutStatisticsInput `json:"create,omitempty"`
	Connect *YoutubeWhereUniqueInput             `json:"connect,omitempty"`
}

type YoutubeCreateWithoutStatisticsInput struct {
	ChannelId       string                           `json:"channelId"`
	ChannelType     *string                          `json:"channelType,omitempty"`
	ChannelName     *string                          `json:"channelName,omitempty"`
	UserName        *string                          `json:"userName,omitempty"`
	VideoCount      *string                          `json:"videoCount,omitempty"`
	SubscriberCount *string                          `json:"subscriberCount,omitempty"`
	VideoViewCount  *string                          `json:"videoViewCount,omitempty"`
	ThumbnailUrl    *string                          `json:"thumbnailUrl,omitempty"`
	BannerUrl       *string                          `json:"bannerUrl,omitempty"`
	Description     *string                          `json:"description,omitempty"`
	PublishedAt     *string                          `json:"publishedAt,omitempty"`
	Country         *string                          `json:"country,omitempty"`
	PageUrl         *string                          `json:"pageUrl,omitempty"`
	Page            PageCreateOneWithoutYoutubeInput `json:"page"`
}

type YoutubeDailyStatisticsUpdateInput struct {
	Date            *string                                         `json:"date,omitempty"`
	VideoCount      *string                                         `json:"videoCount,omitempty"`
	SubscriberCount *string                                         `json:"subscriberCount,omitempty"`
	VideoViewCount  *string                                         `json:"videoViewCount,omitempty"`
	Youtube         *YoutubeUpdateOneRequiredWithoutStatisticsInput `json:"youtube,omitempty"`
}

type YoutubeUpdateOneRequiredWithoutStatisticsInput struct {
	Create  *YoutubeCreateWithoutStatisticsInput     `json:"create,omitempty"`
	Update  *YoutubeUpdateWithoutStatisticsDataInput `json:"update,omitempty"`
	Upsert  *YoutubeUpsertWithoutStatisticsInput     `json:"upsert,omitempty"`
	Connect *YoutubeWhereUniqueInput                 `json:"connect,omitempty"`
}

type YoutubeUpdateWithoutStatisticsDataInput struct {
	ChannelId       *string                                   `json:"channelId,omitempty"`
	ChannelType     *string                                   `json:"channelType,omitempty"`
	ChannelName     *string                                   `json:"channelName,omitempty"`
	UserName        *string                                   `json:"userName,omitempty"`
	VideoCount      *string                                   `json:"videoCount,omitempty"`
	SubscriberCount *string                                   `json:"subscriberCount,omitempty"`
	VideoViewCount  *string                                   `json:"videoViewCount,omitempty"`
	ThumbnailUrl    *string                                   `json:"thumbnailUrl,omitempty"`
	BannerUrl       *string                                   `json:"bannerUrl,omitempty"`
	Description     *string                                   `json:"description,omitempty"`
	PublishedAt     *string                                   `json:"publishedAt,omitempty"`
	Country         *string                                   `json:"country,omitempty"`
	PageUrl         *string                                   `json:"pageUrl,omitempty"`
	Page            *PageUpdateOneRequiredWithoutYoutubeInput `json:"page,omitempty"`
}

type YoutubeUpsertWithoutStatisticsInput struct {
	Update YoutubeUpdateWithoutStatisticsDataInput `json:"update"`
	Create YoutubeCreateWithoutStatisticsInput     `json:"create"`
}

type YoutubeDailyStatisticsUpdateManyMutationInput struct {
	Date            *string `json:"date,omitempty"`
	VideoCount      *string `json:"videoCount,omitempty"`
	SubscriberCount *string `json:"subscriberCount,omitempty"`
	VideoViewCount  *string `json:"videoViewCount,omitempty"`
}

type AdminUserSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *AdminUserWhereInput              `json:"node,omitempty"`
	And                        []AdminUserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AdminUserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AdminUserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AergoAccountSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *AergoAccountWhereInput              `json:"node,omitempty"`
	And                        []AergoAccountSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AergoAccountSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AergoAccountSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AergoAccountHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *AergoAccountHistoryWhereInput              `json:"node,omitempty"`
	And                        []AergoAccountHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AergoAccountHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AergoAccountHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type AfreecaTvSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *AfreecaTvWhereInput              `json:"node,omitempty"`
	And                        []AfreecaTvSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AfreecaTvSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AfreecaTvSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AfreecaTvDailyStatisticsSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *AfreecaTvDailyStatisticsWhereInput              `json:"node,omitempty"`
	And                        []AfreecaTvDailyStatisticsSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AfreecaTvDailyStatisticsSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AfreecaTvDailyStatisticsSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AirDropSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *AirDropWhereInput              `json:"node,omitempty"`
	And                        []AirDropSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AirDropSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AirDropSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AirDropHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                         `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                               `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                               `json:"updatedFields_contains_some,omitempty"`
	Node                       *AirDropHistoryWhereInput              `json:"node,omitempty"`
	And                        []AirDropHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AirDropHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AirDropHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type AirDropMemberSubscriptionWhereInput struct {
	MutationIn                 []MutationType                        `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                               `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                              `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                              `json:"updatedFields_contains_some,omitempty"`
	Node                       *AirDropMemberWhereInput              `json:"node,omitempty"`
	And                        []AirDropMemberSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AirDropMemberSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AirDropMemberSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AppVersionSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *AppVersionWhereInput              `json:"node,omitempty"`
	And                        []AppVersionSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AppVersionSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AppVersionSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BadgeSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *BadgeWhereInput              `json:"node,omitempty"`
	And                        []BadgeSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BadgeSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BadgeSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BadgeVoterSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *BadgeVoterWhereInput              `json:"node,omitempty"`
	And                        []BadgeVoterSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BadgeVoterSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BadgeVoterSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BankSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *BankWhereInput              `json:"node,omitempty"`
	And                        []BankSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BankSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BankSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BankAccountVerificationSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *BankAccountVerificationWhereInput              `json:"node,omitempty"`
	And                        []BankAccountVerificationSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BankAccountVerificationSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BankAccountVerificationSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BankAccountVerificationTransactionInfoSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *BankAccountVerificationTransactionInfoWhereInput              `json:"node,omitempty"`
	And                        []BankAccountVerificationTransactionInfoSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BankAccountVerificationTransactionInfoSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BankAccountVerificationTransactionInfoSubscriptionWhereInput `json:"NOT,omitempty"`
}

type BoardSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *BoardWhereInput              `json:"node,omitempty"`
	And                        []BoardSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []BoardSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []BoardSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CashHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *CashHistoryWhereInput              `json:"node,omitempty"`
	And                        []CashHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CashHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CashHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type CategorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *CategoryWhereInput              `json:"node,omitempty"`
	And                        []CategorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CategorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CategorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type CoinSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *CoinWhereInput              `json:"node,omitempty"`
	And                        []CoinSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CoinSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CoinSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CoinKlineSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *CoinKlineWhereInput              `json:"node,omitempty"`
	And                        []CoinKlineSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CoinKlineSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CoinKlineSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CoinPriceTableSubscriptionWhereInput struct {
	MutationIn                 []MutationType                         `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                               `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                               `json:"updatedFields_contains_some,omitempty"`
	Node                       *CoinPriceTableWhereInput              `json:"node,omitempty"`
	And                        []CoinPriceTableSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CoinPriceTableSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CoinPriceTableSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CommentSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *CommentWhereInput              `json:"node,omitempty"`
	And                        []CommentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CommentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CommentSubscriptionWhereInput `json:"NOT,omitempty"`
}

type CommentReplySubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *CommentReplyWhereInput              `json:"node,omitempty"`
	And                        []CommentReplySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []CommentReplySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []CommentReplySubscriptionWhereInput `json:"NOT,omitempty"`
}

type DeviceSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *DeviceWhereInput              `json:"node,omitempty"`
	And                        []DeviceSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []DeviceSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []DeviceSubscriptionWhereInput `json:"NOT,omitempty"`
}

type FeeSubscriptionWhereInput struct {
	MutationIn                 []MutationType              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *FeeWhereInput              `json:"node,omitempty"`
	And                        []FeeSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FeeSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FeeSubscriptionWhereInput `json:"NOT,omitempty"`
}

type FileSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *FileWhereInput              `json:"node,omitempty"`
	And                        []FileSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FileSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FileSubscriptionWhereInput `json:"NOT,omitempty"`
}

type FileInfoSubscriptionWhereInput struct {
	MutationIn                 []MutationType                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *FileInfoWhereInput              `json:"node,omitempty"`
	And                        []FileInfoSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []FileInfoSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []FileInfoSubscriptionWhereInput `json:"NOT,omitempty"`
}

type InstagramSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *InstagramWhereInput              `json:"node,omitempty"`
	And                        []InstagramSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []InstagramSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []InstagramSubscriptionWhereInput `json:"NOT,omitempty"`
}

type InstagramDailyStatisticsSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                   `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                          `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                         `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                         `json:"updatedFields_contains_some,omitempty"`
	Node                       *InstagramDailyStatisticsWhereInput              `json:"node,omitempty"`
	And                        []InstagramDailyStatisticsSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []InstagramDailyStatisticsSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []InstagramDailyStatisticsSubscriptionWhereInput `json:"NOT,omitempty"`
}

type InviteCodeSubscriptionWhereInput struct {
	MutationIn                 []MutationType                     `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                            `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                           `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                           `json:"updatedFields_contains_some,omitempty"`
	Node                       *InviteCodeWhereInput              `json:"node,omitempty"`
	And                        []InviteCodeSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []InviteCodeSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []InviteCodeSubscriptionWhereInput `json:"NOT,omitempty"`
}

type InviteUserHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                            `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                   `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                  `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                  `json:"updatedFields_contains_some,omitempty"`
	Node                       *InviteUserHistoryWhereInput              `json:"node,omitempty"`
	And                        []InviteUserHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []InviteUserHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []InviteUserHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type MaintenanceSubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *MaintenanceWhereInput              `json:"node,omitempty"`
	And                        []MaintenanceSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []MaintenanceSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []MaintenanceSubscriptionWhereInput `json:"NOT,omitempty"`
}

type MotherHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                        `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                               `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                              `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                              `json:"updatedFields_contains_some,omitempty"`
	Node                       *MotherHistoryWhereInput              `json:"node,omitempty"`
	And                        []MotherHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []MotherHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []MotherHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type NotificationSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *NotificationWhereInput              `json:"node,omitempty"`
	And                        []NotificationSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []NotificationSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []NotificationSubscriptionWhereInput `json:"NOT,omitempty"`
}

type OfferSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *OfferWhereInput              `json:"node,omitempty"`
	And                        []OfferSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []OfferSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []OfferSubscriptionWhereInput `json:"NOT,omitempty"`
}

type OfferorSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *OfferorWhereInput              `json:"node,omitempty"`
	And                        []OfferorSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []OfferorSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []OfferorSubscriptionWhereInput `json:"NOT,omitempty"`
}

type OrderDealsHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                            `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                   `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                  `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                  `json:"updatedFields_contains_some,omitempty"`
	Node                       *OrderDealsHistoryWhereInput              `json:"node,omitempty"`
	And                        []OrderDealsHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []OrderDealsHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []OrderDealsHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type OrderHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *OrderHistoryWhereInput              `json:"node,omitempty"`
	And                        []OrderHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []OrderHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []OrderHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type OrderUserDealsHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *OrderUserDealsHistoryWhereInput              `json:"node,omitempty"`
	And                        []OrderUserDealsHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []OrderUserDealsHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []OrderUserDealsHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type PageSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *PageWhereInput              `json:"node,omitempty"`
	And                        []PageSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PageSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PageSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PageBadgeSubscriptionWhereInput struct {
	MutationIn                 []MutationType                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *PageBadgeWhereInput              `json:"node,omitempty"`
	And                        []PageBadgeSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PageBadgeSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PageBadgeSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PageCommentSubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *PageCommentWhereInput              `json:"node,omitempty"`
	And                        []PageCommentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PageCommentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PageCommentSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PageCommentReplySubscriptionWhereInput struct {
	MutationIn                 []MutationType                           `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                  `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                 `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                 `json:"updatedFields_contains_some,omitempty"`
	Node                       *PageCommentReplyWhereInput              `json:"node,omitempty"`
	And                        []PageCommentReplySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PageCommentReplySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PageCommentReplySubscriptionWhereInput `json:"NOT,omitempty"`
}

type PageFanSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *PageFanWhereInput              `json:"node,omitempty"`
	And                        []PageFanSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PageFanSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PageFanSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PaymentHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                         `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                               `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                               `json:"updatedFields_contains_some,omitempty"`
	Node                       *PaymentHistoryWhereInput              `json:"node,omitempty"`
	And                        []PaymentHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PaymentHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PaymentHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type PhoneVerificationSubscriptionWhereInput struct {
	MutationIn                 []MutationType                            `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                   `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                  `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                  `json:"updatedFields_contains_some,omitempty"`
	Node                       *PhoneVerificationWhereInput              `json:"node,omitempty"`
	And                        []PhoneVerificationSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PhoneVerificationSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PhoneVerificationSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PostSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *PostWhereInput              `json:"node,omitempty"`
	And                        []PostSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PostSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PostSubscriptionWhereInput `json:"NOT,omitempty"`
}

type PostRewardHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                            `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                   `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                  `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                  `json:"updatedFields_contains_some,omitempty"`
	Node                       *PostRewardHistoryWhereInput              `json:"node,omitempty"`
	And                        []PostRewardHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []PostRewardHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []PostRewardHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type QuestExpenditureHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *QuestExpenditureHistoryWhereInput              `json:"node,omitempty"`
	And                        []QuestExpenditureHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []QuestExpenditureHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []QuestExpenditureHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type QuestMemberSubscriptionWhereInput struct {
	MutationIn                 []MutationType                      `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                             `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                            `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                            `json:"updatedFields_contains_some,omitempty"`
	Node                       *QuestMemberWhereInput              `json:"node,omitempty"`
	And                        []QuestMemberSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []QuestMemberSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []QuestMemberSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ReportSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *ReportWhereInput              `json:"node,omitempty"`
	And                        []ReportSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ReportSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ReportSubscriptionWhereInput `json:"NOT,omitempty"`
}

type RequestPageItemSubscriptionWhereInput struct {
	MutationIn                 []MutationType                          `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                 `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                `json:"updatedFields_contains_some,omitempty"`
	Node                       *RequestPageItemWhereInput              `json:"node,omitempty"`
	And                        []RequestPageItemSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []RequestPageItemSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []RequestPageItemSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ReviewContentSubscriptionWhereInput struct {
	MutationIn                 []MutationType                        `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                               `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                              `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                              `json:"updatedFields_contains_some,omitempty"`
	Node                       *ReviewContentWhereInput              `json:"node,omitempty"`
	And                        []ReviewContentSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ReviewContentSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ReviewContentSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ReviewContentCategorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *ReviewContentCategoryWhereInput              `json:"node,omitempty"`
	And                        []ReviewContentCategorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ReviewContentCategorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ReviewContentCategorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type ReviewContentPageSubscriptionWhereInput struct {
	MutationIn                 []MutationType                            `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                   `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                  `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                  `json:"updatedFields_contains_some,omitempty"`
	Node                       *ReviewContentPageWhereInput              `json:"node,omitempty"`
	And                        []ReviewContentPageSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ReviewContentPageSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ReviewContentPageSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ReviewContentPageFeedBackSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                    `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                           `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                          `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                          `json:"updatedFields_contains_some,omitempty"`
	Node                       *ReviewContentPageFeedBackWhereInput              `json:"node,omitempty"`
	And                        []ReviewContentPageFeedBackSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ReviewContentPageFeedBackSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ReviewContentPageFeedBackSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ReviewContentPageViewerSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *ReviewContentPageViewerWhereInput              `json:"node,omitempty"`
	And                        []ReviewContentPageViewerSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ReviewContentPageViewerSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ReviewContentPageViewerSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ReviewContentReviewerSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *ReviewContentReviewerWhereInput              `json:"node,omitempty"`
	And                        []ReviewContentReviewerSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ReviewContentReviewerSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ReviewContentReviewerSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ReviewContentViewerSubscriptionWhereInput struct {
	MutationIn                 []MutationType                              `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                     `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                    `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                    `json:"updatedFields_contains_some,omitempty"`
	Node                       *ReviewContentViewerWhereInput              `json:"node,omitempty"`
	And                        []ReviewContentViewerSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ReviewContentViewerSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ReviewContentViewerSubscriptionWhereInput `json:"NOT,omitempty"`
}

type RewardDropAttendingUserSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *RewardDropAttendingUserWhereInput              `json:"node,omitempty"`
	And                        []RewardDropAttendingUserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []RewardDropAttendingUserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []RewardDropAttendingUserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type RewardDropEventSubscriptionWhereInput struct {
	MutationIn                 []MutationType                          `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                 `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                `json:"updatedFields_contains_some,omitempty"`
	Node                       *RewardDropEventWhereInput              `json:"node,omitempty"`
	And                        []RewardDropEventSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []RewardDropEventSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []RewardDropEventSubscriptionWhereInput `json:"NOT,omitempty"`
}

type TwitchSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *TwitchWhereInput              `json:"node,omitempty"`
	And                        []TwitchSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TwitchSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TwitchSubscriptionWhereInput `json:"NOT,omitempty"`
}

type TwitchDailyStatisticsSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *TwitchDailyStatisticsWhereInput              `json:"node,omitempty"`
	And                        []TwitchDailyStatisticsSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []TwitchDailyStatisticsSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []TwitchDailyStatisticsSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UpdatePostHistorySubscriptionWhereInput struct {
	MutationIn                 []MutationType                            `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                   `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                  `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                  `json:"updatedFields_contains_some,omitempty"`
	Node                       *UpdatePostHistoryWhereInput              `json:"node,omitempty"`
	And                        []UpdatePostHistorySubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UpdatePostHistorySubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UpdatePostHistorySubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type VerificationSubscriptionWhereInput struct {
	MutationIn                 []MutationType                       `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                              `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                             `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                             `json:"updatedFields_contains_some,omitempty"`
	Node                       *VerificationWhereInput              `json:"node,omitempty"`
	And                        []VerificationSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []VerificationSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []VerificationSubscriptionWhereInput `json:"NOT,omitempty"`
}

type WalletSubscriptionWhereInput struct {
	MutationIn                 []MutationType                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *WalletWhereInput              `json:"node,omitempty"`
	And                        []WalletSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []WalletSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []WalletSubscriptionWhereInput `json:"NOT,omitempty"`
}

type YoutubeSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *YoutubeWhereInput              `json:"node,omitempty"`
	And                        []YoutubeSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []YoutubeSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []YoutubeSubscriptionWhereInput `json:"NOT,omitempty"`
}

type YoutubeDailyStatisticsSubscriptionWhereInput struct {
	MutationIn                 []MutationType                                 `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                                        `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                                       `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                                       `json:"updatedFields_contains_some,omitempty"`
	Node                       *YoutubeDailyStatisticsWhereInput              `json:"node,omitempty"`
	And                        []YoutubeDailyStatisticsSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []YoutubeDailyStatisticsSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []YoutubeDailyStatisticsSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AdminUserExec struct {
	exec *prisma.Exec
}

type MembersParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *AdminUserExec) Members(params *MembersParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"members",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExecArray{ret}
}

func (instance *AdminUserExec) CreateNotification() *NotificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Notification"},
		"createNotification",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationExec{ret}
}

func (instance *AdminUserExec) UpdateNotification() *NotificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Notification"},
		"updateNotification",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationExec{ret}
}

func (instance AdminUserExec) Exec(ctx context.Context) (*AdminUser, error) {
	var v AdminUser
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AdminUserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AdminUserExecArray struct {
	exec *prisma.Exec
}

func (instance AdminUserExecArray) Exec(ctx context.Context) ([]AdminUser, error) {
	var v []AdminUser
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AdminUserFields = []string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"}

type AdminUser struct {
	ID        string  `json:"id"`
	Role      Role    `json:"role"`
	Email     string  `json:"email"`
	Password  *string `json:"password,omitempty"`
	NickName  string  `json:"nickName"`
	OtpKey    *string `json:"otpKey,omitempty"`
	Level     *string `json:"level,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type UserExec struct {
	exec *prisma.Exec
}

type FeedCategoriesParamsExec struct {
	Where   *CategoryWhereInput
	OrderBy *CategoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) FeedCategories(params *FeedCategoriesParamsExec) *CategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CategoryWhereInput", "CategoryOrderByInput", "Category"},
		"feedCategories",
		[]string{"id", "name", "order_index"})

	return &CategoryExecArray{ret}
}

func (instance *UserExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance *UserExec) Verification() *VerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Verification"},
		"verification",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExec{ret}
}

type WalletsParamsExec struct {
	Where   *WalletWhereInput
	OrderBy *WalletOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Wallets(params *WalletsParamsExec) *WalletExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"WalletWhereInput", "WalletOrderByInput", "Wallet"},
		"wallets",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletExecArray{ret}
}

type PostsParamsExec struct {
	Where   *PostWhereInput
	OrderBy *PostOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Posts(params *PostsParamsExec) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"posts",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExecArray{ret}
}

type RequestPostsParamsExec struct {
	Where   *PostWhereInput
	OrderBy *PostOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) RequestPosts(params *RequestPostsParamsExec) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"requestPosts",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExecArray{ret}
}

type CommentsParamsExec struct {
	Where   *CommentWhereInput
	OrderBy *CommentOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Comments(params *CommentsParamsExec) *CommentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
		"comments",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExecArray{ret}
}

type FilesParamsExec struct {
	Where   *FileWhereInput
	OrderBy *FileOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Files(params *FilesParamsExec) *FileExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FileWhereInput", "FileOrderByInput", "File"},
		"files",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExecArray{ret}
}

type FileListParamsExec struct {
	Where   *FileInfoWhereInput
	OrderBy *FileInfoOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) FileList(params *FileListParamsExec) *FileInfoExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FileInfoWhereInput", "FileInfoOrderByInput", "FileInfo"},
		"fileList",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExecArray{ret}
}

type LikesParamsExec struct {
	Where   *PostWhereInput
	OrderBy *PostOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Likes(params *LikesParamsExec) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"likes",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExecArray{ret}
}

type ViewsParamsExec struct {
	Where   *PostWhereInput
	OrderBy *PostOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Views(params *ViewsParamsExec) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"views",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExecArray{ret}
}

type JoinOfferParamsExec struct {
	Where   *OfferorWhereInput
	OrderBy *OfferorOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) JoinOffer(params *JoinOfferParamsExec) *OfferorExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"OfferorWhereInput", "OfferorOrderByInput", "Offeror"},
		"joinOffer",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorExecArray{ret}
}

type MyReportParamsExec struct {
	Where   *ReportWhereInput
	OrderBy *ReportOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) MyReport(params *MyReportParamsExec) *ReportExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReportWhereInput", "ReportOrderByInput", "Report"},
		"myReport",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportExecArray{ret}
}

type TargetReportParamsExec struct {
	Where   *ReportWhereInput
	OrderBy *ReportOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) TargetReport(params *TargetReportParamsExec) *ReportExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReportWhereInput", "ReportOrderByInput", "Report"},
		"targetReport",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportExecArray{ret}
}

type JoinedQuestsParamsExec struct {
	Where   *QuestMemberWhereInput
	OrderBy *QuestMemberOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) JoinedQuests(params *JoinedQuestsParamsExec) *QuestMemberExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"QuestMemberWhereInput", "QuestMemberOrderByInput", "QuestMember"},
		"joinedQuests",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberExecArray{ret}
}

func (instance *UserExec) AdminUser() *AdminUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUser"},
		"adminUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

type AttendingRewardDropParamsExec struct {
	Where   *RewardDropAttendingUserWhereInput
	OrderBy *RewardDropAttendingUserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) AttendingRewardDrop(params *AttendingRewardDropParamsExec) *RewardDropAttendingUserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"RewardDropAttendingUserWhereInput", "RewardDropAttendingUserOrderByInput", "RewardDropAttendingUser"},
		"attendingRewardDrop",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserExecArray{ret}
}

type MotherHistoriesParamsExec struct {
	Where   *MotherHistoryWhereInput
	OrderBy *MotherHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) MotherHistories(params *MotherHistoriesParamsExec) *MotherHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"MotherHistoryWhereInput", "MotherHistoryOrderByInput", "MotherHistory"},
		"motherHistories",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExecArray{ret}
}

type OrderHistoriesParamsExec struct {
	Where   *OrderHistoryWhereInput
	OrderBy *OrderHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) OrderHistories(params *OrderHistoriesParamsExec) *OrderHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"OrderHistoryWhereInput", "OrderHistoryOrderByInput", "OrderHistory"},
		"orderHistories",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExecArray{ret}
}

type OrderUserDealsHistoriesParamsExec struct {
	Where   *OrderUserDealsHistoryWhereInput
	OrderBy *OrderUserDealsHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) OrderUserDealsHistories(params *OrderUserDealsHistoriesParamsExec) *OrderUserDealsHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"OrderUserDealsHistoryWhereInput", "OrderUserDealsHistoryOrderByInput", "OrderUserDealsHistory"},
		"orderUserDealsHistories",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExecArray{ret}
}

type CashHistoriesParamsExec struct {
	Where   *CashHistoryWhereInput
	OrderBy *CashHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) CashHistories(params *CashHistoriesParamsExec) *CashHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CashHistoryWhereInput", "CashHistoryOrderByInput", "CashHistory"},
		"cashHistories",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExecArray{ret}
}

type QuestExpenditureHistoriesParamsExec struct {
	Where   *QuestExpenditureHistoryWhereInput
	OrderBy *QuestExpenditureHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) QuestExpenditureHistories(params *QuestExpenditureHistoriesParamsExec) *QuestExpenditureHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"QuestExpenditureHistoryWhereInput", "QuestExpenditureHistoryOrderByInput", "QuestExpenditureHistory"},
		"questExpenditureHistories",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExecArray{ret}
}

type AirDropHistoriesParamsExec struct {
	Where   *AirDropHistoryWhereInput
	OrderBy *AirDropHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) AirDropHistories(params *AirDropHistoriesParamsExec) *AirDropHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AirDropHistoryWhereInput", "AirDropHistoryOrderByInput", "AirDropHistory"},
		"airDropHistories",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExecArray{ret}
}

type AirDropMembersParamsExec struct {
	Where   *AirDropMemberWhereInput
	OrderBy *AirDropMemberOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) AirDropMembers(params *AirDropMembersParamsExec) *AirDropMemberExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AirDropMemberWhereInput", "AirDropMemberOrderByInput", "AirDropMember"},
		"airDropMembers",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExecArray{ret}
}

type PostRewardHistoriesParamsExec struct {
	Where   *PostRewardHistoryWhereInput
	OrderBy *PostRewardHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) PostRewardHistories(params *PostRewardHistoriesParamsExec) *PostRewardHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PostRewardHistoryWhereInput", "PostRewardHistoryOrderByInput", "PostRewardHistory"},
		"postRewardHistories",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExecArray{ret}
}

func (instance *UserExec) AergoAccount() *AergoAccountExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AergoAccount"},
		"aergoAccount",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountExec{ret}
}

func (instance *UserExec) UserRankFee() *FeeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Fee"},
		"userRankFee",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeeExec{ret}
}

type EventFeeParamsExec struct {
	Where   *FeeWhereInput
	OrderBy *FeeOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) EventFee(params *EventFeeParamsExec) *FeeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FeeWhereInput", "FeeOrderByInput", "Fee"},
		"eventFee",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeeExecArray{ret}
}

func (instance *UserExec) InviteCode() *InviteCodeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InviteCode"},
		"inviteCode",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodeExec{ret}
}

func (instance *UserExec) Page() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"page",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserFields = []string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"}

type User struct {
	ID                        string  `json:"id"`
	Role                      Role    `json:"role"`
	FirebaseUid               string  `json:"firebaseUID"`
	Provider                  *string `json:"provider,omitempty"`
	NickName                  string  `json:"nickName"`
	Email                     string  `json:"email"`
	BackupEmail               *string `json:"backupEmail,omitempty"`
	DeviceId                  *string `json:"deviceId,omitempty"`
	Platform                  *string `json:"platform,omitempty"`
	FcmToken                  *string `json:"fcmToken,omitempty"`
	LinkedFacebook            *string `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string `json:"linkedTwitch,omitempty"`
	ContentProvider           *string `json:"contentProvider,omitempty"`
	ContentId                 *string `json:"contentId,omitempty"`
	RevokeTokenKey            *string `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool   `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool   `json:"subscribeEmail,omitempty"`
	DeletedAt                 *string `json:"deletedAt,omitempty"`
	CreatedAt                 string  `json:"createdAt"`
	UpdatedAt                 string  `json:"updatedAt"`
	Status                    int32   `json:"status"`
	NumId                     int32   `json:"numId"`
	UserRank                  *int32  `json:"userRank,omitempty"`
}

type CategoryExec struct {
	exec *prisma.Exec
}

func (instance *CategoryExec) Posts(params *PostsParamsExec) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"posts",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExecArray{ret}
}

type FeedUsersParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CategoryExec) FeedUsers(params *FeedUsersParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"feedUsers",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExecArray{ret}
}

type CoinsParamsExec struct {
	Where   *CoinWhereInput
	OrderBy *CoinOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CategoryExec) Coins(params *CoinsParamsExec) *CoinExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CoinWhereInput", "CoinOrderByInput", "Coin"},
		"coins",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExecArray{ret}
}

func (instance CategoryExec) Exec(ctx context.Context) (*Category, error) {
	var v Category
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CategoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CategoryExecArray struct {
	exec *prisma.Exec
}

func (instance CategoryExecArray) Exec(ctx context.Context) ([]Category, error) {
	var v []Category
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CategoryFields = []string{"id", "name", "order_index"}

type Category struct {
	ID         string   `json:"id"`
	Name       string   `json:"name"`
	OrderIndex *float64 `json:"order_index,omitempty"`
}

type PostExec struct {
	exec *prisma.Exec
}

type CategoriesParamsExec struct {
	Where   *CategoryWhereInput
	OrderBy *CategoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PostExec) Categories(params *CategoriesParamsExec) *CategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CategoryWhereInput", "CategoryOrderByInput", "Category"},
		"categories",
		[]string{"id", "name", "order_index"})

	return &CategoryExecArray{ret}
}

func (instance *PostExec) ToUser() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"toUser",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *PostExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *PostExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance *PostExec) AirDrop() *AirDropExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDrop"},
		"airDrop",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExec{ret}
}

func (instance *PostExec) Image() *FileExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "File"},
		"image",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExec{ret}
}

func (instance *PostExec) FileList(params *FileListParamsExec) *FileInfoExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"FileInfoWhereInput", "FileInfoOrderByInput", "FileInfo"},
		"fileList",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExecArray{ret}
}

type QuestMembersParamsExec struct {
	Where   *QuestMemberWhereInput
	OrderBy *QuestMemberOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PostExec) QuestMembers(params *QuestMembersParamsExec) *QuestMemberExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"QuestMemberWhereInput", "QuestMemberOrderByInput", "QuestMember"},
		"questMembers",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberExecArray{ret}
}

func (instance *PostExec) MotherHistories(params *MotherHistoriesParamsExec) *MotherHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"MotherHistoryWhereInput", "MotherHistoryOrderByInput", "MotherHistory"},
		"motherHistories",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExecArray{ret}
}

func (instance *PostExec) QuestExpenditureHistories(params *QuestExpenditureHistoriesParamsExec) *QuestExpenditureHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"QuestExpenditureHistoryWhereInput", "QuestExpenditureHistoryOrderByInput", "QuestExpenditureHistory"},
		"questExpenditureHistories",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExecArray{ret}
}

func (instance *PostExec) PostRewardHistories(params *PostRewardHistoriesParamsExec) *PostRewardHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PostRewardHistoryWhereInput", "PostRewardHistoryOrderByInput", "PostRewardHistory"},
		"postRewardHistories",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExecArray{ret}
}

func (instance *PostExec) Comments(params *CommentsParamsExec) *CommentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CommentWhereInput", "CommentOrderByInput", "Comment"},
		"comments",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExecArray{ret}
}

func (instance *PostExec) Likes(params *LikesParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"likes",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExecArray{ret}
}

func (instance *PostExec) Views(params *ViewsParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"views",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExecArray{ret}
}

type UpdateHistoriesParamsExec struct {
	Where   *UpdatePostHistoryWhereInput
	OrderBy *UpdatePostHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PostExec) UpdateHistories(params *UpdateHistoriesParamsExec) *UpdatePostHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UpdatePostHistoryWhereInput", "UpdatePostHistoryOrderByInput", "UpdatePostHistory"},
		"updateHistories",
		[]string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"})

	return &UpdatePostHistoryExecArray{ret}
}

func (instance PostExec) Exec(ctx context.Context) (*Post, error) {
	var v Post
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostExecArray struct {
	exec *prisma.Exec
}

func (instance PostExecArray) Exec(ctx context.Context) ([]Post, error) {
	var v []Post
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostFields = []string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"}

type Post struct {
	ID                    string   `json:"id"`
	Type                  int32    `json:"type"`
	PayType               int32    `json:"payType"`
	Content               string   `json:"content"`
	QuestTitle            *string  `json:"questTitle,omitempty"`
	QuestCost             *float64 `json:"questCost,omitempty"`
	QuestMinMemberCount   *int32   `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount *int32   `json:"questLimitMemberCount,omitempty"`
	QuestToDate           *string  `json:"questToDate,omitempty"`
	QuestStatus           *int32   `json:"questStatus,omitempty"`
	CreatedAt             string   `json:"createdAt"`
	UpdatedAt             string   `json:"updatedAt"`
	IsBanner              bool     `json:"isBanner"`
	IsDel                 bool     `json:"isDel"`
	EnableEarlyAccess     *bool    `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt        *string  `json:"publicAccessAt,omitempty"`
	OrderIndex            *float64 `json:"order_index,omitempty"`
}

type CoinExec struct {
	exec *prisma.Exec
}

func (instance *CoinExec) Categories(params *CategoriesParamsExec) *CategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CategoryWhereInput", "CategoryOrderByInput", "Category"},
		"categories",
		[]string{"id", "name", "order_index"})

	return &CategoryExecArray{ret}
}

func (instance *CoinExec) Image() *FileExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "File"},
		"image",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExec{ret}
}

func (instance *CoinExec) Picture() *FileInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileInfo"},
		"picture",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExec{ret}
}

func (instance *CoinExec) Wallets(params *WalletsParamsExec) *WalletExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"WalletWhereInput", "WalletOrderByInput", "Wallet"},
		"wallets",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletExecArray{ret}
}

func (instance *CoinExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *CoinExec) Posts(params *PostsParamsExec) *PostExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PostWhereInput", "PostOrderByInput", "Post"},
		"posts",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExecArray{ret}
}

func (instance *CoinExec) Offer() *OfferExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Offer"},
		"offer",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferExec{ret}
}

func (instance *CoinExec) OrderHistories(params *OrderHistoriesParamsExec) *OrderHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"OrderHistoryWhereInput", "OrderHistoryOrderByInput", "OrderHistory"},
		"orderHistories",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExecArray{ret}
}

type OrderDealsHistoriesParamsExec struct {
	Where   *OrderDealsHistoryWhereInput
	OrderBy *OrderDealsHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CoinExec) OrderDealsHistories(params *OrderDealsHistoriesParamsExec) *OrderDealsHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"OrderDealsHistoryWhereInput", "OrderDealsHistoryOrderByInput", "OrderDealsHistory"},
		"orderDealsHistories",
		[]string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"})

	return &OrderDealsHistoryExecArray{ret}
}

func (instance *CoinExec) OrderUserDealsHistories(params *OrderUserDealsHistoriesParamsExec) *OrderUserDealsHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"OrderUserDealsHistoryWhereInput", "OrderUserDealsHistoryOrderByInput", "OrderUserDealsHistory"},
		"orderUserDealsHistories",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExecArray{ret}
}

func (instance *CoinExec) MotherHistories(params *MotherHistoriesParamsExec) *MotherHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"MotherHistoryWhereInput", "MotherHistoryOrderByInput", "MotherHistory"},
		"motherHistories",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExecArray{ret}
}

func (instance *CoinExec) CoinPriceTable() *CoinPriceTableExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CoinPriceTable"},
		"coinPriceTable",
		[]string{"id", "type", "infoValue", "createdAt", "updatedAt"})

	return &CoinPriceTableExec{ret}
}

type CoinKlineParamsExec struct {
	Where   *CoinKlineWhereInput
	OrderBy *CoinKlineOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CoinExec) CoinKline(params *CoinKlineParamsExec) *CoinKlineExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CoinKlineWhereInput", "CoinKlineOrderByInput", "CoinKline"},
		"coinKline",
		[]string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"})

	return &CoinKlineExecArray{ret}
}

func (instance CoinExec) Exec(ctx context.Context) (*Coin, error) {
	var v Coin
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinExecArray struct {
	exec *prisma.Exec
}

func (instance CoinExecArray) Exec(ctx context.Context) ([]Coin, error) {
	var v []Coin
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinFields = []string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"}

type Coin struct {
	ID              string   `json:"id"`
	Name            string   `json:"name"`
	Qty             float64  `json:"qty"`
	StandardPrice   *float64 `json:"standardPrice,omitempty"`
	CurrentPrice    *float64 `json:"currentPrice,omitempty"`
	Description     string   `json:"description"`
	Status          int32    `json:"status"`
	Weight          string   `json:"weight"`
	DeployTxhash    *string  `json:"deployTxhash,omitempty"`
	ContractAddress *string  `json:"contractAddress,omitempty"`
	ODda            *float64 `json:"oDDA,omitempty"`
	CreatedAt       string   `json:"createdAt"`
	UpdatedAt       string   `json:"updatedAt"`
}

type FileExec struct {
	exec *prisma.Exec
}

func (instance *FileExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance *FileExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *FileExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance FileExec) Exec(ctx context.Context) (*File, error) {
	var v File
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileExecArray struct {
	exec *prisma.Exec
}

func (instance FileExecArray) Exec(ctx context.Context) ([]File, error) {
	var v []File
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FileFields = []string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"}

type File struct {
	ID           string  `json:"id"`
	LocationPath *string `json:"locationPath,omitempty"`
	Name         *string `json:"name,omitempty"`
	ContentType  *string `json:"contentType,omitempty"`
	Url          string  `json:"url"`
	CreatedAt    string  `json:"createdAt"`
	IsDel        bool    `json:"isDel"`
}

type FileInfoExec struct {
	exec *prisma.Exec
}

func (instance *FileInfoExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance *FileInfoExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *FileInfoExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance FileInfoExec) Exec(ctx context.Context) (*FileInfo, error) {
	var v FileInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileInfoExecArray struct {
	exec *prisma.Exec
}

func (instance FileInfoExecArray) Exec(ctx context.Context) ([]FileInfo, error) {
	var v []FileInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FileInfoFields = []string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"}

type FileInfo struct {
	ID           string  `json:"id"`
	TempFileId   *string `json:"tempFileId,omitempty"`
	LocationPath *string `json:"locationPath,omitempty"`
	Name         *string `json:"name,omitempty"`
	ContentType  *string `json:"contentType,omitempty"`
	Url          string  `json:"url"`
	IsVideo      bool    `json:"isVideo"`
	IsDel        bool    `json:"isDel"`
	CreatedAt    string  `json:"createdAt"`
}

type WalletExec struct {
	exec *prisma.Exec
}

func (instance *WalletExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance *WalletExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance WalletExec) Exec(ctx context.Context) (*Wallet, error) {
	var v Wallet
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WalletExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WalletExecArray struct {
	exec *prisma.Exec
}

func (instance WalletExecArray) Exec(ctx context.Context) ([]Wallet, error) {
	var v []Wallet
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var WalletFields = []string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"}

type Wallet struct {
	ID                         string   `json:"id"`
	NumIdCoinName              *string  `json:"numIdCoinName,omitempty"`
	CumulativePurchaseQuantity *float64 `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseValue    *float64 `json:"cumulativePurchaseValue,omitempty"`
	CreatedAt                  string   `json:"createdAt"`
}

type OfferExec struct {
	exec *prisma.Exec
}

func (instance *OfferExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

type OfferorParamsExec struct {
	Where   *OfferorWhereInput
	OrderBy *OfferorOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *OfferExec) Offeror(params *OfferorParamsExec) *OfferorExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"OfferorWhereInput", "OfferorOrderByInput", "Offeror"},
		"offeror",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorExecArray{ret}
}

func (instance OfferExec) Exec(ctx context.Context) (*Offer, error) {
	var v Offer
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OfferExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OfferExecArray struct {
	exec *prisma.Exec
}

func (instance OfferExecArray) Exec(ctx context.Context) ([]Offer, error) {
	var v []Offer
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OfferFields = []string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"}

type Offer struct {
	ID        string `json:"id"`
	Qty       int32  `json:"qty"`
	FromDate  string `json:"fromDate"`
	ToDate    string `json:"toDate"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type OfferorExec struct {
	exec *prisma.Exec
}

func (instance *OfferorExec) Offer() *OfferExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Offer"},
		"offer",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferExec{ret}
}

func (instance *OfferorExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance OfferorExec) Exec(ctx context.Context) (*Offeror, error) {
	var v Offeror
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OfferorExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OfferorExecArray struct {
	exec *prisma.Exec
}

func (instance OfferorExecArray) Exec(ctx context.Context) ([]Offeror, error) {
	var v []Offeror
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OfferorFields = []string{"id", "price", "createdAt", "updatedAt"}

type Offeror struct {
	ID        string `json:"id"`
	Price     int32  `json:"price"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type OrderHistoryExec struct {
	exec *prisma.Exec
}

func (instance *OrderHistoryExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *OrderHistoryExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance *OrderHistoryExec) MotherHistory() *MotherHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MotherHistory"},
		"motherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (instance *OrderHistoryExec) OrderUserDealsHistories(params *OrderUserDealsHistoriesParamsExec) *OrderUserDealsHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"OrderUserDealsHistoryWhereInput", "OrderUserDealsHistoryOrderByInput", "OrderUserDealsHistory"},
		"orderUserDealsHistories",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExecArray{ret}
}

func (instance OrderHistoryExec) Exec(ctx context.Context) (*OrderHistory, error) {
	var v OrderHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance OrderHistoryExecArray) Exec(ctx context.Context) ([]OrderHistory, error) {
	var v []OrderHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderHistoryFields = []string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"}

type OrderHistory struct {
	ID          string   `json:"id"`
	Type        int32    `json:"type"`
	OrderNum    int32    `json:"orderNum"`
	OrderPrice  float64  `json:"orderPrice"`
	DealPrice   float64  `json:"dealPrice"`
	OrderQty    float64  `json:"orderQty"`
	DealQty     float64  `json:"dealQty"`
	LeftQty     float64  `json:"leftQty"`
	DealFee     float64  `json:"dealFee"`
	TakerFee    *float64 `json:"takerFee,omitempty"`
	MakerFee    *float64 `json:"makerFee,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
	Description *string  `json:"description,omitempty"`
	Offset      *int32   `json:"offset,omitempty"`
	IsCancel    *bool    `json:"isCancel,omitempty"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
}

type MotherHistoryExec struct {
	exec *prisma.Exec
}

func (instance *MotherHistoryExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance *MotherHistoryExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *MotherHistoryExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *MotherHistoryExec) OrderUserDealsHistory() *OrderUserDealsHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderUserDealsHistory"},
		"orderUserDealsHistory",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExec{ret}
}

func (instance *MotherHistoryExec) OrderHistory() *OrderHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderHistory"},
		"orderHistory",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExec{ret}
}

func (instance *MotherHistoryExec) CashHistory() *CashHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CashHistory"},
		"cashHistory",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExec{ret}
}

func (instance *MotherHistoryExec) AergoAccountHistory() *AergoAccountHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AergoAccountHistory"},
		"aergoAccountHistory",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExec{ret}
}

func (instance *MotherHistoryExec) QuestExpenditureHistory() *QuestExpenditureHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "QuestExpenditureHistory"},
		"questExpenditureHistory",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExec{ret}
}

func (instance *MotherHistoryExec) AirDropHistory() *AirDropHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDropHistory"},
		"airDropHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExec{ret}
}

func (instance *MotherHistoryExec) PostRewardHistory() *PostRewardHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PostRewardHistory"},
		"postRewardHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExec{ret}
}

func (instance MotherHistoryExec) Exec(ctx context.Context) (*MotherHistory, error) {
	var v MotherHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MotherHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MotherHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance MotherHistoryExecArray) Exec(ctx context.Context) ([]MotherHistory, error) {
	var v []MotherHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MotherHistoryFields = []string{"id", "type", "roleTime", "createdAt", "updatedAt"}

type MotherHistory struct {
	ID        string `json:"id"`
	Type      int32  `json:"type"`
	RoleTime  string `json:"roleTime"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type OrderUserDealsHistoryExec struct {
	exec *prisma.Exec
}

func (instance *OrderUserDealsHistoryExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance *OrderUserDealsHistoryExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *OrderUserDealsHistoryExec) MotherHistory() *MotherHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MotherHistory"},
		"motherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (instance *OrderUserDealsHistoryExec) OrderHistory() *OrderHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderHistory"},
		"orderHistory",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExec{ret}
}

func (instance OrderUserDealsHistoryExec) Exec(ctx context.Context) (*OrderUserDealsHistory, error) {
	var v OrderUserDealsHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderUserDealsHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderUserDealsHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance OrderUserDealsHistoryExecArray) Exec(ctx context.Context) ([]OrderUserDealsHistory, error) {
	var v []OrderUserDealsHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderUserDealsHistoryFields = []string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"}

type OrderUserDealsHistory struct {
	ID          string   `json:"id"`
	Type        int32    `json:"type"`
	Role        *int32   `json:"role,omitempty"`
	DealId      int32    `json:"dealId"`
	UniqueKey   string   `json:"uniqueKey"`
	UniqueId    int32    `json:"uniqueId"`
	DealPrice   float64  `json:"dealPrice"`
	DealQty     float64  `json:"dealQty"`
	Fee         float64  `json:"fee"`
	DealOrderId *int32   `json:"dealOrderId,omitempty"`
	Time        *float64 `json:"time,omitempty"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
}

type CashHistoryExec struct {
	exec *prisma.Exec
}

func (instance *CashHistoryExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *CashHistoryExec) MotherHistory() *MotherHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MotherHistory"},
		"motherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (instance *CashHistoryExec) Qeh() *QuestExpenditureHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "QuestExpenditureHistory"},
		"qeh",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExec{ret}
}

func (instance *CashHistoryExec) AergoAccountHistory() *AergoAccountHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AergoAccountHistory"},
		"aergoAccountHistory",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExec{ret}
}

func (instance CashHistoryExec) Exec(ctx context.Context) (*CashHistory, error) {
	var v CashHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CashHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CashHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance CashHistoryExecArray) Exec(ctx context.Context) ([]CashHistory, error) {
	var v []CashHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CashHistoryFields = []string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"}

type CashHistory struct {
	ID          string   `json:"id"`
	Type        int32    `json:"type"`
	Property    *int32   `json:"property,omitempty"`
	OrderNum    *int32   `json:"orderNum,omitempty"`
	Description *string  `json:"description,omitempty"`
	Price       *int32   `json:"price,omitempty"`
	OPrice      *float64 `json:"oPrice,omitempty"`
	OPriceBack  *float64 `json:"oPriceBack,omitempty"`
	Qty         *float64 `json:"qty,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
}

type QuestExpenditureHistoryExec struct {
	exec *prisma.Exec
}

func (instance *QuestExpenditureHistoryExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *QuestExpenditureHistoryExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *QuestExpenditureHistoryExec) MotherHistory() *MotherHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MotherHistory"},
		"motherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (instance *QuestExpenditureHistoryExec) CashHistory() *CashHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CashHistory"},
		"cashHistory",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExec{ret}
}

func (instance QuestExpenditureHistoryExec) Exec(ctx context.Context) (*QuestExpenditureHistory, error) {
	var v QuestExpenditureHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance QuestExpenditureHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type QuestExpenditureHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance QuestExpenditureHistoryExecArray) Exec(ctx context.Context) ([]QuestExpenditureHistory, error) {
	var v []QuestExpenditureHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var QuestExpenditureHistoryFields = []string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"}

type QuestExpenditureHistory struct {
	ID           string   `json:"id"`
	Type         int32    `json:"type"`
	PayType      int32    `json:"payType"`
	OrderNum     *int32   `json:"orderNum,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Price        *int32   `json:"price,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	OPrice       *int32   `json:"oPrice,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
}

type AergoAccountHistoryExec struct {
	exec *prisma.Exec
}

func (instance *AergoAccountHistoryExec) MotherHistory() *MotherHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MotherHistory"},
		"motherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (instance *AergoAccountHistoryExec) AergoAccount() *AergoAccountExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AergoAccount"},
		"aergoAccount",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountExec{ret}
}

func (instance *AergoAccountHistoryExec) CashHistory() *CashHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CashHistory"},
		"cashHistory",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExec{ret}
}

func (instance AergoAccountHistoryExec) Exec(ctx context.Context) (*AergoAccountHistory, error) {
	var v AergoAccountHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AergoAccountHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AergoAccountHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance AergoAccountHistoryExecArray) Exec(ctx context.Context) ([]AergoAccountHistory, error) {
	var v []AergoAccountHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AergoAccountHistoryFields = []string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"}

type AergoAccountHistory struct {
	ID          string   `json:"id"`
	Type        int32    `json:"type"`
	AergoAmount *string  `json:"aergoAmount,omitempty"`
	AmountFee   *float64 `json:"amount_fee,omitempty"`
	Amount      *float64 `json:"amount,omitempty"`
	MarketPrice *string  `json:"marketPrice,omitempty"`
	TxHash      *string  `json:"txHash,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
	Description *string  `json:"description,omitempty"`
	BlockNo     *int32   `json:"blockNo,omitempty"`
	Status      int32    `json:"status"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
}

type AergoAccountExec struct {
	exec *prisma.Exec
}

func (instance *AergoAccountExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

type HistoriesParamsExec struct {
	Where   *AergoAccountHistoryWhereInput
	OrderBy *AergoAccountHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *AergoAccountExec) Histories(params *HistoriesParamsExec) *AergoAccountHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AergoAccountHistoryWhereInput", "AergoAccountHistoryOrderByInput", "AergoAccountHistory"},
		"histories",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExecArray{ret}
}

func (instance AergoAccountExec) Exec(ctx context.Context) (*AergoAccount, error) {
	var v AergoAccount
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AergoAccountExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AergoAccountExecArray struct {
	exec *prisma.Exec
}

func (instance AergoAccountExecArray) Exec(ctx context.Context) ([]AergoAccount, error) {
	var v []AergoAccount
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AergoAccountFields = []string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"}

type AergoAccount struct {
	ID              string  `json:"id"`
	ContractAddress string  `json:"contractAddress"`
	Amount          float64 `json:"amount"`
	LatestBlock     int32   `json:"latestBlock"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
}

type AirDropHistoryExec struct {
	exec *prisma.Exec
}

func (instance *AirDropHistoryExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *AirDropHistoryExec) MotherHistory() *MotherHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MotherHistory"},
		"motherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (instance *AirDropHistoryExec) AirDrop() *AirDropExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDrop"},
		"airDrop",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExec{ret}
}

func (instance *AirDropHistoryExec) AirDropMember() *AirDropMemberExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDropMember"},
		"airDropMember",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExec{ret}
}

func (instance AirDropHistoryExec) Exec(ctx context.Context) (*AirDropHistory, error) {
	var v AirDropHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropHistoryExecArray) Exec(ctx context.Context) ([]AirDropHistory, error) {
	var v []AirDropHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropHistoryFields = []string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"}

type AirDropHistory struct {
	ID           string   `json:"id"`
	Type         int32    `json:"type"`
	Description  *string  `json:"description,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
}

type AirDropExec struct {
	exec *prisma.Exec
}

func (instance *AirDropExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *AirDropExec) Members(params *MembersParamsExec) *AirDropMemberExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AirDropMemberWhereInput", "AirDropMemberOrderByInput", "AirDropMember"},
		"members",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExecArray{ret}
}

func (instance *AirDropExec) AirDropHistories(params *AirDropHistoriesParamsExec) *AirDropHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AirDropHistoryWhereInput", "AirDropHistoryOrderByInput", "AirDropHistory"},
		"airDropHistories",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExecArray{ret}
}

func (instance AirDropExec) Exec(ctx context.Context) (*AirDrop, error) {
	var v AirDrop
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropExecArray) Exec(ctx context.Context) ([]AirDrop, error) {
	var v []AirDrop
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropFields = []string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"}

type AirDrop struct {
	ID                string  `json:"id"`
	Status            *int32  `json:"status,omitempty"`
	DeployTxhash      *string `json:"deployTxhash,omitempty"`
	ContractAddress   *string `json:"contractAddress,omitempty"`
	RandomArrayString *string `json:"randomArrayString,omitempty"`
	Amount            float64 `json:"amount"`
	Left              float64 `json:"left"`
	ToDate            *string `json:"toDate,omitempty"`
	CreatedAt         string  `json:"createdAt"`
	UpdatedAt         string  `json:"updatedAt"`
	IsDel             bool    `json:"isDel"`
}

type AirDropMemberExec struct {
	exec *prisma.Exec
}

func (instance *AirDropMemberExec) AirDrop() *AirDropExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDrop"},
		"airDrop",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExec{ret}
}

func (instance *AirDropMemberExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *AirDropMemberExec) AirDropHistory() *AirDropHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDropHistory"},
		"airDropHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExec{ret}
}

func (instance AirDropMemberExec) Exec(ctx context.Context) (*AirDropMember, error) {
	var v AirDropMember
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropMemberExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropMemberExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropMemberExecArray) Exec(ctx context.Context) ([]AirDropMember, error) {
	var v []AirDropMember
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropMemberFields = []string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"}

type AirDropMember struct {
	ID        string  `json:"id"`
	DropNum   int32   `json:"dropNum"`
	Qty       float64 `json:"qty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	IsDel     bool    `json:"isDel"`
}

type PostRewardHistoryExec struct {
	exec *prisma.Exec
}

func (instance *PostRewardHistoryExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *PostRewardHistoryExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *PostRewardHistoryExec) MotherHistory() *MotherHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MotherHistory"},
		"motherHistory",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (instance *PostRewardHistoryExec) Comment() *CommentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Comment"},
		"comment",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExec{ret}
}

func (instance PostRewardHistoryExec) Exec(ctx context.Context) (*PostRewardHistory, error) {
	var v PostRewardHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostRewardHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostRewardHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance PostRewardHistoryExecArray) Exec(ctx context.Context) ([]PostRewardHistory, error) {
	var v []PostRewardHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostRewardHistoryFields = []string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"}

type PostRewardHistory struct {
	ID           string   `json:"id"`
	Type         int32    `json:"type"`
	Description  *string  `json:"description,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
}

type CommentExec struct {
	exec *prisma.Exec
}

func (instance *CommentExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *CommentExec) Image() *FileInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileInfo"},
		"image",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExec{ret}
}

type ReplyParamsExec struct {
	Where   *CommentReplyWhereInput
	OrderBy *CommentReplyOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *CommentExec) Reply(params *ReplyParamsExec) *CommentReplyExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"CommentReplyWhereInput", "CommentReplyOrderByInput", "CommentReply"},
		"reply",
		[]string{"id", "content", "createdAt", "updatedAt", "isDel"})

	return &CommentReplyExecArray{ret}
}

func (instance *CommentExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *CommentExec) PostRewardHistory() *PostRewardHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PostRewardHistory"},
		"postRewardHistory",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExec{ret}
}

func (instance CommentExec) Exec(ctx context.Context) (*Comment, error) {
	var v Comment
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentExecArray struct {
	exec *prisma.Exec
}

func (instance CommentExecArray) Exec(ctx context.Context) ([]Comment, error) {
	var v []Comment
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentFields = []string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"}

type Comment struct {
	ID        string  `json:"id"`
	Type      *int32  `json:"type,omitempty"`
	Content   string  `json:"content"`
	Url       *string `json:"url,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	IsDel     bool    `json:"isDel"`
}

type CommentReplyExec struct {
	exec *prisma.Exec
}

func (instance *CommentReplyExec) Comment() *CommentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Comment"},
		"comment",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExec{ret}
}

func (instance *CommentReplyExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance CommentReplyExec) Exec(ctx context.Context) (*CommentReply, error) {
	var v CommentReply
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentReplyExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentReplyExecArray struct {
	exec *prisma.Exec
}

func (instance CommentReplyExecArray) Exec(ctx context.Context) ([]CommentReply, error) {
	var v []CommentReply
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentReplyFields = []string{"id", "content", "createdAt", "updatedAt", "isDel"}

type CommentReply struct {
	ID        string `json:"id"`
	Content   string `json:"content"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	IsDel     bool   `json:"isDel"`
}

type OrderDealsHistoryExec struct {
	exec *prisma.Exec
}

func (instance *OrderDealsHistoryExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance OrderDealsHistoryExec) Exec(ctx context.Context) (*OrderDealsHistory, error) {
	var v OrderDealsHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderDealsHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderDealsHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance OrderDealsHistoryExecArray) Exec(ctx context.Context) ([]OrderDealsHistory, error) {
	var v []OrderDealsHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderDealsHistoryFields = []string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"}

type OrderDealsHistory struct {
	ID        string   `json:"id"`
	Type      int32    `json:"type"`
	DealId    int32    `json:"dealId"`
	DealPrice float64  `json:"dealPrice"`
	DealQty   float64  `json:"dealQty"`
	Time      *float64 `json:"time,omitempty"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
}

type CoinPriceTableExec struct {
	exec *prisma.Exec
}

func (instance *CoinPriceTableExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance CoinPriceTableExec) Exec(ctx context.Context) (*CoinPriceTable, error) {
	var v CoinPriceTable
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinPriceTableExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinPriceTableExecArray struct {
	exec *prisma.Exec
}

func (instance CoinPriceTableExecArray) Exec(ctx context.Context) ([]CoinPriceTable, error) {
	var v []CoinPriceTable
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinPriceTableFields = []string{"id", "type", "infoValue", "createdAt", "updatedAt"}

type CoinPriceTable struct {
	ID        string    `json:"id"`
	Type      int32     `json:"type"`
	InfoValue []float64 `json:"infoValue,omitempty"`
	CreatedAt string    `json:"createdAt"`
	UpdatedAt string    `json:"updatedAt"`
}

type CoinKlineExec struct {
	exec *prisma.Exec
}

func (instance *CoinKlineExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance CoinKlineExec) Exec(ctx context.Context) (*CoinKline, error) {
	var v CoinKline
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinKlineExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinKlineExecArray struct {
	exec *prisma.Exec
}

func (instance CoinKlineExecArray) Exec(ctx context.Context) ([]CoinKline, error) {
	var v []CoinKline
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinKlineFields = []string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"}

type CoinKline struct {
	ID        string  `json:"id"`
	Open      float64 `json:"open"`
	Close     float64 `json:"close"`
	High      float64 `json:"high"`
	Low       float64 `json:"low"`
	Volume    float64 `json:"volume"`
	Deal      float64 `json:"deal"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type QuestMemberExec struct {
	exec *prisma.Exec
}

func (instance *QuestMemberExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *QuestMemberExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance QuestMemberExec) Exec(ctx context.Context) (*QuestMember, error) {
	var v QuestMember
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance QuestMemberExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type QuestMemberExecArray struct {
	exec *prisma.Exec
}

func (instance QuestMemberExecArray) Exec(ctx context.Context) ([]QuestMember, error) {
	var v []QuestMember
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var QuestMemberFields = []string{"id", "note", "createdAt", "isDel"}

type QuestMember struct {
	ID        string  `json:"id"`
	Note      *string `json:"note,omitempty"`
	CreatedAt string  `json:"createdAt"`
	IsDel     bool    `json:"isDel"`
}

type UpdatePostHistoryExec struct {
	exec *prisma.Exec
}

func (instance *UpdatePostHistoryExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *UpdatePostHistoryExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *UpdatePostHistoryExec) Admin() *AdminUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUser"},
		"admin",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (instance UpdatePostHistoryExec) Exec(ctx context.Context) (*UpdatePostHistory, error) {
	var v UpdatePostHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UpdatePostHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UpdatePostHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance UpdatePostHistoryExecArray) Exec(ctx context.Context) ([]UpdatePostHistory, error) {
	var v []UpdatePostHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UpdatePostHistoryFields = []string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"}

type UpdatePostHistory struct {
	ID             string  `json:"id"`
	Action         int32   `json:"action"`
	BeforeContent  *string `json:"beforeContent,omitempty"`
	BeforeImageUrl *string `json:"beforeImageUrl,omitempty"`
	CreatedAt      string  `json:"createdAt"`
}

type VerificationExec struct {
	exec *prisma.Exec
}

func (instance *VerificationExec) Phone() *PhoneVerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneVerification"},
		"phone",
		[]string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"})

	return &PhoneVerificationExec{ret}
}

func (instance *VerificationExec) BankAccount() *BankAccountVerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BankAccountVerification"},
		"bankAccount",
		[]string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationExec{ret}
}

func (instance *VerificationExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance VerificationExec) Exec(ctx context.Context) (*Verification, error) {
	var v Verification
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VerificationExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VerificationExecArray struct {
	exec *prisma.Exec
}

func (instance VerificationExecArray) Exec(ctx context.Context) ([]Verification, error) {
	var v []Verification
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var VerificationFields = []string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"}

type Verification struct {
	ID             string  `json:"id"`
	Level          *int32  `json:"level,omitempty"`
	HasEmail       *bool   `json:"hasEmail,omitempty"`
	HasPin         *bool   `json:"hasPin,omitempty"`
	HasPhone       *bool   `json:"hasPhone,omitempty"`
	HasBankAccount *bool   `json:"hasBankAccount,omitempty"`
	HasInter       *bool   `json:"hasInter,omitempty"`
	PinNumber      *string `json:"pinNumber,omitempty"`
	CreatedAt      string  `json:"createdAt"`
	UpdatedAt      string  `json:"updatedAt"`
}

type PhoneVerificationExec struct {
	exec *prisma.Exec
}

func (instance *PhoneVerificationExec) Verification() *VerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Verification"},
		"verification",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExec{ret}
}

func (instance PhoneVerificationExec) Exec(ctx context.Context) (*PhoneVerification, error) {
	var v PhoneVerification
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneVerificationExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneVerificationExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneVerificationExecArray) Exec(ctx context.Context) ([]PhoneVerification, error) {
	var v []PhoneVerification
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PhoneVerificationFields = []string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"}

type PhoneVerification struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Birth       string  `json:"birth"`
	Foreigner   *bool   `json:"foreigner,omitempty"`
	Gender      string  `json:"gender"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	Ci          string  `json:"CI"`
	Di          string  `json:"DI"`
	ImpUid      *string `json:"imp_uid,omitempty"`
	MerchantUid *string `json:"merchant_uid,omitempty"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
}

type BankAccountVerificationExec struct {
	exec *prisma.Exec
}

func (instance *BankAccountVerificationExec) Verification() *VerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Verification"},
		"verification",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExec{ret}
}

func (instance *BankAccountVerificationExec) Bank() *BankExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Bank"},
		"bank",
		[]string{"id", "code", "name", "createdAt", "updatedAt"})

	return &BankExec{ret}
}

func (instance *BankAccountVerificationExec) TransactionInfo() *BankAccountVerificationTransactionInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BankAccountVerificationTransactionInfo"},
		"transactionInfo",
		[]string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationTransactionInfoExec{ret}
}

func (instance BankAccountVerificationExec) Exec(ctx context.Context) (*BankAccountVerification, error) {
	var v BankAccountVerification
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankAccountVerificationExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankAccountVerificationExecArray struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationExecArray) Exec(ctx context.Context) ([]BankAccountVerification, error) {
	var v []BankAccountVerification
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankAccountVerificationFields = []string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"}

type BankAccountVerification struct {
	ID            string  `json:"id"`
	HolderName    string  `json:"holderName"`
	AccountNumber string  `json:"accountNumber"`
	VerifyAt      *string `json:"verifyAt,omitempty"`
	CreatedAt     string  `json:"createdAt"`
	UpdatedAt     string  `json:"updatedAt"`
}

type BankExec struct {
	exec *prisma.Exec
}

func (instance BankExec) Exec(ctx context.Context) (*Bank, error) {
	var v Bank
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankExecArray struct {
	exec *prisma.Exec
}

func (instance BankExecArray) Exec(ctx context.Context) ([]Bank, error) {
	var v []Bank
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankFields = []string{"id", "code", "name", "createdAt", "updatedAt"}

type Bank struct {
	ID        string `json:"id"`
	Code      string `json:"code"`
	Name      string `json:"name"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type BankAccountVerificationTransactionInfoExec struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationTransactionInfoExec) Exec(ctx context.Context) (*BankAccountVerificationTransactionInfo, error) {
	var v BankAccountVerificationTransactionInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankAccountVerificationTransactionInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankAccountVerificationTransactionInfoExecArray struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationTransactionInfoExecArray) Exec(ctx context.Context) ([]BankAccountVerificationTransactionInfo, error) {
	var v []BankAccountVerificationTransactionInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankAccountVerificationTransactionInfoFields = []string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"}

type BankAccountVerificationTransactionInfo struct {
	ID            string `json:"id"`
	TransactionDt string `json:"transactionDt"`
	TransactionNo string `json:"transactionNo"`
	ExpireAt      string `json:"expireAt"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
}

type ReportExec struct {
	exec *prisma.Exec
}

func (instance *ReportExec) ReportUser() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"reportUser",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *ReportExec) TargetPost() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"targetPost",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *ReportExec) TargetUser() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"targetUser",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance ReportExec) Exec(ctx context.Context) (*Report, error) {
	var v Report
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReportExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReportExecArray struct {
	exec *prisma.Exec
}

func (instance ReportExecArray) Exec(ctx context.Context) ([]Report, error) {
	var v []Report
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReportFields = []string{"id", "type", "reportType", "createdAt"}

type Report struct {
	ID         string `json:"id"`
	Type       int32  `json:"type"`
	ReportType int32  `json:"reportType"`
	CreatedAt  string `json:"createdAt"`
}

type RewardDropAttendingUserExec struct {
	exec *prisma.Exec
}

func (instance *RewardDropAttendingUserExec) RewardDropEvent() *RewardDropEventExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RewardDropEvent"},
		"rewardDropEvent",
		[]string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"})

	return &RewardDropEventExec{ret}
}

func (instance *RewardDropAttendingUserExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance RewardDropAttendingUserExec) Exec(ctx context.Context) (*RewardDropAttendingUser, error) {
	var v RewardDropAttendingUser
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RewardDropAttendingUserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RewardDropAttendingUserExecArray struct {
	exec *prisma.Exec
}

func (instance RewardDropAttendingUserExecArray) Exec(ctx context.Context) ([]RewardDropAttendingUser, error) {
	var v []RewardDropAttendingUser
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RewardDropAttendingUserFields = []string{"id", "memo", "isDel", "createdAt"}

type RewardDropAttendingUser struct {
	ID        string `json:"id"`
	Memo      string `json:"memo"`
	IsDel     bool   `json:"isDel"`
	CreatedAt string `json:"createdAt"`
}

type RewardDropEventExec struct {
	exec *prisma.Exec
}

func (instance *RewardDropEventExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

type AttendingUsersParamsExec struct {
	Where   *RewardDropAttendingUserWhereInput
	OrderBy *RewardDropAttendingUserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *RewardDropEventExec) AttendingUsers(params *AttendingUsersParamsExec) *RewardDropAttendingUserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"RewardDropAttendingUserWhereInput", "RewardDropAttendingUserOrderByInput", "RewardDropAttendingUser"},
		"attendingUsers",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserExecArray{ret}
}

func (instance RewardDropEventExec) Exec(ctx context.Context) (*RewardDropEvent, error) {
	var v RewardDropEvent
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RewardDropEventExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RewardDropEventExecArray struct {
	exec *prisma.Exec
}

func (instance RewardDropEventExecArray) Exec(ctx context.Context) ([]RewardDropEvent, error) {
	var v []RewardDropEvent
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RewardDropEventFields = []string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"}

type RewardDropEvent struct {
	ID             string `json:"id"`
	EventId        string `json:"eventID"`
	Type           int32  `json:"type"`
	Title          string `json:"title"`
	Cash           *int32 `json:"cash,omitempty"`
	Qty            *int32 `json:"qty,omitempty"`
	LimitUserCount int32  `json:"limitUserCount"`
	FromDate       string `json:"fromDate"`
	ToDate         string `json:"toDate"`
	IsDel          bool   `json:"isDel"`
	CreatedAt      string `json:"createdAt"`
}

type FeeExec struct {
	exec *prisma.Exec
}

type RankRelationParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *FeeExec) RankRelation(params *RankRelationParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"rankRelation",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExecArray{ret}
}

type EventRelationParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *FeeExec) EventRelation(params *EventRelationParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"eventRelation",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExecArray{ret}
}

func (instance FeeExec) Exec(ctx context.Context) (*Fee, error) {
	var v Fee
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeeExecArray struct {
	exec *prisma.Exec
}

func (instance FeeExecArray) Exec(ctx context.Context) ([]Fee, error) {
	var v []Fee
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FeeFields = []string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"}

type Fee struct {
	ID                string   `json:"id"`
	Type              int32    `json:"type"`
	Key               int32    `json:"key"`
	Memo              *string  `json:"memo,omitempty"`
	Rank              *int32   `json:"rank,omitempty"`
	AskTakerFee       *float64 `json:"askTakerFee,omitempty"`
	AskMakerFee       *float64 `json:"askMakerFee,omitempty"`
	BidTakerFee       *float64 `json:"bidTakerFee,omitempty"`
	BidMakerFee       *float64 `json:"bidMakerFee,omitempty"`
	MyCoinAskTakerFee *float64 `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskMakerFee *float64 `json:"myCoinAskMakerFee,omitempty"`
	MyCoinBidTakerFee *float64 `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidMakerFee *float64 `json:"myCoinBidMakerFee,omitempty"`
	CreatedAt         string   `json:"createdAt"`
	UpdatedAt         string   `json:"updatedAt"`
}

type InviteCodeExec struct {
	exec *prisma.Exec
}

func (instance *InviteCodeExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

type InviteUsersParamsExec struct {
	Where   *InviteUserHistoryWhereInput
	OrderBy *InviteUserHistoryOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *InviteCodeExec) InviteUsers(params *InviteUsersParamsExec) *InviteUserHistoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"InviteUserHistoryWhereInput", "InviteUserHistoryOrderByInput", "InviteUserHistory"},
		"inviteUsers",
		[]string{"id", "createdAt", "updatedAt"})

	return &InviteUserHistoryExecArray{ret}
}

func (instance InviteCodeExec) Exec(ctx context.Context) (*InviteCode, error) {
	var v InviteCode
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InviteCodeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InviteCodeExecArray struct {
	exec *prisma.Exec
}

func (instance InviteCodeExecArray) Exec(ctx context.Context) ([]InviteCode, error) {
	var v []InviteCode
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InviteCodeFields = []string{"id", "numId", "code", "createdAt", "updatedAt"}

type InviteCode struct {
	ID        string `json:"id"`
	NumId     int32  `json:"numId"`
	Code      string `json:"code"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type InviteUserHistoryExec struct {
	exec *prisma.Exec
}

func (instance *InviteUserHistoryExec) InviteCode() *InviteCodeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InviteCode"},
		"inviteCode",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodeExec{ret}
}

func (instance *InviteUserHistoryExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance InviteUserHistoryExec) Exec(ctx context.Context) (*InviteUserHistory, error) {
	var v InviteUserHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InviteUserHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InviteUserHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance InviteUserHistoryExecArray) Exec(ctx context.Context) ([]InviteUserHistory, error) {
	var v []InviteUserHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InviteUserHistoryFields = []string{"id", "createdAt", "updatedAt"}

type InviteUserHistory struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type PageExec struct {
	exec *prisma.Exec
}

type BadgesParamsExec struct {
	Where   *PageBadgeWhereInput
	OrderBy *PageBadgeOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PageExec) Badges(params *BadgesParamsExec) *PageBadgeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PageBadgeWhereInput", "PageBadgeOrderByInput", "PageBadge"},
		"badges",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExecArray{ret}
}

func (instance *PageExec) Youtube() *YoutubeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Youtube"},
		"youtube",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubeExec{ret}
}

func (instance *PageExec) Twitch() *TwitchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Twitch"},
		"twitch",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchExec{ret}
}

func (instance *PageExec) Instagram() *InstagramExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Instagram"},
		"instagram",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramExec{ret}
}

func (instance *PageExec) AfreecaTv() *AfreecaTvExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AfreecaTV"},
		"afreecaTV",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvExec{ret}
}

type FansParamsExec struct {
	Where   *PageFanWhereInput
	OrderBy *PageFanOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PageExec) Fans(params *FansParamsExec) *PageFanExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PageFanWhereInput", "PageFanOrderByInput", "PageFan"},
		"fans",
		[]string{"id", "createdAt", "updatedAt"})

	return &PageFanExecArray{ret}
}

func (instance *PageExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *PageExec) Comments(params *CommentsParamsExec) *PageCommentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PageCommentWhereInput", "PageCommentOrderByInput", "PageComment"},
		"comments",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExecArray{ret}
}

type RequestPageItemsParamsExec struct {
	Where   *RequestPageItemWhereInput
	OrderBy *RequestPageItemOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PageExec) RequestPageItems(params *RequestPageItemsParamsExec) *RequestPageItemExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"RequestPageItemWhereInput", "RequestPageItemOrderByInput", "RequestPageItem"},
		"requestPageItems",
		[]string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"})

	return &RequestPageItemExecArray{ret}
}

type ReviewsParamsExec struct {
	Where   *ReviewContentPageWhereInput
	OrderBy *ReviewContentPageOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PageExec) Reviews(params *ReviewsParamsExec) *ReviewContentPageExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewContentPageWhereInput", "ReviewContentPageOrderByInput", "ReviewContentPage"},
		"reviews",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExecArray{ret}
}

type RelatedReviewsParamsExec struct {
	Where   *ReviewContentWhereInput
	OrderBy *ReviewContentOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PageExec) RelatedReviews(params *RelatedReviewsParamsExec) *ReviewContentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewContentWhereInput", "ReviewContentOrderByInput", "ReviewContent"},
		"relatedReviews",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExecArray{ret}
}

func (instance PageExec) Exec(ctx context.Context) (*Page, error) {
	var v Page
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageExecArray struct {
	exec *prisma.Exec
}

func (instance PageExecArray) Exec(ctx context.Context) ([]Page, error) {
	var v []Page
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageFields = []string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"}

type Page struct {
	ID          string  `json:"id"`
	PageId      string  `json:"pageId"`
	NickName    *string `json:"nickName,omitempty"`
	AvatarUrl   *string `json:"avatarUrl,omitempty"`
	CoverUrl    *string `json:"coverUrl,omitempty"`
	Description *string `json:"description,omitempty"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
}

type PageBadgeExec struct {
	exec *prisma.Exec
}

func (instance *PageBadgeExec) Badge() *BadgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Badge"},
		"badge",
		[]string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"})

	return &BadgeExec{ret}
}

type VoterParamsExec struct {
	Where   *BadgeVoterWhereInput
	OrderBy *BadgeVoterOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *PageBadgeExec) Voter(params *VoterParamsExec) *BadgeVoterExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"BadgeVoterWhereInput", "BadgeVoterOrderByInput", "BadgeVoter"},
		"voter",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &BadgeVoterExecArray{ret}
}

func (instance *PageBadgeExec) Page() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"page",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance PageBadgeExec) Exec(ctx context.Context) (*PageBadge, error) {
	var v PageBadge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageBadgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageBadgeExecArray struct {
	exec *prisma.Exec
}

func (instance PageBadgeExecArray) Exec(ctx context.Context) ([]PageBadge, error) {
	var v []PageBadge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageBadgeFields = []string{"id", "vote", "createdAt", "updatedAt"}

type PageBadge struct {
	ID        string `json:"id"`
	Vote      int32  `json:"vote"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type BadgeExec struct {
	exec *prisma.Exec
}

type PagesParamsExec struct {
	Where   *PageBadgeWhereInput
	OrderBy *PageBadgeOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *BadgeExec) Pages(params *PagesParamsExec) *PageBadgeExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PageBadgeWhereInput", "PageBadgeOrderByInput", "PageBadge"},
		"pages",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExecArray{ret}
}

func (instance BadgeExec) Exec(ctx context.Context) (*Badge, error) {
	var v Badge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BadgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BadgeExecArray struct {
	exec *prisma.Exec
}

func (instance BadgeExecArray) Exec(ctx context.Context) ([]Badge, error) {
	var v []Badge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BadgeFields = []string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"}

type Badge struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	ImageUrl    *string `json:"imageUrl,omitempty"`
	Description string  `json:"description"`
	OrderIndex  int32   `json:"orderIndex"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
}

type BadgeVoterExec struct {
	exec *prisma.Exec
}

func (instance *BadgeVoterExec) PageBadge() *PageBadgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageBadge"},
		"pageBadge",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExec{ret}
}

func (instance *BadgeVoterExec) ReviewContent() *ReviewContentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContent"},
		"reviewContent",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExec{ret}
}

func (instance *BadgeVoterExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance BadgeVoterExec) Exec(ctx context.Context) (*BadgeVoter, error) {
	var v BadgeVoter
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BadgeVoterExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BadgeVoterExecArray struct {
	exec *prisma.Exec
}

func (instance BadgeVoterExecArray) Exec(ctx context.Context) ([]BadgeVoter, error) {
	var v []BadgeVoter
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BadgeVoterFields = []string{"id", "ip", "createdAt", "updatedAt"}

type BadgeVoter struct {
	ID        string  `json:"id"`
	Ip        *string `json:"ip,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type ReviewContentExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentExec) ReviewContentPage() *ReviewContentPageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPage"},
		"reviewContentPage",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

type ViewersParamsExec struct {
	Where   *ReviewContentViewerWhereInput
	OrderBy *ReviewContentViewerOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ReviewContentExec) Viewers(params *ViewersParamsExec) *ReviewContentViewerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewContentViewerWhereInput", "ReviewContentViewerOrderByInput", "ReviewContentViewer"},
		"viewers",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentViewerExecArray{ret}
}

type ReviewersParamsExec struct {
	Where   *ReviewContentReviewerWhereInput
	OrderBy *ReviewContentReviewerOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ReviewContentExec) Reviewers(params *ReviewersParamsExec) *ReviewContentReviewerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewContentReviewerWhereInput", "ReviewContentReviewerOrderByInput", "ReviewContentReviewer"},
		"reviewers",
		[]string{"id", "review", "createdAt", "updatedAt"})

	return &ReviewContentReviewerExecArray{ret}
}

func (instance *ReviewContentExec) RelatedPage() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"relatedPage",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance *ReviewContentExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance ReviewContentExec) Exec(ctx context.Context) (*ReviewContent, error) {
	var v ReviewContent
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentExecArray) Exec(ctx context.Context) ([]ReviewContent, error) {
	var v []ReviewContent
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentFields = []string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"}

type ReviewContent struct {
	ID              string  `json:"id"`
	PreviewImageUrl string  `json:"previewImageUrl"`
	Title           *string `json:"title,omitempty"`
	Type            string  `json:"type"`
	Url             string  `json:"url"`
	Review          *string `json:"review,omitempty"`
	VideoId         *string `json:"videoId,omitempty"`
	ContentId       *string `json:"contentId,omitempty"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
}

type ReviewContentPageExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageExec) Page() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"page",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance *ReviewContentPageExec) Categories(params *CategoriesParamsExec) *ReviewContentCategoryExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewContentCategoryWhereInput", "ReviewContentCategoryOrderByInput", "ReviewContentCategory"},
		"categories",
		[]string{"id", "name", "imageUrl", "createdAt", "updatedAt"})

	return &ReviewContentCategoryExecArray{ret}
}

func (instance *ReviewContentPageExec) Viewers(params *ViewersParamsExec) *ReviewContentPageViewerExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewContentPageViewerWhereInput", "ReviewContentPageViewerOrderByInput", "ReviewContentPageViewer"},
		"viewers",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentPageViewerExecArray{ret}
}

func (instance *ReviewContentPageExec) Reviews(params *ReviewsParamsExec) *ReviewContentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewContentWhereInput", "ReviewContentOrderByInput", "ReviewContent"},
		"reviews",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExecArray{ret}
}

func (instance *ReviewContentPageExec) Comments(params *CommentsParamsExec) *PageCommentExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PageCommentWhereInput", "PageCommentOrderByInput", "PageComment"},
		"comments",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExecArray{ret}
}

func (instance *ReviewContentPageExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

type FeedBacksParamsExec struct {
	Where   *ReviewContentPageFeedBackWhereInput
	OrderBy *ReviewContentPageFeedBackOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *ReviewContentPageExec) FeedBacks(params *FeedBacksParamsExec) *ReviewContentPageFeedBackExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ReviewContentPageFeedBackWhereInput", "ReviewContentPageFeedBackOrderByInput", "ReviewContentPageFeedBack"},
		"feedBacks",
		[]string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"})

	return &ReviewContentPageFeedBackExecArray{ret}
}

func (instance ReviewContentPageExec) Exec(ctx context.Context) (*ReviewContentPage, error) {
	var v ReviewContentPage
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageExecArray) Exec(ctx context.Context) ([]ReviewContentPage, error) {
	var v []ReviewContentPage
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageFields = []string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"}

type ReviewContentPage struct {
	ID         string  `json:"id"`
	Title      string  `json:"title"`
	SubTitle   *string `json:"subTitle,omitempty"`
	Message    *string `json:"message,omitempty"`
	ReleasedAt string  `json:"releasedAt"`
	IsDrafts   *bool   `json:"isDrafts,omitempty"`
	IsDel      *bool   `json:"isDel,omitempty"`
	CreatedAt  string  `json:"createdAt"`
	UpdatedAt  string  `json:"updatedAt"`
}

type ReviewContentCategoryExec struct {
	exec *prisma.Exec
}

func (instance ReviewContentCategoryExec) Exec(ctx context.Context) (*ReviewContentCategory, error) {
	var v ReviewContentCategory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentCategoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentCategoryExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentCategoryExecArray) Exec(ctx context.Context) ([]ReviewContentCategory, error) {
	var v []ReviewContentCategory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentCategoryFields = []string{"id", "name", "imageUrl", "createdAt", "updatedAt"}

type ReviewContentCategory struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	ImageUrl  string `json:"imageUrl"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type ReviewContentPageViewerExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageViewerExec) ReviewContentPage() *ReviewContentPageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPage"},
		"reviewContentPage",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

func (instance *ReviewContentPageViewerExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance ReviewContentPageViewerExec) Exec(ctx context.Context) (*ReviewContentPageViewer, error) {
	var v ReviewContentPageViewer
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageViewerExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageViewerExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageViewerExecArray) Exec(ctx context.Context) ([]ReviewContentPageViewer, error) {
	var v []ReviewContentPageViewer
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageViewerFields = []string{"id", "ip", "createdAt", "updatedAt"}

type ReviewContentPageViewer struct {
	ID        string  `json:"id"`
	Ip        *string `json:"ip,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type PageCommentExec struct {
	exec *prisma.Exec
}

func (instance *PageCommentExec) Page() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"page",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance *PageCommentExec) Comments(params *CommentsParamsExec) *PageCommentReplyExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"PageCommentReplyWhereInput", "PageCommentReplyOrderByInput", "PageCommentReply"},
		"comments",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentReplyExecArray{ret}
}

func (instance *PageCommentExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *PageCommentExec) RelatedReviewContentPage() *ReviewContentPageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPage"},
		"relatedReviewContentPage",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

func (instance PageCommentExec) Exec(ctx context.Context) (*PageComment, error) {
	var v PageComment
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageCommentExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageCommentExecArray struct {
	exec *prisma.Exec
}

func (instance PageCommentExecArray) Exec(ctx context.Context) ([]PageComment, error) {
	var v []PageComment
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageCommentFields = []string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"}

type PageComment struct {
	ID                string  `json:"id"`
	Content           string  `json:"content"`
	IpAddress         *string `json:"ipAddress,omitempty"`
	ImageUrl          *string `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string `json:"thumbnailImageUrl,omitempty"`
	CreatedAt         string  `json:"createdAt"`
	UpdatedAt         string  `json:"updatedAt"`
	IsDel             bool    `json:"isDel"`
}

type PageCommentReplyExec struct {
	exec *prisma.Exec
}

func (instance *PageCommentReplyExec) PageComment() *PageCommentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageComment"},
		"pageComment",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExec{ret}
}

func (instance *PageCommentReplyExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance PageCommentReplyExec) Exec(ctx context.Context) (*PageCommentReply, error) {
	var v PageCommentReply
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageCommentReplyExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageCommentReplyExecArray struct {
	exec *prisma.Exec
}

func (instance PageCommentReplyExecArray) Exec(ctx context.Context) ([]PageCommentReply, error) {
	var v []PageCommentReply
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageCommentReplyFields = []string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"}

type PageCommentReply struct {
	ID                string  `json:"id"`
	Content           string  `json:"content"`
	IpAddress         *string `json:"ipAddress,omitempty"`
	ImageUrl          *string `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string `json:"thumbnailImageUrl,omitempty"`
	CreatedAt         string  `json:"createdAt"`
	UpdatedAt         string  `json:"updatedAt"`
	IsDel             bool    `json:"isDel"`
}

type ReviewContentPageFeedBackExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageFeedBackExec) ReviewContentPage() *ReviewContentPageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPage"},
		"reviewContentPage",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

func (instance *ReviewContentPageFeedBackExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance ReviewContentPageFeedBackExec) Exec(ctx context.Context) (*ReviewContentPageFeedBack, error) {
	var v ReviewContentPageFeedBack
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageFeedBackExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageFeedBackExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageFeedBackExecArray) Exec(ctx context.Context) ([]ReviewContentPageFeedBack, error) {
	var v []ReviewContentPageFeedBack
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageFeedBackFields = []string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"}

type ReviewContentPageFeedBack struct {
	ID        string  `json:"id"`
	IsLike    bool    `json:"isLike"`
	Message   *string `json:"message,omitempty"`
	IpAddress *string `json:"ipAddress,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type ReviewContentViewerExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentViewerExec) ReviewContent() *ReviewContentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContent"},
		"reviewContent",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExec{ret}
}

func (instance *ReviewContentViewerExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance ReviewContentViewerExec) Exec(ctx context.Context) (*ReviewContentViewer, error) {
	var v ReviewContentViewer
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentViewerExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentViewerExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentViewerExecArray) Exec(ctx context.Context) ([]ReviewContentViewer, error) {
	var v []ReviewContentViewer
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentViewerFields = []string{"id", "ip", "createdAt", "updatedAt"}

type ReviewContentViewer struct {
	ID        string  `json:"id"`
	Ip        *string `json:"ip,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type ReviewContentReviewerExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentReviewerExec) ReviewContent() *ReviewContentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContent"},
		"reviewContent",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExec{ret}
}

func (instance *ReviewContentReviewerExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance ReviewContentReviewerExec) Exec(ctx context.Context) (*ReviewContentReviewer, error) {
	var v ReviewContentReviewer
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentReviewerExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentReviewerExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentReviewerExecArray) Exec(ctx context.Context) ([]ReviewContentReviewer, error) {
	var v []ReviewContentReviewer
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentReviewerFields = []string{"id", "review", "createdAt", "updatedAt"}

type ReviewContentReviewer struct {
	ID        string `json:"id"`
	Review    string `json:"review"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type YoutubeExec struct {
	exec *prisma.Exec
}

func (instance *YoutubeExec) Page() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"page",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

type StatisticsParamsExec struct {
	Where   *YoutubeDailyStatisticsWhereInput
	OrderBy *YoutubeDailyStatisticsOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *YoutubeExec) Statistics(params *StatisticsParamsExec) *YoutubeDailyStatisticsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"YoutubeDailyStatisticsWhereInput", "YoutubeDailyStatisticsOrderByInput", "YoutubeDailyStatistics"},
		"statistics",
		[]string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"})

	return &YoutubeDailyStatisticsExecArray{ret}
}

func (instance YoutubeExec) Exec(ctx context.Context) (*Youtube, error) {
	var v Youtube
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance YoutubeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type YoutubeExecArray struct {
	exec *prisma.Exec
}

func (instance YoutubeExecArray) Exec(ctx context.Context) ([]Youtube, error) {
	var v []Youtube
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var YoutubeFields = []string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"}

type Youtube struct {
	ID              string  `json:"id"`
	ChannelId       string  `json:"channelId"`
	ChannelType     *string `json:"channelType,omitempty"`
	ChannelName     *string `json:"channelName,omitempty"`
	UserName        *string `json:"userName,omitempty"`
	VideoCount      *string `json:"videoCount,omitempty"`
	SubscriberCount *string `json:"subscriberCount,omitempty"`
	VideoViewCount  *string `json:"videoViewCount,omitempty"`
	ThumbnailUrl    *string `json:"thumbnailUrl,omitempty"`
	BannerUrl       *string `json:"bannerUrl,omitempty"`
	Description     *string `json:"description,omitempty"`
	PublishedAt     *string `json:"publishedAt,omitempty"`
	Country         *string `json:"country,omitempty"`
	PageUrl         *string `json:"pageUrl,omitempty"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
}

type YoutubeDailyStatisticsExec struct {
	exec *prisma.Exec
}

func (instance *YoutubeDailyStatisticsExec) Youtube() *YoutubeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Youtube"},
		"youtube",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubeExec{ret}
}

func (instance YoutubeDailyStatisticsExec) Exec(ctx context.Context) (*YoutubeDailyStatistics, error) {
	var v YoutubeDailyStatistics
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance YoutubeDailyStatisticsExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type YoutubeDailyStatisticsExecArray struct {
	exec *prisma.Exec
}

func (instance YoutubeDailyStatisticsExecArray) Exec(ctx context.Context) ([]YoutubeDailyStatistics, error) {
	var v []YoutubeDailyStatistics
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var YoutubeDailyStatisticsFields = []string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"}

type YoutubeDailyStatistics struct {
	ID              string `json:"id"`
	Date            string `json:"date"`
	VideoCount      string `json:"videoCount"`
	SubscriberCount string `json:"subscriberCount"`
	VideoViewCount  string `json:"videoViewCount"`
	CreatedAt       string `json:"createdAt"`
	UpdatedAt       string `json:"updatedAt"`
}

type TwitchExec struct {
	exec *prisma.Exec
}

func (instance *TwitchExec) Page() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"page",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance *TwitchExec) Statistics(params *StatisticsParamsExec) *TwitchDailyStatisticsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"TwitchDailyStatisticsWhereInput", "TwitchDailyStatisticsOrderByInput", "TwitchDailyStatistics"},
		"statistics",
		[]string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"})

	return &TwitchDailyStatisticsExecArray{ret}
}

func (instance TwitchExec) Exec(ctx context.Context) (*Twitch, error) {
	var v Twitch
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TwitchExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TwitchExecArray struct {
	exec *prisma.Exec
}

func (instance TwitchExecArray) Exec(ctx context.Context) ([]Twitch, error) {
	var v []Twitch
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TwitchFields = []string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"}

type Twitch struct {
	ID               string  `json:"id"`
	UserId           string  `json:"userId"`
	UserNo           string  `json:"userNo"`
	UserName         *string `json:"userName,omitempty"`
	FollowerCount    *string `json:"followerCount,omitempty"`
	FollowingCount   *string `json:"followingCount,omitempty"`
	ChannelType      *string `json:"channelType,omitempty"`
	ChannelViewCount *string `json:"channelViewCount,omitempty"`
	AvatarUrl        *string `json:"avatarUrl,omitempty"`
	CoverUrl         *string `json:"coverUrl,omitempty"`
	Description      *string `json:"description,omitempty"`
	PageUrl          *string `json:"pageUrl,omitempty"`
	CreatedAt        string  `json:"createdAt"`
	UpdatedAt        string  `json:"updatedAt"`
}

type TwitchDailyStatisticsExec struct {
	exec *prisma.Exec
}

func (instance *TwitchDailyStatisticsExec) Twitch() *TwitchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Twitch"},
		"twitch",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchExec{ret}
}

func (instance TwitchDailyStatisticsExec) Exec(ctx context.Context) (*TwitchDailyStatistics, error) {
	var v TwitchDailyStatistics
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TwitchDailyStatisticsExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TwitchDailyStatisticsExecArray struct {
	exec *prisma.Exec
}

func (instance TwitchDailyStatisticsExecArray) Exec(ctx context.Context) ([]TwitchDailyStatistics, error) {
	var v []TwitchDailyStatistics
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TwitchDailyStatisticsFields = []string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"}

type TwitchDailyStatistics struct {
	ID               string `json:"id"`
	Date             string `json:"date"`
	FollowerCount    string `json:"followerCount"`
	FollowingCount   string `json:"followingCount"`
	ChannelViewCount string `json:"channelViewCount"`
	CreatedAt        string `json:"createdAt"`
	UpdatedAt        string `json:"updatedAt"`
}

type InstagramExec struct {
	exec *prisma.Exec
}

func (instance *InstagramExec) Page() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"page",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance *InstagramExec) Statistics(params *StatisticsParamsExec) *InstagramDailyStatisticsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"InstagramDailyStatisticsWhereInput", "InstagramDailyStatisticsOrderByInput", "InstagramDailyStatistics"},
		"statistics",
		[]string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"})

	return &InstagramDailyStatisticsExecArray{ret}
}

func (instance InstagramExec) Exec(ctx context.Context) (*Instagram, error) {
	var v Instagram
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InstagramExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InstagramExecArray struct {
	exec *prisma.Exec
}

func (instance InstagramExecArray) Exec(ctx context.Context) ([]Instagram, error) {
	var v []Instagram
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InstagramFields = []string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"}

type Instagram struct {
	ID             string  `json:"id"`
	UserId         string  `json:"userId"`
	UserNo         string  `json:"userNo"`
	UserName       *string `json:"userName,omitempty"`
	PostCount      *string `json:"postCount,omitempty"`
	FollowerCount  *string `json:"followerCount,omitempty"`
	FollowingCount *string `json:"followingCount,omitempty"`
	AvatarUrl      *string `json:"avatarUrl,omitempty"`
	Description    *string `json:"description,omitempty"`
	PageUrl        *string `json:"pageUrl,omitempty"`
	CreatedAt      string  `json:"createdAt"`
	UpdatedAt      string  `json:"updatedAt"`
}

type InstagramDailyStatisticsExec struct {
	exec *prisma.Exec
}

func (instance *InstagramDailyStatisticsExec) Instagram() *InstagramExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Instagram"},
		"instagram",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramExec{ret}
}

func (instance InstagramDailyStatisticsExec) Exec(ctx context.Context) (*InstagramDailyStatistics, error) {
	var v InstagramDailyStatistics
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InstagramDailyStatisticsExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InstagramDailyStatisticsExecArray struct {
	exec *prisma.Exec
}

func (instance InstagramDailyStatisticsExecArray) Exec(ctx context.Context) ([]InstagramDailyStatistics, error) {
	var v []InstagramDailyStatistics
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InstagramDailyStatisticsFields = []string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"}

type InstagramDailyStatistics struct {
	ID             string `json:"id"`
	Date           string `json:"date"`
	PostCount      string `json:"postCount"`
	FollowerCount  string `json:"followerCount"`
	FollowingCount string `json:"followingCount"`
	CreatedAt      string `json:"createdAt"`
	UpdatedAt      string `json:"updatedAt"`
}

type AfreecaTvExec struct {
	exec *prisma.Exec
}

func (instance *AfreecaTvExec) Page() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"page",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance *AfreecaTvExec) Statistics(params *StatisticsParamsExec) *AfreecaTvDailyStatisticsExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AfreecaTVDailyStatisticsWhereInput", "AfreecaTVDailyStatisticsOrderByInput", "AfreecaTVDailyStatistics"},
		"statistics",
		[]string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvDailyStatisticsExecArray{ret}
}

func (instance AfreecaTvExec) Exec(ctx context.Context) (*AfreecaTv, error) {
	var v AfreecaTv
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AfreecaTvExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AfreecaTvExecArray struct {
	exec *prisma.Exec
}

func (instance AfreecaTvExecArray) Exec(ctx context.Context) ([]AfreecaTv, error) {
	var v []AfreecaTv
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AfreecaTVFields = []string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"}

type AfreecaTv struct {
	ID            string  `json:"id"`
	StationNo     string  `json:"stationNo"`
	StationName   *string `json:"stationName,omitempty"`
	StationTitle  *string `json:"stationTitle,omitempty"`
	UserId        string  `json:"userId"`
	UserName      *string `json:"userName,omitempty"`
	AvatarUrl     *string `json:"avatarUrl,omitempty"`
	Description   *string `json:"description,omitempty"`
	PageUrl       *string `json:"pageUrl,omitempty"`
	FollowerCount *string `json:"followerCount,omitempty"`
	ViewCount     *string `json:"viewCount,omitempty"`
	VisitCount    *string `json:"visitCount,omitempty"`
	FanCount      *string `json:"fanCount,omitempty"`
	CreatedAt     string  `json:"createdAt"`
	UpdatedAt     string  `json:"updatedAt"`
}

type AfreecaTvDailyStatisticsExec struct {
	exec *prisma.Exec
}

func (instance *AfreecaTvDailyStatisticsExec) AfreecaTv() *AfreecaTvExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AfreecaTV"},
		"afreecaTV",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvExec{ret}
}

func (instance AfreecaTvDailyStatisticsExec) Exec(ctx context.Context) (*AfreecaTvDailyStatistics, error) {
	var v AfreecaTvDailyStatistics
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AfreecaTvDailyStatisticsExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AfreecaTvDailyStatisticsExecArray struct {
	exec *prisma.Exec
}

func (instance AfreecaTvDailyStatisticsExecArray) Exec(ctx context.Context) ([]AfreecaTvDailyStatistics, error) {
	var v []AfreecaTvDailyStatistics
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AfreecaTVDailyStatisticsFields = []string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"}

type AfreecaTvDailyStatistics struct {
	ID            string `json:"id"`
	Date          string `json:"date"`
	FollowerCount string `json:"followerCount"`
	ViewCount     string `json:"viewCount"`
	VisitCount    string `json:"visitCount"`
	FanCount      string `json:"fanCount"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
}

type PageFanExec struct {
	exec *prisma.Exec
}

func (instance *PageFanExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance PageFanExec) Exec(ctx context.Context) (*PageFan, error) {
	var v PageFan
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageFanExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageFanExecArray struct {
	exec *prisma.Exec
}

func (instance PageFanExecArray) Exec(ctx context.Context) ([]PageFan, error) {
	var v []PageFan
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageFanFields = []string{"id", "createdAt", "updatedAt"}

type PageFan struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type RequestPageItemExec struct {
	exec *prisma.Exec
}

func (instance *RequestPageItemExec) Page() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"page",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance *RequestPageItemExec) Owner() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"owner",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance RequestPageItemExec) Exec(ctx context.Context) (*RequestPageItem, error) {
	var v RequestPageItem
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RequestPageItemExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RequestPageItemExecArray struct {
	exec *prisma.Exec
}

func (instance RequestPageItemExecArray) Exec(ctx context.Context) ([]RequestPageItem, error) {
	var v []RequestPageItem
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RequestPageItemFields = []string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"}

type RequestPageItem struct {
	ID        string  `json:"id"`
	Type      int32   `json:"type"`
	Note      *string `json:"note,omitempty"`
	IpAddress *string `json:"ipAddress,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type NotificationExec struct {
	exec *prisma.Exec
}

type UserParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *NotificationExec) User(params *UserParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExecArray{ret}
}

type SendFailUserParamsExec struct {
	Where   *UserWhereInput
	OrderBy *UserOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *NotificationExec) SendFailUser(params *SendFailUserParamsExec) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"sendFailUser",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExecArray{ret}
}

func (instance *NotificationExec) ByUser() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"byUser",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *NotificationExec) Post() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"post",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *NotificationExec) Coin() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"coin",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance *NotificationExec) CreateUser() *AdminUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUser"},
		"createUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (instance *NotificationExec) UpdateUser() *AdminUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUser"},
		"updateUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (instance NotificationExec) Exec(ctx context.Context) (*Notification, error) {
	var v Notification
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NotificationExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NotificationExecArray struct {
	exec *prisma.Exec
}

func (instance NotificationExecArray) Exec(ctx context.Context) ([]Notification, error) {
	var v []Notification
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NotificationFields = []string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"}

type Notification struct {
	ID          string  `json:"id"`
	NotiType    int32   `json:"notiType"`
	PushType    int32   `json:"pushType"`
	PushState   int32   `json:"pushState"`
	Topic       *string `json:"topic,omitempty"`
	LinkType    string  `json:"linkType"`
	LinkValue   string  `json:"linkValue"`
	Message     string  `json:"message"`
	Image       *string `json:"image,omitempty"`
	PublishType int32   `json:"publishType"`
	PublishDate string  `json:"publishDate"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
	IsDel       bool    `json:"isDel"`
}

type AdminUserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AdminUserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AdminUserConnectionExec) Edges() *AdminUserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AdminUserWhereInput", "AdminUserOrderByInput", "AdminUserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "AdminUser"},
		"node",
		AdminUserFields)

	return &AdminUserEdgeExecArray{nodes}
}

func (instance *AdminUserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAdminUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AdminUserConnectionExec) Exec(ctx context.Context) (*AdminUserConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AdminUserConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AdminUserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AdminUserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AdminUserConnectionExecArray) Exec(ctx context.Context) ([]AdminUserConnection, error) {
	var v []AdminUserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AdminUserConnectionFields = []string{}

type AdminUserConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []AdminUserEdge `json:"edges"`
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageInfoFields = []string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type AdminUserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AdminUserEdgeExec) Node() *AdminUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUser"},
		"node",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (instance AdminUserEdgeExec) Exec(ctx context.Context) (*AdminUserEdge, error) {
	var v AdminUserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AdminUserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AdminUserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AdminUserEdgeExecArray) Exec(ctx context.Context) ([]AdminUserEdge, error) {
	var v []AdminUserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AdminUserEdgeFields = []string{"cursor"}

type AdminUserEdge struct {
	Node   AdminUser `json:"node"`
	Cursor string    `json:"cursor"`
}

type AergoAccountConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AergoAccountConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AergoAccountConnectionExec) Edges() *AergoAccountEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AergoAccountWhereInput", "AergoAccountOrderByInput", "AergoAccountEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "AergoAccount"},
		"node",
		AergoAccountFields)

	return &AergoAccountEdgeExecArray{nodes}
}

func (instance *AergoAccountConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAergoAccount"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AergoAccountConnectionExec) Exec(ctx context.Context) (*AergoAccountConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AergoAccountConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AergoAccountConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AergoAccountConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AergoAccountConnectionExecArray) Exec(ctx context.Context) ([]AergoAccountConnection, error) {
	var v []AergoAccountConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AergoAccountConnectionFields = []string{}

type AergoAccountConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []AergoAccountEdge `json:"edges"`
}

type AergoAccountEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AergoAccountEdgeExec) Node() *AergoAccountExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AergoAccount"},
		"node",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountExec{ret}
}

func (instance AergoAccountEdgeExec) Exec(ctx context.Context) (*AergoAccountEdge, error) {
	var v AergoAccountEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AergoAccountEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AergoAccountEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AergoAccountEdgeExecArray) Exec(ctx context.Context) ([]AergoAccountEdge, error) {
	var v []AergoAccountEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AergoAccountEdgeFields = []string{"cursor"}

type AergoAccountEdge struct {
	Node   AergoAccount `json:"node"`
	Cursor string       `json:"cursor"`
}

type AergoAccountHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AergoAccountHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AergoAccountHistoryConnectionExec) Edges() *AergoAccountHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AergoAccountHistoryWhereInput", "AergoAccountHistoryOrderByInput", "AergoAccountHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "AergoAccountHistory"},
		"node",
		AergoAccountHistoryFields)

	return &AergoAccountHistoryEdgeExecArray{nodes}
}

func (instance *AergoAccountHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAergoAccountHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AergoAccountHistoryConnectionExec) Exec(ctx context.Context) (*AergoAccountHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AergoAccountHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AergoAccountHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AergoAccountHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AergoAccountHistoryConnectionExecArray) Exec(ctx context.Context) ([]AergoAccountHistoryConnection, error) {
	var v []AergoAccountHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AergoAccountHistoryConnectionFields = []string{}

type AergoAccountHistoryConnection struct {
	PageInfo PageInfo                  `json:"pageInfo"`
	Edges    []AergoAccountHistoryEdge `json:"edges"`
}

type AergoAccountHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AergoAccountHistoryEdgeExec) Node() *AergoAccountHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AergoAccountHistory"},
		"node",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExec{ret}
}

func (instance AergoAccountHistoryEdgeExec) Exec(ctx context.Context) (*AergoAccountHistoryEdge, error) {
	var v AergoAccountHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AergoAccountHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AergoAccountHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AergoAccountHistoryEdgeExecArray) Exec(ctx context.Context) ([]AergoAccountHistoryEdge, error) {
	var v []AergoAccountHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AergoAccountHistoryEdgeFields = []string{"cursor"}

type AergoAccountHistoryEdge struct {
	Node   AergoAccountHistory `json:"node"`
	Cursor string              `json:"cursor"`
}

type AfreecaTvConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AfreecaTvConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AfreecaTvConnectionExec) Edges() string {
	// edges := instance.exec.Client.GetMany(
	// 	instance.exec,
	// 	nil,
	// 	[3]string{"AfreecaTVWhereInput", "AfreecaTVOrderByInput", "AfreecaTVEdge"},
	// 	"edges",
	// 	[]string{"cursor"})

	// nodes := edges.Client.GetOne(
	// 	edges,
	// 	nil,
	// 	[2]string{"", "AfreecaTV"},
	// 	"node",
	// 	AfreecaTVFields)

	return ""
}

func (instance *AfreecaTvConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAfreecaTV"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AfreecaTvConnectionExec) Exec(ctx context.Context) (*AfreecaTvConnection, error) {
	// edges, err := instance.Edges().Exec(ctx)
	// if err != nil {
	// 	return nil, err
	// }

	// pageInfo, err := instance.PageInfo().Exec(ctx)
	// if err != nil {
	// 	return nil, err
	// }

	// return &AfreecaTvConnection{
	// 	Edges:    edges,
	// 	PageInfo: *pageInfo,
	// }, nil
	return nil, nil
}

func (instance AfreecaTvConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AfreecaTvConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AfreecaTvConnectionExecArray) Exec(ctx context.Context) ([]AfreecaTvConnection, error) {
	var v []AfreecaTvConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AfreecaTVConnectionFields = []string{}

type AfreecaTvConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []AfreecaTvEdge `json:"edges"`
}

type AfreecaTvEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AfreecaTvEdgeExec) Node() *AfreecaTvExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AfreecaTV"},
		"node",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvExec{ret}
}

func (instance AfreecaTvEdgeExec) Exec(ctx context.Context) (*AfreecaTvEdge, error) {
	var v AfreecaTvEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AfreecaTvEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AfreecaTvEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AfreecaTvEdgeExecArray) Exec(ctx context.Context) ([]AfreecaTvEdge, error) {
	var v []AfreecaTvEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AfreecaTVEdgeFields = []string{"cursor"}

type AfreecaTvEdge struct {
	Node   AfreecaTv `json:"node"`
	Cursor string    `json:"cursor"`
}

type AfreecaTvDailyStatisticsConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AfreecaTvDailyStatisticsConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AfreecaTvDailyStatisticsConnectionExec) Edges() string {
	// edges := instance.exec.Client.GetMany(
	// 	instance.exec,
	// 	nil,
	// 	[3]string{"AfreecaTVDailyStatisticsWhereInput", "AfreecaTVDailyStatisticsOrderByInput", "AfreecaTVDailyStatisticsEdge"},
	// 	"edges",
	// 	[]string{"cursor"})

	// nodes := edges.Client.GetOne(
	// 	edges,
	// 	nil,
	// 	[2]string{"", "AfreecaTVDailyStatistics"},
	// 	"node",
	// 	AfreecaTVDailyStatisticsFields)

	return ""
}

func (instance *AfreecaTvDailyStatisticsConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAfreecaTVDailyStatistics"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AfreecaTvDailyStatisticsConnectionExec) Exec(ctx context.Context) (*AfreecaTvDailyStatisticsConnection, error) {
	// edges, err := instance.Edges().Exec(ctx)
	// if err != nil {
	// 	return nil, err
	// }

	// pageInfo, err := instance.PageInfo().Exec(ctx)
	// if err != nil {
	// 	return nil, err
	// }

	return nil, nil
}

func (instance AfreecaTvDailyStatisticsConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AfreecaTvDailyStatisticsConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AfreecaTvDailyStatisticsConnectionExecArray) Exec(ctx context.Context) ([]AfreecaTvDailyStatisticsConnection, error) {
	var v []AfreecaTvDailyStatisticsConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AfreecaTVDailyStatisticsConnectionFields = []string{}

type AfreecaTvDailyStatisticsConnection struct {
	PageInfo PageInfo                       `json:"pageInfo"`
	Edges    []AfreecaTvDailyStatisticsEdge `json:"edges"`
}

type AfreecaTvDailyStatisticsEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AfreecaTvDailyStatisticsEdgeExec) Node() *AfreecaTvDailyStatisticsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AfreecaTVDailyStatistics"},
		"node",
		[]string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvDailyStatisticsExec{ret}
}

func (instance AfreecaTvDailyStatisticsEdgeExec) Exec(ctx context.Context) (*AfreecaTvDailyStatisticsEdge, error) {
	var v AfreecaTvDailyStatisticsEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AfreecaTvDailyStatisticsEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AfreecaTvDailyStatisticsEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AfreecaTvDailyStatisticsEdgeExecArray) Exec(ctx context.Context) ([]AfreecaTvDailyStatisticsEdge, error) {
	var v []AfreecaTvDailyStatisticsEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AfreecaTVDailyStatisticsEdgeFields = []string{"cursor"}

type AfreecaTvDailyStatisticsEdge struct {
	Node   AfreecaTvDailyStatistics `json:"node"`
	Cursor string                   `json:"cursor"`
}

type AirDropConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AirDropConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AirDropConnectionExec) Edges() *AirDropEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AirDropWhereInput", "AirDropOrderByInput", "AirDropEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "AirDrop"},
		"node",
		AirDropFields)

	return &AirDropEdgeExecArray{nodes}
}

func (instance *AirDropConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAirDrop"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AirDropConnectionExec) Exec(ctx context.Context) (*AirDropConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AirDropConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AirDropConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropConnectionExecArray) Exec(ctx context.Context) ([]AirDropConnection, error) {
	var v []AirDropConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropConnectionFields = []string{}

type AirDropConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []AirDropEdge `json:"edges"`
}

type AirDropEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AirDropEdgeExec) Node() *AirDropExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDrop"},
		"node",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExec{ret}
}

func (instance AirDropEdgeExec) Exec(ctx context.Context) (*AirDropEdge, error) {
	var v AirDropEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropEdgeExecArray) Exec(ctx context.Context) ([]AirDropEdge, error) {
	var v []AirDropEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropEdgeFields = []string{"cursor"}

type AirDropEdge struct {
	Node   AirDrop `json:"node"`
	Cursor string  `json:"cursor"`
}

type AirDropHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AirDropHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AirDropHistoryConnectionExec) Edges() *AirDropHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AirDropHistoryWhereInput", "AirDropHistoryOrderByInput", "AirDropHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "AirDropHistory"},
		"node",
		AirDropHistoryFields)

	return &AirDropHistoryEdgeExecArray{nodes}
}

func (instance *AirDropHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAirDropHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AirDropHistoryConnectionExec) Exec(ctx context.Context) (*AirDropHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AirDropHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AirDropHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropHistoryConnectionExecArray) Exec(ctx context.Context) ([]AirDropHistoryConnection, error) {
	var v []AirDropHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropHistoryConnectionFields = []string{}

type AirDropHistoryConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []AirDropHistoryEdge `json:"edges"`
}

type AirDropHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AirDropHistoryEdgeExec) Node() *AirDropHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDropHistory"},
		"node",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExec{ret}
}

func (instance AirDropHistoryEdgeExec) Exec(ctx context.Context) (*AirDropHistoryEdge, error) {
	var v AirDropHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropHistoryEdgeExecArray) Exec(ctx context.Context) ([]AirDropHistoryEdge, error) {
	var v []AirDropHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropHistoryEdgeFields = []string{"cursor"}

type AirDropHistoryEdge struct {
	Node   AirDropHistory `json:"node"`
	Cursor string         `json:"cursor"`
}

type AirDropMemberConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AirDropMemberConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AirDropMemberConnectionExec) Edges() *AirDropMemberEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AirDropMemberWhereInput", "AirDropMemberOrderByInput", "AirDropMemberEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "AirDropMember"},
		"node",
		AirDropMemberFields)

	return &AirDropMemberEdgeExecArray{nodes}
}

func (instance *AirDropMemberConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAirDropMember"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AirDropMemberConnectionExec) Exec(ctx context.Context) (*AirDropMemberConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AirDropMemberConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AirDropMemberConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropMemberConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropMemberConnectionExecArray) Exec(ctx context.Context) ([]AirDropMemberConnection, error) {
	var v []AirDropMemberConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropMemberConnectionFields = []string{}

type AirDropMemberConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []AirDropMemberEdge `json:"edges"`
}

type AirDropMemberEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AirDropMemberEdgeExec) Node() *AirDropMemberExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDropMember"},
		"node",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExec{ret}
}

func (instance AirDropMemberEdgeExec) Exec(ctx context.Context) (*AirDropMemberEdge, error) {
	var v AirDropMemberEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropMemberEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropMemberEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropMemberEdgeExecArray) Exec(ctx context.Context) ([]AirDropMemberEdge, error) {
	var v []AirDropMemberEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropMemberEdgeFields = []string{"cursor"}

type AirDropMemberEdge struct {
	Node   AirDropMember `json:"node"`
	Cursor string        `json:"cursor"`
}

type AppVersionExec struct {
	exec *prisma.Exec
}

type AffectedDevicesParamsExec struct {
	Where   *DeviceWhereInput
	OrderBy *DeviceOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *AppVersionExec) AffectedDevices(params *AffectedDevicesParamsExec) *DeviceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"DeviceWhereInput", "DeviceOrderByInput", "Device"},
		"affectedDevices",
		[]string{"id", "code", "name"})

	return &DeviceExecArray{ret}
}

func (instance *AppVersionExec) CreateUser() *AdminUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUser"},
		"createUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (instance *AppVersionExec) UpdateUser() *AdminUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUser"},
		"updateUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (instance AppVersionExec) Exec(ctx context.Context) (*AppVersion, error) {
	var v AppVersion
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppVersionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppVersionExecArray struct {
	exec *prisma.Exec
}

func (instance AppVersionExecArray) Exec(ctx context.Context) ([]AppVersion, error) {
	var v []AppVersion
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppVersionFields = []string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"}

type AppVersion struct {
	ID         string `json:"id"`
	Version    string `json:"version"`
	Type       int32  `json:"type"`
	Note       string `json:"note"`
	ReleasedAt string `json:"releasedAt"`
	CreatedAt  string `json:"createdAt"`
	UpdatedAt  string `json:"updatedAt"`
	IsDel      *bool  `json:"isDel,omitempty"`
}

type DeviceExec struct {
	exec *prisma.Exec
}

type MaintenanceParamsExec struct {
	Where   *MaintenanceWhereInput
	OrderBy *MaintenanceOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *DeviceExec) Maintenance(params *MaintenanceParamsExec) *MaintenanceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"MaintenanceWhereInput", "MaintenanceOrderByInput", "Maintenance"},
		"maintenance",
		[]string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"})

	return &MaintenanceExecArray{ret}
}

type AppVersionParamsExec struct {
	Where   *AppVersionWhereInput
	OrderBy *AppVersionOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *DeviceExec) AppVersion(params *AppVersionParamsExec) *AppVersionExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"AppVersionWhereInput", "AppVersionOrderByInput", "AppVersion"},
		"appVersion",
		[]string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"})

	return &AppVersionExecArray{ret}
}

func (instance DeviceExec) Exec(ctx context.Context) (*Device, error) {
	var v Device
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DeviceExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DeviceExecArray struct {
	exec *prisma.Exec
}

func (instance DeviceExecArray) Exec(ctx context.Context) ([]Device, error) {
	var v []Device
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var DeviceFields = []string{"id", "code", "name"}

type Device struct {
	ID   string `json:"id"`
	Code int32  `json:"code"`
	Name string `json:"name"`
}

type MaintenanceExec struct {
	exec *prisma.Exec
}

func (instance *MaintenanceExec) AffectedDevices(params *AffectedDevicesParamsExec) *DeviceExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"DeviceWhereInput", "DeviceOrderByInput", "Device"},
		"affectedDevices",
		[]string{"id", "code", "name"})

	return &DeviceExecArray{ret}
}

func (instance *MaintenanceExec) CreateUser() *AdminUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUser"},
		"createUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (instance *MaintenanceExec) UpdateUser() *AdminUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUser"},
		"updateUser",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (instance MaintenanceExec) Exec(ctx context.Context) (*Maintenance, error) {
	var v Maintenance
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MaintenanceExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MaintenanceExecArray struct {
	exec *prisma.Exec
}

func (instance MaintenanceExecArray) Exec(ctx context.Context) ([]Maintenance, error) {
	var v []Maintenance
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MaintenanceFields = []string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"}

type Maintenance struct {
	ID        string `json:"id"`
	Type      int32  `json:"type"`
	Note      string `json:"note"`
	FromDate  string `json:"fromDate"`
	ToDate    string `json:"toDate"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	IsDel     bool   `json:"isDel"`
}

type AppVersionConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AppVersionConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AppVersionConnectionExec) Edges() *AppVersionEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"AppVersionWhereInput", "AppVersionOrderByInput", "AppVersionEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "AppVersion"},
		"node",
		AppVersionFields)

	return &AppVersionEdgeExecArray{nodes}
}

func (instance *AppVersionConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAppVersion"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance AppVersionConnectionExec) Exec(ctx context.Context) (*AppVersionConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &AppVersionConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance AppVersionConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppVersionConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AppVersionConnectionExecArray) Exec(ctx context.Context) ([]AppVersionConnection, error) {
	var v []AppVersionConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppVersionConnectionFields = []string{}

type AppVersionConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []AppVersionEdge `json:"edges"`
}

type AppVersionEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AppVersionEdgeExec) Node() *AppVersionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AppVersion"},
		"node",
		[]string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"})

	return &AppVersionExec{ret}
}

func (instance AppVersionEdgeExec) Exec(ctx context.Context) (*AppVersionEdge, error) {
	var v AppVersionEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppVersionEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppVersionEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AppVersionEdgeExecArray) Exec(ctx context.Context) ([]AppVersionEdge, error) {
	var v []AppVersionEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppVersionEdgeFields = []string{"cursor"}

type AppVersionEdge struct {
	Node   AppVersion `json:"node"`
	Cursor string     `json:"cursor"`
}

type BadgeConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BadgeConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BadgeConnectionExec) Edges() *BadgeEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BadgeWhereInput", "BadgeOrderByInput", "BadgeEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Badge"},
		"node",
		BadgeFields)

	return &BadgeEdgeExecArray{nodes}
}

func (instance *BadgeConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBadge"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BadgeConnectionExec) Exec(ctx context.Context) (*BadgeConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BadgeConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BadgeConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BadgeConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BadgeConnectionExecArray) Exec(ctx context.Context) ([]BadgeConnection, error) {
	var v []BadgeConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BadgeConnectionFields = []string{}

type BadgeConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []BadgeEdge `json:"edges"`
}

type BadgeEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BadgeEdgeExec) Node() *BadgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Badge"},
		"node",
		[]string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"})

	return &BadgeExec{ret}
}

func (instance BadgeEdgeExec) Exec(ctx context.Context) (*BadgeEdge, error) {
	var v BadgeEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BadgeEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BadgeEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BadgeEdgeExecArray) Exec(ctx context.Context) ([]BadgeEdge, error) {
	var v []BadgeEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BadgeEdgeFields = []string{"cursor"}

type BadgeEdge struct {
	Node   Badge  `json:"node"`
	Cursor string `json:"cursor"`
}

type BadgeVoterConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BadgeVoterConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BadgeVoterConnectionExec) Edges() *BadgeVoterEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BadgeVoterWhereInput", "BadgeVoterOrderByInput", "BadgeVoterEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "BadgeVoter"},
		"node",
		BadgeVoterFields)

	return &BadgeVoterEdgeExecArray{nodes}
}

func (instance *BadgeVoterConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBadgeVoter"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BadgeVoterConnectionExec) Exec(ctx context.Context) (*BadgeVoterConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BadgeVoterConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BadgeVoterConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BadgeVoterConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BadgeVoterConnectionExecArray) Exec(ctx context.Context) ([]BadgeVoterConnection, error) {
	var v []BadgeVoterConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BadgeVoterConnectionFields = []string{}

type BadgeVoterConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []BadgeVoterEdge `json:"edges"`
}

type BadgeVoterEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BadgeVoterEdgeExec) Node() *BadgeVoterExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BadgeVoter"},
		"node",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &BadgeVoterExec{ret}
}

func (instance BadgeVoterEdgeExec) Exec(ctx context.Context) (*BadgeVoterEdge, error) {
	var v BadgeVoterEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BadgeVoterEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BadgeVoterEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BadgeVoterEdgeExecArray) Exec(ctx context.Context) ([]BadgeVoterEdge, error) {
	var v []BadgeVoterEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BadgeVoterEdgeFields = []string{"cursor"}

type BadgeVoterEdge struct {
	Node   BadgeVoter `json:"node"`
	Cursor string     `json:"cursor"`
}

type BankConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BankConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BankConnectionExec) Edges() *BankEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BankWhereInput", "BankOrderByInput", "BankEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Bank"},
		"node",
		BankFields)

	return &BankEdgeExecArray{nodes}
}

func (instance *BankConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBank"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BankConnectionExec) Exec(ctx context.Context) (*BankConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BankConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BankConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BankConnectionExecArray) Exec(ctx context.Context) ([]BankConnection, error) {
	var v []BankConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankConnectionFields = []string{}

type BankConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []BankEdge `json:"edges"`
}

type BankEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BankEdgeExec) Node() *BankExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Bank"},
		"node",
		[]string{"id", "code", "name", "createdAt", "updatedAt"})

	return &BankExec{ret}
}

func (instance BankEdgeExec) Exec(ctx context.Context) (*BankEdge, error) {
	var v BankEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BankEdgeExecArray) Exec(ctx context.Context) ([]BankEdge, error) {
	var v []BankEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankEdgeFields = []string{"cursor"}

type BankEdge struct {
	Node   Bank   `json:"node"`
	Cursor string `json:"cursor"`
}

type BankAccountVerificationConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BankAccountVerificationConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BankAccountVerificationConnectionExec) Edges() *BankAccountVerificationEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BankAccountVerificationWhereInput", "BankAccountVerificationOrderByInput", "BankAccountVerificationEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "BankAccountVerification"},
		"node",
		BankAccountVerificationFields)

	return &BankAccountVerificationEdgeExecArray{nodes}
}

func (instance *BankAccountVerificationConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBankAccountVerification"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BankAccountVerificationConnectionExec) Exec(ctx context.Context) (*BankAccountVerificationConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BankAccountVerificationConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BankAccountVerificationConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankAccountVerificationConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationConnectionExecArray) Exec(ctx context.Context) ([]BankAccountVerificationConnection, error) {
	var v []BankAccountVerificationConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankAccountVerificationConnectionFields = []string{}

type BankAccountVerificationConnection struct {
	PageInfo PageInfo                      `json:"pageInfo"`
	Edges    []BankAccountVerificationEdge `json:"edges"`
}

type BankAccountVerificationEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BankAccountVerificationEdgeExec) Node() *BankAccountVerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BankAccountVerification"},
		"node",
		[]string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationExec{ret}
}

func (instance BankAccountVerificationEdgeExec) Exec(ctx context.Context) (*BankAccountVerificationEdge, error) {
	var v BankAccountVerificationEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankAccountVerificationEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankAccountVerificationEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationEdgeExecArray) Exec(ctx context.Context) ([]BankAccountVerificationEdge, error) {
	var v []BankAccountVerificationEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankAccountVerificationEdgeFields = []string{"cursor"}

type BankAccountVerificationEdge struct {
	Node   BankAccountVerification `json:"node"`
	Cursor string                  `json:"cursor"`
}

type BankAccountVerificationTransactionInfoConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BankAccountVerificationTransactionInfoConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BankAccountVerificationTransactionInfoConnectionExec) Edges() *BankAccountVerificationTransactionInfoEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BankAccountVerificationTransactionInfoWhereInput", "BankAccountVerificationTransactionInfoOrderByInput", "BankAccountVerificationTransactionInfoEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "BankAccountVerificationTransactionInfo"},
		"node",
		BankAccountVerificationTransactionInfoFields)

	return &BankAccountVerificationTransactionInfoEdgeExecArray{nodes}
}

func (instance *BankAccountVerificationTransactionInfoConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBankAccountVerificationTransactionInfo"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BankAccountVerificationTransactionInfoConnectionExec) Exec(ctx context.Context) (*BankAccountVerificationTransactionInfoConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BankAccountVerificationTransactionInfoConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BankAccountVerificationTransactionInfoConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankAccountVerificationTransactionInfoConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationTransactionInfoConnectionExecArray) Exec(ctx context.Context) ([]BankAccountVerificationTransactionInfoConnection, error) {
	var v []BankAccountVerificationTransactionInfoConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankAccountVerificationTransactionInfoConnectionFields = []string{}

type BankAccountVerificationTransactionInfoConnection struct {
	PageInfo PageInfo                                     `json:"pageInfo"`
	Edges    []BankAccountVerificationTransactionInfoEdge `json:"edges"`
}

type BankAccountVerificationTransactionInfoEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BankAccountVerificationTransactionInfoEdgeExec) Node() *BankAccountVerificationTransactionInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BankAccountVerificationTransactionInfo"},
		"node",
		[]string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationTransactionInfoExec{ret}
}

func (instance BankAccountVerificationTransactionInfoEdgeExec) Exec(ctx context.Context) (*BankAccountVerificationTransactionInfoEdge, error) {
	var v BankAccountVerificationTransactionInfoEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankAccountVerificationTransactionInfoEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankAccountVerificationTransactionInfoEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationTransactionInfoEdgeExecArray) Exec(ctx context.Context) ([]BankAccountVerificationTransactionInfoEdge, error) {
	var v []BankAccountVerificationTransactionInfoEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankAccountVerificationTransactionInfoEdgeFields = []string{"cursor"}

type BankAccountVerificationTransactionInfoEdge struct {
	Node   BankAccountVerificationTransactionInfo `json:"node"`
	Cursor string                                 `json:"cursor"`
}

type BoardExec struct {
	exec *prisma.Exec
}

func (instance BoardExec) Exec(ctx context.Context) (*Board, error) {
	var v Board
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BoardExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BoardExecArray struct {
	exec *prisma.Exec
}

func (instance BoardExecArray) Exec(ctx context.Context) ([]Board, error) {
	var v []Board
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BoardFields = []string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"}

type Board struct {
	ID        string `json:"id"`
	Type      int32  `json:"type"`
	Title     string `json:"title"`
	Content   string `json:"content"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	IsDel     *bool  `json:"isDel,omitempty"`
}

type BoardConnectionExec struct {
	exec *prisma.Exec
}

func (instance *BoardConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *BoardConnectionExec) Edges() *BoardEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"BoardWhereInput", "BoardOrderByInput", "BoardEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Board"},
		"node",
		BoardFields)

	return &BoardEdgeExecArray{nodes}
}

func (instance *BoardConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateBoard"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance BoardConnectionExec) Exec(ctx context.Context) (*BoardConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &BoardConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance BoardConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BoardConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance BoardConnectionExecArray) Exec(ctx context.Context) ([]BoardConnection, error) {
	var v []BoardConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BoardConnectionFields = []string{}

type BoardConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []BoardEdge `json:"edges"`
}

type BoardEdgeExec struct {
	exec *prisma.Exec
}

func (instance *BoardEdgeExec) Node() *BoardExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Board"},
		"node",
		[]string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"})

	return &BoardExec{ret}
}

func (instance BoardEdgeExec) Exec(ctx context.Context) (*BoardEdge, error) {
	var v BoardEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BoardEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BoardEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance BoardEdgeExecArray) Exec(ctx context.Context) ([]BoardEdge, error) {
	var v []BoardEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BoardEdgeFields = []string{"cursor"}

type BoardEdge struct {
	Node   Board  `json:"node"`
	Cursor string `json:"cursor"`
}

type CashHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CashHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CashHistoryConnectionExec) Edges() *CashHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CashHistoryWhereInput", "CashHistoryOrderByInput", "CashHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "CashHistory"},
		"node",
		CashHistoryFields)

	return &CashHistoryEdgeExecArray{nodes}
}

func (instance *CashHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCashHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CashHistoryConnectionExec) Exec(ctx context.Context) (*CashHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CashHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CashHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CashHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CashHistoryConnectionExecArray) Exec(ctx context.Context) ([]CashHistoryConnection, error) {
	var v []CashHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CashHistoryConnectionFields = []string{}

type CashHistoryConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []CashHistoryEdge `json:"edges"`
}

type CashHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CashHistoryEdgeExec) Node() *CashHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CashHistory"},
		"node",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExec{ret}
}

func (instance CashHistoryEdgeExec) Exec(ctx context.Context) (*CashHistoryEdge, error) {
	var v CashHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CashHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CashHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CashHistoryEdgeExecArray) Exec(ctx context.Context) ([]CashHistoryEdge, error) {
	var v []CashHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CashHistoryEdgeFields = []string{"cursor"}

type CashHistoryEdge struct {
	Node   CashHistory `json:"node"`
	Cursor string      `json:"cursor"`
}

type CategoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CategoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CategoryConnectionExec) Edges() *CategoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CategoryWhereInput", "CategoryOrderByInput", "CategoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Category"},
		"node",
		CategoryFields)

	return &CategoryEdgeExecArray{nodes}
}

func (instance *CategoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCategory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CategoryConnectionExec) Exec(ctx context.Context) (*CategoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CategoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CategoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CategoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CategoryConnectionExecArray) Exec(ctx context.Context) ([]CategoryConnection, error) {
	var v []CategoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CategoryConnectionFields = []string{}

type CategoryConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []CategoryEdge `json:"edges"`
}

type CategoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CategoryEdgeExec) Node() *CategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Category"},
		"node",
		[]string{"id", "name", "order_index"})

	return &CategoryExec{ret}
}

func (instance CategoryEdgeExec) Exec(ctx context.Context) (*CategoryEdge, error) {
	var v CategoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CategoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CategoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CategoryEdgeExecArray) Exec(ctx context.Context) ([]CategoryEdge, error) {
	var v []CategoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CategoryEdgeFields = []string{"cursor"}

type CategoryEdge struct {
	Node   Category `json:"node"`
	Cursor string   `json:"cursor"`
}

type CoinConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CoinConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CoinConnectionExec) Edges() *CoinEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CoinWhereInput", "CoinOrderByInput", "CoinEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Coin"},
		"node",
		CoinFields)

	return &CoinEdgeExecArray{nodes}
}

func (instance *CoinConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCoin"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CoinConnectionExec) Exec(ctx context.Context) (*CoinConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CoinConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CoinConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CoinConnectionExecArray) Exec(ctx context.Context) ([]CoinConnection, error) {
	var v []CoinConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinConnectionFields = []string{}

type CoinConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []CoinEdge `json:"edges"`
}

type CoinEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CoinEdgeExec) Node() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"node",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance CoinEdgeExec) Exec(ctx context.Context) (*CoinEdge, error) {
	var v CoinEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CoinEdgeExecArray) Exec(ctx context.Context) ([]CoinEdge, error) {
	var v []CoinEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinEdgeFields = []string{"cursor"}

type CoinEdge struct {
	Node   Coin   `json:"node"`
	Cursor string `json:"cursor"`
}

type CoinKlineConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CoinKlineConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CoinKlineConnectionExec) Edges() *CoinKlineEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CoinKlineWhereInput", "CoinKlineOrderByInput", "CoinKlineEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "CoinKline"},
		"node",
		CoinKlineFields)

	return &CoinKlineEdgeExecArray{nodes}
}

func (instance *CoinKlineConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCoinKline"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CoinKlineConnectionExec) Exec(ctx context.Context) (*CoinKlineConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CoinKlineConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CoinKlineConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinKlineConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CoinKlineConnectionExecArray) Exec(ctx context.Context) ([]CoinKlineConnection, error) {
	var v []CoinKlineConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinKlineConnectionFields = []string{}

type CoinKlineConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []CoinKlineEdge `json:"edges"`
}

type CoinKlineEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CoinKlineEdgeExec) Node() *CoinKlineExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CoinKline"},
		"node",
		[]string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"})

	return &CoinKlineExec{ret}
}

func (instance CoinKlineEdgeExec) Exec(ctx context.Context) (*CoinKlineEdge, error) {
	var v CoinKlineEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinKlineEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinKlineEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CoinKlineEdgeExecArray) Exec(ctx context.Context) ([]CoinKlineEdge, error) {
	var v []CoinKlineEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinKlineEdgeFields = []string{"cursor"}

type CoinKlineEdge struct {
	Node   CoinKline `json:"node"`
	Cursor string    `json:"cursor"`
}

type CoinPriceTableConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CoinPriceTableConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CoinPriceTableConnectionExec) Edges() *CoinPriceTableEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CoinPriceTableWhereInput", "CoinPriceTableOrderByInput", "CoinPriceTableEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "CoinPriceTable"},
		"node",
		CoinPriceTableFields)

	return &CoinPriceTableEdgeExecArray{nodes}
}

func (instance *CoinPriceTableConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCoinPriceTable"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CoinPriceTableConnectionExec) Exec(ctx context.Context) (*CoinPriceTableConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CoinPriceTableConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CoinPriceTableConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinPriceTableConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CoinPriceTableConnectionExecArray) Exec(ctx context.Context) ([]CoinPriceTableConnection, error) {
	var v []CoinPriceTableConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinPriceTableConnectionFields = []string{}

type CoinPriceTableConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []CoinPriceTableEdge `json:"edges"`
}

type CoinPriceTableEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CoinPriceTableEdgeExec) Node() *CoinPriceTableExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CoinPriceTable"},
		"node",
		[]string{"id", "type", "infoValue", "createdAt", "updatedAt"})

	return &CoinPriceTableExec{ret}
}

func (instance CoinPriceTableEdgeExec) Exec(ctx context.Context) (*CoinPriceTableEdge, error) {
	var v CoinPriceTableEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinPriceTableEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinPriceTableEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CoinPriceTableEdgeExecArray) Exec(ctx context.Context) ([]CoinPriceTableEdge, error) {
	var v []CoinPriceTableEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinPriceTableEdgeFields = []string{"cursor"}

type CoinPriceTableEdge struct {
	Node   CoinPriceTable `json:"node"`
	Cursor string         `json:"cursor"`
}

type CommentConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CommentConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CommentConnectionExec) Edges() *CommentEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CommentWhereInput", "CommentOrderByInput", "CommentEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Comment"},
		"node",
		CommentFields)

	return &CommentEdgeExecArray{nodes}
}

func (instance *CommentConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateComment"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CommentConnectionExec) Exec(ctx context.Context) (*CommentConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CommentConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CommentConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CommentConnectionExecArray) Exec(ctx context.Context) ([]CommentConnection, error) {
	var v []CommentConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentConnectionFields = []string{}

type CommentConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []CommentEdge `json:"edges"`
}

type CommentEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CommentEdgeExec) Node() *CommentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Comment"},
		"node",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExec{ret}
}

func (instance CommentEdgeExec) Exec(ctx context.Context) (*CommentEdge, error) {
	var v CommentEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CommentEdgeExecArray) Exec(ctx context.Context) ([]CommentEdge, error) {
	var v []CommentEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentEdgeFields = []string{"cursor"}

type CommentEdge struct {
	Node   Comment `json:"node"`
	Cursor string  `json:"cursor"`
}

type CommentReplyConnectionExec struct {
	exec *prisma.Exec
}

func (instance *CommentReplyConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *CommentReplyConnectionExec) Edges() *CommentReplyEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"CommentReplyWhereInput", "CommentReplyOrderByInput", "CommentReplyEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "CommentReply"},
		"node",
		CommentReplyFields)

	return &CommentReplyEdgeExecArray{nodes}
}

func (instance *CommentReplyConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateCommentReply"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance CommentReplyConnectionExec) Exec(ctx context.Context) (*CommentReplyConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &CommentReplyConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance CommentReplyConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentReplyConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance CommentReplyConnectionExecArray) Exec(ctx context.Context) ([]CommentReplyConnection, error) {
	var v []CommentReplyConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentReplyConnectionFields = []string{}

type CommentReplyConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []CommentReplyEdge `json:"edges"`
}

type CommentReplyEdgeExec struct {
	exec *prisma.Exec
}

func (instance *CommentReplyEdgeExec) Node() *CommentReplyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CommentReply"},
		"node",
		[]string{"id", "content", "createdAt", "updatedAt", "isDel"})

	return &CommentReplyExec{ret}
}

func (instance CommentReplyEdgeExec) Exec(ctx context.Context) (*CommentReplyEdge, error) {
	var v CommentReplyEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentReplyEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentReplyEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance CommentReplyEdgeExecArray) Exec(ctx context.Context) ([]CommentReplyEdge, error) {
	var v []CommentReplyEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentReplyEdgeFields = []string{"cursor"}

type CommentReplyEdge struct {
	Node   CommentReply `json:"node"`
	Cursor string       `json:"cursor"`
}

type DeviceConnectionExec struct {
	exec *prisma.Exec
}

func (instance *DeviceConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *DeviceConnectionExec) Edges() *DeviceEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"DeviceWhereInput", "DeviceOrderByInput", "DeviceEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Device"},
		"node",
		DeviceFields)

	return &DeviceEdgeExecArray{nodes}
}

func (instance *DeviceConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateDevice"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance DeviceConnectionExec) Exec(ctx context.Context) (*DeviceConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &DeviceConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance DeviceConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DeviceConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance DeviceConnectionExecArray) Exec(ctx context.Context) ([]DeviceConnection, error) {
	var v []DeviceConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var DeviceConnectionFields = []string{}

type DeviceConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []DeviceEdge `json:"edges"`
}

type DeviceEdgeExec struct {
	exec *prisma.Exec
}

func (instance *DeviceEdgeExec) Node() *DeviceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Device"},
		"node",
		[]string{"id", "code", "name"})

	return &DeviceExec{ret}
}

func (instance DeviceEdgeExec) Exec(ctx context.Context) (*DeviceEdge, error) {
	var v DeviceEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DeviceEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DeviceEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance DeviceEdgeExecArray) Exec(ctx context.Context) ([]DeviceEdge, error) {
	var v []DeviceEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var DeviceEdgeFields = []string{"cursor"}

type DeviceEdge struct {
	Node   Device `json:"node"`
	Cursor string `json:"cursor"`
}

type FeeConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FeeConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FeeConnectionExec) Edges() *FeeEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"FeeWhereInput", "FeeOrderByInput", "FeeEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Fee"},
		"node",
		FeeFields)

	return &FeeEdgeExecArray{nodes}
}

func (instance *FeeConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFee"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance FeeConnectionExec) Exec(ctx context.Context) (*FeeConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &FeeConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance FeeConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeeConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FeeConnectionExecArray) Exec(ctx context.Context) ([]FeeConnection, error) {
	var v []FeeConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FeeConnectionFields = []string{}

type FeeConnection struct {
	PageInfo PageInfo  `json:"pageInfo"`
	Edges    []FeeEdge `json:"edges"`
}

type FeeEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FeeEdgeExec) Node() *FeeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Fee"},
		"node",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeeExec{ret}
}

func (instance FeeEdgeExec) Exec(ctx context.Context) (*FeeEdge, error) {
	var v FeeEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeeEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeeEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FeeEdgeExecArray) Exec(ctx context.Context) ([]FeeEdge, error) {
	var v []FeeEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FeeEdgeFields = []string{"cursor"}

type FeeEdge struct {
	Node   Fee    `json:"node"`
	Cursor string `json:"cursor"`
}

type FileConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FileConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FileConnectionExec) Edges() *FileEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"FileWhereInput", "FileOrderByInput", "FileEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "File"},
		"node",
		FileFields)

	return &FileEdgeExecArray{nodes}
}

func (instance *FileConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFile"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance FileConnectionExec) Exec(ctx context.Context) (*FileConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &FileConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance FileConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FileConnectionExecArray) Exec(ctx context.Context) ([]FileConnection, error) {
	var v []FileConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FileConnectionFields = []string{}

type FileConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []FileEdge `json:"edges"`
}

type FileEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FileEdgeExec) Node() *FileExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "File"},
		"node",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExec{ret}
}

func (instance FileEdgeExec) Exec(ctx context.Context) (*FileEdge, error) {
	var v FileEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FileEdgeExecArray) Exec(ctx context.Context) ([]FileEdge, error) {
	var v []FileEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FileEdgeFields = []string{"cursor"}

type FileEdge struct {
	Node   File   `json:"node"`
	Cursor string `json:"cursor"`
}

type FileInfoConnectionExec struct {
	exec *prisma.Exec
}

func (instance *FileInfoConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *FileInfoConnectionExec) Edges() *FileInfoEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"FileInfoWhereInput", "FileInfoOrderByInput", "FileInfoEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "FileInfo"},
		"node",
		FileInfoFields)

	return &FileInfoEdgeExecArray{nodes}
}

func (instance *FileInfoConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateFileInfo"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance FileInfoConnectionExec) Exec(ctx context.Context) (*FileInfoConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &FileInfoConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance FileInfoConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileInfoConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance FileInfoConnectionExecArray) Exec(ctx context.Context) ([]FileInfoConnection, error) {
	var v []FileInfoConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FileInfoConnectionFields = []string{}

type FileInfoConnection struct {
	PageInfo PageInfo       `json:"pageInfo"`
	Edges    []FileInfoEdge `json:"edges"`
}

type FileInfoEdgeExec struct {
	exec *prisma.Exec
}

func (instance *FileInfoEdgeExec) Node() *FileInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileInfo"},
		"node",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExec{ret}
}

func (instance FileInfoEdgeExec) Exec(ctx context.Context) (*FileInfoEdge, error) {
	var v FileInfoEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileInfoEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileInfoEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance FileInfoEdgeExecArray) Exec(ctx context.Context) ([]FileInfoEdge, error) {
	var v []FileInfoEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FileInfoEdgeFields = []string{"cursor"}

type FileInfoEdge struct {
	Node   FileInfo `json:"node"`
	Cursor string   `json:"cursor"`
}

type InstagramConnectionExec struct {
	exec *prisma.Exec
}

func (instance *InstagramConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *InstagramConnectionExec) Edges() *InstagramEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"InstagramWhereInput", "InstagramOrderByInput", "InstagramEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Instagram"},
		"node",
		InstagramFields)

	return &InstagramEdgeExecArray{nodes}
}

func (instance *InstagramConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateInstagram"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance InstagramConnectionExec) Exec(ctx context.Context) (*InstagramConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &InstagramConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance InstagramConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InstagramConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance InstagramConnectionExecArray) Exec(ctx context.Context) ([]InstagramConnection, error) {
	var v []InstagramConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InstagramConnectionFields = []string{}

type InstagramConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []InstagramEdge `json:"edges"`
}

type InstagramEdgeExec struct {
	exec *prisma.Exec
}

func (instance *InstagramEdgeExec) Node() *InstagramExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Instagram"},
		"node",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramExec{ret}
}

func (instance InstagramEdgeExec) Exec(ctx context.Context) (*InstagramEdge, error) {
	var v InstagramEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InstagramEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InstagramEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance InstagramEdgeExecArray) Exec(ctx context.Context) ([]InstagramEdge, error) {
	var v []InstagramEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InstagramEdgeFields = []string{"cursor"}

type InstagramEdge struct {
	Node   Instagram `json:"node"`
	Cursor string    `json:"cursor"`
}

type InstagramDailyStatisticsConnectionExec struct {
	exec *prisma.Exec
}

func (instance *InstagramDailyStatisticsConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *InstagramDailyStatisticsConnectionExec) Edges() *InstagramDailyStatisticsEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"InstagramDailyStatisticsWhereInput", "InstagramDailyStatisticsOrderByInput", "InstagramDailyStatisticsEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "InstagramDailyStatistics"},
		"node",
		InstagramDailyStatisticsFields)

	return &InstagramDailyStatisticsEdgeExecArray{nodes}
}

func (instance *InstagramDailyStatisticsConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateInstagramDailyStatistics"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance InstagramDailyStatisticsConnectionExec) Exec(ctx context.Context) (*InstagramDailyStatisticsConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &InstagramDailyStatisticsConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance InstagramDailyStatisticsConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InstagramDailyStatisticsConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance InstagramDailyStatisticsConnectionExecArray) Exec(ctx context.Context) ([]InstagramDailyStatisticsConnection, error) {
	var v []InstagramDailyStatisticsConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InstagramDailyStatisticsConnectionFields = []string{}

type InstagramDailyStatisticsConnection struct {
	PageInfo PageInfo                       `json:"pageInfo"`
	Edges    []InstagramDailyStatisticsEdge `json:"edges"`
}

type InstagramDailyStatisticsEdgeExec struct {
	exec *prisma.Exec
}

func (instance *InstagramDailyStatisticsEdgeExec) Node() *InstagramDailyStatisticsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InstagramDailyStatistics"},
		"node",
		[]string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"})

	return &InstagramDailyStatisticsExec{ret}
}

func (instance InstagramDailyStatisticsEdgeExec) Exec(ctx context.Context) (*InstagramDailyStatisticsEdge, error) {
	var v InstagramDailyStatisticsEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InstagramDailyStatisticsEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InstagramDailyStatisticsEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance InstagramDailyStatisticsEdgeExecArray) Exec(ctx context.Context) ([]InstagramDailyStatisticsEdge, error) {
	var v []InstagramDailyStatisticsEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InstagramDailyStatisticsEdgeFields = []string{"cursor"}

type InstagramDailyStatisticsEdge struct {
	Node   InstagramDailyStatistics `json:"node"`
	Cursor string                   `json:"cursor"`
}

type InviteCodeConnectionExec struct {
	exec *prisma.Exec
}

func (instance *InviteCodeConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *InviteCodeConnectionExec) Edges() *InviteCodeEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"InviteCodeWhereInput", "InviteCodeOrderByInput", "InviteCodeEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "InviteCode"},
		"node",
		InviteCodeFields)

	return &InviteCodeEdgeExecArray{nodes}
}

func (instance *InviteCodeConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateInviteCode"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance InviteCodeConnectionExec) Exec(ctx context.Context) (*InviteCodeConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &InviteCodeConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance InviteCodeConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InviteCodeConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance InviteCodeConnectionExecArray) Exec(ctx context.Context) ([]InviteCodeConnection, error) {
	var v []InviteCodeConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InviteCodeConnectionFields = []string{}

type InviteCodeConnection struct {
	PageInfo PageInfo         `json:"pageInfo"`
	Edges    []InviteCodeEdge `json:"edges"`
}

type InviteCodeEdgeExec struct {
	exec *prisma.Exec
}

func (instance *InviteCodeEdgeExec) Node() *InviteCodeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InviteCode"},
		"node",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodeExec{ret}
}

func (instance InviteCodeEdgeExec) Exec(ctx context.Context) (*InviteCodeEdge, error) {
	var v InviteCodeEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InviteCodeEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InviteCodeEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance InviteCodeEdgeExecArray) Exec(ctx context.Context) ([]InviteCodeEdge, error) {
	var v []InviteCodeEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InviteCodeEdgeFields = []string{"cursor"}

type InviteCodeEdge struct {
	Node   InviteCode `json:"node"`
	Cursor string     `json:"cursor"`
}

type InviteUserHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *InviteUserHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *InviteUserHistoryConnectionExec) Edges() *InviteUserHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"InviteUserHistoryWhereInput", "InviteUserHistoryOrderByInput", "InviteUserHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "InviteUserHistory"},
		"node",
		InviteUserHistoryFields)

	return &InviteUserHistoryEdgeExecArray{nodes}
}

func (instance *InviteUserHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateInviteUserHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance InviteUserHistoryConnectionExec) Exec(ctx context.Context) (*InviteUserHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &InviteUserHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance InviteUserHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InviteUserHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance InviteUserHistoryConnectionExecArray) Exec(ctx context.Context) ([]InviteUserHistoryConnection, error) {
	var v []InviteUserHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InviteUserHistoryConnectionFields = []string{}

type InviteUserHistoryConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []InviteUserHistoryEdge `json:"edges"`
}

type InviteUserHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *InviteUserHistoryEdgeExec) Node() *InviteUserHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InviteUserHistory"},
		"node",
		[]string{"id", "createdAt", "updatedAt"})

	return &InviteUserHistoryExec{ret}
}

func (instance InviteUserHistoryEdgeExec) Exec(ctx context.Context) (*InviteUserHistoryEdge, error) {
	var v InviteUserHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InviteUserHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InviteUserHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance InviteUserHistoryEdgeExecArray) Exec(ctx context.Context) ([]InviteUserHistoryEdge, error) {
	var v []InviteUserHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InviteUserHistoryEdgeFields = []string{"cursor"}

type InviteUserHistoryEdge struct {
	Node   InviteUserHistory `json:"node"`
	Cursor string            `json:"cursor"`
}

type MaintenanceConnectionExec struct {
	exec *prisma.Exec
}

func (instance *MaintenanceConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *MaintenanceConnectionExec) Edges() *MaintenanceEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"MaintenanceWhereInput", "MaintenanceOrderByInput", "MaintenanceEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Maintenance"},
		"node",
		MaintenanceFields)

	return &MaintenanceEdgeExecArray{nodes}
}

func (instance *MaintenanceConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateMaintenance"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance MaintenanceConnectionExec) Exec(ctx context.Context) (*MaintenanceConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &MaintenanceConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance MaintenanceConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MaintenanceConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance MaintenanceConnectionExecArray) Exec(ctx context.Context) ([]MaintenanceConnection, error) {
	var v []MaintenanceConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MaintenanceConnectionFields = []string{}

type MaintenanceConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []MaintenanceEdge `json:"edges"`
}

type MaintenanceEdgeExec struct {
	exec *prisma.Exec
}

func (instance *MaintenanceEdgeExec) Node() *MaintenanceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Maintenance"},
		"node",
		[]string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"})

	return &MaintenanceExec{ret}
}

func (instance MaintenanceEdgeExec) Exec(ctx context.Context) (*MaintenanceEdge, error) {
	var v MaintenanceEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MaintenanceEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MaintenanceEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance MaintenanceEdgeExecArray) Exec(ctx context.Context) ([]MaintenanceEdge, error) {
	var v []MaintenanceEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MaintenanceEdgeFields = []string{"cursor"}

type MaintenanceEdge struct {
	Node   Maintenance `json:"node"`
	Cursor string      `json:"cursor"`
}

type MotherHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *MotherHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *MotherHistoryConnectionExec) Edges() *MotherHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"MotherHistoryWhereInput", "MotherHistoryOrderByInput", "MotherHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "MotherHistory"},
		"node",
		MotherHistoryFields)

	return &MotherHistoryEdgeExecArray{nodes}
}

func (instance *MotherHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateMotherHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance MotherHistoryConnectionExec) Exec(ctx context.Context) (*MotherHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &MotherHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance MotherHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MotherHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance MotherHistoryConnectionExecArray) Exec(ctx context.Context) ([]MotherHistoryConnection, error) {
	var v []MotherHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MotherHistoryConnectionFields = []string{}

type MotherHistoryConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []MotherHistoryEdge `json:"edges"`
}

type MotherHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *MotherHistoryEdgeExec) Node() *MotherHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MotherHistory"},
		"node",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (instance MotherHistoryEdgeExec) Exec(ctx context.Context) (*MotherHistoryEdge, error) {
	var v MotherHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MotherHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MotherHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance MotherHistoryEdgeExecArray) Exec(ctx context.Context) ([]MotherHistoryEdge, error) {
	var v []MotherHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MotherHistoryEdgeFields = []string{"cursor"}

type MotherHistoryEdge struct {
	Node   MotherHistory `json:"node"`
	Cursor string        `json:"cursor"`
}

type NotificationConnectionExec struct {
	exec *prisma.Exec
}

func (instance *NotificationConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *NotificationConnectionExec) Edges() *NotificationEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"NotificationWhereInput", "NotificationOrderByInput", "NotificationEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Notification"},
		"node",
		NotificationFields)

	return &NotificationEdgeExecArray{nodes}
}

func (instance *NotificationConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateNotification"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance NotificationConnectionExec) Exec(ctx context.Context) (*NotificationConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &NotificationConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance NotificationConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NotificationConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance NotificationConnectionExecArray) Exec(ctx context.Context) ([]NotificationConnection, error) {
	var v []NotificationConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NotificationConnectionFields = []string{}

type NotificationConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []NotificationEdge `json:"edges"`
}

type NotificationEdgeExec struct {
	exec *prisma.Exec
}

func (instance *NotificationEdgeExec) Node() *NotificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Notification"},
		"node",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationExec{ret}
}

func (instance NotificationEdgeExec) Exec(ctx context.Context) (*NotificationEdge, error) {
	var v NotificationEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NotificationEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NotificationEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance NotificationEdgeExecArray) Exec(ctx context.Context) ([]NotificationEdge, error) {
	var v []NotificationEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NotificationEdgeFields = []string{"cursor"}

type NotificationEdge struct {
	Node   Notification `json:"node"`
	Cursor string       `json:"cursor"`
}

type OfferConnectionExec struct {
	exec *prisma.Exec
}

func (instance *OfferConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *OfferConnectionExec) Edges() *OfferEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"OfferWhereInput", "OfferOrderByInput", "OfferEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Offer"},
		"node",
		OfferFields)

	return &OfferEdgeExecArray{nodes}
}

func (instance *OfferConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateOffer"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance OfferConnectionExec) Exec(ctx context.Context) (*OfferConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &OfferConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance OfferConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OfferConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance OfferConnectionExecArray) Exec(ctx context.Context) ([]OfferConnection, error) {
	var v []OfferConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OfferConnectionFields = []string{}

type OfferConnection struct {
	PageInfo PageInfo    `json:"pageInfo"`
	Edges    []OfferEdge `json:"edges"`
}

type OfferEdgeExec struct {
	exec *prisma.Exec
}

func (instance *OfferEdgeExec) Node() *OfferExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Offer"},
		"node",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferExec{ret}
}

func (instance OfferEdgeExec) Exec(ctx context.Context) (*OfferEdge, error) {
	var v OfferEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OfferEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OfferEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance OfferEdgeExecArray) Exec(ctx context.Context) ([]OfferEdge, error) {
	var v []OfferEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OfferEdgeFields = []string{"cursor"}

type OfferEdge struct {
	Node   Offer  `json:"node"`
	Cursor string `json:"cursor"`
}

type OfferorConnectionExec struct {
	exec *prisma.Exec
}

func (instance *OfferorConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *OfferorConnectionExec) Edges() *OfferorEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"OfferorWhereInput", "OfferorOrderByInput", "OfferorEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Offeror"},
		"node",
		OfferorFields)

	return &OfferorEdgeExecArray{nodes}
}

func (instance *OfferorConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateOfferor"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance OfferorConnectionExec) Exec(ctx context.Context) (*OfferorConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &OfferorConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance OfferorConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OfferorConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance OfferorConnectionExecArray) Exec(ctx context.Context) ([]OfferorConnection, error) {
	var v []OfferorConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OfferorConnectionFields = []string{}

type OfferorConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []OfferorEdge `json:"edges"`
}

type OfferorEdgeExec struct {
	exec *prisma.Exec
}

func (instance *OfferorEdgeExec) Node() *OfferorExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Offeror"},
		"node",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorExec{ret}
}

func (instance OfferorEdgeExec) Exec(ctx context.Context) (*OfferorEdge, error) {
	var v OfferorEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OfferorEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OfferorEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance OfferorEdgeExecArray) Exec(ctx context.Context) ([]OfferorEdge, error) {
	var v []OfferorEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OfferorEdgeFields = []string{"cursor"}

type OfferorEdge struct {
	Node   Offeror `json:"node"`
	Cursor string  `json:"cursor"`
}

type OrderDealsHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *OrderDealsHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *OrderDealsHistoryConnectionExec) Edges() *OrderDealsHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"OrderDealsHistoryWhereInput", "OrderDealsHistoryOrderByInput", "OrderDealsHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "OrderDealsHistory"},
		"node",
		OrderDealsHistoryFields)

	return &OrderDealsHistoryEdgeExecArray{nodes}
}

func (instance *OrderDealsHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateOrderDealsHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance OrderDealsHistoryConnectionExec) Exec(ctx context.Context) (*OrderDealsHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &OrderDealsHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance OrderDealsHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderDealsHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance OrderDealsHistoryConnectionExecArray) Exec(ctx context.Context) ([]OrderDealsHistoryConnection, error) {
	var v []OrderDealsHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderDealsHistoryConnectionFields = []string{}

type OrderDealsHistoryConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []OrderDealsHistoryEdge `json:"edges"`
}

type OrderDealsHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *OrderDealsHistoryEdgeExec) Node() *OrderDealsHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderDealsHistory"},
		"node",
		[]string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"})

	return &OrderDealsHistoryExec{ret}
}

func (instance OrderDealsHistoryEdgeExec) Exec(ctx context.Context) (*OrderDealsHistoryEdge, error) {
	var v OrderDealsHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderDealsHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderDealsHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance OrderDealsHistoryEdgeExecArray) Exec(ctx context.Context) ([]OrderDealsHistoryEdge, error) {
	var v []OrderDealsHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderDealsHistoryEdgeFields = []string{"cursor"}

type OrderDealsHistoryEdge struct {
	Node   OrderDealsHistory `json:"node"`
	Cursor string            `json:"cursor"`
}

type OrderHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *OrderHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *OrderHistoryConnectionExec) Edges() *OrderHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"OrderHistoryWhereInput", "OrderHistoryOrderByInput", "OrderHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "OrderHistory"},
		"node",
		OrderHistoryFields)

	return &OrderHistoryEdgeExecArray{nodes}
}

func (instance *OrderHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateOrderHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance OrderHistoryConnectionExec) Exec(ctx context.Context) (*OrderHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &OrderHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance OrderHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance OrderHistoryConnectionExecArray) Exec(ctx context.Context) ([]OrderHistoryConnection, error) {
	var v []OrderHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderHistoryConnectionFields = []string{}

type OrderHistoryConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []OrderHistoryEdge `json:"edges"`
}

type OrderHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *OrderHistoryEdgeExec) Node() *OrderHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderHistory"},
		"node",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExec{ret}
}

func (instance OrderHistoryEdgeExec) Exec(ctx context.Context) (*OrderHistoryEdge, error) {
	var v OrderHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance OrderHistoryEdgeExecArray) Exec(ctx context.Context) ([]OrderHistoryEdge, error) {
	var v []OrderHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderHistoryEdgeFields = []string{"cursor"}

type OrderHistoryEdge struct {
	Node   OrderHistory `json:"node"`
	Cursor string       `json:"cursor"`
}

type OrderUserDealsHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *OrderUserDealsHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *OrderUserDealsHistoryConnectionExec) Edges() *OrderUserDealsHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"OrderUserDealsHistoryWhereInput", "OrderUserDealsHistoryOrderByInput", "OrderUserDealsHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "OrderUserDealsHistory"},
		"node",
		OrderUserDealsHistoryFields)

	return &OrderUserDealsHistoryEdgeExecArray{nodes}
}

func (instance *OrderUserDealsHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateOrderUserDealsHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance OrderUserDealsHistoryConnectionExec) Exec(ctx context.Context) (*OrderUserDealsHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &OrderUserDealsHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance OrderUserDealsHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderUserDealsHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance OrderUserDealsHistoryConnectionExecArray) Exec(ctx context.Context) ([]OrderUserDealsHistoryConnection, error) {
	var v []OrderUserDealsHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderUserDealsHistoryConnectionFields = []string{}

type OrderUserDealsHistoryConnection struct {
	PageInfo PageInfo                    `json:"pageInfo"`
	Edges    []OrderUserDealsHistoryEdge `json:"edges"`
}

type OrderUserDealsHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *OrderUserDealsHistoryEdgeExec) Node() *OrderUserDealsHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderUserDealsHistory"},
		"node",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExec{ret}
}

func (instance OrderUserDealsHistoryEdgeExec) Exec(ctx context.Context) (*OrderUserDealsHistoryEdge, error) {
	var v OrderUserDealsHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderUserDealsHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderUserDealsHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance OrderUserDealsHistoryEdgeExecArray) Exec(ctx context.Context) ([]OrderUserDealsHistoryEdge, error) {
	var v []OrderUserDealsHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderUserDealsHistoryEdgeFields = []string{"cursor"}

type OrderUserDealsHistoryEdge struct {
	Node   OrderUserDealsHistory `json:"node"`
	Cursor string                `json:"cursor"`
}

type PageConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PageConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PageConnectionExec) Edges() *PageEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PageWhereInput", "PageOrderByInput", "PageEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Page"},
		"node",
		PageFields)

	return &PageEdgeExecArray{nodes}
}

func (instance *PageConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePage"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PageConnectionExec) Exec(ctx context.Context) (*PageConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PageConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PageConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PageConnectionExecArray) Exec(ctx context.Context) ([]PageConnection, error) {
	var v []PageConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageConnectionFields = []string{}

type PageConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []PageEdge `json:"edges"`
}

type PageEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PageEdgeExec) Node() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"node",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance PageEdgeExec) Exec(ctx context.Context) (*PageEdge, error) {
	var v PageEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PageEdgeExecArray) Exec(ctx context.Context) ([]PageEdge, error) {
	var v []PageEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageEdgeFields = []string{"cursor"}

type PageEdge struct {
	Node   Page   `json:"node"`
	Cursor string `json:"cursor"`
}

type PageBadgeConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PageBadgeConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PageBadgeConnectionExec) Edges() *PageBadgeEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PageBadgeWhereInput", "PageBadgeOrderByInput", "PageBadgeEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "PageBadge"},
		"node",
		PageBadgeFields)

	return &PageBadgeEdgeExecArray{nodes}
}

func (instance *PageBadgeConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePageBadge"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PageBadgeConnectionExec) Exec(ctx context.Context) (*PageBadgeConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PageBadgeConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PageBadgeConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageBadgeConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PageBadgeConnectionExecArray) Exec(ctx context.Context) ([]PageBadgeConnection, error) {
	var v []PageBadgeConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageBadgeConnectionFields = []string{}

type PageBadgeConnection struct {
	PageInfo PageInfo        `json:"pageInfo"`
	Edges    []PageBadgeEdge `json:"edges"`
}

type PageBadgeEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PageBadgeEdgeExec) Node() *PageBadgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageBadge"},
		"node",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExec{ret}
}

func (instance PageBadgeEdgeExec) Exec(ctx context.Context) (*PageBadgeEdge, error) {
	var v PageBadgeEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageBadgeEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageBadgeEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PageBadgeEdgeExecArray) Exec(ctx context.Context) ([]PageBadgeEdge, error) {
	var v []PageBadgeEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageBadgeEdgeFields = []string{"cursor"}

type PageBadgeEdge struct {
	Node   PageBadge `json:"node"`
	Cursor string    `json:"cursor"`
}

type PageCommentConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PageCommentConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PageCommentConnectionExec) Edges() *PageCommentEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PageCommentWhereInput", "PageCommentOrderByInput", "PageCommentEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "PageComment"},
		"node",
		PageCommentFields)

	return &PageCommentEdgeExecArray{nodes}
}

func (instance *PageCommentConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePageComment"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PageCommentConnectionExec) Exec(ctx context.Context) (*PageCommentConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PageCommentConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PageCommentConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageCommentConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PageCommentConnectionExecArray) Exec(ctx context.Context) ([]PageCommentConnection, error) {
	var v []PageCommentConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageCommentConnectionFields = []string{}

type PageCommentConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []PageCommentEdge `json:"edges"`
}

type PageCommentEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PageCommentEdgeExec) Node() *PageCommentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageComment"},
		"node",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExec{ret}
}

func (instance PageCommentEdgeExec) Exec(ctx context.Context) (*PageCommentEdge, error) {
	var v PageCommentEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageCommentEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageCommentEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PageCommentEdgeExecArray) Exec(ctx context.Context) ([]PageCommentEdge, error) {
	var v []PageCommentEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageCommentEdgeFields = []string{"cursor"}

type PageCommentEdge struct {
	Node   PageComment `json:"node"`
	Cursor string      `json:"cursor"`
}

type PageCommentReplyConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PageCommentReplyConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PageCommentReplyConnectionExec) Edges() *PageCommentReplyEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PageCommentReplyWhereInput", "PageCommentReplyOrderByInput", "PageCommentReplyEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "PageCommentReply"},
		"node",
		PageCommentReplyFields)

	return &PageCommentReplyEdgeExecArray{nodes}
}

func (instance *PageCommentReplyConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePageCommentReply"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PageCommentReplyConnectionExec) Exec(ctx context.Context) (*PageCommentReplyConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PageCommentReplyConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PageCommentReplyConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageCommentReplyConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PageCommentReplyConnectionExecArray) Exec(ctx context.Context) ([]PageCommentReplyConnection, error) {
	var v []PageCommentReplyConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageCommentReplyConnectionFields = []string{}

type PageCommentReplyConnection struct {
	PageInfo PageInfo               `json:"pageInfo"`
	Edges    []PageCommentReplyEdge `json:"edges"`
}

type PageCommentReplyEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PageCommentReplyEdgeExec) Node() *PageCommentReplyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageCommentReply"},
		"node",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentReplyExec{ret}
}

func (instance PageCommentReplyEdgeExec) Exec(ctx context.Context) (*PageCommentReplyEdge, error) {
	var v PageCommentReplyEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageCommentReplyEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageCommentReplyEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PageCommentReplyEdgeExecArray) Exec(ctx context.Context) ([]PageCommentReplyEdge, error) {
	var v []PageCommentReplyEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageCommentReplyEdgeFields = []string{"cursor"}

type PageCommentReplyEdge struct {
	Node   PageCommentReply `json:"node"`
	Cursor string           `json:"cursor"`
}

type PageFanConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PageFanConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PageFanConnectionExec) Edges() *PageFanEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PageFanWhereInput", "PageFanOrderByInput", "PageFanEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "PageFan"},
		"node",
		PageFanFields)

	return &PageFanEdgeExecArray{nodes}
}

func (instance *PageFanConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePageFan"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PageFanConnectionExec) Exec(ctx context.Context) (*PageFanConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PageFanConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PageFanConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageFanConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PageFanConnectionExecArray) Exec(ctx context.Context) ([]PageFanConnection, error) {
	var v []PageFanConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageFanConnectionFields = []string{}

type PageFanConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []PageFanEdge `json:"edges"`
}

type PageFanEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PageFanEdgeExec) Node() *PageFanExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageFan"},
		"node",
		[]string{"id", "createdAt", "updatedAt"})

	return &PageFanExec{ret}
}

func (instance PageFanEdgeExec) Exec(ctx context.Context) (*PageFanEdge, error) {
	var v PageFanEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageFanEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageFanEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PageFanEdgeExecArray) Exec(ctx context.Context) ([]PageFanEdge, error) {
	var v []PageFanEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageFanEdgeFields = []string{"cursor"}

type PageFanEdge struct {
	Node   PageFan `json:"node"`
	Cursor string  `json:"cursor"`
}

type PaymentHistoryExec struct {
	exec *prisma.Exec
}

func (instance *PaymentHistoryExec) User() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"user",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance PaymentHistoryExec) Exec(ctx context.Context) (*PaymentHistory, error) {
	var v PaymentHistory
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentHistoryExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentHistoryExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentHistoryExecArray) Exec(ctx context.Context) ([]PaymentHistory, error) {
	var v []PaymentHistory
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PaymentHistoryFields = []string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"}

type PaymentHistory struct {
	ID               string  `json:"id"`
	Code             *string `json:"code,omitempty"`
	Message          *string `json:"message,omitempty"`
	OrderNo          *string `json:"order_no,omitempty"`
	ServiceName      *string `json:"service_name,omitempty"`
	ProductName      *string `json:"product_name,omitempty"`
	CustomParameter  *string `json:"custom_parameter,omitempty"`
	Tid              *string `json:"tid,omitempty"`
	Cid              *string `json:"cid,omitempty"`
	Amount           *int32  `json:"amount,omitempty"`
	AmountFee        *int32  `json:"amount_fee,omitempty"`
	AmountWithoutFee *int32  `json:"amount_without_fee,omitempty"`
	Pgcode           *string `json:"pgcode,omitempty"`
	PayInfo          *string `json:"pay_info,omitempty"`
	DomesticFlag     *string `json:"domestic_flag,omitempty"`
	TransactionDate  *string `json:"transaction_date,omitempty"`
	InstallMonth     *string `json:"install_month,omitempty"`
	CardInfo         *string `json:"card_info,omitempty"`
	Payhash          *string `json:"payhash,omitempty"`
	AccountNo        *string `json:"account_no,omitempty"`
	AccountName      *string `json:"account_name,omitempty"`
	BankCode         *string `json:"bank_code,omitempty"`
	BankName         *string `json:"bank_name,omitempty"`
	ExpireDate       *string `json:"expire_date,omitempty"`
	ExpireTime       *string `json:"expire_time,omitempty"`
	IssueTid         *string `json:"issue_tid,omitempty"`
	CreatedAt        string  `json:"createdAt"`
}

type PaymentHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PaymentHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PaymentHistoryConnectionExec) Edges() *PaymentHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PaymentHistoryWhereInput", "PaymentHistoryOrderByInput", "PaymentHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "PaymentHistory"},
		"node",
		PaymentHistoryFields)

	return &PaymentHistoryEdgeExecArray{nodes}
}

func (instance *PaymentHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePaymentHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PaymentHistoryConnectionExec) Exec(ctx context.Context) (*PaymentHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PaymentHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PaymentHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentHistoryConnectionExecArray) Exec(ctx context.Context) ([]PaymentHistoryConnection, error) {
	var v []PaymentHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PaymentHistoryConnectionFields = []string{}

type PaymentHistoryConnection struct {
	PageInfo PageInfo             `json:"pageInfo"`
	Edges    []PaymentHistoryEdge `json:"edges"`
}

type PaymentHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PaymentHistoryEdgeExec) Node() *PaymentHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentHistory"},
		"node",
		[]string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"})

	return &PaymentHistoryExec{ret}
}

func (instance PaymentHistoryEdgeExec) Exec(ctx context.Context) (*PaymentHistoryEdge, error) {
	var v PaymentHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentHistoryEdgeExecArray) Exec(ctx context.Context) ([]PaymentHistoryEdge, error) {
	var v []PaymentHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PaymentHistoryEdgeFields = []string{"cursor"}

type PaymentHistoryEdge struct {
	Node   PaymentHistory `json:"node"`
	Cursor string         `json:"cursor"`
}

type PhoneVerificationConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PhoneVerificationConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PhoneVerificationConnectionExec) Edges() *PhoneVerificationEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PhoneVerificationWhereInput", "PhoneVerificationOrderByInput", "PhoneVerificationEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "PhoneVerification"},
		"node",
		PhoneVerificationFields)

	return &PhoneVerificationEdgeExecArray{nodes}
}

func (instance *PhoneVerificationConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePhoneVerification"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PhoneVerificationConnectionExec) Exec(ctx context.Context) (*PhoneVerificationConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PhoneVerificationConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PhoneVerificationConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneVerificationConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneVerificationConnectionExecArray) Exec(ctx context.Context) ([]PhoneVerificationConnection, error) {
	var v []PhoneVerificationConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PhoneVerificationConnectionFields = []string{}

type PhoneVerificationConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []PhoneVerificationEdge `json:"edges"`
}

type PhoneVerificationEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PhoneVerificationEdgeExec) Node() *PhoneVerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneVerification"},
		"node",
		[]string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"})

	return &PhoneVerificationExec{ret}
}

func (instance PhoneVerificationEdgeExec) Exec(ctx context.Context) (*PhoneVerificationEdge, error) {
	var v PhoneVerificationEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneVerificationEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneVerificationEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneVerificationEdgeExecArray) Exec(ctx context.Context) ([]PhoneVerificationEdge, error) {
	var v []PhoneVerificationEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PhoneVerificationEdgeFields = []string{"cursor"}

type PhoneVerificationEdge struct {
	Node   PhoneVerification `json:"node"`
	Cursor string            `json:"cursor"`
}

type PostConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PostConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PostConnectionExec) Edges() *PostEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PostWhereInput", "PostOrderByInput", "PostEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Post"},
		"node",
		PostFields)

	return &PostEdgeExecArray{nodes}
}

func (instance *PostConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePost"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PostConnectionExec) Exec(ctx context.Context) (*PostConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PostConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PostConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PostConnectionExecArray) Exec(ctx context.Context) ([]PostConnection, error) {
	var v []PostConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostConnectionFields = []string{}

type PostConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []PostEdge `json:"edges"`
}

type PostEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PostEdgeExec) Node() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"node",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance PostEdgeExec) Exec(ctx context.Context) (*PostEdge, error) {
	var v PostEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PostEdgeExecArray) Exec(ctx context.Context) ([]PostEdge, error) {
	var v []PostEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostEdgeFields = []string{"cursor"}

type PostEdge struct {
	Node   Post   `json:"node"`
	Cursor string `json:"cursor"`
}

type PostRewardHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *PostRewardHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *PostRewardHistoryConnectionExec) Edges() *PostRewardHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"PostRewardHistoryWhereInput", "PostRewardHistoryOrderByInput", "PostRewardHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "PostRewardHistory"},
		"node",
		PostRewardHistoryFields)

	return &PostRewardHistoryEdgeExecArray{nodes}
}

func (instance *PostRewardHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregatePostRewardHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance PostRewardHistoryConnectionExec) Exec(ctx context.Context) (*PostRewardHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &PostRewardHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance PostRewardHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostRewardHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance PostRewardHistoryConnectionExecArray) Exec(ctx context.Context) ([]PostRewardHistoryConnection, error) {
	var v []PostRewardHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostRewardHistoryConnectionFields = []string{}

type PostRewardHistoryConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []PostRewardHistoryEdge `json:"edges"`
}

type PostRewardHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *PostRewardHistoryEdgeExec) Node() *PostRewardHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PostRewardHistory"},
		"node",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExec{ret}
}

func (instance PostRewardHistoryEdgeExec) Exec(ctx context.Context) (*PostRewardHistoryEdge, error) {
	var v PostRewardHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostRewardHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostRewardHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance PostRewardHistoryEdgeExecArray) Exec(ctx context.Context) ([]PostRewardHistoryEdge, error) {
	var v []PostRewardHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostRewardHistoryEdgeFields = []string{"cursor"}

type PostRewardHistoryEdge struct {
	Node   PostRewardHistory `json:"node"`
	Cursor string            `json:"cursor"`
}

type QuestExpenditureHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *QuestExpenditureHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *QuestExpenditureHistoryConnectionExec) Edges() *QuestExpenditureHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"QuestExpenditureHistoryWhereInput", "QuestExpenditureHistoryOrderByInput", "QuestExpenditureHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "QuestExpenditureHistory"},
		"node",
		QuestExpenditureHistoryFields)

	return &QuestExpenditureHistoryEdgeExecArray{nodes}
}

func (instance *QuestExpenditureHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateQuestExpenditureHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance QuestExpenditureHistoryConnectionExec) Exec(ctx context.Context) (*QuestExpenditureHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &QuestExpenditureHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance QuestExpenditureHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type QuestExpenditureHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance QuestExpenditureHistoryConnectionExecArray) Exec(ctx context.Context) ([]QuestExpenditureHistoryConnection, error) {
	var v []QuestExpenditureHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var QuestExpenditureHistoryConnectionFields = []string{}

type QuestExpenditureHistoryConnection struct {
	PageInfo PageInfo                      `json:"pageInfo"`
	Edges    []QuestExpenditureHistoryEdge `json:"edges"`
}

type QuestExpenditureHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *QuestExpenditureHistoryEdgeExec) Node() *QuestExpenditureHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "QuestExpenditureHistory"},
		"node",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExec{ret}
}

func (instance QuestExpenditureHistoryEdgeExec) Exec(ctx context.Context) (*QuestExpenditureHistoryEdge, error) {
	var v QuestExpenditureHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance QuestExpenditureHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type QuestExpenditureHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance QuestExpenditureHistoryEdgeExecArray) Exec(ctx context.Context) ([]QuestExpenditureHistoryEdge, error) {
	var v []QuestExpenditureHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var QuestExpenditureHistoryEdgeFields = []string{"cursor"}

type QuestExpenditureHistoryEdge struct {
	Node   QuestExpenditureHistory `json:"node"`
	Cursor string                  `json:"cursor"`
}

type QuestMemberConnectionExec struct {
	exec *prisma.Exec
}

func (instance *QuestMemberConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *QuestMemberConnectionExec) Edges() *QuestMemberEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"QuestMemberWhereInput", "QuestMemberOrderByInput", "QuestMemberEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "QuestMember"},
		"node",
		QuestMemberFields)

	return &QuestMemberEdgeExecArray{nodes}
}

func (instance *QuestMemberConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateQuestMember"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance QuestMemberConnectionExec) Exec(ctx context.Context) (*QuestMemberConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &QuestMemberConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance QuestMemberConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type QuestMemberConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance QuestMemberConnectionExecArray) Exec(ctx context.Context) ([]QuestMemberConnection, error) {
	var v []QuestMemberConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var QuestMemberConnectionFields = []string{}

type QuestMemberConnection struct {
	PageInfo PageInfo          `json:"pageInfo"`
	Edges    []QuestMemberEdge `json:"edges"`
}

type QuestMemberEdgeExec struct {
	exec *prisma.Exec
}

func (instance *QuestMemberEdgeExec) Node() *QuestMemberExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "QuestMember"},
		"node",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberExec{ret}
}

func (instance QuestMemberEdgeExec) Exec(ctx context.Context) (*QuestMemberEdge, error) {
	var v QuestMemberEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance QuestMemberEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type QuestMemberEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance QuestMemberEdgeExecArray) Exec(ctx context.Context) ([]QuestMemberEdge, error) {
	var v []QuestMemberEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var QuestMemberEdgeFields = []string{"cursor"}

type QuestMemberEdge struct {
	Node   QuestMember `json:"node"`
	Cursor string      `json:"cursor"`
}

type ReportConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ReportConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ReportConnectionExec) Edges() *ReportEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ReportWhereInput", "ReportOrderByInput", "ReportEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Report"},
		"node",
		ReportFields)

	return &ReportEdgeExecArray{nodes}
}

func (instance *ReportConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateReport"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ReportConnectionExec) Exec(ctx context.Context) (*ReportConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ReportConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ReportConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReportConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ReportConnectionExecArray) Exec(ctx context.Context) ([]ReportConnection, error) {
	var v []ReportConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReportConnectionFields = []string{}

type ReportConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []ReportEdge `json:"edges"`
}

type ReportEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ReportEdgeExec) Node() *ReportExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Report"},
		"node",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportExec{ret}
}

func (instance ReportEdgeExec) Exec(ctx context.Context) (*ReportEdge, error) {
	var v ReportEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReportEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReportEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ReportEdgeExecArray) Exec(ctx context.Context) ([]ReportEdge, error) {
	var v []ReportEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReportEdgeFields = []string{"cursor"}

type ReportEdge struct {
	Node   Report `json:"node"`
	Cursor string `json:"cursor"`
}

type RequestPageItemConnectionExec struct {
	exec *prisma.Exec
}

func (instance *RequestPageItemConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *RequestPageItemConnectionExec) Edges() *RequestPageItemEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"RequestPageItemWhereInput", "RequestPageItemOrderByInput", "RequestPageItemEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "RequestPageItem"},
		"node",
		RequestPageItemFields)

	return &RequestPageItemEdgeExecArray{nodes}
}

func (instance *RequestPageItemConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateRequestPageItem"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance RequestPageItemConnectionExec) Exec(ctx context.Context) (*RequestPageItemConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &RequestPageItemConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance RequestPageItemConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RequestPageItemConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance RequestPageItemConnectionExecArray) Exec(ctx context.Context) ([]RequestPageItemConnection, error) {
	var v []RequestPageItemConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RequestPageItemConnectionFields = []string{}

type RequestPageItemConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []RequestPageItemEdge `json:"edges"`
}

type RequestPageItemEdgeExec struct {
	exec *prisma.Exec
}

func (instance *RequestPageItemEdgeExec) Node() *RequestPageItemExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RequestPageItem"},
		"node",
		[]string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"})

	return &RequestPageItemExec{ret}
}

func (instance RequestPageItemEdgeExec) Exec(ctx context.Context) (*RequestPageItemEdge, error) {
	var v RequestPageItemEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RequestPageItemEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RequestPageItemEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance RequestPageItemEdgeExecArray) Exec(ctx context.Context) ([]RequestPageItemEdge, error) {
	var v []RequestPageItemEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RequestPageItemEdgeFields = []string{"cursor"}

type RequestPageItemEdge struct {
	Node   RequestPageItem `json:"node"`
	Cursor string          `json:"cursor"`
}

type ReviewContentConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ReviewContentConnectionExec) Edges() *ReviewContentEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ReviewContentWhereInput", "ReviewContentOrderByInput", "ReviewContentEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ReviewContent"},
		"node",
		ReviewContentFields)

	return &ReviewContentEdgeExecArray{nodes}
}

func (instance *ReviewContentConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateReviewContent"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ReviewContentConnectionExec) Exec(ctx context.Context) (*ReviewContentConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ReviewContentConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ReviewContentConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentConnectionExecArray) Exec(ctx context.Context) ([]ReviewContentConnection, error) {
	var v []ReviewContentConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentConnectionFields = []string{}

type ReviewContentConnection struct {
	PageInfo PageInfo            `json:"pageInfo"`
	Edges    []ReviewContentEdge `json:"edges"`
}

type ReviewContentEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentEdgeExec) Node() *ReviewContentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContent"},
		"node",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExec{ret}
}

func (instance ReviewContentEdgeExec) Exec(ctx context.Context) (*ReviewContentEdge, error) {
	var v ReviewContentEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentEdgeExecArray) Exec(ctx context.Context) ([]ReviewContentEdge, error) {
	var v []ReviewContentEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentEdgeFields = []string{"cursor"}

type ReviewContentEdge struct {
	Node   ReviewContent `json:"node"`
	Cursor string        `json:"cursor"`
}

type ReviewContentCategoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentCategoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ReviewContentCategoryConnectionExec) Edges() *ReviewContentCategoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ReviewContentCategoryWhereInput", "ReviewContentCategoryOrderByInput", "ReviewContentCategoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ReviewContentCategory"},
		"node",
		ReviewContentCategoryFields)

	return &ReviewContentCategoryEdgeExecArray{nodes}
}

func (instance *ReviewContentCategoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateReviewContentCategory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ReviewContentCategoryConnectionExec) Exec(ctx context.Context) (*ReviewContentCategoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ReviewContentCategoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ReviewContentCategoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentCategoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentCategoryConnectionExecArray) Exec(ctx context.Context) ([]ReviewContentCategoryConnection, error) {
	var v []ReviewContentCategoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentCategoryConnectionFields = []string{}

type ReviewContentCategoryConnection struct {
	PageInfo PageInfo                    `json:"pageInfo"`
	Edges    []ReviewContentCategoryEdge `json:"edges"`
}

type ReviewContentCategoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentCategoryEdgeExec) Node() *ReviewContentCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentCategory"},
		"node",
		[]string{"id", "name", "imageUrl", "createdAt", "updatedAt"})

	return &ReviewContentCategoryExec{ret}
}

func (instance ReviewContentCategoryEdgeExec) Exec(ctx context.Context) (*ReviewContentCategoryEdge, error) {
	var v ReviewContentCategoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentCategoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentCategoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentCategoryEdgeExecArray) Exec(ctx context.Context) ([]ReviewContentCategoryEdge, error) {
	var v []ReviewContentCategoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentCategoryEdgeFields = []string{"cursor"}

type ReviewContentCategoryEdge struct {
	Node   ReviewContentCategory `json:"node"`
	Cursor string                `json:"cursor"`
}

type ReviewContentPageConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ReviewContentPageConnectionExec) Edges() *ReviewContentPageEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ReviewContentPageWhereInput", "ReviewContentPageOrderByInput", "ReviewContentPageEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ReviewContentPage"},
		"node",
		ReviewContentPageFields)

	return &ReviewContentPageEdgeExecArray{nodes}
}

func (instance *ReviewContentPageConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateReviewContentPage"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ReviewContentPageConnectionExec) Exec(ctx context.Context) (*ReviewContentPageConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ReviewContentPageConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ReviewContentPageConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageConnectionExecArray) Exec(ctx context.Context) ([]ReviewContentPageConnection, error) {
	var v []ReviewContentPageConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageConnectionFields = []string{}

type ReviewContentPageConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []ReviewContentPageEdge `json:"edges"`
}

type ReviewContentPageEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageEdgeExec) Node() *ReviewContentPageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPage"},
		"node",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

func (instance ReviewContentPageEdgeExec) Exec(ctx context.Context) (*ReviewContentPageEdge, error) {
	var v ReviewContentPageEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageEdgeExecArray) Exec(ctx context.Context) ([]ReviewContentPageEdge, error) {
	var v []ReviewContentPageEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageEdgeFields = []string{"cursor"}

type ReviewContentPageEdge struct {
	Node   ReviewContentPage `json:"node"`
	Cursor string            `json:"cursor"`
}

type ReviewContentPageFeedBackConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageFeedBackConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ReviewContentPageFeedBackConnectionExec) Edges() *ReviewContentPageFeedBackEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ReviewContentPageFeedBackWhereInput", "ReviewContentPageFeedBackOrderByInput", "ReviewContentPageFeedBackEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ReviewContentPageFeedBack"},
		"node",
		ReviewContentPageFeedBackFields)

	return &ReviewContentPageFeedBackEdgeExecArray{nodes}
}

func (instance *ReviewContentPageFeedBackConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateReviewContentPageFeedBack"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ReviewContentPageFeedBackConnectionExec) Exec(ctx context.Context) (*ReviewContentPageFeedBackConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ReviewContentPageFeedBackConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ReviewContentPageFeedBackConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageFeedBackConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageFeedBackConnectionExecArray) Exec(ctx context.Context) ([]ReviewContentPageFeedBackConnection, error) {
	var v []ReviewContentPageFeedBackConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageFeedBackConnectionFields = []string{}

type ReviewContentPageFeedBackConnection struct {
	PageInfo PageInfo                        `json:"pageInfo"`
	Edges    []ReviewContentPageFeedBackEdge `json:"edges"`
}

type ReviewContentPageFeedBackEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageFeedBackEdgeExec) Node() *ReviewContentPageFeedBackExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPageFeedBack"},
		"node",
		[]string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"})

	return &ReviewContentPageFeedBackExec{ret}
}

func (instance ReviewContentPageFeedBackEdgeExec) Exec(ctx context.Context) (*ReviewContentPageFeedBackEdge, error) {
	var v ReviewContentPageFeedBackEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageFeedBackEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageFeedBackEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageFeedBackEdgeExecArray) Exec(ctx context.Context) ([]ReviewContentPageFeedBackEdge, error) {
	var v []ReviewContentPageFeedBackEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageFeedBackEdgeFields = []string{"cursor"}

type ReviewContentPageFeedBackEdge struct {
	Node   ReviewContentPageFeedBack `json:"node"`
	Cursor string                    `json:"cursor"`
}

type ReviewContentPageViewerConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageViewerConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ReviewContentPageViewerConnectionExec) Edges() *ReviewContentPageViewerEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ReviewContentPageViewerWhereInput", "ReviewContentPageViewerOrderByInput", "ReviewContentPageViewerEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ReviewContentPageViewer"},
		"node",
		ReviewContentPageViewerFields)

	return &ReviewContentPageViewerEdgeExecArray{nodes}
}

func (instance *ReviewContentPageViewerConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateReviewContentPageViewer"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ReviewContentPageViewerConnectionExec) Exec(ctx context.Context) (*ReviewContentPageViewerConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ReviewContentPageViewerConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ReviewContentPageViewerConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageViewerConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageViewerConnectionExecArray) Exec(ctx context.Context) ([]ReviewContentPageViewerConnection, error) {
	var v []ReviewContentPageViewerConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageViewerConnectionFields = []string{}

type ReviewContentPageViewerConnection struct {
	PageInfo PageInfo                      `json:"pageInfo"`
	Edges    []ReviewContentPageViewerEdge `json:"edges"`
}

type ReviewContentPageViewerEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageViewerEdgeExec) Node() *ReviewContentPageViewerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPageViewer"},
		"node",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentPageViewerExec{ret}
}

func (instance ReviewContentPageViewerEdgeExec) Exec(ctx context.Context) (*ReviewContentPageViewerEdge, error) {
	var v ReviewContentPageViewerEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageViewerEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageViewerEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageViewerEdgeExecArray) Exec(ctx context.Context) ([]ReviewContentPageViewerEdge, error) {
	var v []ReviewContentPageViewerEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageViewerEdgeFields = []string{"cursor"}

type ReviewContentPageViewerEdge struct {
	Node   ReviewContentPageViewer `json:"node"`
	Cursor string                  `json:"cursor"`
}

type ReviewContentReviewerConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentReviewerConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ReviewContentReviewerConnectionExec) Edges() *ReviewContentReviewerEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ReviewContentReviewerWhereInput", "ReviewContentReviewerOrderByInput", "ReviewContentReviewerEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ReviewContentReviewer"},
		"node",
		ReviewContentReviewerFields)

	return &ReviewContentReviewerEdgeExecArray{nodes}
}

func (instance *ReviewContentReviewerConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateReviewContentReviewer"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ReviewContentReviewerConnectionExec) Exec(ctx context.Context) (*ReviewContentReviewerConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ReviewContentReviewerConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ReviewContentReviewerConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentReviewerConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentReviewerConnectionExecArray) Exec(ctx context.Context) ([]ReviewContentReviewerConnection, error) {
	var v []ReviewContentReviewerConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentReviewerConnectionFields = []string{}

type ReviewContentReviewerConnection struct {
	PageInfo PageInfo                    `json:"pageInfo"`
	Edges    []ReviewContentReviewerEdge `json:"edges"`
}

type ReviewContentReviewerEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentReviewerEdgeExec) Node() *ReviewContentReviewerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentReviewer"},
		"node",
		[]string{"id", "review", "createdAt", "updatedAt"})

	return &ReviewContentReviewerExec{ret}
}

func (instance ReviewContentReviewerEdgeExec) Exec(ctx context.Context) (*ReviewContentReviewerEdge, error) {
	var v ReviewContentReviewerEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentReviewerEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentReviewerEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentReviewerEdgeExecArray) Exec(ctx context.Context) ([]ReviewContentReviewerEdge, error) {
	var v []ReviewContentReviewerEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentReviewerEdgeFields = []string{"cursor"}

type ReviewContentReviewerEdge struct {
	Node   ReviewContentReviewer `json:"node"`
	Cursor string                `json:"cursor"`
}

type ReviewContentViewerConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentViewerConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ReviewContentViewerConnectionExec) Edges() *ReviewContentViewerEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"ReviewContentViewerWhereInput", "ReviewContentViewerOrderByInput", "ReviewContentViewerEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "ReviewContentViewer"},
		"node",
		ReviewContentViewerFields)

	return &ReviewContentViewerEdgeExecArray{nodes}
}

func (instance *ReviewContentViewerConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateReviewContentViewer"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance ReviewContentViewerConnectionExec) Exec(ctx context.Context) (*ReviewContentViewerConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &ReviewContentViewerConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance ReviewContentViewerConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentViewerConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentViewerConnectionExecArray) Exec(ctx context.Context) ([]ReviewContentViewerConnection, error) {
	var v []ReviewContentViewerConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentViewerConnectionFields = []string{}

type ReviewContentViewerConnection struct {
	PageInfo PageInfo                  `json:"pageInfo"`
	Edges    []ReviewContentViewerEdge `json:"edges"`
}

type ReviewContentViewerEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentViewerEdgeExec) Node() *ReviewContentViewerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentViewer"},
		"node",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentViewerExec{ret}
}

func (instance ReviewContentViewerEdgeExec) Exec(ctx context.Context) (*ReviewContentViewerEdge, error) {
	var v ReviewContentViewerEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentViewerEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentViewerEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentViewerEdgeExecArray) Exec(ctx context.Context) ([]ReviewContentViewerEdge, error) {
	var v []ReviewContentViewerEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentViewerEdgeFields = []string{"cursor"}

type ReviewContentViewerEdge struct {
	Node   ReviewContentViewer `json:"node"`
	Cursor string              `json:"cursor"`
}

type RewardDropAttendingUserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *RewardDropAttendingUserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *RewardDropAttendingUserConnectionExec) Edges() *RewardDropAttendingUserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"RewardDropAttendingUserWhereInput", "RewardDropAttendingUserOrderByInput", "RewardDropAttendingUserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "RewardDropAttendingUser"},
		"node",
		RewardDropAttendingUserFields)

	return &RewardDropAttendingUserEdgeExecArray{nodes}
}

func (instance *RewardDropAttendingUserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateRewardDropAttendingUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance RewardDropAttendingUserConnectionExec) Exec(ctx context.Context) (*RewardDropAttendingUserConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &RewardDropAttendingUserConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance RewardDropAttendingUserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RewardDropAttendingUserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance RewardDropAttendingUserConnectionExecArray) Exec(ctx context.Context) ([]RewardDropAttendingUserConnection, error) {
	var v []RewardDropAttendingUserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RewardDropAttendingUserConnectionFields = []string{}

type RewardDropAttendingUserConnection struct {
	PageInfo PageInfo                      `json:"pageInfo"`
	Edges    []RewardDropAttendingUserEdge `json:"edges"`
}

type RewardDropAttendingUserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *RewardDropAttendingUserEdgeExec) Node() *RewardDropAttendingUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RewardDropAttendingUser"},
		"node",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserExec{ret}
}

func (instance RewardDropAttendingUserEdgeExec) Exec(ctx context.Context) (*RewardDropAttendingUserEdge, error) {
	var v RewardDropAttendingUserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RewardDropAttendingUserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RewardDropAttendingUserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance RewardDropAttendingUserEdgeExecArray) Exec(ctx context.Context) ([]RewardDropAttendingUserEdge, error) {
	var v []RewardDropAttendingUserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RewardDropAttendingUserEdgeFields = []string{"cursor"}

type RewardDropAttendingUserEdge struct {
	Node   RewardDropAttendingUser `json:"node"`
	Cursor string                  `json:"cursor"`
}

type RewardDropEventConnectionExec struct {
	exec *prisma.Exec
}

func (instance *RewardDropEventConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *RewardDropEventConnectionExec) Edges() *RewardDropEventEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"RewardDropEventWhereInput", "RewardDropEventOrderByInput", "RewardDropEventEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "RewardDropEvent"},
		"node",
		RewardDropEventFields)

	return &RewardDropEventEdgeExecArray{nodes}
}

func (instance *RewardDropEventConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateRewardDropEvent"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance RewardDropEventConnectionExec) Exec(ctx context.Context) (*RewardDropEventConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &RewardDropEventConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance RewardDropEventConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RewardDropEventConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance RewardDropEventConnectionExecArray) Exec(ctx context.Context) ([]RewardDropEventConnection, error) {
	var v []RewardDropEventConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RewardDropEventConnectionFields = []string{}

type RewardDropEventConnection struct {
	PageInfo PageInfo              `json:"pageInfo"`
	Edges    []RewardDropEventEdge `json:"edges"`
}

type RewardDropEventEdgeExec struct {
	exec *prisma.Exec
}

func (instance *RewardDropEventEdgeExec) Node() *RewardDropEventExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RewardDropEvent"},
		"node",
		[]string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"})

	return &RewardDropEventExec{ret}
}

func (instance RewardDropEventEdgeExec) Exec(ctx context.Context) (*RewardDropEventEdge, error) {
	var v RewardDropEventEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RewardDropEventEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RewardDropEventEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance RewardDropEventEdgeExecArray) Exec(ctx context.Context) ([]RewardDropEventEdge, error) {
	var v []RewardDropEventEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RewardDropEventEdgeFields = []string{"cursor"}

type RewardDropEventEdge struct {
	Node   RewardDropEvent `json:"node"`
	Cursor string          `json:"cursor"`
}

type TwitchConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TwitchConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TwitchConnectionExec) Edges() *TwitchEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"TwitchWhereInput", "TwitchOrderByInput", "TwitchEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Twitch"},
		"node",
		TwitchFields)

	return &TwitchEdgeExecArray{nodes}
}

func (instance *TwitchConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTwitch"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance TwitchConnectionExec) Exec(ctx context.Context) (*TwitchConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &TwitchConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance TwitchConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TwitchConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TwitchConnectionExecArray) Exec(ctx context.Context) ([]TwitchConnection, error) {
	var v []TwitchConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TwitchConnectionFields = []string{}

type TwitchConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []TwitchEdge `json:"edges"`
}

type TwitchEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TwitchEdgeExec) Node() *TwitchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Twitch"},
		"node",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchExec{ret}
}

func (instance TwitchEdgeExec) Exec(ctx context.Context) (*TwitchEdge, error) {
	var v TwitchEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TwitchEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TwitchEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TwitchEdgeExecArray) Exec(ctx context.Context) ([]TwitchEdge, error) {
	var v []TwitchEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TwitchEdgeFields = []string{"cursor"}

type TwitchEdge struct {
	Node   Twitch `json:"node"`
	Cursor string `json:"cursor"`
}

type TwitchDailyStatisticsConnectionExec struct {
	exec *prisma.Exec
}

func (instance *TwitchDailyStatisticsConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *TwitchDailyStatisticsConnectionExec) Edges() *TwitchDailyStatisticsEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"TwitchDailyStatisticsWhereInput", "TwitchDailyStatisticsOrderByInput", "TwitchDailyStatisticsEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "TwitchDailyStatistics"},
		"node",
		TwitchDailyStatisticsFields)

	return &TwitchDailyStatisticsEdgeExecArray{nodes}
}

func (instance *TwitchDailyStatisticsConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateTwitchDailyStatistics"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance TwitchDailyStatisticsConnectionExec) Exec(ctx context.Context) (*TwitchDailyStatisticsConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &TwitchDailyStatisticsConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance TwitchDailyStatisticsConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TwitchDailyStatisticsConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance TwitchDailyStatisticsConnectionExecArray) Exec(ctx context.Context) ([]TwitchDailyStatisticsConnection, error) {
	var v []TwitchDailyStatisticsConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TwitchDailyStatisticsConnectionFields = []string{}

type TwitchDailyStatisticsConnection struct {
	PageInfo PageInfo                    `json:"pageInfo"`
	Edges    []TwitchDailyStatisticsEdge `json:"edges"`
}

type TwitchDailyStatisticsEdgeExec struct {
	exec *prisma.Exec
}

func (instance *TwitchDailyStatisticsEdgeExec) Node() *TwitchDailyStatisticsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TwitchDailyStatistics"},
		"node",
		[]string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"})

	return &TwitchDailyStatisticsExec{ret}
}

func (instance TwitchDailyStatisticsEdgeExec) Exec(ctx context.Context) (*TwitchDailyStatisticsEdge, error) {
	var v TwitchDailyStatisticsEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TwitchDailyStatisticsEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TwitchDailyStatisticsEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance TwitchDailyStatisticsEdgeExecArray) Exec(ctx context.Context) ([]TwitchDailyStatisticsEdge, error) {
	var v []TwitchDailyStatisticsEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TwitchDailyStatisticsEdgeFields = []string{"cursor"}

type TwitchDailyStatisticsEdge struct {
	Node   TwitchDailyStatistics `json:"node"`
	Cursor string                `json:"cursor"`
}

type UpdatePostHistoryConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UpdatePostHistoryConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UpdatePostHistoryConnectionExec) Edges() *UpdatePostHistoryEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UpdatePostHistoryWhereInput", "UpdatePostHistoryOrderByInput", "UpdatePostHistoryEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "UpdatePostHistory"},
		"node",
		UpdatePostHistoryFields)

	return &UpdatePostHistoryEdgeExecArray{nodes}
}

func (instance *UpdatePostHistoryConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUpdatePostHistory"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UpdatePostHistoryConnectionExec) Exec(ctx context.Context) (*UpdatePostHistoryConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &UpdatePostHistoryConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance UpdatePostHistoryConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UpdatePostHistoryConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UpdatePostHistoryConnectionExecArray) Exec(ctx context.Context) ([]UpdatePostHistoryConnection, error) {
	var v []UpdatePostHistoryConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UpdatePostHistoryConnectionFields = []string{}

type UpdatePostHistoryConnection struct {
	PageInfo PageInfo                `json:"pageInfo"`
	Edges    []UpdatePostHistoryEdge `json:"edges"`
}

type UpdatePostHistoryEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UpdatePostHistoryEdgeExec) Node() *UpdatePostHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UpdatePostHistory"},
		"node",
		[]string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"})

	return &UpdatePostHistoryExec{ret}
}

func (instance UpdatePostHistoryEdgeExec) Exec(ctx context.Context) (*UpdatePostHistoryEdge, error) {
	var v UpdatePostHistoryEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UpdatePostHistoryEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UpdatePostHistoryEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UpdatePostHistoryEdgeExecArray) Exec(ctx context.Context) ([]UpdatePostHistoryEdge, error) {
	var v []UpdatePostHistoryEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UpdatePostHistoryEdgeFields = []string{"cursor"}

type UpdatePostHistoryEdge struct {
	Node   UpdatePostHistory `json:"node"`
	Cursor string            `json:"cursor"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"UserWhereInput", "UserOrderByInput", "UserEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "User"},
		"node",
		UserFields)

	return &UserEdgeExecArray{nodes}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &UserConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserConnectionFields = []string{}

type UserConnection struct {
	PageInfo PageInfo   `json:"pageInfo"`
	Edges    []UserEdge `json:"edges"`
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserEdgeFields = []string{"cursor"}

type UserEdge struct {
	Node   User   `json:"node"`
	Cursor string `json:"cursor"`
}

type VerificationConnectionExec struct {
	exec *prisma.Exec
}

func (instance *VerificationConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *VerificationConnectionExec) Edges() *VerificationEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"VerificationWhereInput", "VerificationOrderByInput", "VerificationEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Verification"},
		"node",
		VerificationFields)

	return &VerificationEdgeExecArray{nodes}
}

func (instance *VerificationConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateVerification"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance VerificationConnectionExec) Exec(ctx context.Context) (*VerificationConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &VerificationConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance VerificationConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VerificationConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance VerificationConnectionExecArray) Exec(ctx context.Context) ([]VerificationConnection, error) {
	var v []VerificationConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var VerificationConnectionFields = []string{}

type VerificationConnection struct {
	PageInfo PageInfo           `json:"pageInfo"`
	Edges    []VerificationEdge `json:"edges"`
}

type VerificationEdgeExec struct {
	exec *prisma.Exec
}

func (instance *VerificationEdgeExec) Node() *VerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Verification"},
		"node",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExec{ret}
}

func (instance VerificationEdgeExec) Exec(ctx context.Context) (*VerificationEdge, error) {
	var v VerificationEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VerificationEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VerificationEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance VerificationEdgeExecArray) Exec(ctx context.Context) ([]VerificationEdge, error) {
	var v []VerificationEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var VerificationEdgeFields = []string{"cursor"}

type VerificationEdge struct {
	Node   Verification `json:"node"`
	Cursor string       `json:"cursor"`
}

type WalletConnectionExec struct {
	exec *prisma.Exec
}

func (instance *WalletConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *WalletConnectionExec) Edges() *WalletEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"WalletWhereInput", "WalletOrderByInput", "WalletEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Wallet"},
		"node",
		WalletFields)

	return &WalletEdgeExecArray{nodes}
}

func (instance *WalletConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateWallet"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance WalletConnectionExec) Exec(ctx context.Context) (*WalletConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &WalletConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance WalletConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WalletConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance WalletConnectionExecArray) Exec(ctx context.Context) ([]WalletConnection, error) {
	var v []WalletConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var WalletConnectionFields = []string{}

type WalletConnection struct {
	PageInfo PageInfo     `json:"pageInfo"`
	Edges    []WalletEdge `json:"edges"`
}

type WalletEdgeExec struct {
	exec *prisma.Exec
}

func (instance *WalletEdgeExec) Node() *WalletExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Wallet"},
		"node",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletExec{ret}
}

func (instance WalletEdgeExec) Exec(ctx context.Context) (*WalletEdge, error) {
	var v WalletEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WalletEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WalletEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance WalletEdgeExecArray) Exec(ctx context.Context) ([]WalletEdge, error) {
	var v []WalletEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var WalletEdgeFields = []string{"cursor"}

type WalletEdge struct {
	Node   Wallet `json:"node"`
	Cursor string `json:"cursor"`
}

type YoutubeConnectionExec struct {
	exec *prisma.Exec
}

func (instance *YoutubeConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *YoutubeConnectionExec) Edges() *YoutubeEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"YoutubeWhereInput", "YoutubeOrderByInput", "YoutubeEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "Youtube"},
		"node",
		YoutubeFields)

	return &YoutubeEdgeExecArray{nodes}
}

func (instance *YoutubeConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateYoutube"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance YoutubeConnectionExec) Exec(ctx context.Context) (*YoutubeConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &YoutubeConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance YoutubeConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type YoutubeConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance YoutubeConnectionExecArray) Exec(ctx context.Context) ([]YoutubeConnection, error) {
	var v []YoutubeConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var YoutubeConnectionFields = []string{}

type YoutubeConnection struct {
	PageInfo PageInfo      `json:"pageInfo"`
	Edges    []YoutubeEdge `json:"edges"`
}

type YoutubeEdgeExec struct {
	exec *prisma.Exec
}

func (instance *YoutubeEdgeExec) Node() *YoutubeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Youtube"},
		"node",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubeExec{ret}
}

func (instance YoutubeEdgeExec) Exec(ctx context.Context) (*YoutubeEdge, error) {
	var v YoutubeEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance YoutubeEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type YoutubeEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance YoutubeEdgeExecArray) Exec(ctx context.Context) ([]YoutubeEdge, error) {
	var v []YoutubeEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var YoutubeEdgeFields = []string{"cursor"}

type YoutubeEdge struct {
	Node   Youtube `json:"node"`
	Cursor string  `json:"cursor"`
}

type YoutubeDailyStatisticsConnectionExec struct {
	exec *prisma.Exec
}

func (instance *YoutubeDailyStatisticsConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *YoutubeDailyStatisticsConnectionExec) Edges() *YoutubeDailyStatisticsEdgeExecArray {
	edges := instance.exec.Client.GetMany(
		instance.exec,
		nil,
		[3]string{"YoutubeDailyStatisticsWhereInput", "YoutubeDailyStatisticsOrderByInput", "YoutubeDailyStatisticsEdge"},
		"edges",
		[]string{"cursor"})

	nodes := edges.Client.GetOne(
		edges,
		nil,
		[2]string{"", "YoutubeDailyStatistics"},
		"node",
		YoutubeDailyStatisticsFields)

	return &YoutubeDailyStatisticsEdgeExecArray{nodes}
}

func (instance *YoutubeDailyStatisticsConnectionExec) Aggregate(ctx context.Context) (*Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateYoutubeDailyStatistics"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return &v, err
}

func (instance YoutubeDailyStatisticsConnectionExec) Exec(ctx context.Context) (*YoutubeDailyStatisticsConnection, error) {
	edges, err := instance.Edges().Exec(ctx)
	if err != nil {
		return nil, err
	}

	pageInfo, err := instance.PageInfo().Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &YoutubeDailyStatisticsConnection{
		Edges:    edges,
		PageInfo: *pageInfo,
	}, nil
}

func (instance YoutubeDailyStatisticsConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type YoutubeDailyStatisticsConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance YoutubeDailyStatisticsConnectionExecArray) Exec(ctx context.Context) ([]YoutubeDailyStatisticsConnection, error) {
	var v []YoutubeDailyStatisticsConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var YoutubeDailyStatisticsConnectionFields = []string{}

type YoutubeDailyStatisticsConnection struct {
	PageInfo PageInfo                     `json:"pageInfo"`
	Edges    []YoutubeDailyStatisticsEdge `json:"edges"`
}

type YoutubeDailyStatisticsEdgeExec struct {
	exec *prisma.Exec
}

func (instance *YoutubeDailyStatisticsEdgeExec) Node() *YoutubeDailyStatisticsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "YoutubeDailyStatistics"},
		"node",
		[]string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"})

	return &YoutubeDailyStatisticsExec{ret}
}

func (instance YoutubeDailyStatisticsEdgeExec) Exec(ctx context.Context) (*YoutubeDailyStatisticsEdge, error) {
	var v YoutubeDailyStatisticsEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance YoutubeDailyStatisticsEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type YoutubeDailyStatisticsEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance YoutubeDailyStatisticsEdgeExecArray) Exec(ctx context.Context) ([]YoutubeDailyStatisticsEdge, error) {
	var v []YoutubeDailyStatisticsEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var YoutubeDailyStatisticsEdgeFields = []string{"cursor"}

type YoutubeDailyStatisticsEdge struct {
	Node   YoutubeDailyStatistics `json:"node"`
	Cursor string                 `json:"cursor"`
}

type AdminUserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AdminUserSubscriptionPayloadExec) Node() *AdminUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUser"},
		"node",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserExec{ret}
}

func (instance *AdminUserSubscriptionPayloadExec) PreviousValues() *AdminUserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AdminUserPreviousValues"},
		"previousValues",
		[]string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"})

	return &AdminUserPreviousValuesExec{ret}
}

func (instance AdminUserSubscriptionPayloadExec) Exec(ctx context.Context) (*AdminUserSubscriptionPayload, error) {
	var v AdminUserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AdminUserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AdminUserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AdminUserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AdminUserSubscriptionPayload, error) {
	var v []AdminUserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AdminUserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AdminUserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *AdminUser   `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AdminUserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AdminUserPreviousValuesExec) Exec(ctx context.Context) (*AdminUserPreviousValues, error) {
	var v AdminUserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AdminUserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AdminUserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AdminUserPreviousValuesExecArray) Exec(ctx context.Context) ([]AdminUserPreviousValues, error) {
	var v []AdminUserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AdminUserPreviousValuesFields = []string{"id", "role", "email", "password", "nickName", "otpKey", "level", "createdAt", "updatedAt"}

type AdminUserPreviousValues struct {
	ID        string  `json:"id"`
	Role      Role    `json:"role"`
	Email     string  `json:"email"`
	Password  *string `json:"password,omitempty"`
	NickName  string  `json:"nickName"`
	OtpKey    *string `json:"otpKey,omitempty"`
	Level     *string `json:"level,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type AergoAccountSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AergoAccountSubscriptionPayloadExec) Node() *AergoAccountExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AergoAccount"},
		"node",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountExec{ret}
}

func (instance *AergoAccountSubscriptionPayloadExec) PreviousValues() *AergoAccountPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AergoAccountPreviousValues"},
		"previousValues",
		[]string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"})

	return &AergoAccountPreviousValuesExec{ret}
}

func (instance AergoAccountSubscriptionPayloadExec) Exec(ctx context.Context) (*AergoAccountSubscriptionPayload, error) {
	var v AergoAccountSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AergoAccountSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AergoAccountSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AergoAccountSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AergoAccountSubscriptionPayload, error) {
	var v []AergoAccountSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AergoAccountSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AergoAccountSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *AergoAccount `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type AergoAccountPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AergoAccountPreviousValuesExec) Exec(ctx context.Context) (*AergoAccountPreviousValues, error) {
	var v AergoAccountPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AergoAccountPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AergoAccountPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AergoAccountPreviousValuesExecArray) Exec(ctx context.Context) ([]AergoAccountPreviousValues, error) {
	var v []AergoAccountPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AergoAccountPreviousValuesFields = []string{"id", "contractAddress", "amount", "latestBlock", "createdAt", "updatedAt"}

type AergoAccountPreviousValues struct {
	ID              string  `json:"id"`
	ContractAddress string  `json:"contractAddress"`
	Amount          float64 `json:"amount"`
	LatestBlock     int32   `json:"latestBlock"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
}

type AergoAccountHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AergoAccountHistorySubscriptionPayloadExec) Node() *AergoAccountHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AergoAccountHistory"},
		"node",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryExec{ret}
}

func (instance *AergoAccountHistorySubscriptionPayloadExec) PreviousValues() *AergoAccountHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AergoAccountHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"})

	return &AergoAccountHistoryPreviousValuesExec{ret}
}

func (instance AergoAccountHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*AergoAccountHistorySubscriptionPayload, error) {
	var v AergoAccountHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AergoAccountHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AergoAccountHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AergoAccountHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AergoAccountHistorySubscriptionPayload, error) {
	var v []AergoAccountHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AergoAccountHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AergoAccountHistorySubscriptionPayload struct {
	Mutation      MutationType         `json:"mutation"`
	Node          *AergoAccountHistory `json:"node,omitempty"`
	UpdatedFields []string             `json:"updatedFields,omitempty"`
}

type AergoAccountHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AergoAccountHistoryPreviousValuesExec) Exec(ctx context.Context) (*AergoAccountHistoryPreviousValues, error) {
	var v AergoAccountHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AergoAccountHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AergoAccountHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AergoAccountHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]AergoAccountHistoryPreviousValues, error) {
	var v []AergoAccountHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AergoAccountHistoryPreviousValuesFields = []string{"id", "type", "aergoAmount", "amount_fee", "amount", "marketPrice", "txHash", "memo", "description", "blockNo", "status", "createdAt", "updatedAt"}

type AergoAccountHistoryPreviousValues struct {
	ID          string   `json:"id"`
	Type        int32    `json:"type"`
	AergoAmount *string  `json:"aergoAmount,omitempty"`
	AmountFee   *float64 `json:"amount_fee,omitempty"`
	Amount      *float64 `json:"amount,omitempty"`
	MarketPrice *string  `json:"marketPrice,omitempty"`
	TxHash      *string  `json:"txHash,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
	Description *string  `json:"description,omitempty"`
	BlockNo     *int32   `json:"blockNo,omitempty"`
	Status      int32    `json:"status"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
}

type AfreecaTvSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AfreecaTvSubscriptionPayloadExec) Node() *AfreecaTvExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AfreecaTV"},
		"node",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvExec{ret}
}

func (instance *AfreecaTvSubscriptionPayloadExec) PreviousValues() *AfreecaTvPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AfreecaTVPreviousValues"},
		"previousValues",
		[]string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvPreviousValuesExec{ret}
}

func (instance AfreecaTvSubscriptionPayloadExec) Exec(ctx context.Context) (*AfreecaTvSubscriptionPayload, error) {
	var v AfreecaTvSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AfreecaTvSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AfreecaTvSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AfreecaTvSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AfreecaTvSubscriptionPayload, error) {
	var v []AfreecaTvSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AfreecaTVSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AfreecaTvSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *AfreecaTv   `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AfreecaTvPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AfreecaTvPreviousValuesExec) Exec(ctx context.Context) (*AfreecaTvPreviousValues, error) {
	var v AfreecaTvPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AfreecaTvPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AfreecaTvPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AfreecaTvPreviousValuesExecArray) Exec(ctx context.Context) ([]AfreecaTvPreviousValues, error) {
	var v []AfreecaTvPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AfreecaTVPreviousValuesFields = []string{"id", "stationNo", "stationName", "stationTitle", "userId", "userName", "avatarUrl", "description", "pageUrl", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"}

type AfreecaTvPreviousValues struct {
	ID            string  `json:"id"`
	StationNo     string  `json:"stationNo"`
	StationName   *string `json:"stationName,omitempty"`
	StationTitle  *string `json:"stationTitle,omitempty"`
	UserId        string  `json:"userId"`
	UserName      *string `json:"userName,omitempty"`
	AvatarUrl     *string `json:"avatarUrl,omitempty"`
	Description   *string `json:"description,omitempty"`
	PageUrl       *string `json:"pageUrl,omitempty"`
	FollowerCount *string `json:"followerCount,omitempty"`
	ViewCount     *string `json:"viewCount,omitempty"`
	VisitCount    *string `json:"visitCount,omitempty"`
	FanCount      *string `json:"fanCount,omitempty"`
	CreatedAt     string  `json:"createdAt"`
	UpdatedAt     string  `json:"updatedAt"`
}

type AfreecaTvDailyStatisticsSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AfreecaTvDailyStatisticsSubscriptionPayloadExec) Node() *AfreecaTvDailyStatisticsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AfreecaTVDailyStatistics"},
		"node",
		[]string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvDailyStatisticsExec{ret}
}

func (instance *AfreecaTvDailyStatisticsSubscriptionPayloadExec) PreviousValues() *AfreecaTvDailyStatisticsPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AfreecaTVDailyStatisticsPreviousValues"},
		"previousValues",
		[]string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"})

	return &AfreecaTvDailyStatisticsPreviousValuesExec{ret}
}

func (instance AfreecaTvDailyStatisticsSubscriptionPayloadExec) Exec(ctx context.Context) (*AfreecaTvDailyStatisticsSubscriptionPayload, error) {
	var v AfreecaTvDailyStatisticsSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AfreecaTvDailyStatisticsSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AfreecaTvDailyStatisticsSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AfreecaTvDailyStatisticsSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AfreecaTvDailyStatisticsSubscriptionPayload, error) {
	var v []AfreecaTvDailyStatisticsSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AfreecaTVDailyStatisticsSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AfreecaTvDailyStatisticsSubscriptionPayload struct {
	Mutation      MutationType              `json:"mutation"`
	Node          *AfreecaTvDailyStatistics `json:"node,omitempty"`
	UpdatedFields []string                  `json:"updatedFields,omitempty"`
}

type AfreecaTvDailyStatisticsPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AfreecaTvDailyStatisticsPreviousValuesExec) Exec(ctx context.Context) (*AfreecaTvDailyStatisticsPreviousValues, error) {
	var v AfreecaTvDailyStatisticsPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AfreecaTvDailyStatisticsPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AfreecaTvDailyStatisticsPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AfreecaTvDailyStatisticsPreviousValuesExecArray) Exec(ctx context.Context) ([]AfreecaTvDailyStatisticsPreviousValues, error) {
	var v []AfreecaTvDailyStatisticsPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AfreecaTVDailyStatisticsPreviousValuesFields = []string{"id", "date", "followerCount", "viewCount", "visitCount", "fanCount", "createdAt", "updatedAt"}

type AfreecaTvDailyStatisticsPreviousValues struct {
	ID            string `json:"id"`
	Date          string `json:"date"`
	FollowerCount string `json:"followerCount"`
	ViewCount     string `json:"viewCount"`
	VisitCount    string `json:"visitCount"`
	FanCount      string `json:"fanCount"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
}

type AirDropSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AirDropSubscriptionPayloadExec) Node() *AirDropExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDrop"},
		"node",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropExec{ret}
}

func (instance *AirDropSubscriptionPayloadExec) PreviousValues() *AirDropPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDropPreviousValues"},
		"previousValues",
		[]string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"})

	return &AirDropPreviousValuesExec{ret}
}

func (instance AirDropSubscriptionPayloadExec) Exec(ctx context.Context) (*AirDropSubscriptionPayload, error) {
	var v AirDropSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AirDropSubscriptionPayload, error) {
	var v []AirDropSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AirDropSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *AirDrop     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AirDropPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AirDropPreviousValuesExec) Exec(ctx context.Context) (*AirDropPreviousValues, error) {
	var v AirDropPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropPreviousValuesExecArray) Exec(ctx context.Context) ([]AirDropPreviousValues, error) {
	var v []AirDropPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropPreviousValuesFields = []string{"id", "status", "deployTxhash", "contractAddress", "randomArrayString", "amount", "left", "toDate", "createdAt", "updatedAt", "isDel"}

type AirDropPreviousValues struct {
	ID                string  `json:"id"`
	Status            *int32  `json:"status,omitempty"`
	DeployTxhash      *string `json:"deployTxhash,omitempty"`
	ContractAddress   *string `json:"contractAddress,omitempty"`
	RandomArrayString *string `json:"randomArrayString,omitempty"`
	Amount            float64 `json:"amount"`
	Left              float64 `json:"left"`
	ToDate            *string `json:"toDate,omitempty"`
	CreatedAt         string  `json:"createdAt"`
	UpdatedAt         string  `json:"updatedAt"`
	IsDel             bool    `json:"isDel"`
}

type AirDropHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AirDropHistorySubscriptionPayloadExec) Node() *AirDropHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDropHistory"},
		"node",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryExec{ret}
}

func (instance *AirDropHistorySubscriptionPayloadExec) PreviousValues() *AirDropHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDropHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &AirDropHistoryPreviousValuesExec{ret}
}

func (instance AirDropHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*AirDropHistorySubscriptionPayload, error) {
	var v AirDropHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AirDropHistorySubscriptionPayload, error) {
	var v []AirDropHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AirDropHistorySubscriptionPayload struct {
	Mutation      MutationType    `json:"mutation"`
	Node          *AirDropHistory `json:"node,omitempty"`
	UpdatedFields []string        `json:"updatedFields,omitempty"`
}

type AirDropHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AirDropHistoryPreviousValuesExec) Exec(ctx context.Context) (*AirDropHistoryPreviousValues, error) {
	var v AirDropHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]AirDropHistoryPreviousValues, error) {
	var v []AirDropHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropHistoryPreviousValuesFields = []string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"}

type AirDropHistoryPreviousValues struct {
	ID           string   `json:"id"`
	Type         int32    `json:"type"`
	Description  *string  `json:"description,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
}

type AirDropMemberSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AirDropMemberSubscriptionPayloadExec) Node() *AirDropMemberExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDropMember"},
		"node",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberExec{ret}
}

func (instance *AirDropMemberSubscriptionPayloadExec) PreviousValues() *AirDropMemberPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AirDropMemberPreviousValues"},
		"previousValues",
		[]string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"})

	return &AirDropMemberPreviousValuesExec{ret}
}

func (instance AirDropMemberSubscriptionPayloadExec) Exec(ctx context.Context) (*AirDropMemberSubscriptionPayload, error) {
	var v AirDropMemberSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropMemberSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropMemberSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropMemberSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AirDropMemberSubscriptionPayload, error) {
	var v []AirDropMemberSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropMemberSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AirDropMemberSubscriptionPayload struct {
	Mutation      MutationType   `json:"mutation"`
	Node          *AirDropMember `json:"node,omitempty"`
	UpdatedFields []string       `json:"updatedFields,omitempty"`
}

type AirDropMemberPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AirDropMemberPreviousValuesExec) Exec(ctx context.Context) (*AirDropMemberPreviousValues, error) {
	var v AirDropMemberPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AirDropMemberPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AirDropMemberPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AirDropMemberPreviousValuesExecArray) Exec(ctx context.Context) ([]AirDropMemberPreviousValues, error) {
	var v []AirDropMemberPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AirDropMemberPreviousValuesFields = []string{"id", "dropNum", "qty", "createdAt", "updatedAt", "isDel"}

type AirDropMemberPreviousValues struct {
	ID        string  `json:"id"`
	DropNum   int32   `json:"dropNum"`
	Qty       float64 `json:"qty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	IsDel     bool    `json:"isDel"`
}

type AppVersionSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AppVersionSubscriptionPayloadExec) Node() *AppVersionExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AppVersion"},
		"node",
		[]string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"})

	return &AppVersionExec{ret}
}

func (instance *AppVersionSubscriptionPayloadExec) PreviousValues() *AppVersionPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AppVersionPreviousValues"},
		"previousValues",
		[]string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"})

	return &AppVersionPreviousValuesExec{ret}
}

func (instance AppVersionSubscriptionPayloadExec) Exec(ctx context.Context) (*AppVersionSubscriptionPayload, error) {
	var v AppVersionSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppVersionSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppVersionSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AppVersionSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AppVersionSubscriptionPayload, error) {
	var v []AppVersionSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppVersionSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type AppVersionSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *AppVersion  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type AppVersionPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AppVersionPreviousValuesExec) Exec(ctx context.Context) (*AppVersionPreviousValues, error) {
	var v AppVersionPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AppVersionPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AppVersionPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AppVersionPreviousValuesExecArray) Exec(ctx context.Context) ([]AppVersionPreviousValues, error) {
	var v []AppVersionPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var AppVersionPreviousValuesFields = []string{"id", "version", "type", "note", "releasedAt", "createdAt", "updatedAt", "isDel"}

type AppVersionPreviousValues struct {
	ID         string `json:"id"`
	Version    string `json:"version"`
	Type       int32  `json:"type"`
	Note       string `json:"note"`
	ReleasedAt string `json:"releasedAt"`
	CreatedAt  string `json:"createdAt"`
	UpdatedAt  string `json:"updatedAt"`
	IsDel      *bool  `json:"isDel,omitempty"`
}

type BadgeSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BadgeSubscriptionPayloadExec) Node() *BadgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Badge"},
		"node",
		[]string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"})

	return &BadgeExec{ret}
}

func (instance *BadgeSubscriptionPayloadExec) PreviousValues() *BadgePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BadgePreviousValues"},
		"previousValues",
		[]string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"})

	return &BadgePreviousValuesExec{ret}
}

func (instance BadgeSubscriptionPayloadExec) Exec(ctx context.Context) (*BadgeSubscriptionPayload, error) {
	var v BadgeSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BadgeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BadgeSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BadgeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BadgeSubscriptionPayload, error) {
	var v []BadgeSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BadgeSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BadgeSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Badge       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type BadgePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BadgePreviousValuesExec) Exec(ctx context.Context) (*BadgePreviousValues, error) {
	var v BadgePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BadgePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BadgePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BadgePreviousValuesExecArray) Exec(ctx context.Context) ([]BadgePreviousValues, error) {
	var v []BadgePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BadgePreviousValuesFields = []string{"id", "name", "imageUrl", "description", "orderIndex", "createdAt", "updatedAt"}

type BadgePreviousValues struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	ImageUrl    *string `json:"imageUrl,omitempty"`
	Description string  `json:"description"`
	OrderIndex  int32   `json:"orderIndex"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
}

type BadgeVoterSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BadgeVoterSubscriptionPayloadExec) Node() *BadgeVoterExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BadgeVoter"},
		"node",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &BadgeVoterExec{ret}
}

func (instance *BadgeVoterSubscriptionPayloadExec) PreviousValues() *BadgeVoterPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BadgeVoterPreviousValues"},
		"previousValues",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &BadgeVoterPreviousValuesExec{ret}
}

func (instance BadgeVoterSubscriptionPayloadExec) Exec(ctx context.Context) (*BadgeVoterSubscriptionPayload, error) {
	var v BadgeVoterSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BadgeVoterSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BadgeVoterSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BadgeVoterSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BadgeVoterSubscriptionPayload, error) {
	var v []BadgeVoterSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BadgeVoterSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BadgeVoterSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *BadgeVoter  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type BadgeVoterPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BadgeVoterPreviousValuesExec) Exec(ctx context.Context) (*BadgeVoterPreviousValues, error) {
	var v BadgeVoterPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BadgeVoterPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BadgeVoterPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BadgeVoterPreviousValuesExecArray) Exec(ctx context.Context) ([]BadgeVoterPreviousValues, error) {
	var v []BadgeVoterPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BadgeVoterPreviousValuesFields = []string{"id", "ip", "createdAt", "updatedAt"}

type BadgeVoterPreviousValues struct {
	ID        string  `json:"id"`
	Ip        *string `json:"ip,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type BankSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BankSubscriptionPayloadExec) Node() *BankExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Bank"},
		"node",
		[]string{"id", "code", "name", "createdAt", "updatedAt"})

	return &BankExec{ret}
}

func (instance *BankSubscriptionPayloadExec) PreviousValues() *BankPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BankPreviousValues"},
		"previousValues",
		[]string{"id", "code", "name", "createdAt", "updatedAt"})

	return &BankPreviousValuesExec{ret}
}

func (instance BankSubscriptionPayloadExec) Exec(ctx context.Context) (*BankSubscriptionPayload, error) {
	var v BankSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BankSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BankSubscriptionPayload, error) {
	var v []BankSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BankSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Bank        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type BankPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BankPreviousValuesExec) Exec(ctx context.Context) (*BankPreviousValues, error) {
	var v BankPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BankPreviousValuesExecArray) Exec(ctx context.Context) ([]BankPreviousValues, error) {
	var v []BankPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankPreviousValuesFields = []string{"id", "code", "name", "createdAt", "updatedAt"}

type BankPreviousValues struct {
	ID        string `json:"id"`
	Code      string `json:"code"`
	Name      string `json:"name"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type BankAccountVerificationSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BankAccountVerificationSubscriptionPayloadExec) Node() *BankAccountVerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BankAccountVerification"},
		"node",
		[]string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationExec{ret}
}

func (instance *BankAccountVerificationSubscriptionPayloadExec) PreviousValues() *BankAccountVerificationPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BankAccountVerificationPreviousValues"},
		"previousValues",
		[]string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationPreviousValuesExec{ret}
}

func (instance BankAccountVerificationSubscriptionPayloadExec) Exec(ctx context.Context) (*BankAccountVerificationSubscriptionPayload, error) {
	var v BankAccountVerificationSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankAccountVerificationSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankAccountVerificationSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BankAccountVerificationSubscriptionPayload, error) {
	var v []BankAccountVerificationSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankAccountVerificationSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BankAccountVerificationSubscriptionPayload struct {
	Mutation      MutationType             `json:"mutation"`
	Node          *BankAccountVerification `json:"node,omitempty"`
	UpdatedFields []string                 `json:"updatedFields,omitempty"`
}

type BankAccountVerificationPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationPreviousValuesExec) Exec(ctx context.Context) (*BankAccountVerificationPreviousValues, error) {
	var v BankAccountVerificationPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankAccountVerificationPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankAccountVerificationPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationPreviousValuesExecArray) Exec(ctx context.Context) ([]BankAccountVerificationPreviousValues, error) {
	var v []BankAccountVerificationPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankAccountVerificationPreviousValuesFields = []string{"id", "holderName", "accountNumber", "verifyAt", "createdAt", "updatedAt"}

type BankAccountVerificationPreviousValues struct {
	ID            string  `json:"id"`
	HolderName    string  `json:"holderName"`
	AccountNumber string  `json:"accountNumber"`
	VerifyAt      *string `json:"verifyAt,omitempty"`
	CreatedAt     string  `json:"createdAt"`
	UpdatedAt     string  `json:"updatedAt"`
}

type BankAccountVerificationTransactionInfoSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BankAccountVerificationTransactionInfoSubscriptionPayloadExec) Node() *BankAccountVerificationTransactionInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BankAccountVerificationTransactionInfo"},
		"node",
		[]string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationTransactionInfoExec{ret}
}

func (instance *BankAccountVerificationTransactionInfoSubscriptionPayloadExec) PreviousValues() *BankAccountVerificationTransactionInfoPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BankAccountVerificationTransactionInfoPreviousValues"},
		"previousValues",
		[]string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"})

	return &BankAccountVerificationTransactionInfoPreviousValuesExec{ret}
}

func (instance BankAccountVerificationTransactionInfoSubscriptionPayloadExec) Exec(ctx context.Context) (*BankAccountVerificationTransactionInfoSubscriptionPayload, error) {
	var v BankAccountVerificationTransactionInfoSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankAccountVerificationTransactionInfoSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankAccountVerificationTransactionInfoSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationTransactionInfoSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BankAccountVerificationTransactionInfoSubscriptionPayload, error) {
	var v []BankAccountVerificationTransactionInfoSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankAccountVerificationTransactionInfoSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BankAccountVerificationTransactionInfoSubscriptionPayload struct {
	Mutation      MutationType                            `json:"mutation"`
	Node          *BankAccountVerificationTransactionInfo `json:"node,omitempty"`
	UpdatedFields []string                                `json:"updatedFields,omitempty"`
}

type BankAccountVerificationTransactionInfoPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationTransactionInfoPreviousValuesExec) Exec(ctx context.Context) (*BankAccountVerificationTransactionInfoPreviousValues, error) {
	var v BankAccountVerificationTransactionInfoPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BankAccountVerificationTransactionInfoPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BankAccountVerificationTransactionInfoPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BankAccountVerificationTransactionInfoPreviousValuesExecArray) Exec(ctx context.Context) ([]BankAccountVerificationTransactionInfoPreviousValues, error) {
	var v []BankAccountVerificationTransactionInfoPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BankAccountVerificationTransactionInfoPreviousValuesFields = []string{"id", "transactionDt", "transactionNo", "expireAt", "createdAt", "updatedAt"}

type BankAccountVerificationTransactionInfoPreviousValues struct {
	ID            string `json:"id"`
	TransactionDt string `json:"transactionDt"`
	TransactionNo string `json:"transactionNo"`
	ExpireAt      string `json:"expireAt"`
	CreatedAt     string `json:"createdAt"`
	UpdatedAt     string `json:"updatedAt"`
}

type BoardSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *BoardSubscriptionPayloadExec) Node() *BoardExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Board"},
		"node",
		[]string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"})

	return &BoardExec{ret}
}

func (instance *BoardSubscriptionPayloadExec) PreviousValues() *BoardPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "BoardPreviousValues"},
		"previousValues",
		[]string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"})

	return &BoardPreviousValuesExec{ret}
}

func (instance BoardSubscriptionPayloadExec) Exec(ctx context.Context) (*BoardSubscriptionPayload, error) {
	var v BoardSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BoardSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BoardSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance BoardSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]BoardSubscriptionPayload, error) {
	var v []BoardSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BoardSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type BoardSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Board       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type BoardPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance BoardPreviousValuesExec) Exec(ctx context.Context) (*BoardPreviousValues, error) {
	var v BoardPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance BoardPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type BoardPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance BoardPreviousValuesExecArray) Exec(ctx context.Context) ([]BoardPreviousValues, error) {
	var v []BoardPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var BoardPreviousValuesFields = []string{"id", "type", "title", "content", "createdAt", "updatedAt", "isDel"}

type BoardPreviousValues struct {
	ID        string `json:"id"`
	Type      int32  `json:"type"`
	Title     string `json:"title"`
	Content   string `json:"content"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	IsDel     *bool  `json:"isDel,omitempty"`
}

type CashHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CashHistorySubscriptionPayloadExec) Node() *CashHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CashHistory"},
		"node",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryExec{ret}
}

func (instance *CashHistorySubscriptionPayloadExec) PreviousValues() *CashHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CashHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"})

	return &CashHistoryPreviousValuesExec{ret}
}

func (instance CashHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*CashHistorySubscriptionPayload, error) {
	var v CashHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CashHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CashHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CashHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CashHistorySubscriptionPayload, error) {
	var v []CashHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CashHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CashHistorySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *CashHistory `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CashHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CashHistoryPreviousValuesExec) Exec(ctx context.Context) (*CashHistoryPreviousValues, error) {
	var v CashHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CashHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CashHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CashHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]CashHistoryPreviousValues, error) {
	var v []CashHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CashHistoryPreviousValuesFields = []string{"id", "type", "property", "orderNum", "description", "price", "oPrice", "oPriceBack", "qty", "memo", "createdAt", "updatedAt"}

type CashHistoryPreviousValues struct {
	ID          string   `json:"id"`
	Type        int32    `json:"type"`
	Property    *int32   `json:"property,omitempty"`
	OrderNum    *int32   `json:"orderNum,omitempty"`
	Description *string  `json:"description,omitempty"`
	Price       *int32   `json:"price,omitempty"`
	OPrice      *float64 `json:"oPrice,omitempty"`
	OPriceBack  *float64 `json:"oPriceBack,omitempty"`
	Qty         *float64 `json:"qty,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
}

type CategorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CategorySubscriptionPayloadExec) Node() *CategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Category"},
		"node",
		[]string{"id", "name", "order_index"})

	return &CategoryExec{ret}
}

func (instance *CategorySubscriptionPayloadExec) PreviousValues() *CategoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CategoryPreviousValues"},
		"previousValues",
		[]string{"id", "name", "order_index"})

	return &CategoryPreviousValuesExec{ret}
}

func (instance CategorySubscriptionPayloadExec) Exec(ctx context.Context) (*CategorySubscriptionPayload, error) {
	var v CategorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CategorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CategorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CategorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CategorySubscriptionPayload, error) {
	var v []CategorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CategorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CategorySubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Category    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CategoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CategoryPreviousValuesExec) Exec(ctx context.Context) (*CategoryPreviousValues, error) {
	var v CategoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CategoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CategoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CategoryPreviousValuesExecArray) Exec(ctx context.Context) ([]CategoryPreviousValues, error) {
	var v []CategoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CategoryPreviousValuesFields = []string{"id", "name", "order_index"}

type CategoryPreviousValues struct {
	ID         string   `json:"id"`
	Name       string   `json:"name"`
	OrderIndex *float64 `json:"order_index,omitempty"`
}

type CoinSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CoinSubscriptionPayloadExec) Node() *CoinExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Coin"},
		"node",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinExec{ret}
}

func (instance *CoinSubscriptionPayloadExec) PreviousValues() *CoinPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CoinPreviousValues"},
		"previousValues",
		[]string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"})

	return &CoinPreviousValuesExec{ret}
}

func (instance CoinSubscriptionPayloadExec) Exec(ctx context.Context) (*CoinSubscriptionPayload, error) {
	var v CoinSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CoinSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CoinSubscriptionPayload, error) {
	var v []CoinSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CoinSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Coin        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CoinPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CoinPreviousValuesExec) Exec(ctx context.Context) (*CoinPreviousValues, error) {
	var v CoinPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CoinPreviousValuesExecArray) Exec(ctx context.Context) ([]CoinPreviousValues, error) {
	var v []CoinPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinPreviousValuesFields = []string{"id", "name", "qty", "standardPrice", "currentPrice", "description", "status", "weight", "deployTxhash", "contractAddress", "oDDA", "createdAt", "updatedAt"}

type CoinPreviousValues struct {
	ID              string   `json:"id"`
	Name            string   `json:"name"`
	Qty             float64  `json:"qty"`
	StandardPrice   *float64 `json:"standardPrice,omitempty"`
	CurrentPrice    *float64 `json:"currentPrice,omitempty"`
	Description     string   `json:"description"`
	Status          int32    `json:"status"`
	Weight          string   `json:"weight"`
	DeployTxhash    *string  `json:"deployTxhash,omitempty"`
	ContractAddress *string  `json:"contractAddress,omitempty"`
	ODda            *float64 `json:"oDDA,omitempty"`
	CreatedAt       string   `json:"createdAt"`
	UpdatedAt       string   `json:"updatedAt"`
}

type CoinKlineSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CoinKlineSubscriptionPayloadExec) Node() *CoinKlineExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CoinKline"},
		"node",
		[]string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"})

	return &CoinKlineExec{ret}
}

func (instance *CoinKlineSubscriptionPayloadExec) PreviousValues() *CoinKlinePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CoinKlinePreviousValues"},
		"previousValues",
		[]string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"})

	return &CoinKlinePreviousValuesExec{ret}
}

func (instance CoinKlineSubscriptionPayloadExec) Exec(ctx context.Context) (*CoinKlineSubscriptionPayload, error) {
	var v CoinKlineSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinKlineSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinKlineSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CoinKlineSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CoinKlineSubscriptionPayload, error) {
	var v []CoinKlineSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinKlineSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CoinKlineSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *CoinKline   `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CoinKlinePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CoinKlinePreviousValuesExec) Exec(ctx context.Context) (*CoinKlinePreviousValues, error) {
	var v CoinKlinePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinKlinePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinKlinePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CoinKlinePreviousValuesExecArray) Exec(ctx context.Context) ([]CoinKlinePreviousValues, error) {
	var v []CoinKlinePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinKlinePreviousValuesFields = []string{"id", "open", "close", "high", "low", "volume", "deal", "createdAt", "updatedAt"}

type CoinKlinePreviousValues struct {
	ID        string  `json:"id"`
	Open      float64 `json:"open"`
	Close     float64 `json:"close"`
	High      float64 `json:"high"`
	Low       float64 `json:"low"`
	Volume    float64 `json:"volume"`
	Deal      float64 `json:"deal"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type CoinPriceTableSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CoinPriceTableSubscriptionPayloadExec) Node() *CoinPriceTableExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CoinPriceTable"},
		"node",
		[]string{"id", "type", "infoValue", "createdAt", "updatedAt"})

	return &CoinPriceTableExec{ret}
}

func (instance *CoinPriceTableSubscriptionPayloadExec) PreviousValues() *CoinPriceTablePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CoinPriceTablePreviousValues"},
		"previousValues",
		[]string{"id", "type", "infoValue", "createdAt", "updatedAt"})

	return &CoinPriceTablePreviousValuesExec{ret}
}

func (instance CoinPriceTableSubscriptionPayloadExec) Exec(ctx context.Context) (*CoinPriceTableSubscriptionPayload, error) {
	var v CoinPriceTableSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinPriceTableSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinPriceTableSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CoinPriceTableSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CoinPriceTableSubscriptionPayload, error) {
	var v []CoinPriceTableSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinPriceTableSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CoinPriceTableSubscriptionPayload struct {
	Mutation      MutationType    `json:"mutation"`
	Node          *CoinPriceTable `json:"node,omitempty"`
	UpdatedFields []string        `json:"updatedFields,omitempty"`
}

type CoinPriceTablePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CoinPriceTablePreviousValuesExec) Exec(ctx context.Context) (*CoinPriceTablePreviousValues, error) {
	var v CoinPriceTablePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CoinPriceTablePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CoinPriceTablePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CoinPriceTablePreviousValuesExecArray) Exec(ctx context.Context) ([]CoinPriceTablePreviousValues, error) {
	var v []CoinPriceTablePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CoinPriceTablePreviousValuesFields = []string{"id", "type", "infoValue", "createdAt", "updatedAt"}

type CoinPriceTablePreviousValues struct {
	ID        string    `json:"id"`
	Type      int32     `json:"type"`
	InfoValue []float64 `json:"infoValue,omitempty"`
	CreatedAt string    `json:"createdAt"`
	UpdatedAt string    `json:"updatedAt"`
}

type CommentSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CommentSubscriptionPayloadExec) Node() *CommentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Comment"},
		"node",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentExec{ret}
}

func (instance *CommentSubscriptionPayloadExec) PreviousValues() *CommentPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CommentPreviousValues"},
		"previousValues",
		[]string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"})

	return &CommentPreviousValuesExec{ret}
}

func (instance CommentSubscriptionPayloadExec) Exec(ctx context.Context) (*CommentSubscriptionPayload, error) {
	var v CommentSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CommentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CommentSubscriptionPayload, error) {
	var v []CommentSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CommentSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Comment     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type CommentPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CommentPreviousValuesExec) Exec(ctx context.Context) (*CommentPreviousValues, error) {
	var v CommentPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CommentPreviousValuesExecArray) Exec(ctx context.Context) ([]CommentPreviousValues, error) {
	var v []CommentPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentPreviousValuesFields = []string{"id", "type", "content", "url", "createdAt", "updatedAt", "isDel"}

type CommentPreviousValues struct {
	ID        string  `json:"id"`
	Type      *int32  `json:"type,omitempty"`
	Content   string  `json:"content"`
	Url       *string `json:"url,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
	IsDel     bool    `json:"isDel"`
}

type CommentReplySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *CommentReplySubscriptionPayloadExec) Node() *CommentReplyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CommentReply"},
		"node",
		[]string{"id", "content", "createdAt", "updatedAt", "isDel"})

	return &CommentReplyExec{ret}
}

func (instance *CommentReplySubscriptionPayloadExec) PreviousValues() *CommentReplyPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "CommentReplyPreviousValues"},
		"previousValues",
		[]string{"id", "content", "createdAt", "updatedAt", "isDel"})

	return &CommentReplyPreviousValuesExec{ret}
}

func (instance CommentReplySubscriptionPayloadExec) Exec(ctx context.Context) (*CommentReplySubscriptionPayload, error) {
	var v CommentReplySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentReplySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentReplySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance CommentReplySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]CommentReplySubscriptionPayload, error) {
	var v []CommentReplySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentReplySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type CommentReplySubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *CommentReply `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type CommentReplyPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance CommentReplyPreviousValuesExec) Exec(ctx context.Context) (*CommentReplyPreviousValues, error) {
	var v CommentReplyPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance CommentReplyPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type CommentReplyPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance CommentReplyPreviousValuesExecArray) Exec(ctx context.Context) ([]CommentReplyPreviousValues, error) {
	var v []CommentReplyPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var CommentReplyPreviousValuesFields = []string{"id", "content", "createdAt", "updatedAt", "isDel"}

type CommentReplyPreviousValues struct {
	ID        string `json:"id"`
	Content   string `json:"content"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	IsDel     bool   `json:"isDel"`
}

type DeviceSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *DeviceSubscriptionPayloadExec) Node() *DeviceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Device"},
		"node",
		[]string{"id", "code", "name"})

	return &DeviceExec{ret}
}

func (instance *DeviceSubscriptionPayloadExec) PreviousValues() *DevicePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "DevicePreviousValues"},
		"previousValues",
		[]string{"id", "code", "name"})

	return &DevicePreviousValuesExec{ret}
}

func (instance DeviceSubscriptionPayloadExec) Exec(ctx context.Context) (*DeviceSubscriptionPayload, error) {
	var v DeviceSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DeviceSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DeviceSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance DeviceSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]DeviceSubscriptionPayload, error) {
	var v []DeviceSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var DeviceSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type DeviceSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Device      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type DevicePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance DevicePreviousValuesExec) Exec(ctx context.Context) (*DevicePreviousValues, error) {
	var v DevicePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance DevicePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type DevicePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance DevicePreviousValuesExecArray) Exec(ctx context.Context) ([]DevicePreviousValues, error) {
	var v []DevicePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var DevicePreviousValuesFields = []string{"id", "code", "name"}

type DevicePreviousValues struct {
	ID   string `json:"id"`
	Code int32  `json:"code"`
	Name string `json:"name"`
}

type FeeSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FeeSubscriptionPayloadExec) Node() *FeeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Fee"},
		"node",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeeExec{ret}
}

func (instance *FeeSubscriptionPayloadExec) PreviousValues() *FeePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FeePreviousValues"},
		"previousValues",
		[]string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"})

	return &FeePreviousValuesExec{ret}
}

func (instance FeeSubscriptionPayloadExec) Exec(ctx context.Context) (*FeeSubscriptionPayload, error) {
	var v FeeSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeeSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FeeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FeeSubscriptionPayload, error) {
	var v []FeeSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FeeSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type FeeSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Fee         `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FeePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FeePreviousValuesExec) Exec(ctx context.Context) (*FeePreviousValues, error) {
	var v FeePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FeePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FeePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FeePreviousValuesExecArray) Exec(ctx context.Context) ([]FeePreviousValues, error) {
	var v []FeePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FeePreviousValuesFields = []string{"id", "type", "key", "memo", "rank", "askTakerFee", "askMakerFee", "bidTakerFee", "bidMakerFee", "myCoinAskTakerFee", "myCoinAskMakerFee", "myCoinBidTakerFee", "myCoinBidMakerFee", "createdAt", "updatedAt"}

type FeePreviousValues struct {
	ID                string   `json:"id"`
	Type              int32    `json:"type"`
	Key               int32    `json:"key"`
	Memo              *string  `json:"memo,omitempty"`
	Rank              *int32   `json:"rank,omitempty"`
	AskTakerFee       *float64 `json:"askTakerFee,omitempty"`
	AskMakerFee       *float64 `json:"askMakerFee,omitempty"`
	BidTakerFee       *float64 `json:"bidTakerFee,omitempty"`
	BidMakerFee       *float64 `json:"bidMakerFee,omitempty"`
	MyCoinAskTakerFee *float64 `json:"myCoinAskTakerFee,omitempty"`
	MyCoinAskMakerFee *float64 `json:"myCoinAskMakerFee,omitempty"`
	MyCoinBidTakerFee *float64 `json:"myCoinBidTakerFee,omitempty"`
	MyCoinBidMakerFee *float64 `json:"myCoinBidMakerFee,omitempty"`
	CreatedAt         string   `json:"createdAt"`
	UpdatedAt         string   `json:"updatedAt"`
}

type FileSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FileSubscriptionPayloadExec) Node() *FileExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "File"},
		"node",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FileExec{ret}
}

func (instance *FileSubscriptionPayloadExec) PreviousValues() *FilePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FilePreviousValues"},
		"previousValues",
		[]string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"})

	return &FilePreviousValuesExec{ret}
}

func (instance FileSubscriptionPayloadExec) Exec(ctx context.Context) (*FileSubscriptionPayload, error) {
	var v FileSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FileSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FileSubscriptionPayload, error) {
	var v []FileSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FileSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type FileSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *File        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FilePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FilePreviousValuesExec) Exec(ctx context.Context) (*FilePreviousValues, error) {
	var v FilePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FilePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FilePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FilePreviousValuesExecArray) Exec(ctx context.Context) ([]FilePreviousValues, error) {
	var v []FilePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FilePreviousValuesFields = []string{"id", "locationPath", "name", "contentType", "url", "createdAt", "isDel"}

type FilePreviousValues struct {
	ID           string  `json:"id"`
	LocationPath *string `json:"locationPath,omitempty"`
	Name         *string `json:"name,omitempty"`
	ContentType  *string `json:"contentType,omitempty"`
	Url          string  `json:"url"`
	CreatedAt    string  `json:"createdAt"`
	IsDel        bool    `json:"isDel"`
}

type FileInfoSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *FileInfoSubscriptionPayloadExec) Node() *FileInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileInfo"},
		"node",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoExec{ret}
}

func (instance *FileInfoSubscriptionPayloadExec) PreviousValues() *FileInfoPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "FileInfoPreviousValues"},
		"previousValues",
		[]string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"})

	return &FileInfoPreviousValuesExec{ret}
}

func (instance FileInfoSubscriptionPayloadExec) Exec(ctx context.Context) (*FileInfoSubscriptionPayload, error) {
	var v FileInfoSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileInfoSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileInfoSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance FileInfoSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]FileInfoSubscriptionPayload, error) {
	var v []FileInfoSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FileInfoSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type FileInfoSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *FileInfo    `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type FileInfoPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance FileInfoPreviousValuesExec) Exec(ctx context.Context) (*FileInfoPreviousValues, error) {
	var v FileInfoPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance FileInfoPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type FileInfoPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance FileInfoPreviousValuesExecArray) Exec(ctx context.Context) ([]FileInfoPreviousValues, error) {
	var v []FileInfoPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var FileInfoPreviousValuesFields = []string{"id", "tempFileId", "locationPath", "name", "contentType", "url", "isVideo", "isDel", "createdAt"}

type FileInfoPreviousValues struct {
	ID           string  `json:"id"`
	TempFileId   *string `json:"tempFileId,omitempty"`
	LocationPath *string `json:"locationPath,omitempty"`
	Name         *string `json:"name,omitempty"`
	ContentType  *string `json:"contentType,omitempty"`
	Url          string  `json:"url"`
	IsVideo      bool    `json:"isVideo"`
	IsDel        bool    `json:"isDel"`
	CreatedAt    string  `json:"createdAt"`
}

type InstagramSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *InstagramSubscriptionPayloadExec) Node() *InstagramExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Instagram"},
		"node",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramExec{ret}
}

func (instance *InstagramSubscriptionPayloadExec) PreviousValues() *InstagramPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InstagramPreviousValues"},
		"previousValues",
		[]string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &InstagramPreviousValuesExec{ret}
}

func (instance InstagramSubscriptionPayloadExec) Exec(ctx context.Context) (*InstagramSubscriptionPayload, error) {
	var v InstagramSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InstagramSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InstagramSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance InstagramSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]InstagramSubscriptionPayload, error) {
	var v []InstagramSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InstagramSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type InstagramSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Instagram   `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type InstagramPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance InstagramPreviousValuesExec) Exec(ctx context.Context) (*InstagramPreviousValues, error) {
	var v InstagramPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InstagramPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InstagramPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance InstagramPreviousValuesExecArray) Exec(ctx context.Context) ([]InstagramPreviousValues, error) {
	var v []InstagramPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InstagramPreviousValuesFields = []string{"id", "userId", "userNo", "userName", "postCount", "followerCount", "followingCount", "avatarUrl", "description", "pageUrl", "createdAt", "updatedAt"}

type InstagramPreviousValues struct {
	ID             string  `json:"id"`
	UserId         string  `json:"userId"`
	UserNo         string  `json:"userNo"`
	UserName       *string `json:"userName,omitempty"`
	PostCount      *string `json:"postCount,omitempty"`
	FollowerCount  *string `json:"followerCount,omitempty"`
	FollowingCount *string `json:"followingCount,omitempty"`
	AvatarUrl      *string `json:"avatarUrl,omitempty"`
	Description    *string `json:"description,omitempty"`
	PageUrl        *string `json:"pageUrl,omitempty"`
	CreatedAt      string  `json:"createdAt"`
	UpdatedAt      string  `json:"updatedAt"`
}

type InstagramDailyStatisticsSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *InstagramDailyStatisticsSubscriptionPayloadExec) Node() *InstagramDailyStatisticsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InstagramDailyStatistics"},
		"node",
		[]string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"})

	return &InstagramDailyStatisticsExec{ret}
}

func (instance *InstagramDailyStatisticsSubscriptionPayloadExec) PreviousValues() *InstagramDailyStatisticsPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InstagramDailyStatisticsPreviousValues"},
		"previousValues",
		[]string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"})

	return &InstagramDailyStatisticsPreviousValuesExec{ret}
}

func (instance InstagramDailyStatisticsSubscriptionPayloadExec) Exec(ctx context.Context) (*InstagramDailyStatisticsSubscriptionPayload, error) {
	var v InstagramDailyStatisticsSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InstagramDailyStatisticsSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InstagramDailyStatisticsSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance InstagramDailyStatisticsSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]InstagramDailyStatisticsSubscriptionPayload, error) {
	var v []InstagramDailyStatisticsSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InstagramDailyStatisticsSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type InstagramDailyStatisticsSubscriptionPayload struct {
	Mutation      MutationType              `json:"mutation"`
	Node          *InstagramDailyStatistics `json:"node,omitempty"`
	UpdatedFields []string                  `json:"updatedFields,omitempty"`
}

type InstagramDailyStatisticsPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance InstagramDailyStatisticsPreviousValuesExec) Exec(ctx context.Context) (*InstagramDailyStatisticsPreviousValues, error) {
	var v InstagramDailyStatisticsPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InstagramDailyStatisticsPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InstagramDailyStatisticsPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance InstagramDailyStatisticsPreviousValuesExecArray) Exec(ctx context.Context) ([]InstagramDailyStatisticsPreviousValues, error) {
	var v []InstagramDailyStatisticsPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InstagramDailyStatisticsPreviousValuesFields = []string{"id", "date", "postCount", "followerCount", "followingCount", "createdAt", "updatedAt"}

type InstagramDailyStatisticsPreviousValues struct {
	ID             string `json:"id"`
	Date           string `json:"date"`
	PostCount      string `json:"postCount"`
	FollowerCount  string `json:"followerCount"`
	FollowingCount string `json:"followingCount"`
	CreatedAt      string `json:"createdAt"`
	UpdatedAt      string `json:"updatedAt"`
}

type InviteCodeSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *InviteCodeSubscriptionPayloadExec) Node() *InviteCodeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InviteCode"},
		"node",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodeExec{ret}
}

func (instance *InviteCodeSubscriptionPayloadExec) PreviousValues() *InviteCodePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InviteCodePreviousValues"},
		"previousValues",
		[]string{"id", "numId", "code", "createdAt", "updatedAt"})

	return &InviteCodePreviousValuesExec{ret}
}

func (instance InviteCodeSubscriptionPayloadExec) Exec(ctx context.Context) (*InviteCodeSubscriptionPayload, error) {
	var v InviteCodeSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InviteCodeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InviteCodeSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance InviteCodeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]InviteCodeSubscriptionPayload, error) {
	var v []InviteCodeSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InviteCodeSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type InviteCodeSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *InviteCode  `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type InviteCodePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance InviteCodePreviousValuesExec) Exec(ctx context.Context) (*InviteCodePreviousValues, error) {
	var v InviteCodePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InviteCodePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InviteCodePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance InviteCodePreviousValuesExecArray) Exec(ctx context.Context) ([]InviteCodePreviousValues, error) {
	var v []InviteCodePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InviteCodePreviousValuesFields = []string{"id", "numId", "code", "createdAt", "updatedAt"}

type InviteCodePreviousValues struct {
	ID        string `json:"id"`
	NumId     int32  `json:"numId"`
	Code      string `json:"code"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type InviteUserHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *InviteUserHistorySubscriptionPayloadExec) Node() *InviteUserHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InviteUserHistory"},
		"node",
		[]string{"id", "createdAt", "updatedAt"})

	return &InviteUserHistoryExec{ret}
}

func (instance *InviteUserHistorySubscriptionPayloadExec) PreviousValues() *InviteUserHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "InviteUserHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt"})

	return &InviteUserHistoryPreviousValuesExec{ret}
}

func (instance InviteUserHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*InviteUserHistorySubscriptionPayload, error) {
	var v InviteUserHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InviteUserHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InviteUserHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance InviteUserHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]InviteUserHistorySubscriptionPayload, error) {
	var v []InviteUserHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InviteUserHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type InviteUserHistorySubscriptionPayload struct {
	Mutation      MutationType       `json:"mutation"`
	Node          *InviteUserHistory `json:"node,omitempty"`
	UpdatedFields []string           `json:"updatedFields,omitempty"`
}

type InviteUserHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance InviteUserHistoryPreviousValuesExec) Exec(ctx context.Context) (*InviteUserHistoryPreviousValues, error) {
	var v InviteUserHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance InviteUserHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type InviteUserHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance InviteUserHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]InviteUserHistoryPreviousValues, error) {
	var v []InviteUserHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var InviteUserHistoryPreviousValuesFields = []string{"id", "createdAt", "updatedAt"}

type InviteUserHistoryPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type MaintenanceSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *MaintenanceSubscriptionPayloadExec) Node() *MaintenanceExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Maintenance"},
		"node",
		[]string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"})

	return &MaintenanceExec{ret}
}

func (instance *MaintenanceSubscriptionPayloadExec) PreviousValues() *MaintenancePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MaintenancePreviousValues"},
		"previousValues",
		[]string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"})

	return &MaintenancePreviousValuesExec{ret}
}

func (instance MaintenanceSubscriptionPayloadExec) Exec(ctx context.Context) (*MaintenanceSubscriptionPayload, error) {
	var v MaintenanceSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MaintenanceSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MaintenanceSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance MaintenanceSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]MaintenanceSubscriptionPayload, error) {
	var v []MaintenanceSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MaintenanceSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type MaintenanceSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Maintenance `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type MaintenancePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance MaintenancePreviousValuesExec) Exec(ctx context.Context) (*MaintenancePreviousValues, error) {
	var v MaintenancePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MaintenancePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MaintenancePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance MaintenancePreviousValuesExecArray) Exec(ctx context.Context) ([]MaintenancePreviousValues, error) {
	var v []MaintenancePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MaintenancePreviousValuesFields = []string{"id", "type", "note", "fromDate", "toDate", "createdAt", "updatedAt", "isDel"}

type MaintenancePreviousValues struct {
	ID        string `json:"id"`
	Type      int32  `json:"type"`
	Note      string `json:"note"`
	FromDate  string `json:"fromDate"`
	ToDate    string `json:"toDate"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
	IsDel     bool   `json:"isDel"`
}

type MotherHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *MotherHistorySubscriptionPayloadExec) Node() *MotherHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MotherHistory"},
		"node",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryExec{ret}
}

func (instance *MotherHistorySubscriptionPayloadExec) PreviousValues() *MotherHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "MotherHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "type", "roleTime", "createdAt", "updatedAt"})

	return &MotherHistoryPreviousValuesExec{ret}
}

func (instance MotherHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*MotherHistorySubscriptionPayload, error) {
	var v MotherHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MotherHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MotherHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance MotherHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]MotherHistorySubscriptionPayload, error) {
	var v []MotherHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MotherHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type MotherHistorySubscriptionPayload struct {
	Mutation      MutationType   `json:"mutation"`
	Node          *MotherHistory `json:"node,omitempty"`
	UpdatedFields []string       `json:"updatedFields,omitempty"`
}

type MotherHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance MotherHistoryPreviousValuesExec) Exec(ctx context.Context) (*MotherHistoryPreviousValues, error) {
	var v MotherHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance MotherHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type MotherHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance MotherHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]MotherHistoryPreviousValues, error) {
	var v []MotherHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var MotherHistoryPreviousValuesFields = []string{"id", "type", "roleTime", "createdAt", "updatedAt"}

type MotherHistoryPreviousValues struct {
	ID        string `json:"id"`
	Type      int32  `json:"type"`
	RoleTime  string `json:"roleTime"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type NotificationSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *NotificationSubscriptionPayloadExec) Node() *NotificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Notification"},
		"node",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationExec{ret}
}

func (instance *NotificationSubscriptionPayloadExec) PreviousValues() *NotificationPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "NotificationPreviousValues"},
		"previousValues",
		[]string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"})

	return &NotificationPreviousValuesExec{ret}
}

func (instance NotificationSubscriptionPayloadExec) Exec(ctx context.Context) (*NotificationSubscriptionPayload, error) {
	var v NotificationSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NotificationSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NotificationSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance NotificationSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]NotificationSubscriptionPayload, error) {
	var v []NotificationSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NotificationSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type NotificationSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *Notification `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type NotificationPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance NotificationPreviousValuesExec) Exec(ctx context.Context) (*NotificationPreviousValues, error) {
	var v NotificationPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance NotificationPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type NotificationPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance NotificationPreviousValuesExecArray) Exec(ctx context.Context) ([]NotificationPreviousValues, error) {
	var v []NotificationPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var NotificationPreviousValuesFields = []string{"id", "notiType", "pushType", "pushState", "topic", "linkType", "linkValue", "message", "image", "publishType", "publishDate", "createdAt", "updatedAt", "isDel"}

type NotificationPreviousValues struct {
	ID          string  `json:"id"`
	NotiType    int32   `json:"notiType"`
	PushType    int32   `json:"pushType"`
	PushState   int32   `json:"pushState"`
	Topic       *string `json:"topic,omitempty"`
	LinkType    string  `json:"linkType"`
	LinkValue   string  `json:"linkValue"`
	Message     string  `json:"message"`
	Image       *string `json:"image,omitempty"`
	PublishType int32   `json:"publishType"`
	PublishDate string  `json:"publishDate"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
	IsDel       bool    `json:"isDel"`
}

type OfferSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *OfferSubscriptionPayloadExec) Node() *OfferExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Offer"},
		"node",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferExec{ret}
}

func (instance *OfferSubscriptionPayloadExec) PreviousValues() *OfferPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OfferPreviousValues"},
		"previousValues",
		[]string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"})

	return &OfferPreviousValuesExec{ret}
}

func (instance OfferSubscriptionPayloadExec) Exec(ctx context.Context) (*OfferSubscriptionPayload, error) {
	var v OfferSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OfferSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OfferSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance OfferSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]OfferSubscriptionPayload, error) {
	var v []OfferSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OfferSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type OfferSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Offer       `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type OfferPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance OfferPreviousValuesExec) Exec(ctx context.Context) (*OfferPreviousValues, error) {
	var v OfferPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OfferPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OfferPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance OfferPreviousValuesExecArray) Exec(ctx context.Context) ([]OfferPreviousValues, error) {
	var v []OfferPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OfferPreviousValuesFields = []string{"id", "qty", "fromDate", "toDate", "createdAt", "updatedAt"}

type OfferPreviousValues struct {
	ID        string `json:"id"`
	Qty       int32  `json:"qty"`
	FromDate  string `json:"fromDate"`
	ToDate    string `json:"toDate"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type OfferorSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *OfferorSubscriptionPayloadExec) Node() *OfferorExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Offeror"},
		"node",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorExec{ret}
}

func (instance *OfferorSubscriptionPayloadExec) PreviousValues() *OfferorPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OfferorPreviousValues"},
		"previousValues",
		[]string{"id", "price", "createdAt", "updatedAt"})

	return &OfferorPreviousValuesExec{ret}
}

func (instance OfferorSubscriptionPayloadExec) Exec(ctx context.Context) (*OfferorSubscriptionPayload, error) {
	var v OfferorSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OfferorSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OfferorSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance OfferorSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]OfferorSubscriptionPayload, error) {
	var v []OfferorSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OfferorSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type OfferorSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Offeror     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type OfferorPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance OfferorPreviousValuesExec) Exec(ctx context.Context) (*OfferorPreviousValues, error) {
	var v OfferorPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OfferorPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OfferorPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance OfferorPreviousValuesExecArray) Exec(ctx context.Context) ([]OfferorPreviousValues, error) {
	var v []OfferorPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OfferorPreviousValuesFields = []string{"id", "price", "createdAt", "updatedAt"}

type OfferorPreviousValues struct {
	ID        string `json:"id"`
	Price     int32  `json:"price"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type OrderDealsHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *OrderDealsHistorySubscriptionPayloadExec) Node() *OrderDealsHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderDealsHistory"},
		"node",
		[]string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"})

	return &OrderDealsHistoryExec{ret}
}

func (instance *OrderDealsHistorySubscriptionPayloadExec) PreviousValues() *OrderDealsHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderDealsHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"})

	return &OrderDealsHistoryPreviousValuesExec{ret}
}

func (instance OrderDealsHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*OrderDealsHistorySubscriptionPayload, error) {
	var v OrderDealsHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderDealsHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderDealsHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance OrderDealsHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]OrderDealsHistorySubscriptionPayload, error) {
	var v []OrderDealsHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderDealsHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type OrderDealsHistorySubscriptionPayload struct {
	Mutation      MutationType       `json:"mutation"`
	Node          *OrderDealsHistory `json:"node,omitempty"`
	UpdatedFields []string           `json:"updatedFields,omitempty"`
}

type OrderDealsHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance OrderDealsHistoryPreviousValuesExec) Exec(ctx context.Context) (*OrderDealsHistoryPreviousValues, error) {
	var v OrderDealsHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderDealsHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderDealsHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance OrderDealsHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]OrderDealsHistoryPreviousValues, error) {
	var v []OrderDealsHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderDealsHistoryPreviousValuesFields = []string{"id", "type", "dealId", "dealPrice", "dealQty", "time", "createdAt", "updatedAt"}

type OrderDealsHistoryPreviousValues struct {
	ID        string   `json:"id"`
	Type      int32    `json:"type"`
	DealId    int32    `json:"dealId"`
	DealPrice float64  `json:"dealPrice"`
	DealQty   float64  `json:"dealQty"`
	Time      *float64 `json:"time,omitempty"`
	CreatedAt string   `json:"createdAt"`
	UpdatedAt string   `json:"updatedAt"`
}

type OrderHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *OrderHistorySubscriptionPayloadExec) Node() *OrderHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderHistory"},
		"node",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryExec{ret}
}

func (instance *OrderHistorySubscriptionPayloadExec) PreviousValues() *OrderHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"})

	return &OrderHistoryPreviousValuesExec{ret}
}

func (instance OrderHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*OrderHistorySubscriptionPayload, error) {
	var v OrderHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance OrderHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]OrderHistorySubscriptionPayload, error) {
	var v []OrderHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type OrderHistorySubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *OrderHistory `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type OrderHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance OrderHistoryPreviousValuesExec) Exec(ctx context.Context) (*OrderHistoryPreviousValues, error) {
	var v OrderHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance OrderHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]OrderHistoryPreviousValues, error) {
	var v []OrderHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderHistoryPreviousValuesFields = []string{"id", "type", "orderNum", "orderPrice", "dealPrice", "orderQty", "dealQty", "leftQty", "dealFee", "takerFee", "makerFee", "memo", "description", "offset", "isCancel", "createdAt", "updatedAt"}

type OrderHistoryPreviousValues struct {
	ID          string   `json:"id"`
	Type        int32    `json:"type"`
	OrderNum    int32    `json:"orderNum"`
	OrderPrice  float64  `json:"orderPrice"`
	DealPrice   float64  `json:"dealPrice"`
	OrderQty    float64  `json:"orderQty"`
	DealQty     float64  `json:"dealQty"`
	LeftQty     float64  `json:"leftQty"`
	DealFee     float64  `json:"dealFee"`
	TakerFee    *float64 `json:"takerFee,omitempty"`
	MakerFee    *float64 `json:"makerFee,omitempty"`
	Memo        *string  `json:"memo,omitempty"`
	Description *string  `json:"description,omitempty"`
	Offset      *int32   `json:"offset,omitempty"`
	IsCancel    *bool    `json:"isCancel,omitempty"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
}

type OrderUserDealsHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *OrderUserDealsHistorySubscriptionPayloadExec) Node() *OrderUserDealsHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderUserDealsHistory"},
		"node",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryExec{ret}
}

func (instance *OrderUserDealsHistorySubscriptionPayloadExec) PreviousValues() *OrderUserDealsHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "OrderUserDealsHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"})

	return &OrderUserDealsHistoryPreviousValuesExec{ret}
}

func (instance OrderUserDealsHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*OrderUserDealsHistorySubscriptionPayload, error) {
	var v OrderUserDealsHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderUserDealsHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderUserDealsHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance OrderUserDealsHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]OrderUserDealsHistorySubscriptionPayload, error) {
	var v []OrderUserDealsHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderUserDealsHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type OrderUserDealsHistorySubscriptionPayload struct {
	Mutation      MutationType           `json:"mutation"`
	Node          *OrderUserDealsHistory `json:"node,omitempty"`
	UpdatedFields []string               `json:"updatedFields,omitempty"`
}

type OrderUserDealsHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance OrderUserDealsHistoryPreviousValuesExec) Exec(ctx context.Context) (*OrderUserDealsHistoryPreviousValues, error) {
	var v OrderUserDealsHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance OrderUserDealsHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type OrderUserDealsHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance OrderUserDealsHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]OrderUserDealsHistoryPreviousValues, error) {
	var v []OrderUserDealsHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var OrderUserDealsHistoryPreviousValuesFields = []string{"id", "type", "role", "dealId", "uniqueKey", "uniqueId", "dealPrice", "dealQty", "fee", "dealOrderId", "time", "createdAt", "updatedAt"}

type OrderUserDealsHistoryPreviousValues struct {
	ID          string   `json:"id"`
	Type        int32    `json:"type"`
	Role        *int32   `json:"role,omitempty"`
	DealId      int32    `json:"dealId"`
	UniqueKey   string   `json:"uniqueKey"`
	UniqueId    int32    `json:"uniqueId"`
	DealPrice   float64  `json:"dealPrice"`
	DealQty     float64  `json:"dealQty"`
	Fee         float64  `json:"fee"`
	DealOrderId *int32   `json:"dealOrderId,omitempty"`
	Time        *float64 `json:"time,omitempty"`
	CreatedAt   string   `json:"createdAt"`
	UpdatedAt   string   `json:"updatedAt"`
}

type PageSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PageSubscriptionPayloadExec) Node() *PageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Page"},
		"node",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PageExec{ret}
}

func (instance *PageSubscriptionPayloadExec) PreviousValues() *PagePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PagePreviousValues"},
		"previousValues",
		[]string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"})

	return &PagePreviousValuesExec{ret}
}

func (instance PageSubscriptionPayloadExec) Exec(ctx context.Context) (*PageSubscriptionPayload, error) {
	var v PageSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PageSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PageSubscriptionPayload, error) {
	var v []PageSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PageSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Page        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PagePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PagePreviousValuesExec) Exec(ctx context.Context) (*PagePreviousValues, error) {
	var v PagePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PagePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PagePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PagePreviousValuesExecArray) Exec(ctx context.Context) ([]PagePreviousValues, error) {
	var v []PagePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PagePreviousValuesFields = []string{"id", "pageId", "nickName", "avatarUrl", "coverUrl", "description", "createdAt", "updatedAt"}

type PagePreviousValues struct {
	ID          string  `json:"id"`
	PageId      string  `json:"pageId"`
	NickName    *string `json:"nickName,omitempty"`
	AvatarUrl   *string `json:"avatarUrl,omitempty"`
	CoverUrl    *string `json:"coverUrl,omitempty"`
	Description *string `json:"description,omitempty"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
}

type PageBadgeSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PageBadgeSubscriptionPayloadExec) Node() *PageBadgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageBadge"},
		"node",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgeExec{ret}
}

func (instance *PageBadgeSubscriptionPayloadExec) PreviousValues() *PageBadgePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageBadgePreviousValues"},
		"previousValues",
		[]string{"id", "vote", "createdAt", "updatedAt"})

	return &PageBadgePreviousValuesExec{ret}
}

func (instance PageBadgeSubscriptionPayloadExec) Exec(ctx context.Context) (*PageBadgeSubscriptionPayload, error) {
	var v PageBadgeSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageBadgeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageBadgeSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PageBadgeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PageBadgeSubscriptionPayload, error) {
	var v []PageBadgeSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageBadgeSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PageBadgeSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *PageBadge   `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PageBadgePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PageBadgePreviousValuesExec) Exec(ctx context.Context) (*PageBadgePreviousValues, error) {
	var v PageBadgePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageBadgePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageBadgePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PageBadgePreviousValuesExecArray) Exec(ctx context.Context) ([]PageBadgePreviousValues, error) {
	var v []PageBadgePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageBadgePreviousValuesFields = []string{"id", "vote", "createdAt", "updatedAt"}

type PageBadgePreviousValues struct {
	ID        string `json:"id"`
	Vote      int32  `json:"vote"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type PageCommentSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PageCommentSubscriptionPayloadExec) Node() *PageCommentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageComment"},
		"node",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentExec{ret}
}

func (instance *PageCommentSubscriptionPayloadExec) PreviousValues() *PageCommentPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageCommentPreviousValues"},
		"previousValues",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentPreviousValuesExec{ret}
}

func (instance PageCommentSubscriptionPayloadExec) Exec(ctx context.Context) (*PageCommentSubscriptionPayload, error) {
	var v PageCommentSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageCommentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageCommentSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PageCommentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PageCommentSubscriptionPayload, error) {
	var v []PageCommentSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageCommentSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PageCommentSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *PageComment `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PageCommentPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PageCommentPreviousValuesExec) Exec(ctx context.Context) (*PageCommentPreviousValues, error) {
	var v PageCommentPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageCommentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageCommentPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PageCommentPreviousValuesExecArray) Exec(ctx context.Context) ([]PageCommentPreviousValues, error) {
	var v []PageCommentPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageCommentPreviousValuesFields = []string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"}

type PageCommentPreviousValues struct {
	ID                string  `json:"id"`
	Content           string  `json:"content"`
	IpAddress         *string `json:"ipAddress,omitempty"`
	ImageUrl          *string `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string `json:"thumbnailImageUrl,omitempty"`
	CreatedAt         string  `json:"createdAt"`
	UpdatedAt         string  `json:"updatedAt"`
	IsDel             bool    `json:"isDel"`
}

type PageCommentReplySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PageCommentReplySubscriptionPayloadExec) Node() *PageCommentReplyExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageCommentReply"},
		"node",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentReplyExec{ret}
}

func (instance *PageCommentReplySubscriptionPayloadExec) PreviousValues() *PageCommentReplyPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageCommentReplyPreviousValues"},
		"previousValues",
		[]string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"})

	return &PageCommentReplyPreviousValuesExec{ret}
}

func (instance PageCommentReplySubscriptionPayloadExec) Exec(ctx context.Context) (*PageCommentReplySubscriptionPayload, error) {
	var v PageCommentReplySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageCommentReplySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageCommentReplySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PageCommentReplySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PageCommentReplySubscriptionPayload, error) {
	var v []PageCommentReplySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageCommentReplySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PageCommentReplySubscriptionPayload struct {
	Mutation      MutationType      `json:"mutation"`
	Node          *PageCommentReply `json:"node,omitempty"`
	UpdatedFields []string          `json:"updatedFields,omitempty"`
}

type PageCommentReplyPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PageCommentReplyPreviousValuesExec) Exec(ctx context.Context) (*PageCommentReplyPreviousValues, error) {
	var v PageCommentReplyPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageCommentReplyPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageCommentReplyPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PageCommentReplyPreviousValuesExecArray) Exec(ctx context.Context) ([]PageCommentReplyPreviousValues, error) {
	var v []PageCommentReplyPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageCommentReplyPreviousValuesFields = []string{"id", "content", "ipAddress", "imageUrl", "thumbnailImageUrl", "createdAt", "updatedAt", "isDel"}

type PageCommentReplyPreviousValues struct {
	ID                string  `json:"id"`
	Content           string  `json:"content"`
	IpAddress         *string `json:"ipAddress,omitempty"`
	ImageUrl          *string `json:"imageUrl,omitempty"`
	ThumbnailImageUrl *string `json:"thumbnailImageUrl,omitempty"`
	CreatedAt         string  `json:"createdAt"`
	UpdatedAt         string  `json:"updatedAt"`
	IsDel             bool    `json:"isDel"`
}

type PageFanSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PageFanSubscriptionPayloadExec) Node() *PageFanExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageFan"},
		"node",
		[]string{"id", "createdAt", "updatedAt"})

	return &PageFanExec{ret}
}

func (instance *PageFanSubscriptionPayloadExec) PreviousValues() *PageFanPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageFanPreviousValues"},
		"previousValues",
		[]string{"id", "createdAt", "updatedAt"})

	return &PageFanPreviousValuesExec{ret}
}

func (instance PageFanSubscriptionPayloadExec) Exec(ctx context.Context) (*PageFanSubscriptionPayload, error) {
	var v PageFanSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageFanSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageFanSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PageFanSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PageFanSubscriptionPayload, error) {
	var v []PageFanSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageFanSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PageFanSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *PageFan     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PageFanPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PageFanPreviousValuesExec) Exec(ctx context.Context) (*PageFanPreviousValues, error) {
	var v PageFanPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageFanPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageFanPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PageFanPreviousValuesExecArray) Exec(ctx context.Context) ([]PageFanPreviousValues, error) {
	var v []PageFanPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PageFanPreviousValuesFields = []string{"id", "createdAt", "updatedAt"}

type PageFanPreviousValues struct {
	ID        string `json:"id"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type PaymentHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PaymentHistorySubscriptionPayloadExec) Node() *PaymentHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentHistory"},
		"node",
		[]string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"})

	return &PaymentHistoryExec{ret}
}

func (instance *PaymentHistorySubscriptionPayloadExec) PreviousValues() *PaymentHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PaymentHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"})

	return &PaymentHistoryPreviousValuesExec{ret}
}

func (instance PaymentHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*PaymentHistorySubscriptionPayload, error) {
	var v PaymentHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PaymentHistorySubscriptionPayload, error) {
	var v []PaymentHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PaymentHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PaymentHistorySubscriptionPayload struct {
	Mutation      MutationType    `json:"mutation"`
	Node          *PaymentHistory `json:"node,omitempty"`
	UpdatedFields []string        `json:"updatedFields,omitempty"`
}

type PaymentHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PaymentHistoryPreviousValuesExec) Exec(ctx context.Context) (*PaymentHistoryPreviousValues, error) {
	var v PaymentHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PaymentHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PaymentHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PaymentHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]PaymentHistoryPreviousValues, error) {
	var v []PaymentHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PaymentHistoryPreviousValuesFields = []string{"id", "code", "message", "order_no", "service_name", "product_name", "custom_parameter", "tid", "cid", "amount", "amount_fee", "amount_without_fee", "pgcode", "pay_info", "domestic_flag", "transaction_date", "install_month", "card_info", "payhash", "account_no", "account_name", "bank_code", "bank_name", "expire_date", "expire_time", "issue_tid", "createdAt"}

type PaymentHistoryPreviousValues struct {
	ID               string  `json:"id"`
	Code             *string `json:"code,omitempty"`
	Message          *string `json:"message,omitempty"`
	OrderNo          *string `json:"order_no,omitempty"`
	ServiceName      *string `json:"service_name,omitempty"`
	ProductName      *string `json:"product_name,omitempty"`
	CustomParameter  *string `json:"custom_parameter,omitempty"`
	Tid              *string `json:"tid,omitempty"`
	Cid              *string `json:"cid,omitempty"`
	Amount           *int32  `json:"amount,omitempty"`
	AmountFee        *int32  `json:"amount_fee,omitempty"`
	AmountWithoutFee *int32  `json:"amount_without_fee,omitempty"`
	Pgcode           *string `json:"pgcode,omitempty"`
	PayInfo          *string `json:"pay_info,omitempty"`
	DomesticFlag     *string `json:"domestic_flag,omitempty"`
	TransactionDate  *string `json:"transaction_date,omitempty"`
	InstallMonth     *string `json:"install_month,omitempty"`
	CardInfo         *string `json:"card_info,omitempty"`
	Payhash          *string `json:"payhash,omitempty"`
	AccountNo        *string `json:"account_no,omitempty"`
	AccountName      *string `json:"account_name,omitempty"`
	BankCode         *string `json:"bank_code,omitempty"`
	BankName         *string `json:"bank_name,omitempty"`
	ExpireDate       *string `json:"expire_date,omitempty"`
	ExpireTime       *string `json:"expire_time,omitempty"`
	IssueTid         *string `json:"issue_tid,omitempty"`
	CreatedAt        string  `json:"createdAt"`
}

type PhoneVerificationSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PhoneVerificationSubscriptionPayloadExec) Node() *PhoneVerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneVerification"},
		"node",
		[]string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"})

	return &PhoneVerificationExec{ret}
}

func (instance *PhoneVerificationSubscriptionPayloadExec) PreviousValues() *PhoneVerificationPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PhoneVerificationPreviousValues"},
		"previousValues",
		[]string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"})

	return &PhoneVerificationPreviousValuesExec{ret}
}

func (instance PhoneVerificationSubscriptionPayloadExec) Exec(ctx context.Context) (*PhoneVerificationSubscriptionPayload, error) {
	var v PhoneVerificationSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneVerificationSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneVerificationSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneVerificationSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PhoneVerificationSubscriptionPayload, error) {
	var v []PhoneVerificationSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PhoneVerificationSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PhoneVerificationSubscriptionPayload struct {
	Mutation      MutationType       `json:"mutation"`
	Node          *PhoneVerification `json:"node,omitempty"`
	UpdatedFields []string           `json:"updatedFields,omitempty"`
}

type PhoneVerificationPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PhoneVerificationPreviousValuesExec) Exec(ctx context.Context) (*PhoneVerificationPreviousValues, error) {
	var v PhoneVerificationPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PhoneVerificationPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PhoneVerificationPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PhoneVerificationPreviousValuesExecArray) Exec(ctx context.Context) ([]PhoneVerificationPreviousValues, error) {
	var v []PhoneVerificationPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PhoneVerificationPreviousValuesFields = []string{"id", "name", "birth", "foreigner", "gender", "phoneNumber", "CI", "DI", "imp_uid", "merchant_uid", "createdAt", "updatedAt"}

type PhoneVerificationPreviousValues struct {
	ID          string  `json:"id"`
	Name        string  `json:"name"`
	Birth       string  `json:"birth"`
	Foreigner   *bool   `json:"foreigner,omitempty"`
	Gender      string  `json:"gender"`
	PhoneNumber *string `json:"phoneNumber,omitempty"`
	Ci          string  `json:"CI"`
	Di          string  `json:"DI"`
	ImpUid      *string `json:"imp_uid,omitempty"`
	MerchantUid *string `json:"merchant_uid,omitempty"`
	CreatedAt   string  `json:"createdAt"`
	UpdatedAt   string  `json:"updatedAt"`
}

type PostSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PostSubscriptionPayloadExec) Node() *PostExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Post"},
		"node",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostExec{ret}
}

func (instance *PostSubscriptionPayloadExec) PreviousValues() *PostPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PostPreviousValues"},
		"previousValues",
		[]string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"})

	return &PostPreviousValuesExec{ret}
}

func (instance PostSubscriptionPayloadExec) Exec(ctx context.Context) (*PostSubscriptionPayload, error) {
	var v PostSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PostSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PostSubscriptionPayload, error) {
	var v []PostSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PostSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Post        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type PostPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PostPreviousValuesExec) Exec(ctx context.Context) (*PostPreviousValues, error) {
	var v PostPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PostPreviousValuesExecArray) Exec(ctx context.Context) ([]PostPreviousValues, error) {
	var v []PostPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostPreviousValuesFields = []string{"id", "type", "payType", "content", "questTitle", "questCost", "questMinMemberCount", "questLimitMemberCount", "questToDate", "questStatus", "createdAt", "updatedAt", "isBanner", "isDel", "enableEarlyAccess", "publicAccessAt", "order_index"}

type PostPreviousValues struct {
	ID                    string   `json:"id"`
	Type                  int32    `json:"type"`
	PayType               int32    `json:"payType"`
	Content               string   `json:"content"`
	QuestTitle            *string  `json:"questTitle,omitempty"`
	QuestCost             *float64 `json:"questCost,omitempty"`
	QuestMinMemberCount   *int32   `json:"questMinMemberCount,omitempty"`
	QuestLimitMemberCount *int32   `json:"questLimitMemberCount,omitempty"`
	QuestToDate           *string  `json:"questToDate,omitempty"`
	QuestStatus           *int32   `json:"questStatus,omitempty"`
	CreatedAt             string   `json:"createdAt"`
	UpdatedAt             string   `json:"updatedAt"`
	IsBanner              bool     `json:"isBanner"`
	IsDel                 bool     `json:"isDel"`
	EnableEarlyAccess     *bool    `json:"enableEarlyAccess,omitempty"`
	PublicAccessAt        *string  `json:"publicAccessAt,omitempty"`
	OrderIndex            *float64 `json:"order_index,omitempty"`
}

type PostRewardHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *PostRewardHistorySubscriptionPayloadExec) Node() *PostRewardHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PostRewardHistory"},
		"node",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryExec{ret}
}

func (instance *PostRewardHistorySubscriptionPayloadExec) PreviousValues() *PostRewardHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PostRewardHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &PostRewardHistoryPreviousValuesExec{ret}
}

func (instance PostRewardHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*PostRewardHistorySubscriptionPayload, error) {
	var v PostRewardHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostRewardHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostRewardHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance PostRewardHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]PostRewardHistorySubscriptionPayload, error) {
	var v []PostRewardHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostRewardHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type PostRewardHistorySubscriptionPayload struct {
	Mutation      MutationType       `json:"mutation"`
	Node          *PostRewardHistory `json:"node,omitempty"`
	UpdatedFields []string           `json:"updatedFields,omitempty"`
}

type PostRewardHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance PostRewardHistoryPreviousValuesExec) Exec(ctx context.Context) (*PostRewardHistoryPreviousValues, error) {
	var v PostRewardHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PostRewardHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PostRewardHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance PostRewardHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]PostRewardHistoryPreviousValues, error) {
	var v []PostRewardHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var PostRewardHistoryPreviousValuesFields = []string{"id", "type", "description", "qty", "currentPrice", "memo", "createdAt", "updatedAt"}

type PostRewardHistoryPreviousValues struct {
	ID           string   `json:"id"`
	Type         int32    `json:"type"`
	Description  *string  `json:"description,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
}

type QuestExpenditureHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *QuestExpenditureHistorySubscriptionPayloadExec) Node() *QuestExpenditureHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "QuestExpenditureHistory"},
		"node",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryExec{ret}
}

func (instance *QuestExpenditureHistorySubscriptionPayloadExec) PreviousValues() *QuestExpenditureHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "QuestExpenditureHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"})

	return &QuestExpenditureHistoryPreviousValuesExec{ret}
}

func (instance QuestExpenditureHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*QuestExpenditureHistorySubscriptionPayload, error) {
	var v QuestExpenditureHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance QuestExpenditureHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type QuestExpenditureHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance QuestExpenditureHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]QuestExpenditureHistorySubscriptionPayload, error) {
	var v []QuestExpenditureHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var QuestExpenditureHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type QuestExpenditureHistorySubscriptionPayload struct {
	Mutation      MutationType             `json:"mutation"`
	Node          *QuestExpenditureHistory `json:"node,omitempty"`
	UpdatedFields []string                 `json:"updatedFields,omitempty"`
}

type QuestExpenditureHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance QuestExpenditureHistoryPreviousValuesExec) Exec(ctx context.Context) (*QuestExpenditureHistoryPreviousValues, error) {
	var v QuestExpenditureHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance QuestExpenditureHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type QuestExpenditureHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance QuestExpenditureHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]QuestExpenditureHistoryPreviousValues, error) {
	var v []QuestExpenditureHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var QuestExpenditureHistoryPreviousValuesFields = []string{"id", "type", "payType", "orderNum", "description", "price", "qty", "oPrice", "currentPrice", "memo", "createdAt", "updatedAt"}

type QuestExpenditureHistoryPreviousValues struct {
	ID           string   `json:"id"`
	Type         int32    `json:"type"`
	PayType      int32    `json:"payType"`
	OrderNum     *int32   `json:"orderNum,omitempty"`
	Description  *string  `json:"description,omitempty"`
	Price        *int32   `json:"price,omitempty"`
	Qty          *float64 `json:"qty,omitempty"`
	OPrice       *int32   `json:"oPrice,omitempty"`
	CurrentPrice *float64 `json:"currentPrice,omitempty"`
	Memo         *string  `json:"memo,omitempty"`
	CreatedAt    string   `json:"createdAt"`
	UpdatedAt    string   `json:"updatedAt"`
}

type QuestMemberSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *QuestMemberSubscriptionPayloadExec) Node() *QuestMemberExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "QuestMember"},
		"node",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberExec{ret}
}

func (instance *QuestMemberSubscriptionPayloadExec) PreviousValues() *QuestMemberPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "QuestMemberPreviousValues"},
		"previousValues",
		[]string{"id", "note", "createdAt", "isDel"})

	return &QuestMemberPreviousValuesExec{ret}
}

func (instance QuestMemberSubscriptionPayloadExec) Exec(ctx context.Context) (*QuestMemberSubscriptionPayload, error) {
	var v QuestMemberSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance QuestMemberSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type QuestMemberSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance QuestMemberSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]QuestMemberSubscriptionPayload, error) {
	var v []QuestMemberSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var QuestMemberSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type QuestMemberSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *QuestMember `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type QuestMemberPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance QuestMemberPreviousValuesExec) Exec(ctx context.Context) (*QuestMemberPreviousValues, error) {
	var v QuestMemberPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance QuestMemberPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type QuestMemberPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance QuestMemberPreviousValuesExecArray) Exec(ctx context.Context) ([]QuestMemberPreviousValues, error) {
	var v []QuestMemberPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var QuestMemberPreviousValuesFields = []string{"id", "note", "createdAt", "isDel"}

type QuestMemberPreviousValues struct {
	ID        string  `json:"id"`
	Note      *string `json:"note,omitempty"`
	CreatedAt string  `json:"createdAt"`
	IsDel     bool    `json:"isDel"`
}

type ReportSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ReportSubscriptionPayloadExec) Node() *ReportExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Report"},
		"node",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportExec{ret}
}

func (instance *ReportSubscriptionPayloadExec) PreviousValues() *ReportPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReportPreviousValues"},
		"previousValues",
		[]string{"id", "type", "reportType", "createdAt"})

	return &ReportPreviousValuesExec{ret}
}

func (instance ReportSubscriptionPayloadExec) Exec(ctx context.Context) (*ReportSubscriptionPayload, error) {
	var v ReportSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReportSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReportSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ReportSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ReportSubscriptionPayload, error) {
	var v []ReportSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReportSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ReportSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Report      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type ReportPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ReportPreviousValuesExec) Exec(ctx context.Context) (*ReportPreviousValues, error) {
	var v ReportPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReportPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReportPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ReportPreviousValuesExecArray) Exec(ctx context.Context) ([]ReportPreviousValues, error) {
	var v []ReportPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReportPreviousValuesFields = []string{"id", "type", "reportType", "createdAt"}

type ReportPreviousValues struct {
	ID         string `json:"id"`
	Type       int32  `json:"type"`
	ReportType int32  `json:"reportType"`
	CreatedAt  string `json:"createdAt"`
}

type RequestPageItemSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *RequestPageItemSubscriptionPayloadExec) Node() *RequestPageItemExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RequestPageItem"},
		"node",
		[]string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"})

	return &RequestPageItemExec{ret}
}

func (instance *RequestPageItemSubscriptionPayloadExec) PreviousValues() *RequestPageItemPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RequestPageItemPreviousValues"},
		"previousValues",
		[]string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"})

	return &RequestPageItemPreviousValuesExec{ret}
}

func (instance RequestPageItemSubscriptionPayloadExec) Exec(ctx context.Context) (*RequestPageItemSubscriptionPayload, error) {
	var v RequestPageItemSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RequestPageItemSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RequestPageItemSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance RequestPageItemSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RequestPageItemSubscriptionPayload, error) {
	var v []RequestPageItemSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RequestPageItemSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type RequestPageItemSubscriptionPayload struct {
	Mutation      MutationType     `json:"mutation"`
	Node          *RequestPageItem `json:"node,omitempty"`
	UpdatedFields []string         `json:"updatedFields,omitempty"`
}

type RequestPageItemPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance RequestPageItemPreviousValuesExec) Exec(ctx context.Context) (*RequestPageItemPreviousValues, error) {
	var v RequestPageItemPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RequestPageItemPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RequestPageItemPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance RequestPageItemPreviousValuesExecArray) Exec(ctx context.Context) ([]RequestPageItemPreviousValues, error) {
	var v []RequestPageItemPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RequestPageItemPreviousValuesFields = []string{"id", "type", "note", "ipAddress", "createdAt", "updatedAt"}

type RequestPageItemPreviousValues struct {
	ID        string  `json:"id"`
	Type      int32   `json:"type"`
	Note      *string `json:"note,omitempty"`
	IpAddress *string `json:"ipAddress,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type ReviewContentSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentSubscriptionPayloadExec) Node() *ReviewContentExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContent"},
		"node",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentExec{ret}
}

func (instance *ReviewContentSubscriptionPayloadExec) PreviousValues() *ReviewContentPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPreviousValues"},
		"previousValues",
		[]string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"})

	return &ReviewContentPreviousValuesExec{ret}
}

func (instance ReviewContentSubscriptionPayloadExec) Exec(ctx context.Context) (*ReviewContentSubscriptionPayload, error) {
	var v ReviewContentSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ReviewContentSubscriptionPayload, error) {
	var v []ReviewContentSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ReviewContentSubscriptionPayload struct {
	Mutation      MutationType   `json:"mutation"`
	Node          *ReviewContent `json:"node,omitempty"`
	UpdatedFields []string       `json:"updatedFields,omitempty"`
}

type ReviewContentPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ReviewContentPreviousValuesExec) Exec(ctx context.Context) (*ReviewContentPreviousValues, error) {
	var v ReviewContentPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPreviousValuesExecArray) Exec(ctx context.Context) ([]ReviewContentPreviousValues, error) {
	var v []ReviewContentPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPreviousValuesFields = []string{"id", "previewImageUrl", "title", "type", "url", "review", "videoId", "contentId", "createdAt", "updatedAt"}

type ReviewContentPreviousValues struct {
	ID              string  `json:"id"`
	PreviewImageUrl string  `json:"previewImageUrl"`
	Title           *string `json:"title,omitempty"`
	Type            string  `json:"type"`
	Url             string  `json:"url"`
	Review          *string `json:"review,omitempty"`
	VideoId         *string `json:"videoId,omitempty"`
	ContentId       *string `json:"contentId,omitempty"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
}

type ReviewContentCategorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentCategorySubscriptionPayloadExec) Node() *ReviewContentCategoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentCategory"},
		"node",
		[]string{"id", "name", "imageUrl", "createdAt", "updatedAt"})

	return &ReviewContentCategoryExec{ret}
}

func (instance *ReviewContentCategorySubscriptionPayloadExec) PreviousValues() *ReviewContentCategoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentCategoryPreviousValues"},
		"previousValues",
		[]string{"id", "name", "imageUrl", "createdAt", "updatedAt"})

	return &ReviewContentCategoryPreviousValuesExec{ret}
}

func (instance ReviewContentCategorySubscriptionPayloadExec) Exec(ctx context.Context) (*ReviewContentCategorySubscriptionPayload, error) {
	var v ReviewContentCategorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentCategorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentCategorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentCategorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ReviewContentCategorySubscriptionPayload, error) {
	var v []ReviewContentCategorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentCategorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ReviewContentCategorySubscriptionPayload struct {
	Mutation      MutationType           `json:"mutation"`
	Node          *ReviewContentCategory `json:"node,omitempty"`
	UpdatedFields []string               `json:"updatedFields,omitempty"`
}

type ReviewContentCategoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ReviewContentCategoryPreviousValuesExec) Exec(ctx context.Context) (*ReviewContentCategoryPreviousValues, error) {
	var v ReviewContentCategoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentCategoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentCategoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentCategoryPreviousValuesExecArray) Exec(ctx context.Context) ([]ReviewContentCategoryPreviousValues, error) {
	var v []ReviewContentCategoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentCategoryPreviousValuesFields = []string{"id", "name", "imageUrl", "createdAt", "updatedAt"}

type ReviewContentCategoryPreviousValues struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	ImageUrl  string `json:"imageUrl"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type ReviewContentPageSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageSubscriptionPayloadExec) Node() *ReviewContentPageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPage"},
		"node",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPageExec{ret}
}

func (instance *ReviewContentPageSubscriptionPayloadExec) PreviousValues() *ReviewContentPagePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPagePreviousValues"},
		"previousValues",
		[]string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"})

	return &ReviewContentPagePreviousValuesExec{ret}
}

func (instance ReviewContentPageSubscriptionPayloadExec) Exec(ctx context.Context) (*ReviewContentPageSubscriptionPayload, error) {
	var v ReviewContentPageSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ReviewContentPageSubscriptionPayload, error) {
	var v []ReviewContentPageSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ReviewContentPageSubscriptionPayload struct {
	Mutation      MutationType       `json:"mutation"`
	Node          *ReviewContentPage `json:"node,omitempty"`
	UpdatedFields []string           `json:"updatedFields,omitempty"`
}

type ReviewContentPagePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ReviewContentPagePreviousValuesExec) Exec(ctx context.Context) (*ReviewContentPagePreviousValues, error) {
	var v ReviewContentPagePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPagePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPagePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPagePreviousValuesExecArray) Exec(ctx context.Context) ([]ReviewContentPagePreviousValues, error) {
	var v []ReviewContentPagePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPagePreviousValuesFields = []string{"id", "title", "subTitle", "message", "releasedAt", "isDrafts", "isDel", "createdAt", "updatedAt"}

type ReviewContentPagePreviousValues struct {
	ID         string  `json:"id"`
	Title      string  `json:"title"`
	SubTitle   *string `json:"subTitle,omitempty"`
	Message    *string `json:"message,omitempty"`
	ReleasedAt string  `json:"releasedAt"`
	IsDrafts   *bool   `json:"isDrafts,omitempty"`
	IsDel      *bool   `json:"isDel,omitempty"`
	CreatedAt  string  `json:"createdAt"`
	UpdatedAt  string  `json:"updatedAt"`
}

type ReviewContentPageFeedBackSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageFeedBackSubscriptionPayloadExec) Node() *ReviewContentPageFeedBackExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPageFeedBack"},
		"node",
		[]string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"})

	return &ReviewContentPageFeedBackExec{ret}
}

func (instance *ReviewContentPageFeedBackSubscriptionPayloadExec) PreviousValues() *ReviewContentPageFeedBackPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPageFeedBackPreviousValues"},
		"previousValues",
		[]string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"})

	return &ReviewContentPageFeedBackPreviousValuesExec{ret}
}

func (instance ReviewContentPageFeedBackSubscriptionPayloadExec) Exec(ctx context.Context) (*ReviewContentPageFeedBackSubscriptionPayload, error) {
	var v ReviewContentPageFeedBackSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageFeedBackSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageFeedBackSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageFeedBackSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ReviewContentPageFeedBackSubscriptionPayload, error) {
	var v []ReviewContentPageFeedBackSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageFeedBackSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ReviewContentPageFeedBackSubscriptionPayload struct {
	Mutation      MutationType               `json:"mutation"`
	Node          *ReviewContentPageFeedBack `json:"node,omitempty"`
	UpdatedFields []string                   `json:"updatedFields,omitempty"`
}

type ReviewContentPageFeedBackPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageFeedBackPreviousValuesExec) Exec(ctx context.Context) (*ReviewContentPageFeedBackPreviousValues, error) {
	var v ReviewContentPageFeedBackPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageFeedBackPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageFeedBackPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageFeedBackPreviousValuesExecArray) Exec(ctx context.Context) ([]ReviewContentPageFeedBackPreviousValues, error) {
	var v []ReviewContentPageFeedBackPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageFeedBackPreviousValuesFields = []string{"id", "isLike", "message", "ipAddress", "createdAt", "updatedAt"}

type ReviewContentPageFeedBackPreviousValues struct {
	ID        string  `json:"id"`
	IsLike    bool    `json:"isLike"`
	Message   *string `json:"message,omitempty"`
	IpAddress *string `json:"ipAddress,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type ReviewContentPageViewerSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentPageViewerSubscriptionPayloadExec) Node() *ReviewContentPageViewerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPageViewer"},
		"node",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentPageViewerExec{ret}
}

func (instance *ReviewContentPageViewerSubscriptionPayloadExec) PreviousValues() *ReviewContentPageViewerPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentPageViewerPreviousValues"},
		"previousValues",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentPageViewerPreviousValuesExec{ret}
}

func (instance ReviewContentPageViewerSubscriptionPayloadExec) Exec(ctx context.Context) (*ReviewContentPageViewerSubscriptionPayload, error) {
	var v ReviewContentPageViewerSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageViewerSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageViewerSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageViewerSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ReviewContentPageViewerSubscriptionPayload, error) {
	var v []ReviewContentPageViewerSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageViewerSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ReviewContentPageViewerSubscriptionPayload struct {
	Mutation      MutationType             `json:"mutation"`
	Node          *ReviewContentPageViewer `json:"node,omitempty"`
	UpdatedFields []string                 `json:"updatedFields,omitempty"`
}

type ReviewContentPageViewerPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageViewerPreviousValuesExec) Exec(ctx context.Context) (*ReviewContentPageViewerPreviousValues, error) {
	var v ReviewContentPageViewerPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentPageViewerPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentPageViewerPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentPageViewerPreviousValuesExecArray) Exec(ctx context.Context) ([]ReviewContentPageViewerPreviousValues, error) {
	var v []ReviewContentPageViewerPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentPageViewerPreviousValuesFields = []string{"id", "ip", "createdAt", "updatedAt"}

type ReviewContentPageViewerPreviousValues struct {
	ID        string  `json:"id"`
	Ip        *string `json:"ip,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type ReviewContentReviewerSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentReviewerSubscriptionPayloadExec) Node() *ReviewContentReviewerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentReviewer"},
		"node",
		[]string{"id", "review", "createdAt", "updatedAt"})

	return &ReviewContentReviewerExec{ret}
}

func (instance *ReviewContentReviewerSubscriptionPayloadExec) PreviousValues() *ReviewContentReviewerPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentReviewerPreviousValues"},
		"previousValues",
		[]string{"id", "review", "createdAt", "updatedAt"})

	return &ReviewContentReviewerPreviousValuesExec{ret}
}

func (instance ReviewContentReviewerSubscriptionPayloadExec) Exec(ctx context.Context) (*ReviewContentReviewerSubscriptionPayload, error) {
	var v ReviewContentReviewerSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentReviewerSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentReviewerSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentReviewerSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ReviewContentReviewerSubscriptionPayload, error) {
	var v []ReviewContentReviewerSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentReviewerSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ReviewContentReviewerSubscriptionPayload struct {
	Mutation      MutationType           `json:"mutation"`
	Node          *ReviewContentReviewer `json:"node,omitempty"`
	UpdatedFields []string               `json:"updatedFields,omitempty"`
}

type ReviewContentReviewerPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ReviewContentReviewerPreviousValuesExec) Exec(ctx context.Context) (*ReviewContentReviewerPreviousValues, error) {
	var v ReviewContentReviewerPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentReviewerPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentReviewerPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentReviewerPreviousValuesExecArray) Exec(ctx context.Context) ([]ReviewContentReviewerPreviousValues, error) {
	var v []ReviewContentReviewerPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentReviewerPreviousValuesFields = []string{"id", "review", "createdAt", "updatedAt"}

type ReviewContentReviewerPreviousValues struct {
	ID        string `json:"id"`
	Review    string `json:"review"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type ReviewContentViewerSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ReviewContentViewerSubscriptionPayloadExec) Node() *ReviewContentViewerExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentViewer"},
		"node",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentViewerExec{ret}
}

func (instance *ReviewContentViewerSubscriptionPayloadExec) PreviousValues() *ReviewContentViewerPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ReviewContentViewerPreviousValues"},
		"previousValues",
		[]string{"id", "ip", "createdAt", "updatedAt"})

	return &ReviewContentViewerPreviousValuesExec{ret}
}

func (instance ReviewContentViewerSubscriptionPayloadExec) Exec(ctx context.Context) (*ReviewContentViewerSubscriptionPayload, error) {
	var v ReviewContentViewerSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentViewerSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentViewerSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentViewerSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ReviewContentViewerSubscriptionPayload, error) {
	var v []ReviewContentViewerSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentViewerSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type ReviewContentViewerSubscriptionPayload struct {
	Mutation      MutationType         `json:"mutation"`
	Node          *ReviewContentViewer `json:"node,omitempty"`
	UpdatedFields []string             `json:"updatedFields,omitempty"`
}

type ReviewContentViewerPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ReviewContentViewerPreviousValuesExec) Exec(ctx context.Context) (*ReviewContentViewerPreviousValues, error) {
	var v ReviewContentViewerPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ReviewContentViewerPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ReviewContentViewerPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ReviewContentViewerPreviousValuesExecArray) Exec(ctx context.Context) ([]ReviewContentViewerPreviousValues, error) {
	var v []ReviewContentViewerPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var ReviewContentViewerPreviousValuesFields = []string{"id", "ip", "createdAt", "updatedAt"}

type ReviewContentViewerPreviousValues struct {
	ID        string  `json:"id"`
	Ip        *string `json:"ip,omitempty"`
	CreatedAt string  `json:"createdAt"`
	UpdatedAt string  `json:"updatedAt"`
}

type RewardDropAttendingUserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *RewardDropAttendingUserSubscriptionPayloadExec) Node() *RewardDropAttendingUserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RewardDropAttendingUser"},
		"node",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserExec{ret}
}

func (instance *RewardDropAttendingUserSubscriptionPayloadExec) PreviousValues() *RewardDropAttendingUserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RewardDropAttendingUserPreviousValues"},
		"previousValues",
		[]string{"id", "memo", "isDel", "createdAt"})

	return &RewardDropAttendingUserPreviousValuesExec{ret}
}

func (instance RewardDropAttendingUserSubscriptionPayloadExec) Exec(ctx context.Context) (*RewardDropAttendingUserSubscriptionPayload, error) {
	var v RewardDropAttendingUserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RewardDropAttendingUserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RewardDropAttendingUserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance RewardDropAttendingUserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RewardDropAttendingUserSubscriptionPayload, error) {
	var v []RewardDropAttendingUserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RewardDropAttendingUserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type RewardDropAttendingUserSubscriptionPayload struct {
	Mutation      MutationType             `json:"mutation"`
	Node          *RewardDropAttendingUser `json:"node,omitempty"`
	UpdatedFields []string                 `json:"updatedFields,omitempty"`
}

type RewardDropAttendingUserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance RewardDropAttendingUserPreviousValuesExec) Exec(ctx context.Context) (*RewardDropAttendingUserPreviousValues, error) {
	var v RewardDropAttendingUserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RewardDropAttendingUserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RewardDropAttendingUserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance RewardDropAttendingUserPreviousValuesExecArray) Exec(ctx context.Context) ([]RewardDropAttendingUserPreviousValues, error) {
	var v []RewardDropAttendingUserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RewardDropAttendingUserPreviousValuesFields = []string{"id", "memo", "isDel", "createdAt"}

type RewardDropAttendingUserPreviousValues struct {
	ID        string `json:"id"`
	Memo      string `json:"memo"`
	IsDel     bool   `json:"isDel"`
	CreatedAt string `json:"createdAt"`
}

type RewardDropEventSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *RewardDropEventSubscriptionPayloadExec) Node() *RewardDropEventExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RewardDropEvent"},
		"node",
		[]string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"})

	return &RewardDropEventExec{ret}
}

func (instance *RewardDropEventSubscriptionPayloadExec) PreviousValues() *RewardDropEventPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "RewardDropEventPreviousValues"},
		"previousValues",
		[]string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"})

	return &RewardDropEventPreviousValuesExec{ret}
}

func (instance RewardDropEventSubscriptionPayloadExec) Exec(ctx context.Context) (*RewardDropEventSubscriptionPayload, error) {
	var v RewardDropEventSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RewardDropEventSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RewardDropEventSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance RewardDropEventSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]RewardDropEventSubscriptionPayload, error) {
	var v []RewardDropEventSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RewardDropEventSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type RewardDropEventSubscriptionPayload struct {
	Mutation      MutationType     `json:"mutation"`
	Node          *RewardDropEvent `json:"node,omitempty"`
	UpdatedFields []string         `json:"updatedFields,omitempty"`
}

type RewardDropEventPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance RewardDropEventPreviousValuesExec) Exec(ctx context.Context) (*RewardDropEventPreviousValues, error) {
	var v RewardDropEventPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance RewardDropEventPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type RewardDropEventPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance RewardDropEventPreviousValuesExecArray) Exec(ctx context.Context) ([]RewardDropEventPreviousValues, error) {
	var v []RewardDropEventPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var RewardDropEventPreviousValuesFields = []string{"id", "eventID", "type", "title", "cash", "qty", "limitUserCount", "fromDate", "toDate", "isDel", "createdAt"}

type RewardDropEventPreviousValues struct {
	ID             string `json:"id"`
	EventId        string `json:"eventID"`
	Type           int32  `json:"type"`
	Title          string `json:"title"`
	Cash           *int32 `json:"cash,omitempty"`
	Qty            *int32 `json:"qty,omitempty"`
	LimitUserCount int32  `json:"limitUserCount"`
	FromDate       string `json:"fromDate"`
	ToDate         string `json:"toDate"`
	IsDel          bool   `json:"isDel"`
	CreatedAt      string `json:"createdAt"`
}

type TwitchSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TwitchSubscriptionPayloadExec) Node() *TwitchExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Twitch"},
		"node",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchExec{ret}
}

func (instance *TwitchSubscriptionPayloadExec) PreviousValues() *TwitchPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TwitchPreviousValues"},
		"previousValues",
		[]string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"})

	return &TwitchPreviousValuesExec{ret}
}

func (instance TwitchSubscriptionPayloadExec) Exec(ctx context.Context) (*TwitchSubscriptionPayload, error) {
	var v TwitchSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TwitchSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TwitchSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TwitchSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TwitchSubscriptionPayload, error) {
	var v []TwitchSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TwitchSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type TwitchSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Twitch      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type TwitchPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TwitchPreviousValuesExec) Exec(ctx context.Context) (*TwitchPreviousValues, error) {
	var v TwitchPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TwitchPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TwitchPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TwitchPreviousValuesExecArray) Exec(ctx context.Context) ([]TwitchPreviousValues, error) {
	var v []TwitchPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TwitchPreviousValuesFields = []string{"id", "userId", "userNo", "userName", "followerCount", "followingCount", "channelType", "channelViewCount", "avatarUrl", "coverUrl", "description", "pageUrl", "createdAt", "updatedAt"}

type TwitchPreviousValues struct {
	ID               string  `json:"id"`
	UserId           string  `json:"userId"`
	UserNo           string  `json:"userNo"`
	UserName         *string `json:"userName,omitempty"`
	FollowerCount    *string `json:"followerCount,omitempty"`
	FollowingCount   *string `json:"followingCount,omitempty"`
	ChannelType      *string `json:"channelType,omitempty"`
	ChannelViewCount *string `json:"channelViewCount,omitempty"`
	AvatarUrl        *string `json:"avatarUrl,omitempty"`
	CoverUrl         *string `json:"coverUrl,omitempty"`
	Description      *string `json:"description,omitempty"`
	PageUrl          *string `json:"pageUrl,omitempty"`
	CreatedAt        string  `json:"createdAt"`
	UpdatedAt        string  `json:"updatedAt"`
}

type TwitchDailyStatisticsSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *TwitchDailyStatisticsSubscriptionPayloadExec) Node() *TwitchDailyStatisticsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TwitchDailyStatistics"},
		"node",
		[]string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"})

	return &TwitchDailyStatisticsExec{ret}
}

func (instance *TwitchDailyStatisticsSubscriptionPayloadExec) PreviousValues() *TwitchDailyStatisticsPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "TwitchDailyStatisticsPreviousValues"},
		"previousValues",
		[]string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"})

	return &TwitchDailyStatisticsPreviousValuesExec{ret}
}

func (instance TwitchDailyStatisticsSubscriptionPayloadExec) Exec(ctx context.Context) (*TwitchDailyStatisticsSubscriptionPayload, error) {
	var v TwitchDailyStatisticsSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TwitchDailyStatisticsSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TwitchDailyStatisticsSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance TwitchDailyStatisticsSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]TwitchDailyStatisticsSubscriptionPayload, error) {
	var v []TwitchDailyStatisticsSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TwitchDailyStatisticsSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type TwitchDailyStatisticsSubscriptionPayload struct {
	Mutation      MutationType           `json:"mutation"`
	Node          *TwitchDailyStatistics `json:"node,omitempty"`
	UpdatedFields []string               `json:"updatedFields,omitempty"`
}

type TwitchDailyStatisticsPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance TwitchDailyStatisticsPreviousValuesExec) Exec(ctx context.Context) (*TwitchDailyStatisticsPreviousValues, error) {
	var v TwitchDailyStatisticsPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance TwitchDailyStatisticsPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type TwitchDailyStatisticsPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance TwitchDailyStatisticsPreviousValuesExecArray) Exec(ctx context.Context) ([]TwitchDailyStatisticsPreviousValues, error) {
	var v []TwitchDailyStatisticsPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var TwitchDailyStatisticsPreviousValuesFields = []string{"id", "date", "followerCount", "followingCount", "channelViewCount", "createdAt", "updatedAt"}

type TwitchDailyStatisticsPreviousValues struct {
	ID               string `json:"id"`
	Date             string `json:"date"`
	FollowerCount    string `json:"followerCount"`
	FollowingCount   string `json:"followingCount"`
	ChannelViewCount string `json:"channelViewCount"`
	CreatedAt        string `json:"createdAt"`
	UpdatedAt        string `json:"updatedAt"`
}

type UpdatePostHistorySubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UpdatePostHistorySubscriptionPayloadExec) Node() *UpdatePostHistoryExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UpdatePostHistory"},
		"node",
		[]string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"})

	return &UpdatePostHistoryExec{ret}
}

func (instance *UpdatePostHistorySubscriptionPayloadExec) PreviousValues() *UpdatePostHistoryPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UpdatePostHistoryPreviousValues"},
		"previousValues",
		[]string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"})

	return &UpdatePostHistoryPreviousValuesExec{ret}
}

func (instance UpdatePostHistorySubscriptionPayloadExec) Exec(ctx context.Context) (*UpdatePostHistorySubscriptionPayload, error) {
	var v UpdatePostHistorySubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UpdatePostHistorySubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UpdatePostHistorySubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UpdatePostHistorySubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UpdatePostHistorySubscriptionPayload, error) {
	var v []UpdatePostHistorySubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UpdatePostHistorySubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type UpdatePostHistorySubscriptionPayload struct {
	Mutation      MutationType       `json:"mutation"`
	Node          *UpdatePostHistory `json:"node,omitempty"`
	UpdatedFields []string           `json:"updatedFields,omitempty"`
}

type UpdatePostHistoryPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UpdatePostHistoryPreviousValuesExec) Exec(ctx context.Context) (*UpdatePostHistoryPreviousValues, error) {
	var v UpdatePostHistoryPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UpdatePostHistoryPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UpdatePostHistoryPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UpdatePostHistoryPreviousValuesExecArray) Exec(ctx context.Context) ([]UpdatePostHistoryPreviousValues, error) {
	var v []UpdatePostHistoryPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UpdatePostHistoryPreviousValuesFields = []string{"id", "action", "beforeContent", "beforeImageUrl", "createdAt"}

type UpdatePostHistoryPreviousValues struct {
	ID             string  `json:"id"`
	Action         int32   `json:"action"`
	BeforeContent  *string `json:"beforeContent,omitempty"`
	BeforeImageUrl *string `json:"beforeImageUrl,omitempty"`
	CreatedAt      string  `json:"createdAt"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type UserSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *User        `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var UserPreviousValuesFields = []string{"id", "role", "firebaseUID", "provider", "nickName", "email", "backupEmail", "deviceId", "platform", "fcmToken", "linkedFacebook", "linkedTwitter", "linkedInstagram", "linkedYoutube", "linkedTwitch", "contentProvider", "contentId", "revokeTokenKey", "subscribePushNotification", "subscribeEmail", "deletedAt", "createdAt", "updatedAt", "status", "numId", "userRank"}

type UserPreviousValues struct {
	ID                        string  `json:"id"`
	Role                      Role    `json:"role"`
	FirebaseUid               string  `json:"firebaseUID"`
	Provider                  *string `json:"provider,omitempty"`
	NickName                  string  `json:"nickName"`
	Email                     string  `json:"email"`
	BackupEmail               *string `json:"backupEmail,omitempty"`
	DeviceId                  *string `json:"deviceId,omitempty"`
	Platform                  *string `json:"platform,omitempty"`
	FcmToken                  *string `json:"fcmToken,omitempty"`
	LinkedFacebook            *string `json:"linkedFacebook,omitempty"`
	LinkedTwitter             *string `json:"linkedTwitter,omitempty"`
	LinkedInstagram           *string `json:"linkedInstagram,omitempty"`
	LinkedYoutube             *string `json:"linkedYoutube,omitempty"`
	LinkedTwitch              *string `json:"linkedTwitch,omitempty"`
	ContentProvider           *string `json:"contentProvider,omitempty"`
	ContentId                 *string `json:"contentId,omitempty"`
	RevokeTokenKey            *string `json:"revokeTokenKey,omitempty"`
	SubscribePushNotification *bool   `json:"subscribePushNotification,omitempty"`
	SubscribeEmail            *bool   `json:"subscribeEmail,omitempty"`
	DeletedAt                 *string `json:"deletedAt,omitempty"`
	CreatedAt                 string  `json:"createdAt"`
	UpdatedAt                 string  `json:"updatedAt"`
	Status                    int32   `json:"status"`
	NumId                     int32   `json:"numId"`
	UserRank                  *int32  `json:"userRank,omitempty"`
}

type VerificationSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *VerificationSubscriptionPayloadExec) Node() *VerificationExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Verification"},
		"node",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationExec{ret}
}

func (instance *VerificationSubscriptionPayloadExec) PreviousValues() *VerificationPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "VerificationPreviousValues"},
		"previousValues",
		[]string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"})

	return &VerificationPreviousValuesExec{ret}
}

func (instance VerificationSubscriptionPayloadExec) Exec(ctx context.Context) (*VerificationSubscriptionPayload, error) {
	var v VerificationSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VerificationSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VerificationSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance VerificationSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]VerificationSubscriptionPayload, error) {
	var v []VerificationSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var VerificationSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type VerificationSubscriptionPayload struct {
	Mutation      MutationType  `json:"mutation"`
	Node          *Verification `json:"node,omitempty"`
	UpdatedFields []string      `json:"updatedFields,omitempty"`
}

type VerificationPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance VerificationPreviousValuesExec) Exec(ctx context.Context) (*VerificationPreviousValues, error) {
	var v VerificationPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance VerificationPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type VerificationPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance VerificationPreviousValuesExecArray) Exec(ctx context.Context) ([]VerificationPreviousValues, error) {
	var v []VerificationPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var VerificationPreviousValuesFields = []string{"id", "level", "hasEmail", "hasPin", "hasPhone", "hasBankAccount", "hasInter", "pinNumber", "createdAt", "updatedAt"}

type VerificationPreviousValues struct {
	ID             string  `json:"id"`
	Level          *int32  `json:"level,omitempty"`
	HasEmail       *bool   `json:"hasEmail,omitempty"`
	HasPin         *bool   `json:"hasPin,omitempty"`
	HasPhone       *bool   `json:"hasPhone,omitempty"`
	HasBankAccount *bool   `json:"hasBankAccount,omitempty"`
	HasInter       *bool   `json:"hasInter,omitempty"`
	PinNumber      *string `json:"pinNumber,omitempty"`
	CreatedAt      string  `json:"createdAt"`
	UpdatedAt      string  `json:"updatedAt"`
}

type WalletSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *WalletSubscriptionPayloadExec) Node() *WalletExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Wallet"},
		"node",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletExec{ret}
}

func (instance *WalletSubscriptionPayloadExec) PreviousValues() *WalletPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "WalletPreviousValues"},
		"previousValues",
		[]string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"})

	return &WalletPreviousValuesExec{ret}
}

func (instance WalletSubscriptionPayloadExec) Exec(ctx context.Context) (*WalletSubscriptionPayload, error) {
	var v WalletSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WalletSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WalletSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance WalletSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]WalletSubscriptionPayload, error) {
	var v []WalletSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var WalletSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type WalletSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Wallet      `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type WalletPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance WalletPreviousValuesExec) Exec(ctx context.Context) (*WalletPreviousValues, error) {
	var v WalletPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance WalletPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type WalletPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance WalletPreviousValuesExecArray) Exec(ctx context.Context) ([]WalletPreviousValues, error) {
	var v []WalletPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var WalletPreviousValuesFields = []string{"id", "numIdCoinName", "cumulativePurchaseQuantity", "cumulativePurchaseValue", "createdAt"}

type WalletPreviousValues struct {
	ID                         string   `json:"id"`
	NumIdCoinName              *string  `json:"numIdCoinName,omitempty"`
	CumulativePurchaseQuantity *float64 `json:"cumulativePurchaseQuantity,omitempty"`
	CumulativePurchaseValue    *float64 `json:"cumulativePurchaseValue,omitempty"`
	CreatedAt                  string   `json:"createdAt"`
}

type YoutubeSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *YoutubeSubscriptionPayloadExec) Node() *YoutubeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Youtube"},
		"node",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubeExec{ret}
}

func (instance *YoutubeSubscriptionPayloadExec) PreviousValues() *YoutubePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "YoutubePreviousValues"},
		"previousValues",
		[]string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"})

	return &YoutubePreviousValuesExec{ret}
}

func (instance YoutubeSubscriptionPayloadExec) Exec(ctx context.Context) (*YoutubeSubscriptionPayload, error) {
	var v YoutubeSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance YoutubeSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type YoutubeSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance YoutubeSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]YoutubeSubscriptionPayload, error) {
	var v []YoutubeSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var YoutubeSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type YoutubeSubscriptionPayload struct {
	Mutation      MutationType `json:"mutation"`
	Node          *Youtube     `json:"node,omitempty"`
	UpdatedFields []string     `json:"updatedFields,omitempty"`
}

type YoutubePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance YoutubePreviousValuesExec) Exec(ctx context.Context) (*YoutubePreviousValues, error) {
	var v YoutubePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance YoutubePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type YoutubePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance YoutubePreviousValuesExecArray) Exec(ctx context.Context) ([]YoutubePreviousValues, error) {
	var v []YoutubePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var YoutubePreviousValuesFields = []string{"id", "channelId", "channelType", "channelName", "userName", "videoCount", "subscriberCount", "videoViewCount", "thumbnailUrl", "bannerUrl", "description", "publishedAt", "country", "pageUrl", "createdAt", "updatedAt"}

type YoutubePreviousValues struct {
	ID              string  `json:"id"`
	ChannelId       string  `json:"channelId"`
	ChannelType     *string `json:"channelType,omitempty"`
	ChannelName     *string `json:"channelName,omitempty"`
	UserName        *string `json:"userName,omitempty"`
	VideoCount      *string `json:"videoCount,omitempty"`
	SubscriberCount *string `json:"subscriberCount,omitempty"`
	VideoViewCount  *string `json:"videoViewCount,omitempty"`
	ThumbnailUrl    *string `json:"thumbnailUrl,omitempty"`
	BannerUrl       *string `json:"bannerUrl,omitempty"`
	Description     *string `json:"description,omitempty"`
	PublishedAt     *string `json:"publishedAt,omitempty"`
	Country         *string `json:"country,omitempty"`
	PageUrl         *string `json:"pageUrl,omitempty"`
	CreatedAt       string  `json:"createdAt"`
	UpdatedAt       string  `json:"updatedAt"`
}

type YoutubeDailyStatisticsSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *YoutubeDailyStatisticsSubscriptionPayloadExec) Node() *YoutubeDailyStatisticsExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "YoutubeDailyStatistics"},
		"node",
		[]string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"})

	return &YoutubeDailyStatisticsExec{ret}
}

func (instance *YoutubeDailyStatisticsSubscriptionPayloadExec) PreviousValues() *YoutubeDailyStatisticsPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "YoutubeDailyStatisticsPreviousValues"},
		"previousValues",
		[]string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"})

	return &YoutubeDailyStatisticsPreviousValuesExec{ret}
}

func (instance YoutubeDailyStatisticsSubscriptionPayloadExec) Exec(ctx context.Context) (*YoutubeDailyStatisticsSubscriptionPayload, error) {
	var v YoutubeDailyStatisticsSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance YoutubeDailyStatisticsSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type YoutubeDailyStatisticsSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance YoutubeDailyStatisticsSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]YoutubeDailyStatisticsSubscriptionPayload, error) {
	var v []YoutubeDailyStatisticsSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var YoutubeDailyStatisticsSubscriptionPayloadFields = []string{"mutation", "updatedFields"}

type YoutubeDailyStatisticsSubscriptionPayload struct {
	Mutation      MutationType            `json:"mutation"`
	Node          *YoutubeDailyStatistics `json:"node,omitempty"`
	UpdatedFields []string                `json:"updatedFields,omitempty"`
}

type YoutubeDailyStatisticsPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance YoutubeDailyStatisticsPreviousValuesExec) Exec(ctx context.Context) (*YoutubeDailyStatisticsPreviousValues, error) {
	var v YoutubeDailyStatisticsPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance YoutubeDailyStatisticsPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type YoutubeDailyStatisticsPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance YoutubeDailyStatisticsPreviousValuesExecArray) Exec(ctx context.Context) ([]YoutubeDailyStatisticsPreviousValues, error) {
	var v []YoutubeDailyStatisticsPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

var YoutubeDailyStatisticsPreviousValuesFields = []string{"id", "date", "videoCount", "subscriberCount", "videoViewCount", "createdAt", "updatedAt"}

type YoutubeDailyStatisticsPreviousValues struct {
	ID              string `json:"id"`
	Date            string `json:"date"`
	VideoCount      string `json:"videoCount"`
	SubscriberCount string `json:"subscriberCount"`
	VideoViewCount  string `json:"videoViewCount"`
	CreatedAt       string `json:"createdAt"`
	UpdatedAt       string `json:"updatedAt"`
}
