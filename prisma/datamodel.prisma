enum Role {
  ADMIN,
  USER
}

type Category {
  id: ID! @unique
  name: String! @unique
  posts: [Post!]!
  feedUsers: [User!]!
  coins: [Coin!]!
  order_index: Float
}

type AdminUser {
  id: ID! @unique
  role: Role!
  email: String! @unique
  password: String
  nickName: String! @unique
  otpKey: String
  level: String
  members: [User!]!
  createNotification: Notification @relation(name: "CreateNotification")
  updateNotification: Notification @relation(name: "UpdateNotification")
  createdAt: DateTime!
  updatedAt: DateTime!
}

type User {
  id: ID! @unique
  role: Role!
  firebaseUID: String! @unique
  provider: String @default(value: password)
  nickName: String! @unique
  email: String! @unique
  backupEmail: String
  deviceId: String
  platform: String
  fcmToken: String
  feedCategories: [Category!]!
  linkedFacebook: String
  linkedTwitter: String
  linkedInstagram: String
  linkedYoutube: String
  linkedTwitch: String
  contentProvider: String
  contentId: String
  revokeTokenKey: String @unique
  subscribePushNotification: Boolean @default(value: true)
  subscribeEmail: Boolean @default(value: true)
  coin: Coin @relation(name: "UserCoin", onDelete: CASCADE)
  verification: Verification @relation(name: "UserVerification", onDelete: CASCADE)
  wallets: [Wallet!]! @relation(name: "UserWallets", onDelete: CASCADE)
  posts: [Post!]! @relation(name: "UserPosts", onDelete: CASCADE)
  requestPosts: [Post!]! @relation(name: "RequestUserPosts", onDelete: CASCADE)
  comments: [Comment!]! @relation(name: "UserComments", onDelete: CASCADE)
  files: [File!]! @relation(name: "UserFiles", onDelete: CASCADE)
  fileList: [FileInfo!]! @relation(name: "UserFileList", onDelete: CASCADE)
  likes: [Post!]! @relation(name: "PostLike", onDelete: CASCADE)
  views: [Post!]! @relation(name: "PostView", onDelete: CASCADE)
  joinOffer: [Offeror!]!@relation(name: "UserOfferor", onDelete: CASCADE)
  myReport: [Report!]! @relation(name: "UserMyReport", onDelete: CASCADE)
  targetReport: [Report!]! @relation(name: "UserTargetReport")
  joinedQuests: [QuestMember!]! @relation(name: "JoinedQuests", onDelete: CASCADE)
  adminUser: AdminUser
  deletedAt: DateTime #삭제 예정인 유저(status == 1)한테 부여하는 값.
  createdAt: DateTime!
  updatedAt: DateTime!
  status: Int! @default(value: 0)
  numId: Int! @unique @default(value: 0)
  attendingRewardDrop: [RewardDropAttendingUser!]! @relation(name: "UserRewardDrop", onDelete: CASCADE)
  motherHistories: [MotherHistory!]! @relation(name: "UserMH", onDelete: SET_NULL)
  orderHistories: [OrderHistory!]! @relation(name: "UserOH", onDelete: SET_NULL)
  orderUserDealsHistories: [OrderUserDealsHistory!]! @relation(name: "UserOUDH", onDelete: SET_NULL)
  cashHistories: [CashHistory!]! @relation(name: "UserCH", onDelete: SET_NULL)
  questExpenditureHistories: [QuestExpenditureHistory!]! @relation(name: "UserQEH", onDelete: SET_NULL)
  airDropHistories: [AirDropHistory!]! @relation(name: "UserADH", onDelete: SET_NULL)
  airDropMembers: [AirDropMember!]! @relation(name: "UserADM", onDelete: SET_NULL)
  postRewardHistories: [PostRewardHistory!]! @relation(name: "UserPRH", onDelete: SET_NULL)
  userRank: Int @default(value: 5)
  aergoAccount: AergoAccount
  userRankFee: Fee @relation(name: "UserRankFee", onDelete: SET_NULL)
  eventFee: [Fee!]! @relation(name: "EventFee", onDelete: SET_NULL)
  inviteCode: InviteCode
  page: Page
  contentsBookMark: [ReviewContentBookMark!]! @relation(name: "UserRCBM", onDelete: CASCADE)
  webCashHistories: [WebCashHistory!]! #웹캐시 변동이력
  pageShopOrders: [PageShopOrder!]! #해당 유저의 티켓 주문정보들
  isWEB: Boolean @default(value: false) #웹/앱유저 필터링을 위해
}

type WebCashHistory{
  id: ID! @unique
  type: Int! #1.후원티켓판매입금대기(구매승인안됨), 2.후원티켓판매입금처리(구매승인완료), 3.다른사람에게후원으로차감(임시), 4.환급(출금), 5.기타
  amount: Int! #변동금
  shopPayment: PageShopOrderPayment
  user: User!
  memo: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InviteCode {
  id: ID! @unique
  numId: Int! @unique @default(value: 0)
  code: String! @unique
  owner: User
  inviteUsers: [InviteUserHistory!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InviteUserHistory {
  id: ID! @unique
  inviteCode: InviteCode!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Badge{
  id: ID! @unique
  name: String! @unique
  imageUrl: String
  description: String!
  orderIndex: Int! @unique
  pages: [PageBadge!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PageBadge{
  id: ID! @unique
  badge: Badge!
  vote: Int! @default(value: 0)
  voter: [BadgeVoter!]! @relation(name: "PageBadgeVoters", onDelete: CASCADE)
  page: Page! @relation(name: "PageBadges", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SearchWord{
  id: ID! @unique
  word: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BadgeVoter{
  id: ID! @unique
  pageBadge: PageBadge @relation(name: "PageBadgeVoters", onDelete: SET_NULL)
  reviewContent: ReviewContent
  user: User
  ip: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PageComment{
  id: ID! @unique
  page: Page! @relation(name: "PageComments", onDelete: SET_NULL)
  content: String!
  comments: [PageCommentReply!]!
  ipAddress: String
  imageUrl: String #set gif or upload image
  thumbnailImageUrl: String
  owner: User
  relatedReviewContentPage: ReviewContentPage
  createdAt: DateTime!
  updatedAt: DateTime!
  isDel: Boolean! @default(value: false)
}

type PageCommentReply {
  id: ID! @unique
  pageComment: PageComment!
  content: String!
  ipAddress: String
  imageUrl: String #set gif or upload image
  thumbnailImageUrl: String #set gif or upload image thumbnail
  owner: User
  createdAt: DateTime!
  updatedAt: DateTime!
  isDel: Boolean! @default(value: false)
}

type Page{
  id: ID! @unique
  pageId: String! @unique
  pageIdAlias: String @unique
  nickName: String #닉네임
  avatarUrl: String #프로필 이미지 url
  coverUrl: String #배너 이미지 url
  description: String #소개
  badges: [PageBadge!]! @relation(name: "PageBadges", onDelete: CASCADE)
  youtube: Youtube @relation(name: "PageYoutube", onDelete: CASCADE)
  twitch: Twitch @relation(name: "PageTwitch", onDelete: CASCADE)
  instagram: Instagram @relation(name: "PageInstagram", onDelete: CASCADE)
  afreecaTV: AfreecaTV @relation(name: "PageAfreecaTV", onDelete: CASCADE)
  fans: [PageFan!]!
  snsALRequest: [SNSAccountLinkingRequest!]!
  fanCount: Int! @default(value: 0)
  owner: User
  comments: [PageComment!]! @relation(name: "PageComments", onDelete: CASCADE) #방명록
  requestPageItems: [RequestPageItem!]! @relation(name: "RequestPageItems", onDelete: CASCADE)
  reviews: [ReviewContentPage!]!
  relatedReviews: [ReviewContent!]!
  viewers: [PageViewer!]!
  viewTermCount: Int! @default(value: 0) #24시간 동안 조회수 카운트
  reviewTermCount: Int! @default(value: 0) #24시간 동안 생성된 리뷰 카운트
  fanTermCount: Int! @default(value: 0) #24시간 동안 fans 카운트
  popularIndicator: Int! @default(value: 0)
  useShop: Boolean @default(value: true) #후원티켓샵 활성화 유/무
  useShopM: Boolean! @default(value: true) #관리자가 후원티켓 활성화 유/무
  shopProducts: [PageShopProduct!]! #후원티켓상품목록
  pageShopOrders: [PageShopOrder!]! #해당 페이지의 티켓 주문정보들
  createdAt: DateTime!
  updatedAt: DateTime!
}

#페이지 상품목록
type PageShopProduct{
  id: ID! @unique
  page: Page! #페이지정보
  name: String! #상품명
  price: Int! #후원금액
  stockQty: Int! @default(value: 1000) #재고수량
  description: String! #상품설명
  slotId: String! @unique #슬롯번호
  shortID: String @unique #redirect 용
  status: Int! @default(value: 0) #상태값 : 0: 구매가능, 1: 감춤, 2: 삭제
  createdAt: DateTime!
  updatedAt: DateTime!
}

#주문정보
type PageShopOrder{
  id: ID! @unique
  page: Page!
  product: PageShopProduct #주문시 product 재고수량 보정을 위해 연결시켜 둠 추후 구매시 정보는 productName, productDescription, productPrice
  productId: String #어떤이유로 취소시 재고보정을 위해
  productName: String! #주문상품 이름
  productDescription: String! #주문상품 설명
  productPrice: Int! #주문상품 가격
  qty: Int! #주문수량
  payment: PageShopOrderPayment! @relation(name: "PageShopOrderPayment", onDelete: CASCADE) #결제정보
  comment: String #주문 요청사항
  user: User! #주문자
  confirmation: PageShopOrderConfirmation #후원인증정보
  status: Int! @default(value: 0) #0:주문, 1:결제요청, 2:결제완료(인증대기), 3:구매결정(인증), 4:취소
  confirmationAt: DateTime #인증시 날짜기록(인증일 기준으로 자동 구매승인 처리예정)
  confirmAt: DateTime #구매확정일자
  paymentAt: DateTime #결제일
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PageShopOrderConfirmation{
  id: ID! @unique
  order: PageShopOrder! #후원정보
  imageUrl: String #첨부이미지주소
  videoUrl: String #첨부동영상주소
  memo: String #추가전할말
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PageShopOrderPayment{
  id: ID! @unique
  code:	String #결과코드
  message: String #메시지
  user: User #가맹점 결제자(회원) 아이디(email, 영문 및 숫자 가능)
  cashHistory: WebCashHistory #캐시이력
  order: PageShopOrder! @relation(name: "PageShopOrderPayment", onDelete: SET_NULL) #주문정보
  order_no:	String @unique#가맹점의 주문 번호
  service_name:	String #결제 서비스명
  product_name:	String #결제 상품(컨텐츠)명
  custom_parameter:	String #주문요청시 가맹점가 전송한 값
  tid: String #결제고유번호
  cid: String #승인번호
  amount:	Int #결제금액-실결제된 금액 (부가세10% + pg수수료 포함)
  amount_fee: Int #충전 수수료 (부가세 + pg수수료)
  amount_without_fee: Int #충전금액 수수료 미포함 (amount - amount_fee)
  pgcode:	String #결제요청한 pg명
  pay_info: String #결제 부가정보
  domestic_flag: String #국내 / 해외 신용카드 구분 (Y : 국내, N : 해외)
  transaction_date: String #거래일시(YYYY-MM-DD HH:MM:SS)
  install_month: String #할부개월수
  card_info: String #카드 번호 (중간 4자리 masking 처리 )
  payhash: String #파라메터 검증을 위한 sha256 hash 값 (user_id +amount + tid +결제용 API Key) * 일부 결제 수단은 전달되지 않습니다.(가상계좌 등)
  account_no: String #가상계좌 번호
  account_name:	String #가상계좌 예금주
  bank_code: String #가상계좌 은행 코드
  bank_name: String #가상계좌 은행명
  expire_date: String #가상계좌 입금만료일
  expire_time: String #가상계좌 입금시간
  issue_tid: String
  isLocalDev: Boolean @default(value: false) #로컬 개발모드로 테스트 할때를 위해
  createdAt: DateTime!
}

type PageTicketDonationAmount {
  id: ID! @unique
  rankKey: String! @unique # seller.page.id + buyer.user.id
  sellerPage: Page!
  buyerUser: User!
  totalAmount: Int!
}

type PageViewer{
  id: ID! @unique
  page: Page!
  user: User
  ip: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PageFan {
  id: ID! @unique
  page: Page!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PageFanBoard {
  id: ID! @unique
  page: Page!
  content: String!
  imageUrl: String
  likes: [PageFanBoardLike!]!
  comments: [PageFanBoardComment!]!
  ipAddress: String!
  user: User!
  isDel: Boolean! @default(value: false)
  createdAt: DateTime!
  updatedAt: DateTime!
}

#팬보드 좋아요 한사람
type PageFanBoardLike{
  id: ID! @unique
  pageFanBoard: PageFanBoard!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PageFanBoardCommentLike{
  id: ID! @unique
  pageFanBoardComment: PageFanBoardComment!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PageFanBoardComment{
  id: ID! @unique
  pageFanBoard: PageFanBoard!
  content: String!
  imageUrl: String
  likes: [PageFanBoardCommentLike!]!
  ipAddress: String!
  user: User!
  isDel: Boolean! @default(value: false)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContentCategory{
  id: ID! @unique
  name: String! @unique
  imageUrl: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContentPage{
  id: ID! @unique
  page: Page!
  categories: [ReviewContentCategory!]!
  title: String!
  subTitle: String
  message: String
  viewers: [ReviewContentPageViewer!]!
  reviews: [ReviewContent!]!
  comments: [PageComment!]!
  owner: User!
  feedBacks: [ReviewContentPageFeedBack!]!
  releasedAt: DateTime!
  isDrafts: Boolean @default(value: true)
  isDel: Boolean @default(value: false)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContentPageViewer{
  id: ID! @unique
  reviewContentPage: ReviewContentPage!
  user: User
  ip: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContentPageFeedBack{
  id: ID! @unique
  isLike: Boolean!
  reviewContentPage: ReviewContentPage!
  message: String
  owner: User
  ipAddress: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContent{
  id: ID! @unique
  reviewContentPage: ReviewContentPage
  previewImageUrl: String!
  title: String
  description: String
  type: String!
  url: String!
  review: String
  videoId: String
  contentId: String #컨텐츠 아이디 - 체크를 위해 필수값으로 수정
  viewers: [ReviewContentViewer!]!
  reviews: [ReviewContentReview!]!
  relatedPage: Page!
  badgeVoters: [BadgeVoter!]!
  upVoters: [ReviewContentUpVoter!]!
  downVoters: [ReviewContentDownVoter!]!
  upVoteCount: Int! @default(value: 0)
  downVoteCount: Int! @default(value: 0)
  totalVoteCount: Int! @default(value: 0)
  viewTermCount: Int! @default(value: 0) #24시간 동안 조회수 카운트
  reviewTermCount: Int! @default(value: 0) #24시간 동안 생성된 리뷰 카운트
  reviewCount: Int! @default(value: 0) #리뷰 총갯수 카운트
  popularIndicator: Int! @default(value: 0)
  bookMarks: [ReviewContentBookMark!]! @relation(name: "RCRCBM", onDelete: CASCADE)
  owner: User
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContentUpVoter{
  id: ID! @unique
  reviewContent: ReviewContent!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContentDownVoter{
  id: ID! @unique
  reviewContent: ReviewContent!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContentReview{
  id: ID! @unique
  reviewContent: ReviewContent!
  keyWordBadge: [Badge!]!
  review: String!
  isUpVote: Boolean @default(value: true)
  likes: [ReviewContentReviewLike!]!
  likeCount: Int! @default(value: 0)
  commentCount: Int! @default(value: 0) #코멘트 갯수
  likeCommentSum: Int! @default(value: 0) #라이크갯수+코멘트갯수
  comments: [ReviewContentReviewComment!]!
  reports: [ReviewContentReviewReport!]! #신고 이력
  owner: User!
  isDel: Boolean! @default(value: false)
  createdAt: DateTime!
  updatedAt: DateTime!
}

#리뷰 좋아요 한사람
type ReviewContentReviewLike{
  id: ID! @unique
  reviewContentReview: ReviewContentReview!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContentReviewComment{
  id: ID! @unique
  reviewContentReview: ReviewContentReview!
  text: String!
  imageUrl: String
  ipAddress: String!
  user: User!
  isDel: Boolean! @default(value: "false")
  createdAt: DateTime!
  updatedAt: DateTime!
}


type ReviewContentViewer{
  id: ID! @unique
  reviewContent: ReviewContent!
  user: User
  ip: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContentBookMark{
  id: ID! @unique
  bookMarkUser: User! @relation(name: "UserRCBM", onDelete: SET_NULL)
  bookMarkContent: ReviewContent! @relation(name: "RCRCBM", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReviewContentReviewReport {
  id: ID! @unique
  type: Int! #1.지나친 광고성, 2.도배 및 중복, 3.저작권 침해, 4.욕설 및 비방, 5.선정적인 내용
  reviewContentReview: ReviewContentReview! #리뷰
  reporter: User! #신고자
  createdAt: DateTime!
}

type RequestPageItem {
  id: ID! @unique
  type: Int! # 1:chu발행요청,2:instagram정보요청,3:twitch정보요청,4:아프리카tv데이터 요청
  page: Page! @relation(name: "RequestPageItems", onDelete: SET_NULL)
  note: String
  ipAddress: String
  owner: User
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Youtube {
  id: ID! @unique
  channelId: String! @unique #채널아이디
  channelType: String #채널타입
  channelName: String #채널이름
  userName: String #유저 이름
  videoCount: String #업로드 동영상수
  subscriberCount: String #구독자수
  videoViewCount: String #비디오 조회수
  thumbnailUrl: String #프로필 이미지 url
  bannerUrl: String #배너 이미지 url
  description: String #채널 설명
  publishedAt: DateTime #채널 생성일
  country: String #국가
  pageUrl: String #페이지 url
  page: Page! @relation(name: "PageYoutube", onDelete: SET_NULL)
  statistics: [YoutubeDailyStatistics!]! @relation(name: "YoutubeDailyStatistics", onDelete: CASCADE) #일일 유튜브 통계정보를 저장
  createdAt: DateTime!
  updatedAt: DateTime!
}

type YoutubeDailyStatistics {
  id: ID! @unique
  date: String! #일자
  videoCount: String! #업로드 동영상수
  subscriberCount: String! #구독자수
  videoViewCount: String! #비디오조회수
  youtube: Youtube! @relation(name: "YoutubeDailyStatistics", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Twitch {
  id: ID! @unique
  userId: String! #유저아이디
  userNo: String! @unique #유저고유아이디
  userName: String #닉네임
  followerCount: String #총팔로워수
  followingCount: String #총팔잉수
  channelType: String #채널 방문자수
  channelViewCount: String #채널 방문자수
  avatarUrl: String #프로필 이미지 url
  coverUrl: String #배너 이미지 url
  description: String #소개
  pageUrl: String #페이지 url
  page: Page! @relation(name: "PageTwitch", onDelete: SET_NULL)
  statistics: [TwitchDailyStatistics!]! @relation(name: "TwitchDailyStatistics", onDelete: CASCADE) #일일 트위치 통계정보를 저장
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TwitchDailyStatistics {
  id: ID! @unique
  date: String!
  followerCount: String! #총팔로워수
  followingCount: String! #총팔잉수
  channelViewCount: String! #채널 방문자수
  twitch: Twitch! @relation(name: "TwitchDailyStatistics", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Instagram {
  id: ID! @unique
  userId: String! #유저아이디
  userNo: String! @unique #유저고유아이디
  userName: String #닉네임
  postCount: String #포스팅수
  followerCount: String #총팔로워수
  followingCount: String #총팔잉수
  avatarUrl: String #프로필 이미지 url
  description: String #소개
  pageUrl: String #페이지 url
  page: Page! @relation(name: "PageInstagram", onDelete: SET_NULL)
  statistics: [InstagramDailyStatistics!]! @relation(name: "InstagramDailyStatistics", onDelete: CASCADE) #일일 인스타 통계정보를 저장
  createdAt: DateTime!
  updatedAt: DateTime!
}

type InstagramDailyStatistics {
  id: ID! @unique
  date: String!
  postCount: String! #포스팅수
  followerCount: String! #총팔로워수
  followingCount: String! #총팔잉수
  instagram: Instagram! @relation(name: "InstagramDailyStatistics", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AfreecaTV {
  id: ID! @unique
  stationNo: String! @unique #유저고유아이디
  stationName: String
  stationTitle: String
  userId: String! @unique#유저아이디
  userName: String #닉네임
  avatarUrl: String #프로필 이미지 url
  description: String #소개
  pageUrl: String #페이지 url
  page: Page! @relation(name: "PageAfreecaTV", onDelete: SET_NULL)
  statistics: [AfreecaTVDailyStatistics!]! @relation(name: "AfreecaTVDailyStatistics", onDelete: CASCADE)  #일일 아프리카 통계정보를 저장
  followerCount: String #구독자수
  viewCount: String
  visitCount: String
  fanCount: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AfreecaTVDailyStatistics {
  id: ID! @unique
  date: String!
  followerCount: String!
  viewCount: String!
  visitCount: String!
  fanCount: String!
  afreecaTV: AfreecaTV! @relation(name: "AfreecaTVDailyStatistics", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
}

#payletter 결제결과를 저장
type PaymentHistory{
  id: ID! @unique
  code:	String #결과코드
  message: String #메시지
  user: User #가맹점 결제자(회원) 아이디(email, 영문 및 숫자 가능)
  order_no:	String @unique#가맹점의 주문 번호
  service_name:	String #결제 서비스명
  product_name:	String #결제 상품(컨텐츠)명
  custom_parameter:	String #주문요청시 가맹점가 전송한 값
  tid: String #결제고유번호
  cid: String #승인번호
  amount:	Int #결제금액-실결제된 금액 (부가세10% + pg수수료 포함)
  amount_fee: Int #충전 수수료 (부가세 + pg수수료)
  amount_without_fee: Int #충전금액 수수료 미포함 (amount - amount_fee)
  pgcode:	String #결제요청한 pg명
  pay_info: String #결제 부가정보
  domestic_flag: String #국내 / 해외 신용카드 구분 (Y : 국내, N : 해외)
  transaction_date: String #거래일시(YYYY-MM-DD HH:MM:SS)
  install_month: String #할부개월수
  card_info: String #카드 번호 (중간 4자리 masking 처리 )
  payhash: String #파라메터 검증을 위한 sha256 hash 값 (user_id +amount + tid +결제용 API Key) * 일부 결제 수단은 전달되지 않습니다.(가상계좌 등)
  account_no: String #가상계좌 번호
  account_name:	String #가상계좌 예금주
  bank_code: String #가상계좌 은행 코드
  bank_name: String #가상계좌 은행명
  expire_date: String #가상계좌 입금만료일
  expire_time: String #가상계좌 입금시간
  issue_tid: String
  createdAt: DateTime!
}

#type = 1:cash, 2:coin
type RewardDropEvent {
  id: ID! @unique
  eventID: String! @unique
  type: Int!
  title: String!
  cash: Int
  coin: Coin
  qty: Int
  limitUserCount: Int!
  fromDate: DateTime!
  toDate: DateTime!
  attendingUsers: [RewardDropAttendingUser!]!
  isDel: Boolean! @default(value: false)
  createdAt: DateTime!
}

type Fee {
  id: ID! @unique
	type: Int! #0 - 등급 수수료 1 - 이벤트 수수료
	key: Int! @unique
	memo: String
	rank: Int @unique
	askTakerFee: Float @default(value: 0.0015)
	askMakerFee: Float @default(value: 0.0015)
	bidTakerFee: Float @default(value: 0.0015)
	bidMakerFee: Float @default(value: 0.0015)
	myCoinAskTakerFee: Float @default(value: 0.01)
	myCoinAskMakerFee: Float @default(value: 0.01)
	myCoinBidTakerFee: Float @default(value: 0.0015)
	myCoinBidMakerFee: Float @default(value: 0.0015)
  rankRelation: [User!]! @relation(name: "UserRankFee", onDelete: SET_NULL)
  eventRelation: [User!]! @relation(name: "EventFee", onDelete: SET_NULL)
	createdAt: DateTime!
	updatedAt: DateTime!
}

type RewardDropAttendingUser {
  id: ID! @unique
  rewardDropEvent: RewardDropEvent!,
  user: User! @relation(name: "UserRewardDrop", onDelete: SET_NULL)
  memo: String!
  isDel: Boolean! @default(value: false)
  createdAt: DateTime!
}

#사용자 아르고 지갑
type AergoAccount {
  id: ID! @unique
  contractAddress: String! @unique #ERC20 지갑 컨트렉트 주소
  amount: Float! @default(value: 0)
  owner: User
  latestBlock: Int! @default(value: 0)
  histories: [AergoAccountHistory!]! @relation(name: "AergoAccount", onDelete: CASCADE)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AergoAccountHistory {
  id: ID! @unique
  type: Int! #1 입금, 2 출금, 3 갓츄캐쉬전환
  motherHistory: MotherHistory @relation(name: "MHAAH", onDelete: CASCADE)
  aergoAccount: AergoAccount! @relation(name: "AergoAccount", onDelete: SET_NULL)
  cashHistory: CashHistory #갓츄캐쉬 전환시만 기록
  aergoAmount: String #아르고 입금,출금시 입출금 수량(tokenDecimal : 18)
  amount_fee: Float #아르고 갓츄캐쉬로 전환시 수수료
  amount: Float #아르고 갓츄캐쉬(수수료 포함)
  marketPrice: String #전환요청시 업비트 기준시세정보
  txHash: String #입/출금시 기록
  memo: String
  description: String
  blockNo: Int @default(value: 0) #입/출금시만 필요
  status: Int! @default(value: 1) #1 대기, 2 완료, 3 아르고차감 완료(아르고 캐시로 환전시), 4 입금실패(최소 요구량등의 조건 만족 못함 or 데이터이상?), 5 캐쉬전환실패
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Wallet {
  id: ID! @unique
  coin: Coin! @relation(name: "CoinWallets", onDelete: SET_NULL)
  owner: User! @relation(name: "UserWallets", onDelete: SET_NULL)
  numIdCoinName: String @unique
  cumulativePurchaseQuantity: Float
  cumulativePurchaseValue: Float
  createdAt: DateTime!
}

type Coin {
  id: ID! @unique
  categories: [Category!]!
  name: String! @unique
  qty: Float!
  standardPrice: Float @default(value: 0)
  currentPrice: Float
  image: File!
  picture: FileInfo
  description: String!
  wallets: [Wallet!]! @relation(name: "CoinWallets", onDelete: CASCADE)
  owner: User! @relation(name: "UserCoin", onDelete: SET_NULL)
  posts: [Post!]! @relation(name: "CoinPosts", onDelete: CASCADE)
  offer: Offer @relation(name: "CoinOffer", onDelete: CASCADE)
  status: Int! @default(value: 1)
  weight: String!
  orderHistories: [OrderHistory!]! @relation(name: "CoinOH", onDelete: SET_NULL)
  orderDealsHistories: [OrderDealsHistory!]! @relation(name: "CoinODH", onDelete: SET_NULL)
  orderUserDealsHistories: [OrderUserDealsHistory!]! @relation(name: "CoinOUDH", onDelete: SET_NULL)
  motherHistories: [MotherHistory!]! @relation(name: "CoinMH", onDelete: SET_NULL)
  coinPriceTable: CoinPriceTable @relation(name: "CoinCPT", onDelete: SET_NULL)
  coinKline: [CoinKline!]! @relation(name: "CoinCK", onDelete: CASCADE)
  deployTxhash: String #코인 스마트 컨트렉트 작성에 대한 트랙잭션 해시값
  contractAddress: String #코인 스마트 컨트랙트 주소
  oDDA: Float #Owner daily deal amount
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CoinKline {
 id: ID! @unique
 open: Float! #시가
 close: Float! #종가
 high: Float! #고가
 low: Float! #저가
 volume: Float! #누적거래량
 deal: Float! #누적거래액
 coin: Coin @relation(name: "CoinCK", onDelete: SET_NULL)
 createdAt: DateTime!
 updatedAt: DateTime!
}

type OrderDealsHistory {
 id: ID! @unique
 type: Int!
 dealId: Int! @unique
 coin: Coin @relation(name: "CoinODH", onDelete: SET_NULL)
 dealPrice: Float!
 dealQty: Float!
 time: Float
 createdAt: DateTime!
 updatedAt: DateTime!
}

type OrderUserDealsHistory {
 id: ID! @unique
 type: Int! #0매도, 1매수
 role: Int #1 maker , 2 taker
 dealId: Int!
 uniqueKey: String! @unique #양식 > dealID/side
 uniqueId: Int! #거래소에서 dealid와 별도로 유저별로 딜에대한 id값 줄거라함. 유니크 하지 않지만 이미 이름 이리 했으니 걍 두자
 coin: Coin @relation(name: "CoinOUDH", onDelete: SET_NULL)
 user: User @relation(name: "UserOUDH", onDelete: SET_NULL) #개인 타임라인을 위해 추가
 motherHistory: MotherHistory @relation(name: "MHOUDH", onDelete: CASCADE)
 orderHistory: OrderHistory @relation(name: "OHOUDH", onDelete: SET_NULL)
 dealPrice: Float!
 dealQty: Float!
 fee: Float!
 dealOrderId: Int
 time: Float
 createdAt: DateTime!
 updatedAt: DateTime!
}

# qty == left  //미체결 주문
# qty - left > 0  //부분 체결 주문
# left == 0 //체결 완료 주문
type OrderHistory {
  id: ID! @unique
  type: Int! #0 매도, 1 매수
  orderNum: Int! @unique
  user: User @relation(name: "UserOH", onDelete: SET_NULL)
  coin: Coin @relation(name: "CoinOH", onDelete: SET_NULL)
  motherHistory: MotherHistory @relation(name: "MHOH", onDelete: CASCADE)
  orderUserDealsHistories: [OrderUserDealsHistory!]! @relation(name: "OHOUDH", onDelete: SET_NULL)
  orderPrice: Float!
  dealPrice: Float! @default(value: 0)
  orderQty: Float!
  dealQty: Float! @default(value: 0)
  leftQty: Float!
  dealFee: Float! @default(value: 0)
  takerFee: Float @default(value: 0)
  makerFee: Float @default(value: 0)
  memo: String
  description: String
  offset: Int @default(value: 0)
  isCancel: Boolean @default(value: false)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CashHistory {
  id: ID! @unique
  type: Int! #1 입금(캐쉬 충전), 2 출금(캐쉬 정산), 3 대기
  property: Int #1 PG(충전), 2 계좌(출금), 3 퀘스트, 4 청약, 10 이벤트 참여, 11 아르고-캐시 전환
  orderNum: Int @unique
  description: String
  user: User @relation(name: "UserCH", onDelete: SET_NULL)
  motherHistory: MotherHistory @relation(name: "MHCH", onDelete: CASCADE)
  qeh: QuestExpenditureHistory @relation(name: "CHQEH", onDelete: SET_NULL)
  aergoAccountHistory: AergoAccountHistory #aergo캐시전환으로 생겨난 캐시 히스토리일 경우 참조값 존재
  price: Int
  oPrice: Float # 원래값 (수수료 먹이기 전.)
  oPriceBack: Float
  qty: Float # 값 (수수료 적용 후.)
  memo: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type QuestExpenditureHistory {
  id: ID! @unique
  type: Int! #0 퀘스트출금, 1 퀘스트입금, 2 퀘스트환불
  payType: Int! @default(value: 0) #1:코인, 2:캐시
  orderNum: Int @unique
  description: String
  user: User @relation(name: "UserQEH", onDelete: SET_NULL)
  post: Post @relation(name: "PostQEH", onDelete: SET_NULL)
  motherHistory: MotherHistory @relation(name: "MHQEH", onDelete: CASCADE)
  cashHistory: CashHistory @relation(name: "CHQEH", onDelete: SET_NULL)
  price: Int
  qty: Float
  oPrice: Int # 원래값 (수수료 먹이기 전.)
  currentPrice: Float # 퀘스트 코인 주인이 퀘스트 완료 보상 받을 경우 그때 현잿가
  memo: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AirDropHistory { #에어드랍 관련 코인 증감 기록.
  id: ID! @unique
  type: Int! #0 코인 지출(에어드랍 생성), 1 코인 희득(에어드랍 참여), 2 코인 반환(에어드랍 취소,에어드랍 기간 마감)
  description: String
  user: User @relation(name: "UserADH", onDelete: SET_NULL)
  motherHistory: MotherHistory @relation(name: "MHADH", onDelete: CASCADE)
  airDrop: AirDrop @relation(name: "AirDropADH", onDelete: SET_NULL)
  airDropMember: AirDropMember @relation(name: "ADMADH", onDelete: SET_NULL)
  qty: Float
  currentPrice: Float # 에어드랍 참여자가 참여 보상 받을 경우 그때 현잿가
  memo: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PostRewardHistory { #포스트 코인주인 댓글에 대한 리워드 관련 기록.
  id: ID! @unique
  type: Int! #0 코인 지출, 1 코인 희득, 2 코인 반환(쓸일 있으려나?)
  description: String
  user: User @relation(name: "UserPRH", onDelete: SET_NULL)
  post: Post @relation(name: "PostPRH", onDelete: SET_NULL)
  motherHistory: MotherHistory @relation(name: "MHPRH", onDelete: CASCADE)
  comment: Comment @relation(name: "CommentPRH", onDelete: SET_NULL)
  qty: Float
  currentPrice: Float # 코인 희득시 값이 들어감. 그때 거래소 현잿가
  memo: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type MotherHistory {
 id: ID! @unique
 type: Int! #1 OrderDealsHistory, 2 OrderHistory, 3 CashHistory, 4 QuestExpenditureHistory, 5 AirDropHistory, 6 PostRewardHistory, 7 aergoAccountHistory
 roleTime: DateTime! #이 타입을 정렬할때 쓰기 위한 시간값. 나중에 추가된 타입이라 이미 작성된 히스토리들도 여기 들어와야 해서
 coin: Coin @relation(name: "CoinMH", onDelete: SET_NULL) #검색 편의성을 위해 넣음
 user: User @relation(name: "UserMH", onDelete: SET_NULL) #검색 편의성을 위해 넣음
 post: Post @relation(name: "PostMH", onDelete: SET_NULL) #검색 편의성을 위해 넣음
 orderUserDealsHistory: OrderUserDealsHistory @relation(name: "MHOUDH", onDelete: SET_NULL)
 orderHistory: OrderHistory @relation(name: "MHOH", onDelete: SET_NULL)
 cashHistory: CashHistory @relation(name: "MHCH", onDelete: SET_NULL)
 aergoAccountHistory: AergoAccountHistory @relation(name: "MHAAH", onDelete: SET_NULL)
 questExpenditureHistory: QuestExpenditureHistory @relation(name: "MHQEH", onDelete: SET_NULL)
 airDropHistory: AirDropHistory @relation(name: "MHADH", onDelete: SET_NULL)
 postRewardHistory: PostRewardHistory @relation(name: "MHPRH", onDelete: SET_NULL)
 createdAt: DateTime!
 updatedAt: DateTime!
}

type CoinPriceTable{
  id: ID! @unique
  type: Int!
  coin: Coin @relation(name: "CoinCPT", onDelete: SET_NULL)
  infoValue: [Float!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Offer {
  id: ID! @unique
  coin: Coin! @relation(name: "CoinOffer", onDelete: SET_NULL)
  qty: Int!
  offeror: [Offeror!]! @relation(name: "OfferOfferor", onDelete: CASCADE)
  fromDate: DateTime!
  toDate: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Offeror {
  id: ID! @unique
  price: Int!
  offer: Offer! @relation(name: "OfferOfferor", onDelete: SET_NULL)
  user: User! @relation(name: "UserOfferor", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Post {
  id: ID! @unique
  type: Int! @default(value: 0) #0: 일반, 1: 퀘스트, 2: 수락된 요청퀘스트, 3: 요청퀘스트 대기, 4: 에어드랍
  payType: Int! @default(value: 0) #0:일반, 1:코인, 2:캐시
  categories: [Category!]!
  content: String!
  toUser: User @relation(name: "RequestUserPosts", onDelete: SET_NULL)
  owner: User! @relation(name: "UserPosts", onDelete: SET_NULL)
  coin: Coin!  @relation(name: "CoinPosts", onDelete: SET_NULL)
  airDrop: AirDrop  @relation(name: "AirDropPosts", onDelete: SET_NULL)
  image: File
  fileList: [FileInfo!]!
  questTitle: String
  questCost: Float
  questMinMemberCount: Int
  questLimitMemberCount: Int
  questToDate: DateTime
  questMembers: [QuestMember!]! @relation(name: "QuestMembers", onDelete: CASCADE)
  questStatus: Int @default(value: 1)
  motherHistories: [MotherHistory!]! @relation(name: "PostMH", onDelete: SET_NULL)
  questExpenditureHistories: [QuestExpenditureHistory!]! @relation(name: "PostQEH", onDelete: SET_NULL)
  postRewardHistories: [PostRewardHistory!]! @relation(name: "PostPRH", onDelete: SET_NULL)
  comments: [Comment!]! @relation(name: "PostComments", onDelete: CASCADE)
  likes: [User!]! @relation(name: "PostLike", onDelete: SET_NULL)
  views:[User!]! @relation(name: "PostView", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
  updateHistories: [UpdatePostHistory!]! @relation(name: "UpdateHistories", onDelete: CASCADE)
  isBanner: Boolean! @default(value: false)
  isDel: Boolean! @default(value: false)
  enableEarlyAccess: Boolean @default(value: false)
  publicAccessAt: DateTime
  order_index: Float @default(value: 2)
}

type AirDrop {
  id: ID! @unique
  status: Int @default(value: 1) #1 준비중, 2 진행중, 3 취소, 4 잔여0 완료, 5 잔여있게 완료
  post: Post!  @relation(name: "AirDropPosts", onDelete: SET_NULL)
  deployTxhash: String # 스마트 컨트렉트통한 랜덤 요청에 대한 트렉잭션 해시 값
  contractAddress: String # 스마트 컨트렉트 주소
  randomArrayString: String # 랜덤어레이 (문자열로 저장하고 꺼내서 배열로 변환해 사용.)
  amount: Float! #에어드랍 총량
  left: Float! #에어드랍 잔여량
  members: [AirDropMember!]! @relation(name: "AirDropMember", onDelete: CASCADE) #에어드랍 참여 멤버들
  toDate: DateTime #에어드랍 마감 시간
  airDropHistories: [AirDropHistory!]! @relation(name: "AirDropADH", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
  isDel: Boolean! @default(value: false)
}

type AirDropMember {
  id: ID! @unique
  airDrop: AirDrop! @relation(name: "AirDropMember", onDelete: SET_NULL)
  user: User! @relation(name: "UserADM", onDelete: SET_NULL)
  dropNum: Int! #에어드랍 순서. 0부터 시작
  qty: Float! #코인 희득량
  airDropHistory: AirDropHistory @relation(name: "ADMADH", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
  isDel: Boolean! @default(value: false)
}

#action 1: update, 2: delete
type UpdatePostHistory {
  id: ID! @unique
  action: Int!
  post: Post! @relation(name: "UpdateHistories", onDelete: SET_NULL)
  beforeContent: String
  beforeImageUrl: String
  user: User
  admin: AdminUser
  createdAt: DateTime!
}

type Comment {
  id: ID! @unique
  type: Int @default(value: 0) #0: 일반(내용만), 1: gif 이미지만, 2: 스티커+내용
  post: Post! @relation(name: "PostComments", onDelete: SET_NULL)
  content: String!
  image: FileInfo
  url: String #gif url
  reply: [CommentReply!]! @relation(name: "CommentReplies", onDelete: CASCADE)
  owner: User! @relation(name: "UserComments", onDelete: SET_NULL)
  postRewardHistory: PostRewardHistory @relation(name: "CommentPRH", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
  isDel: Boolean! @default(value: false)
}

type CommentReply {
  id: ID! @unique
  comment: Comment! @relation(name: "CommentReplies", onDelete: SET_NULL)
  content: String!
  owner: User! @relation(name: "UserCommentReplies", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
  isDel: Boolean! @default(value: false)
}

type QuestMember {
  id: ID! @unique
  post: Post! @relation(name: "QuestMembers", onDelete: SET_NULL)
  user: User! @relation(name: "JoinedQuests", onDelete: SET_NULL)
  note: String
  createdAt: DateTime!
  isDel: Boolean! @default(value: false)
}

type Report {
  id: ID! @unique
  type: Int!
  reportUser: User! @relation(name: "UserMyReport", onDelete: SET_NULL)
  reportType: Int!
  targetPost: Post
  targetUser: User @relation(name: "UserTargetReport")
  createdAt: DateTime!
}

type File {
  id: ID! @unique
  coin: Coin,
  post: Post,
  locationPath: String
  name: String
  contentType: String
  url: String!
  owner: User @relation(name: "UserFiles", onDelete: SET_NULL)
  createdAt: DateTime!
  isDel: Boolean! @default(value: false)
}

type FileInfo {
  id: ID! @unique
  coin: Coin,
  post: Post,
  tempFileId: String @unique
  locationPath: String
  name: String
  contentType: String
  url: String!
  owner: User @relation(name: "UserFileList", onDelete: SET_NULL)
  isVideo: Boolean! @default(value: false)
  isDel: Boolean! @default(value: false)
  createdAt: DateTime!
}

type Board {
  id: ID! @unique
  type: Int! @default(value: 0)
  title: String!
  content: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  isDel: Boolean @default(value: false)
}

type Verification {
  id: ID! @unique
  level: Int @default(value: 0)
  hasEmail: Boolean @default(value: false)
  hasPin: Boolean @default(value: false)
  hasPhone: Boolean @default(value: false)
  hasBankAccount: Boolean @default(value: false)
  hasInter: Boolean @default(value: false)
  pinNumber: String
  phone: PhoneVerification @relation(name: "PhoneVerification", onDelete: CASCADE)
  bankAccount: BankAccountVerification  @relation(name: "BankAccountVerification", onDelete: CASCADE)
  user: User! @relation(name: "UserVerification", onDelete: SET_NULL)
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhoneVerification {
  id: ID! @unique
  verification: Verification @relation(name: "PhoneVerification", onDelete: SET_NULL)
  name: String!
  birth: String!
  foreigner: Boolean
  gender: String!
  phoneNumber: String
  CI: String! @unique
  DI: String!
  imp_uid: String
  merchant_uid: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Bank {
  id: ID! @unique
  code: String! @unique
  name: String! @unique
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankAccountVerificationTransactionInfo {
  id: ID! @unique
  transactionDt: String!
  transactionNo: String!
  expireAt: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type BankAccountVerification {
  id: ID! @unique
  verification: Verification @relation(name: "BankAccountVerification", onDelete: SET_NULL)
  bank: Bank!
  holderName: String!
  accountNumber: String!
  transactionInfo: BankAccountVerificationTransactionInfo!
  verifyAt: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
}

type Notification {
  id: ID! @unique
  notiType: Int! @default(value: 0) #0 앱 기본(일반적인 알림. 동일한 알림도 적재됨), 1 앱 좋아요 (중복불가), 2 웹앱공용 알림 , 3 웹알림, 4 웹 팬알림, 5 웹 좋아요
  pushType: Int! #0 개별 1 토픽 2 갓츄웹(현잰 푸시없음)
  pushState: Int! #즉시 발송일 경우엔 일반적으로 처음부터 2로 생성.
  user: [User!]! @relation(name: "NotificationUser") #0 개별 일 경우만 empty array 아님
  sendFailUser: [User!]! @relation(name: "NotificationFailUser") #
  byUser: User @relation(name: "NotificationByUser") # 보내는 사람. 현재는 notiType이 1일 경우만 있는지 체크
  post: Post #특정 포스트에 대한 알림일 경우 붙을 수 있음.
  coin: Coin #코인에 대한 알림일 경우엔 코인 정보가 붙음
  page: Page #페이지에 대한 알림일 경우''
  reviewContent: ReviewContent #ReviewContent에 대한 알림일 경우''
  reviewContentReview: ReviewContentReview #ReviewContentReview에 대한 알림일 경우''
  reviewContentReviewComment: ReviewContentReviewComment #ReviewContentReviewComment에 대한 알림일 경우''
  topic: String #1 토픽 일 경우만 해당 토픽값 들어있음
  linkType: String! @default(value: "") #앱 딥링크타입
  linkValue: String! @default(value: "") #앱 딥링크 값
  webLinkType: String! @default(value: "") #웹에서 해당 알림 링크타입
  webLinkValue: String! @default(value: "") #웹에서 해당 알림 값
  message: String!
  image: String
  publishType: Int!
  publishDate: DateTime!
  isRead: Boolean! @default(value: false) #읽힌 알림인지
  createUser: AdminUser @relation(name: "CreateNotification")
  updateUser: AdminUser @relation(name: "UpdateNotification")
  createdAt: DateTime!
  updatedAt: DateTime!
  isDel: Boolean! @default(value: false)
}

type Device {
  id: ID! @unique
  maintenance: [Maintenance!]! @relation(name: "DeviceMaintenance", onDelete: SET_NULL)
  appVersion: [AppVersion!]! @relation(name: "DeviceAppVersion", onDelete: SET_NULL)
  code: Int! @unique
  name: String! @unique
}

type Maintenance {
  id: ID! @unique
  type: Int!
  affectedDevices: [Device!]! @relation(name: "DeviceMaintenance", onDelete: SET_NULL)
  note: String!
  fromDate: DateTime!
  toDate: DateTime!
  createUser: AdminUser @relation(name: "CreateMaintenance")
  updateUser: AdminUser @relation(name: "UpdateMaintenance")
  createdAt: DateTime!
  updatedAt: DateTime!
  isDel: Boolean! @default(value: false)
}

type AppVersion {
  id: ID! @unique
  version: String! @unique
  type: Int!
  affectedDevices: [Device!]! @relation(name: "DeviceAppVersion", onDelete: SET_NULL)
  note: String!
  createUser: AdminUser @relation(name: "CreateAppVersion")
  updateUser: AdminUser @relation(name: "UpdateAppVersion")
  releasedAt: DateTime!
  createdAt: DateTime!
  updatedAt: DateTime!
  isDel: Boolean @default(value: false)
}

type SNSAccountLinkingRequest {
  id: ID! @unique
  snsType: Int! #0 instagram, 1 youtube, 2 afreecaTV, 3 twitch
  urlValue: String! #각 snsType별 인증하려 하는 주소
  authenticationValue: String! #인증값 기획상 본인 인증 이모티콘 값
  isAuth: Boolean! @default(value: false) #해당 요청의 인증 확인이 되었는가 유무
  optionValue: String #예비 필드
  description: String #주석
  page: Page! #요청한 유저의 페이지
  createdAt: DateTime!
  updatedAt: DateTime!
}

# 유튜브 인기 영상을 모아볼 예정
# 1. 30분 or 1시간 마다 50건씩 크롤링 저장
# 2. 크롤링시 같은 같은 컨텐츠가 있을시 카운팅 인기 순위로 사용
# 3. 삭제 주기는 24시간
type HotYoutube {
  id: ID! @unique
  contentId: String! @unique
  previewImageUrl: String! #이미지
  description: String! #설명
  title: String! #제목
  avatarUrl: String! #프로필 이미지
  nickName: String! #닉네임
  popularIndicator: Int! #재크롤링시 포함되어 있으면 + 1
  tags: String @default(value: "") #태그 저장
  createdAt: DateTime!
  updatedAt: DateTime!
}

type GotchuWebBanner{
  id: ID! @unique
  BannerName: String! @unique #배너네임 유니크
  ImageUrl_PC: String #피씨 이미지 url(보통 여러 해상도를 고려해 배열문자열로 받지만 일단 단일필드로)
  ImageUrl_M: String #모바일 이미지 url
  description: String #설명 (어드민에서 보임)
  linkURL: String #링크url 필요할 경우 사용
  option: String #기타 옵션값
  sortNum: Int! #배너 정렬 기준이 되는 값. 일단 낮은 수에서 높은수 순으로 정렬한다 보겠음.
  status: Int! #배너 상태. 1 : 활성화된 배너, 2 : 비활성화된 배너(어드민에선 활성화 배너 사이에 보임) , 3 : 삭제한 배너(논리)
  createdAt: DateTime!
  updatedAt: DateTime!
}
